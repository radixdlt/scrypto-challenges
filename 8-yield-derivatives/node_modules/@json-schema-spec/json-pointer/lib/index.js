"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Ptr {
    static parse(s) {
        if (s === "") {
            return new Ptr([]);
        }
        if (!s.startsWith("/")) {
            throw new InvalidPtrError(s);
        }
        const [, ...tokens] = s.split("/");
        return new Ptr(tokens.map((token) => {
            return token.replace(/~1/g, "/").replace(/~0/g, "~");
        }));
    }
    constructor(tokens) {
        this.tokens = tokens;
    }
    toString() {
        if (this.tokens.length === 0) {
            return "";
        }
        const tokens = this.tokens.map((token) => {
            return token.replace(/~/g, "~0").replace(/\//g, "~1");
        });
        return `/${tokens.join("/")}`;
    }
    eval(instance) {
        for (const token of this.tokens) {
            if (instance.hasOwnProperty(token)) {
                instance = instance[token];
            }
            else {
                throw new EvalError(instance, token);
            }
        }
        return instance;
    }
}
exports.default = Ptr;
class InvalidPtrError extends Error {
    constructor(ptr) {
        super(`Invalid JSON Pointer: ${ptr}`);
        this.ptr = ptr;
    }
}
exports.InvalidPtrError = InvalidPtrError;
class EvalError extends Error {
    constructor(instance, token) {
        super(`Error evaluating JSON Pointer: no attribute ${token} on ${instance}`);
        this.instance = instance;
        this.token = token;
    }
}
exports.EvalError = EvalError;
//# sourceMappingURL=index.js.map