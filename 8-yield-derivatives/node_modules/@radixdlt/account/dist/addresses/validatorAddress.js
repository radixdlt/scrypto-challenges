"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidatorAddress = exports.isValidatorAddressOrUnsafeInput = exports.isValidatorAddress = void 0;
const neverthrow_1 = require("neverthrow");
const crypto_1 = require("@radixdlt/crypto");
const bech32_1 = require("../bech32");
const abstractAddress_1 = require("./abstractAddress");
const _types_1 = require("./_types");
const primitives_1 = require("@radixdlt/primitives");
const isValidatorAddress = (something) => {
    if (!(0, abstractAddress_1.isAbstractAddress)(something))
        return false;
    return something.addressType === _types_1.AddressTypeT.VALIDATOR;
};
exports.isValidatorAddress = isValidatorAddress;
const maxLength = 300; // arbitrarily chosen
const encoding = bech32_1.Encoding.BECH32;
const hrpFromNetwork = (network) => primitives_1.HRP[network].validator;
const networkFromHRP = hrp => hrp === primitives_1.HRP.mainnet.validator
    ? (0, neverthrow_1.ok)(primitives_1.Network.MAINNET)
    : hrp === primitives_1.HRP.stokenet.validator
        ? (0, neverthrow_1.ok)(primitives_1.Network.STOKENET)
        : hrp === primitives_1.HRP.localnet.validator
            ? (0, neverthrow_1.ok)(primitives_1.Network.LOCALNET)
            : hrp === primitives_1.HRP.releasenet.validator
                ? (0, neverthrow_1.ok)(primitives_1.Network.RELEASENET)
                : hrp === primitives_1.HRP.rcnet.validator
                    ? (0, neverthrow_1.ok)(primitives_1.Network.RCNET)
                    : hrp === primitives_1.HRP.milestonenet.validator
                        ? (0, neverthrow_1.ok)(primitives_1.Network.MILESTONENET)
                        : hrp === primitives_1.HRP.testnet6.validator
                            ? (0, neverthrow_1.ok)(primitives_1.Network.TESTNET6)
                            : hrp === primitives_1.HRP.sandpitnet.validator
                                ? (0, neverthrow_1.ok)(primitives_1.Network.SANDPITNET)
                                : (0, neverthrow_1.err)(Error(`Failed to parse network from HRP ${hrp} for ValidatorAddress.`));
const fromPublicKeyAndNetwork = (input) => abstractAddress_1.AbstractAddress.byFormattingPublicKeyDataAndBech32ConvertingIt(Object.assign(Object.assign({}, input), { network: input.network, hrpFromNetwork, addressType: _types_1.AddressTypeT.VALIDATOR, typeguard: exports.isValidatorAddress, encoding,
    maxLength }))
    .orElse(e => {
    throw new Error(`Expected to always be able to create validator address from publicKey and network, but got error: ${e.message}`);
})
    ._unsafeUnwrap({ withStackTrace: true });
const fromString = (bechString) => abstractAddress_1.AbstractAddress.fromString({
    bechString,
    addressType: _types_1.AddressTypeT.VALIDATOR,
    typeguard: exports.isValidatorAddress,
    networkFromHRP,
    encoding,
    maxLength,
});
const fromBuffer = (buffer) => {
    const fromBuf = (buf) => crypto_1.PublicKey.fromBuffer(buf).map(publicKey => fromPublicKeyAndNetwork({
        publicKey,
        network: primitives_1.Network.MAINNET, // should change
    }));
    if (buffer.length === 34 && buffer[0] === 0x04) {
        const sliced = buffer.slice(1);
        if (sliced.length !== 33) {
            return (0, neverthrow_1.err)(new Error('Failed to slice buffer.'));
        }
        return fromBuf(sliced);
    }
    else if (buffer.length === 33) {
        return fromBuf(buffer);
    }
    else {
        return (0, neverthrow_1.err)(new Error(`Bad length of buffer, got #${buffer.length} bytes, but expected 33.`));
    }
};
const isValidatorAddressUnsafeInput = (something) => typeof something === 'string' || Buffer.isBuffer(something);
const isValidatorAddressOrUnsafeInput = (something) => (0, exports.isValidatorAddress)(something) || isValidatorAddressUnsafeInput(something);
exports.isValidatorAddressOrUnsafeInput = isValidatorAddressOrUnsafeInput;
const fromUnsafe = (input) => (0, exports.isValidatorAddress)(input)
    ? (0, neverthrow_1.ok)(input)
    : typeof input === 'string'
        ? fromString(input)
        : fromBuffer(input);
exports.ValidatorAddress = {
    fromUnsafe,
    fromPublicKeyAndNetwork,
};
//# sourceMappingURL=validatorAddress.js.map