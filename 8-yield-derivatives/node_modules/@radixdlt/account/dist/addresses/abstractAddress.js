"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractAddress = exports.isAbstractAddress = void 0;
const neverthrow_1 = require("neverthrow");
const crypto_1 = require("@radixdlt/crypto");
const util_1 = require("@radixdlt/util");
const bech32_1 = require("../bech32");
const isAbstractAddress = (something) => {
    const inspection = something;
    return (inspection.publicKey !== undefined &&
        (0, crypto_1.isPublicKey)(inspection.publicKey) &&
        inspection.equals !== undefined &&
        inspection.toString !== undefined &&
        inspection.addressType !== undefined);
};
exports.isAbstractAddress = isAbstractAddress;
const __create = (input) => {
    const { hrp, data, encoding, maxLength, network, publicKey, addressType, typeguard, } = input;
    return bech32_1.Bech32.encode({ hrp, data, encoding, maxLength })
        .mapErr(error => {
        const errMsg = `Incorrect implementation, failed to Bech32 encode data, underlying error: ${(0, util_1.msgFromError)(error)}, but expect to always be able to.`;
        console.error(errMsg);
        throw new Error(errMsg);
    })
        .map(encoded => {
        const toString = () => encoded.toString();
        const equals = (other) => {
            if (!(0, exports.isAbstractAddress)(other)) {
                return false;
            }
            return (other.publicKey.equals(publicKey) &&
                other.network === network &&
                addressType === other.addressType);
        };
        const abstract = {
            addressType,
            network,
            publicKey,
            toString,
            equals,
        };
        if (!typeguard(abstract)) {
            const errMsg = `Incorrect implementation, expected to have created an address of type ${addressType.toString()}`;
            util_1.log.error(errMsg);
            throw new Error(errMsg);
        }
        return abstract;
    });
};
const byFormattingPublicKeyDataAndBech32ConvertingIt = (input) => {
    var _a;
    const { publicKey, hrpFromNetwork, network } = input;
    const formatDataToBech32Convert = (_a = input.formatDataToBech32Convert) !== null && _a !== void 0 ? _a : (b => b);
    const publicKeyBytes = publicKey.asData({ compressed: true });
    const bytes = formatDataToBech32Convert(publicKeyBytes);
    const hrp = hrpFromNetwork(network);
    return bech32_1.Bech32.convertDataToBech32(bytes).andThen(data => __create(Object.assign(Object.assign({}, input), { hrp,
        data,
        publicKey })));
};
const fromString = (input) => {
    var _a;
    const { bechString, networkFromHRP } = input;
    const validateDataAndExtractPubKeyBytes = (_a = input.validateDataAndExtractPubKeyBytes) !== null && _a !== void 0 ? _a : ((passthroughData) => (0, neverthrow_1.ok)(passthroughData));
    return bech32_1.Bech32.decode(input)
        .andThen(({ hrp, data: bech32Data }) => bech32_1.Bech32.convertDataFromBech32(bech32Data).map(dataFromBech32 => ({
        bech32Data,
        dataFromBech32,
        hrp,
    })))
        .andThen(({ bech32Data, dataFromBech32, hrp }) => validateDataAndExtractPubKeyBytes(dataFromBech32).map(publicKeyBytes => ({
        bech32Data,
        publicKeyBytes,
        hrp,
    })))
        .andThen(({ bech32Data, publicKeyBytes, hrp }) => (0, neverthrow_1.combine)([
        networkFromHRP(hrp),
        crypto_1.PublicKey.fromBuffer(publicKeyBytes),
    ]).map(resultList => {
        const network = resultList[0];
        const publicKey = resultList[1];
        return {
            bech32Data,
            hrp,
            network,
            publicKey,
        };
    }))
        .andThen(({ bech32Data, hrp, network, publicKey }) => __create(Object.assign(Object.assign({}, input), { network: network, hrp, data: bech32Data, publicKey })))
        .map((abstractAddress) => {
        // Soundness check
        if (abstractAddress.toString().toLowerCase() !==
            bechString.toLowerCase()) {
            const errMsg = `Incorrect implementation, AbstractAddress mismatch, passed in: ${bechString.toLowerCase()}, created: ${abstractAddress
                .toString()
                .toLowerCase()}`;
            util_1.log.error(errMsg);
            throw new Error(errMsg);
        }
        return abstractAddress;
    });
};
exports.AbstractAddress = {
    byFormattingPublicKeyDataAndBech32ConvertingIt,
    fromString,
};
//# sourceMappingURL=abstractAddress.js.map