"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountAddress = exports.isAccountAddressOrUnsafeInput = exports.isAccountAddress = void 0;
const neverthrow_1 = require("neverthrow");
const crypto_1 = require("@radixdlt/crypto");
const bech32_1 = require("../bech32");
const abstractAddress_1 = require("./abstractAddress");
const util_1 = require("@radixdlt/util");
const _types_1 = require("./_types");
const primitives_1 = require("@radixdlt/primitives");
const isAccountAddress = (something) => {
    if (!(0, abstractAddress_1.isAbstractAddress)(something))
        return false;
    return something.addressType === _types_1.AddressTypeT.ACCOUNT;
};
exports.isAccountAddress = isAccountAddress;
const maxLength = 300; // arbitrarily chosen
const versionByte = Buffer.from([0x04]);
const encoding = bech32_1.Encoding.BECH32;
const hrpFromNetwork = (network) => primitives_1.HRP[network].account;
const networkFromHRP = hrp => hrp === primitives_1.HRP.mainnet.account
    ? (0, neverthrow_1.ok)(primitives_1.Network.MAINNET)
    : hrp === primitives_1.HRP.stokenet.account
        ? (0, neverthrow_1.ok)(primitives_1.Network.STOKENET)
        : hrp === primitives_1.HRP.localnet.account
            ? (0, neverthrow_1.ok)(primitives_1.Network.LOCALNET)
            : hrp === primitives_1.HRP.releasenet.account
                ? (0, neverthrow_1.ok)(primitives_1.Network.RELEASENET)
                : hrp === primitives_1.HRP.rcnet.account
                    ? (0, neverthrow_1.ok)(primitives_1.Network.RCNET)
                    : hrp === primitives_1.HRP.milestonenet.account
                        ? (0, neverthrow_1.ok)(primitives_1.Network.MILESTONENET)
                        : hrp === primitives_1.HRP.testnet6.account
                            ? (0, neverthrow_1.ok)(primitives_1.Network.TESTNET6)
                            : hrp === primitives_1.HRP.sandpitnet.account
                                ? (0, neverthrow_1.ok)(primitives_1.Network.SANDPITNET)
                                : (0, neverthrow_1.err)(Error(`Failed to parse network from HRP ${hrp} for AccountAddress.`));
const formatDataToBech32Convert = data => Buffer.concat([versionByte, data]);
const validateDataAndExtractPubKeyBytes = (data) => {
    const receivedVersionByte = data.slice(0, 1);
    if (!(0, util_1.buffersEquals)(versionByte, receivedVersionByte)) {
        const errMsg = `Wrong version byte, expected '${versionByte.toString('hex')}', but got: '${receivedVersionByte.toString('hex')}'`;
        console.error(errMsg);
        return (0, neverthrow_1.err)(new Error(errMsg));
    }
    return (0, neverthrow_1.ok)(data.slice(1, data.length));
};
const fromPublicKeyAndNetwork = (input) => abstractAddress_1.AbstractAddress.byFormattingPublicKeyDataAndBech32ConvertingIt(Object.assign(Object.assign({}, input), { network: input.network, hrpFromNetwork, addressType: _types_1.AddressTypeT.ACCOUNT, typeguard: exports.isAccountAddress, formatDataToBech32Convert,
    encoding,
    maxLength }))
    .orElse(e => {
    throw new Error(`Expected to always be able to create AccountAddress from publicKey and network, but got error: ${e.message}`);
})
    ._unsafeUnwrap({ withStackTrace: true });
const fromString = (bechString) => abstractAddress_1.AbstractAddress.fromString({
    bechString,
    addressType: _types_1.AddressTypeT.ACCOUNT,
    networkFromHRP,
    typeguard: exports.isAccountAddress,
    validateDataAndExtractPubKeyBytes,
    encoding,
    maxLength,
});
const fromBuffer = (buffer) => {
    const fromBuf = (buf) => crypto_1.PublicKey.fromBuffer(buf).map(publicKey => fromPublicKeyAndNetwork({
        publicKey,
        network: primitives_1.Network.MAINNET, // yikes!
    }));
    if (buffer.length === 34 && buffer[0] === 0x04) {
        const sliced = buffer.slice(1);
        if (sliced.length !== 33) {
            return (0, neverthrow_1.err)(new Error('Failed to slice buffer.'));
        }
        return fromBuf(sliced);
    }
    else if (buffer.length === 33) {
        return fromBuf(buffer);
    }
    else {
        return (0, neverthrow_1.err)(new Error(`Bad length of buffer, got #${buffer.length} bytes, but expected 33.`));
    }
};
const isAccountAddressUnsafeInput = (something) => typeof something === 'string' || Buffer.isBuffer(something);
const isAccountAddressOrUnsafeInput = (something) => (0, exports.isAccountAddress)(something) || isAccountAddressUnsafeInput(something);
exports.isAccountAddressOrUnsafeInput = isAccountAddressOrUnsafeInput;
const fromUnsafe = (input) => (0, exports.isAccountAddress)(input)
    ? (0, neverthrow_1.ok)(input)
    : typeof input === 'string'
        ? fromString(input)
        : fromBuffer(input);
exports.AccountAddress = {
    isAccountAddress: exports.isAccountAddress,
    fromUnsafe,
    fromPublicKeyAndNetwork,
};
//# sourceMappingURL=accountAddress.js.map