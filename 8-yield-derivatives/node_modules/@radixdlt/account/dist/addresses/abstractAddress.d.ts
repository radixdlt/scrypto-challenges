/// <reference types="node" />
import { Result } from 'neverthrow';
import { PublicKeyT } from '@radixdlt/crypto';
import { Encoding } from '../bech32';
import { AbstractAddressT, AddressTypeT } from './_types';
import { Network } from '@radixdlt/primitives';
export declare const isAbstractAddress: (something: unknown) => something is Readonly<{
    addressType: AddressTypeT;
    network: Network;
    publicKey: Readonly<{
        __hex: string;
        asData: (input: {
            readonly compressed: boolean;
        }) => Buffer;
        toString: (compressed?: boolean | undefined) => string;
        isValidSignature: (input: Readonly<{
            signature: Readonly<{
                r: import("@radixdlt/uint256").UInt256;
                s: import("@radixdlt/uint256").UInt256;
                toDER: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>;
            hashedMessage: Buffer;
        }>) => boolean;
        decodeToPointOnCurve: () => Readonly<{
            x: import("@radixdlt/uint256").UInt256;
            y: import("@radixdlt/uint256").UInt256;
            toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
            toString: (includePrefixByte?: boolean | undefined) => string;
            equals: (other: Readonly<any>) => boolean;
            add: (other: Readonly<any>) => Readonly<any>;
            multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
            multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
        }>;
        equals: (other: Readonly<any>) => boolean;
    }>;
    toString: () => string;
    equals: (other: Readonly<any>) => boolean;
}>;
export declare type TypeGuard<A extends AbstractAddressT> = (something: unknown) => something is A;
export declare type NetworkFromHRP = (hrp: string) => Result<Network, Error>;
export declare type HRPFromNetwork = (network: Network) => string;
export declare type FormatDataToBech32Convert = (publicKeyBytes: Buffer) => Buffer;
export declare type ValidateDataAndExtractPubKeyBytes = (data: Buffer) => Result<Buffer, Error>;
export declare const AbstractAddress: {
    byFormattingPublicKeyDataAndBech32ConvertingIt: <A extends Readonly<{
        addressType: AddressTypeT;
        network: Network;
        publicKey: Readonly<{
            __hex: string;
            asData: (input: {
                readonly compressed: boolean;
            }) => Buffer;
            toString: (compressed?: boolean | undefined) => string;
            isValidSignature: (input: Readonly<{
                signature: Readonly<{
                    r: import("@radixdlt/uint256").UInt256;
                    s: import("@radixdlt/uint256").UInt256;
                    toDER: () => string;
                    equals: (other: Readonly<any>) => boolean;
                }>;
                hashedMessage: Buffer;
            }>) => boolean;
            decodeToPointOnCurve: () => Readonly<{
                x: import("@radixdlt/uint256").UInt256;
                y: import("@radixdlt/uint256").UInt256;
                toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                toString: (includePrefixByte?: boolean | undefined) => string;
                equals: (other: Readonly<any>) => boolean;
                add: (other: Readonly<any>) => Readonly<any>;
                multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
            }>;
            equals: (other: Readonly<any>) => boolean;
        }>;
        toString: () => string;
        equals: (other: Readonly<any>) => boolean;
    }>>(input: Readonly<{
        publicKey: PublicKeyT;
        hrpFromNetwork: HRPFromNetwork;
        addressType: AddressTypeT;
        network: Network;
        typeguard: TypeGuard<A>;
        formatDataToBech32Convert?: FormatDataToBech32Convert | undefined;
        encoding?: Encoding | undefined;
        maxLength?: number | undefined;
    }>) => Result<A, Error>;
    fromString: <A_1 extends Readonly<{
        addressType: AddressTypeT;
        network: Network;
        publicKey: Readonly<{
            __hex: string;
            asData: (input: {
                readonly compressed: boolean;
            }) => Buffer;
            toString: (compressed?: boolean | undefined) => string;
            isValidSignature: (input: Readonly<{
                signature: Readonly<{
                    r: import("@radixdlt/uint256").UInt256;
                    s: import("@radixdlt/uint256").UInt256;
                    toDER: () => string;
                    equals: (other: Readonly<any>) => boolean;
                }>;
                hashedMessage: Buffer;
            }>) => boolean;
            decodeToPointOnCurve: () => Readonly<{
                x: import("@radixdlt/uint256").UInt256;
                y: import("@radixdlt/uint256").UInt256;
                toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                toString: (includePrefixByte?: boolean | undefined) => string;
                equals: (other: Readonly<any>) => boolean;
                add: (other: Readonly<any>) => Readonly<any>;
                multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
            }>;
            equals: (other: Readonly<any>) => boolean;
        }>;
        toString: () => string;
        equals: (other: Readonly<any>) => boolean;
    }>>(input: Readonly<{
        bechString: string;
        addressType: AddressTypeT;
        networkFromHRP: NetworkFromHRP;
        typeguard: TypeGuard<A_1>;
        validateDataAndExtractPubKeyBytes?: ValidateDataAndExtractPubKeyBytes | undefined;
        encoding?: Encoding | undefined;
        maxLength?: number | undefined;
    }>) => Result<A_1, Error>;
};
//# sourceMappingURL=abstractAddress.d.ts.map