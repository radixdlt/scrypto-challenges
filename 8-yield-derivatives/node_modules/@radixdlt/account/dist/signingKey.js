"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SigningKey = exports.isSigningKey = void 0;
const crypto_1 = require("@radixdlt/crypto");
const operators_1 = require("rxjs/operators");
const rxjs_1 = require("rxjs");
const util_1 = require("@radixdlt/util");
const _types_1 = require("./_types");
const neverthrow_1 = require("neverthrow");
const prelude_ts_1 = require("prelude-ts");
const stringifySigningKey = (signingKey) => `
		type: ${signingKey.type.typeIdentifier.toString()},
		publicKey: ${signingKey.publicKey.toString(true)},
		hdPath?: ${prelude_ts_1.Option.of(signingKey.hdPath)
    .map(hdp => hdp.toString())
    .getOrElse('NONE')},
		isHDSigningKey: ${signingKey.isHDSigningKey ? 'YES' : 'NO'},
		isHardwareSigningKey: ${signingKey.isHardwareSigningKey ? 'YES' : 'NO'},
	`;
const makeSigningKeyTypeHD = (input) => {
    const { hdPath, hdSigningKeyType } = input;
    const isHardwareSigningKey = hdSigningKeyType === _types_1.HDSigningKeyTypeIdentifier.HARDWARE_OR_REMOTE;
    const uniqueKey = `${isHardwareSigningKey ? 'Hardware' : 'Local'}_HD_signingKey_at_path_${hdPath.toString()}`;
    return {
        typeIdentifier: _types_1.SigningKeyTypeIdentifier.HD_SIGNING_KEY,
        hdSigningKeyType,
        hdPath,
        uniqueKey,
        isHDSigningKey: true,
        isHardwareSigningKey,
    };
};
const makeSigningKeyTypeNonHD = (input) => {
    const named = prelude_ts_1.Option.of(input.name)
        .map(n => `named_${n}`)
        .getOrElse('');
    const uniqueKey = `Non_hd_${named}pubKey${input.publicKey.toString(true)}`;
    return {
        typeIdentifier: _types_1.SigningKeyTypeIdentifier.NON_HD_SIGNING_KEY,
        uniqueKey,
        isHDSigningKey: false,
        isHardwareSigningKey: false,
        name: input.name,
    };
};
const makeDecrypt = (diffieHellman) => (input) => (0, util_1.toObservable)(crypto_1.MessageEncryption.decrypt(Object.assign(Object.assign({}, input), { diffieHellmanPoint: () => diffieHellman(input.publicKeyOfOtherParty) })).map((buf) => buf.toString('utf-8')));
const makeEncrypt = (diffieHellman) => (input) => (0, util_1.toObservable)(crypto_1.MessageEncryption.encrypt({
    plaintext: input.plaintext,
    diffieHellmanPoint: () => diffieHellman(input.publicKeyOfOtherParty),
}));
const makeEncryptHW = (hardwareSigningKey) => (input) => hardwareSigningKey.keyExchange(input.publicKeyOfOtherParty, 'encrypt').pipe((0, operators_1.mergeMap)((dhPoint) => (0, util_1.toObservable)(crypto_1.MessageEncryption.encrypt({
    plaintext: input.plaintext,
    diffieHellmanPoint: () => (0, neverthrow_1.okAsync)(dhPoint),
}))));
const makeDecryptHW = (hardwareSigningKey) => (input) => hardwareSigningKey.keyExchange(input.publicKeyOfOtherParty, 'decrypt').pipe((0, operators_1.mergeMap)((dhPoint) => (0, util_1.toObservable)(crypto_1.MessageEncryption.decrypt({
    encryptedMessage: input.encryptedMessage,
    diffieHellmanPoint: () => (0, neverthrow_1.okAsync)(dhPoint),
}))), (0, operators_1.map)((b) => b.toString('utf8')));
const fromPrivateKeyNamedOrFromHDPath = (input) => {
    const { privateKey } = input;
    const publicKey = privateKey.publicKey();
    const sign = (tx, _nonXrdHRP) => (0, util_1.toObservable)(privateKey.sign(Buffer.from(tx.hashOfBlobToSign, 'hex')));
    const diffieHellman = privateKey.diffieHellman;
    const type = input.pathOrName === undefined || typeof input.pathOrName === 'string'
        ? makeSigningKeyTypeNonHD({
            publicKey,
            name: input.pathOrName,
        })
        : makeSigningKeyTypeHD({
            hdPath: input.pathOrName,
            hdSigningKeyType: _types_1.HDSigningKeyTypeIdentifier.LOCAL,
        });
    const newSigningKey = Object.assign(Object.assign({}, type), { isLocalHDSigningKey: type.isHDSigningKey && !type.isHardwareSigningKey, decrypt: makeDecrypt(diffieHellman), encrypt: makeEncrypt(diffieHellman), sign: sign, signHash: (hashedMessage) => (0, util_1.toObservable)(privateKey.sign(hashedMessage)), hdPath: input.pathOrName === undefined ||
            typeof input.pathOrName === 'string'
            ? undefined
            : input.pathOrName, publicKey, getPublicKeyDisplayOnlyAddress: () => (0, rxjs_1.of)(publicKey), type, uniqueIdentifier: type.uniqueKey, toString: () => {
            throw new Error('Overriden below');
        }, equals: (other) => publicKey.equals(other.publicKey), __diffieHellman: diffieHellman });
    return Object.assign(Object.assign({}, newSigningKey), { toString: () => stringifySigningKey(newSigningKey) });
};
const fromPrivateKeyAtHDPath = (input) => fromPrivateKeyNamedOrFromHDPath(Object.assign(Object.assign({}, input), { pathOrName: input.hdPath }));
const fromPrivateKey = (input) => fromPrivateKeyNamedOrFromHDPath(Object.assign(Object.assign({}, input), { pathOrName: input.name }));
const fromHDPathWithHWSigningKey = (input) => {
    const { hdPath, hardwareSigningKey } = input;
    const type = makeSigningKeyTypeHD({
        hdPath,
        hdSigningKeyType: _types_1.HDSigningKeyTypeIdentifier.HARDWARE_OR_REMOTE,
    });
    const newSigningKey = Object.assign(Object.assign({}, type), { isLocalHDSigningKey: false, publicKey: hardwareSigningKey.publicKey, hdPath, getPublicKeyDisplayOnlyAddress: () => hardwareSigningKey.getPublicKeyDisplayOnlyAddress(), sign: (tx, nonXrdHRP) => hardwareSigningKey.sign(tx, nonXrdHRP), signHash: (hashesMessage) => hardwareSigningKey.signHash(hashesMessage), decrypt: makeDecryptHW(hardwareSigningKey), encrypt: makeEncryptHW(hardwareSigningKey), type, uniqueIdentifier: type.uniqueKey, toString: () => {
            throw new Error('Overridden below.');
        }, equals: (other) => hardwareSigningKey.publicKey.equals(other.publicKey), __diffieHellman: (_publicKeyOfOtherParty) => {
            throw new Error('No Dh here, only used for testing.');
        } });
    return Object.assign(Object.assign({}, newSigningKey), { toString: () => stringifySigningKey(newSigningKey) });
};
const byDerivingNodeAtPath = (input) => fromPrivateKeyAtHDPath(Object.assign(Object.assign({}, input), { privateKey: input.deriveNodeAtPath().privateKey }));
const fromHDPathWithHDMasterNode = (input) => {
    const hdNodeAtPath = input.hdMasterNode.derive(input.hdPath);
    return fromPrivateKeyAtHDPath(Object.assign(Object.assign({}, input), { privateKey: hdNodeAtPath.privateKey }));
};
const fromHDPathWithHDMasterSeed = (input) => {
    const hdMasterNode = input.hdMasterSeed.masterNode();
    return fromHDPathWithHDMasterNode(Object.assign(Object.assign({}, input), { hdMasterNode }));
};
const isSigningKey = (something) => {
    const inspection = something;
    return (inspection.publicKey !== undefined &&
        (0, crypto_1.isPublicKey)(inspection.publicKey) &&
        inspection.sign !== undefined &&
        inspection.encrypt !== undefined &&
        inspection.decrypt !== undefined &&
        inspection.type !== undefined);
};
exports.isSigningKey = isSigningKey;
exports.SigningKey = {
    __unsafeFromPrivateKeyAtHDPath: fromPrivateKeyAtHDPath,
    fromPrivateKey,
    byDerivingNodeAtPath,
    fromHDPathWithHWSigningKey,
    fromHDPathWithHDMasterNode,
    fromHDPathWithHDMasterSeed,
};
//# sourceMappingURL=signingKey.js.map