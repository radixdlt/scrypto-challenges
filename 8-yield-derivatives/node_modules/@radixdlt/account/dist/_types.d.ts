/// <reference types="node" />
import { Observable } from 'rxjs';
import { Option } from 'prelude-ts';
import { DiffieHellman, EncryptedMessageT, HDPathRadixT, MnemomicT, PrivateKeyT, PublicKeyT, SignatureT } from '@radixdlt/crypto';
import { HardwareWalletT } from '@radixdlt/hardware-wallet';
import { BuiltTransactionReadyToSign } from '@radixdlt/primitives';
export declare type Signing = Readonly<{
    signHash: (hashedMessage: Buffer) => Observable<SignatureT>;
    sign: (tx: BuiltTransactionReadyToSign, nonXrdHRP?: string) => Observable<SignatureT>;
}>;
export declare type SigningKeyEncryptionInput = Readonly<{
    plaintext: Buffer | string;
    publicKeyOfOtherParty: PublicKeyT;
}>;
export declare type Encrypting = Readonly<{
    encrypt: (input: SigningKeyEncryptionInput) => Observable<EncryptedMessageT>;
}>;
export declare type SigningKeyDecryptionInput = Readonly<{
    encryptedMessage: Buffer | EncryptedMessageT;
    publicKeyOfOtherParty: PublicKeyT;
}>;
export declare type Decrypting = Readonly<{
    decrypt: (input: SigningKeyDecryptionInput) => Observable<string>;
}>;
export declare enum HDSigningKeyTypeIdentifier {
    LOCAL = "LOCAL",
    HARDWARE_OR_REMOTE = "HARDWARE_OR_REMOTE"
}
export declare enum SigningKeyTypeIdentifier {
    HD_SIGNING_KEY = "HD_SIGNING_KEY",
    NON_HD_SIGNING_KEY = "NON_HD_SIGNING_KEY"
}
export declare type BaseSigningKeyTypeT<T extends SigningKeyTypeIdentifier> = Readonly<{
    typeIdentifier: T;
    isHDSigningKey: boolean;
    isHardwareSigningKey: boolean;
    uniqueKey: string;
}>;
export declare type SigningKeyTypeHDT = BaseSigningKeyTypeT<SigningKeyTypeIdentifier.HD_SIGNING_KEY> & Readonly<{
    hdSigningKeyType: HDSigningKeyTypeIdentifier;
    hdPath: HDPathRadixT;
}>;
export declare type SigningKeyTypeNonHDT = BaseSigningKeyTypeT<SigningKeyTypeIdentifier.NON_HD_SIGNING_KEY> & Readonly<{
    name?: string;
}>;
export declare type SigningKeyTypeT = SigningKeyTypeHDT | SigningKeyTypeNonHDT;
export declare type PrivateKeyToSigningKeyInput = Readonly<{
    privateKey: PrivateKeyT;
    name?: string;
}>;
export declare type HWSigningKeyDerivation = 'next' | HDPathRadixT;
export declare type DeriveHWSigningKeyInput = Readonly<{
    keyDerivation: HWSigningKeyDerivation;
    hardwareWalletConnection: Observable<HardwareWalletT>;
    alsoSwitchTo: boolean;
    verificationPrompt?: boolean;
}>;
export declare type SigningKeyT = Signing & Encrypting & Decrypting & Readonly<{
    __diffieHellman: DiffieHellman;
    type: SigningKeyTypeT;
    publicKey: PublicKeyT;
    getPublicKeyDisplayOnlyAddress: () => Observable<PublicKeyT>;
    uniqueIdentifier: string;
    toString: () => string;
    equals: (other: SigningKeyT) => boolean;
    hdPath?: HDPathRadixT;
    isHDSigningKey: boolean;
    isHardwareSigningKey: boolean;
    isLocalHDSigningKey: boolean;
}>;
export declare type SigningKeysT = Readonly<{
    toString: () => string;
    equals: (other: SigningKeysT) => boolean;
    getHDSigningKeyByHDPath: (hdPath: HDPathRadixT) => Option<SigningKeyT>;
    getAnySigningKeyByPublicKey: (publicKey: PublicKeyT) => Option<SigningKeyT>;
    all: SigningKeyT[];
    hdSigningKeys: () => SigningKeyT[];
    localHDSigningKeys: () => SigningKeyT[];
    hardwareHDSigningKeys: () => SigningKeyT[];
    nonHDSigningKeys: () => SigningKeyT[];
    size: () => number;
}>;
export declare type SwitchToSigningKey = Readonly<{
    toSigningKey: SigningKeyT;
}>;
export declare type SwitchToIndex = Readonly<{
    toIndex: number;
}>;
export declare type SwitchSigningKeyInput = 'first' | 'last' | SwitchToSigningKey | SwitchToIndex;
export declare type DeriveNextInput = undefined | Readonly<{
    isHardened?: boolean;
    alsoSwitchTo?: boolean;
}>;
export declare type AddSigningKeyByPrivateKeyInput = PrivateKeyToSigningKeyInput & {
    alsoSwitchTo?: boolean;
};
export declare type SigningKeychainT = Signing & Readonly<{
    __unsafeGetSigningKey: () => SigningKeyT;
    revealMnemonic: () => MnemomicT;
    restoreLocalHDSigningKeysUpToIndex: (index: number) => Observable<SigningKeysT>;
    deriveNextLocalHDSigningKey: (input?: DeriveNextInput) => Observable<SigningKeyT>;
    deriveHWSigningKey: (input: DeriveHWSigningKeyInput) => Observable<SigningKeyT>;
    addSigningKeyFromPrivateKey: (input: AddSigningKeyByPrivateKeyInput) => SigningKeyT;
    switchSigningKey: (input: SwitchSigningKeyInput) => SigningKeyT;
    observeActiveSigningKey: () => Observable<SigningKeyT>;
    observeSigningKeys: () => Observable<SigningKeysT>;
}>;
//# sourceMappingURL=_types.d.ts.map