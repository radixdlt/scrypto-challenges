"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readBuffer = exports.BufferReader = void 0;
/* eslint-disable */
const neverthrow_1 = require("neverthrow");
const createBufferReader = (buf) => {
    if (!Buffer.isBuffer(buf)) {
        buf = Buffer.from(buf); // Convert Uint8Array to Buffer for Electron renderer compatibility ðŸ’©
    }
    let offset = 0;
    let bytesLeftToRead = buf.length;
    const readNextBuffer = (byteCount) => {
        if (byteCount < 0)
            return neverthrow_1.err(new Error(`'byteCount' must be no negative`));
        if (byteCount === 0) {
            return neverthrow_1.ok(Buffer.alloc(0));
        }
        if (offset + byteCount > buf.length)
            return neverthrow_1.err(new Error(`Out of buffer's boundary`));
        const bufToReturn = Buffer.alloc(byteCount);
        buf.copy(bufToReturn, 0, offset, offset + byteCount);
        if (bufToReturn.length !== byteCount) {
            throw new Error(`Incorrect length of newly read buffer...`);
        }
        offset += byteCount;
        bytesLeftToRead -= byteCount;
        // console.log(`
        // 	ðŸ§µðŸ§µðŸ§µ
        // 		read: #${byteCount} bytes,
        // 		read buffer: '0x${bufToReturn.toString('hex')}',
        // 		offset: ${offset},
        // 		source buffer: '0x${buf.toString('hex')}',
        // 		length of source buffer: #${buf.length} bytes.
        // 		bytesLeftToRead: #${bytesLeftToRead}
        // 	ðŸ§µðŸ§µðŸ§µ
        // `)
        return neverthrow_1.ok(bufToReturn);
    };
    const finishedParsing = () => {
        if (bytesLeftToRead < 0) {
            throw new Error(`Incorrect implementation, read too many bytes.`);
        }
        return bytesLeftToRead === 0;
    };
    return {
        readNextBuffer,
        finishedParsing,
        remainingBytes: () => {
            if (finishedParsing())
                return Buffer.alloc(0);
            const leftBuf = Buffer.alloc(bytesLeftToRead);
            buf.copy(leftBuf, 0, offset);
            return leftBuf;
        },
    };
};
exports.BufferReader = {
    create: createBufferReader,
};
const readBuffer = (buffer) => {
    const bufferReader = createBufferReader(buffer);
    return bufferReader.readNextBuffer;
};
exports.readBuffer = readBuffer;
/* eslint-enable */
//# sourceMappingURL=bufferReader.js.map