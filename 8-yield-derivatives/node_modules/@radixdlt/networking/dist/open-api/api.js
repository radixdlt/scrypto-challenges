"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Radix Gateway API
 * This API is designed to enable clients to efficiently query information on the RadixDLT ledger, and allow clients to simply build and submit transactions to the network.  The API is designed for use by the Radix Foundation\'s [Desktop Wallet](https://wallet.radixdlt.com/) and [Explorer](https://explorer.radixdlt.com/), and replaces the original Olympia \"Archive Node API\".  # Gateway API Overview  The Gateway API is separated into distinct groupings:  * `/gateway` - Information about the Gateway API status * `/account/_*` - To query account-related information * `/token/_*` - To query token-related information * `/validator/_*` and `/validators` - To query validator-related information * `/transaction/_*` - To build, finalize and submit transactions, and to read the status and content of submitted and on-ledger transactions.  The Gateway API is implemented by the [Network Gateway](https://github.com/radixdlt/radixdlt-network-gateway), which is configured to read from full node/s to extract and index data from the network.  # Gateway API Format  The API is designed in a JSON-RPC style, using HTTP as a transport layer, which means that:  * All requests are POST requests. * Any error is returned with an HTTP status code of 500, with a returned error object.   * The error object contains an HTTP-like `code`   * The error object also contains a structured/typed `details` sub-object, with a `type` discriminator, allowing for structured error interpretation in clients.  # Comparison to other Radix APIs  * [Core API](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/radixdlt/radixdlt/main/radixdlt-core/radixdlt/src/main/java/com/radixdlt/api/core/api.yaml) - The Core API is a low level API exposed by full nodes, and designed for use on internal networks. It is primarily designed for network integrations such as exchanges, ledger analytics providers, or hosted ledger data dashboards. The Core API provides endpoints for reading the mempool, constructing transactions and also exposes a stream of committed transactions.  * [System API](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/radixdlt/radixdlt/main/radixdlt-core/radixdlt/src/main/java/com/radixdlt/api/system/api.yaml) - The System API is a private API exposed by full nodes to read system status.  The Gateway API offers a much wider range of query options and is more performant than the Core API. It is built on top of the Core API, ingesting data via the Core API transaction stream into a relational database.  The Gateway API transaction/construction endpoints operate with the concept of \"actions\" - these are higher-levels of intent compared with the Core API, which makes it easier for clients to use. The Core API should be used if you require more power/flexiblity for managing UTXOs, or submitting transactions which can\'t be mapped to a Gateway API action.
 *
 * The version of the OpenAPI document: 1.1.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidatorApi = exports.ValidatorApiFactory = exports.ValidatorApiFp = exports.ValidatorApiAxiosParamCreator = exports.TransactionApi = exports.TransactionApiFactory = exports.TransactionApiFp = exports.TransactionApiAxiosParamCreator = exports.TokenApi = exports.TokenApiFactory = exports.TokenApiFp = exports.TokenApiAxiosParamCreator = exports.StatusApi = exports.StatusApiFactory = exports.StatusApiFp = exports.StatusApiAxiosParamCreator = exports.AccountApi = exports.AccountApiFactory = exports.AccountApiFp = exports.AccountApiAxiosParamCreator = exports.TransactionStatusStatusEnum = void 0;
const tslib_1 = require("tslib");
const axios_1 = (0, tslib_1.__importDefault)(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 * @export
 * @enum {string}
 */
var TransactionStatusStatusEnum;
(function (TransactionStatusStatusEnum) {
    TransactionStatusStatusEnum["Pending"] = "PENDING";
    TransactionStatusStatusEnum["Confirmed"] = "CONFIRMED";
    TransactionStatusStatusEnum["Failed"] = "FAILED";
})(TransactionStatusStatusEnum = exports.TransactionStatusStatusEnum || (exports.TransactionStatusStatusEnum = {}));
/**
 * AccountApi - axios parameter creator
 * @export
 */
const AccountApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns an account\'s available and staked token balances, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Account Balances
         * @param {AccountBalancesRequest} accountBalancesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalancesPost: (accountBalancesRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'accountBalancesRequest' is not null or undefined
            (0, common_1.assertParamExists)('accountBalancesPost', 'accountBalancesRequest', accountBalancesRequest);
            const localVarPath = `/account/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountBalancesRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the account address associated with the given public key.
         * @summary Derive Account Identifier
         * @param {AccountDeriveRequest} accountDeriveRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDerivePost: (accountDeriveRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'accountDeriveRequest' is not null or undefined
            (0, common_1.assertParamExists)('accountDerivePost', 'accountDeriveRequest', accountDeriveRequest);
            const localVarPath = `/account/derive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountDeriveRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Stake Positions
         * @param {AccountStakesRequest} accountStakesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountStakesPost: (accountStakesRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'accountStakesRequest' is not null or undefined
            (0, common_1.assertParamExists)('accountStakesPost', 'accountStakesRequest', accountStakesRequest);
            const localVarPath = `/account/stakes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountStakesRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Account Transactions
         * @param {AccountTransactionsRequest} accountTransactionsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsPost: (accountTransactionsRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'accountTransactionsRequest' is not null or undefined
            (0, common_1.assertParamExists)('accountTransactionsPost', 'accountTransactionsRequest', accountTransactionsRequest);
            const localVarPath = `/account/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountTransactionsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Unstake Positions
         * @param {AccountUnstakesRequest} accountUnstakesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUnstakesPost: (accountUnstakesRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'accountUnstakesRequest' is not null or undefined
            (0, common_1.assertParamExists)('accountUnstakesPost', 'accountUnstakesRequest', accountUnstakesRequest);
            const localVarPath = `/account/unstakes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountUnstakesRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AccountApiAxiosParamCreator = AccountApiAxiosParamCreator;
/**
 * AccountApi - functional programming interface
 * @export
 */
const AccountApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns an account\'s available and staked token balances, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Account Balances
         * @param {AccountBalancesRequest} accountBalancesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalancesPost(accountBalancesRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountBalancesPost(accountBalancesRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the account address associated with the given public key.
         * @summary Derive Account Identifier
         * @param {AccountDeriveRequest} accountDeriveRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDerivePost(accountDeriveRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountDerivePost(accountDeriveRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Stake Positions
         * @param {AccountStakesRequest} accountStakesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountStakesPost(accountStakesRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountStakesPost(accountStakesRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Account Transactions
         * @param {AccountTransactionsRequest} accountTransactionsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsPost(accountTransactionsRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountTransactionsPost(accountTransactionsRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Unstake Positions
         * @param {AccountUnstakesRequest} accountUnstakesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUnstakesPost(accountUnstakesRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountUnstakesPost(accountUnstakesRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AccountApiFp = AccountApiFp;
/**
 * AccountApi - factory interface
 * @export
 */
const AccountApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountApiFp)(configuration);
    return {
        /**
         * Returns an account\'s available and staked token balances, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Account Balances
         * @param {AccountBalancesRequest} accountBalancesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalancesPost(accountBalancesRequest, options) {
            return localVarFp
                .accountBalancesPost(accountBalancesRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns the account address associated with the given public key.
         * @summary Derive Account Identifier
         * @param {AccountDeriveRequest} accountDeriveRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDerivePost(accountDeriveRequest, options) {
            return localVarFp
                .accountDerivePost(accountDeriveRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Stake Positions
         * @param {AccountStakesRequest} accountStakesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountStakesPost(accountStakesRequest, options) {
            return localVarFp
                .accountStakesPost(accountStakesRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Account Transactions
         * @param {AccountTransactionsRequest} accountTransactionsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsPost(accountTransactionsRequest, options) {
            return localVarFp
                .accountTransactionsPost(accountTransactionsRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
         * @summary Get Unstake Positions
         * @param {AccountUnstakesRequest} accountUnstakesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUnstakesPost(accountUnstakesRequest, options) {
            return localVarFp
                .accountUnstakesPost(accountUnstakesRequest, options)
                .then(request => request(axios, basePath));
        },
    };
};
exports.AccountApiFactory = AccountApiFactory;
/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
class AccountApi extends base_1.BaseAPI {
    /**
     * Returns an account\'s available and staked token balances, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
     * @summary Get Account Balances
     * @param {AccountBalancesRequest} accountBalancesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    accountBalancesPost(accountBalancesRequest, options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .accountBalancesPost(accountBalancesRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns the account address associated with the given public key.
     * @summary Derive Account Identifier
     * @param {AccountDeriveRequest} accountDeriveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    accountDerivePost(accountDeriveRequest, options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .accountDerivePost(accountDeriveRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
     * @summary Get Stake Positions
     * @param {AccountStakesRequest} accountStakesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    accountStakesPost(accountStakesRequest, options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .accountStakesPost(accountStakesRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
     * @summary Get Account Transactions
     * @param {AccountTransactionsRequest} accountTransactionsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    accountTransactionsPost(accountTransactionsRequest, options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .accountTransactionsPost(accountTransactionsRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
     * @summary Get Unstake Positions
     * @param {AccountUnstakesRequest} accountUnstakesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    accountUnstakesPost(accountUnstakesRequest, options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .accountUnstakesPost(accountUnstakesRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
}
exports.AccountApi = AccountApi;
/**
 * StatusApi - axios parameter creator
 * @export
 */
const StatusApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the Gateway API version, network and current ledger state.
         * @summary Get Gateway Info
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayPost: (body, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('gatewayPost', 'body', body);
            const localVarPath = `/gateway`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.StatusApiAxiosParamCreator = StatusApiAxiosParamCreator;
/**
 * StatusApi - functional programming interface
 * @export
 */
const StatusApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.StatusApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns the Gateway API version, network and current ledger state.
         * @summary Get Gateway Info
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayPost(body, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.gatewayPost(body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.StatusApiFp = StatusApiFp;
/**
 * StatusApi - factory interface
 * @export
 */
const StatusApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.StatusApiFp)(configuration);
    return {
        /**
         * Returns the Gateway API version, network and current ledger state.
         * @summary Get Gateway Info
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayPost(body, options) {
            return localVarFp
                .gatewayPost(body, options)
                .then(request => request(axios, basePath));
        },
    };
};
exports.StatusApiFactory = StatusApiFactory;
/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
class StatusApi extends base_1.BaseAPI {
    /**
     * Returns the Gateway API version, network and current ledger state.
     * @summary Get Gateway Info
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    gatewayPost(body, options) {
        return (0, exports.StatusApiFp)(this.configuration)
            .gatewayPost(body, options)
            .then(request => request(this.axios, this.basePath));
    }
}
exports.StatusApi = StatusApi;
/**
 * TokenApi - axios parameter creator
 * @export
 */
const TokenApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.
         * @summary Derive Token Identifier
         * @param {TokenDeriveRequest} tokenDeriveRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDerivePost: (tokenDeriveRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'tokenDeriveRequest' is not null or undefined
            (0, common_1.assertParamExists)('tokenDerivePost', 'tokenDeriveRequest', tokenDeriveRequest);
            const localVarPath = `/token/derive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tokenDeriveRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns information about XRD, including its Radix Resource Identifier.
         * @summary Get Native Token Info
         * @param {TokenNativeRequest} tokenNativeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenNativePost: (tokenNativeRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'tokenNativeRequest' is not null or undefined
            (0, common_1.assertParamExists)('tokenNativePost', 'tokenNativeRequest', tokenNativeRequest);
            const localVarPath = `/token/native`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tokenNativeRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns information about any token, given its Radix Resource Identifier.
         * @summary Get Token Info
         * @param {TokenRequest} tokenRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost: (tokenRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'tokenRequest' is not null or undefined
            (0, common_1.assertParamExists)('tokenPost', 'tokenRequest', tokenRequest);
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tokenRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TokenApiAxiosParamCreator = TokenApiAxiosParamCreator;
/**
 * TokenApi - functional programming interface
 * @export
 */
const TokenApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TokenApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.
         * @summary Derive Token Identifier
         * @param {TokenDeriveRequest} tokenDeriveRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDerivePost(tokenDeriveRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenDerivePost(tokenDeriveRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns information about XRD, including its Radix Resource Identifier.
         * @summary Get Native Token Info
         * @param {TokenNativeRequest} tokenNativeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenNativePost(tokenNativeRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenNativePost(tokenNativeRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns information about any token, given its Radix Resource Identifier.
         * @summary Get Token Info
         * @param {TokenRequest} tokenRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(tokenRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenPost(tokenRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TokenApiFp = TokenApiFp;
/**
 * TokenApi - factory interface
 * @export
 */
const TokenApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TokenApiFp)(configuration);
    return {
        /**
         * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.
         * @summary Derive Token Identifier
         * @param {TokenDeriveRequest} tokenDeriveRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDerivePost(tokenDeriveRequest, options) {
            return localVarFp
                .tokenDerivePost(tokenDeriveRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns information about XRD, including its Radix Resource Identifier.
         * @summary Get Native Token Info
         * @param {TokenNativeRequest} tokenNativeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenNativePost(tokenNativeRequest, options) {
            return localVarFp
                .tokenNativePost(tokenNativeRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns information about any token, given its Radix Resource Identifier.
         * @summary Get Token Info
         * @param {TokenRequest} tokenRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(tokenRequest, options) {
            return localVarFp
                .tokenPost(tokenRequest, options)
                .then(request => request(axios, basePath));
        },
    };
};
exports.TokenApiFactory = TokenApiFactory;
/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
class TokenApi extends base_1.BaseAPI {
    /**
     * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.
     * @summary Derive Token Identifier
     * @param {TokenDeriveRequest} tokenDeriveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    tokenDerivePost(tokenDeriveRequest, options) {
        return (0, exports.TokenApiFp)(this.configuration)
            .tokenDerivePost(tokenDeriveRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns information about XRD, including its Radix Resource Identifier.
     * @summary Get Native Token Info
     * @param {TokenNativeRequest} tokenNativeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    tokenNativePost(tokenNativeRequest, options) {
        return (0, exports.TokenApiFp)(this.configuration)
            .tokenNativePost(tokenNativeRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns information about any token, given its Radix Resource Identifier.
     * @summary Get Token Info
     * @param {TokenRequest} tokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    tokenPost(tokenRequest, options) {
        return (0, exports.TokenApiFp)(this.configuration)
            .tokenPost(tokenRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
}
exports.TokenApi = TokenApi;
/**
 * TransactionApi - axios parameter creator
 * @export
 */
const TransactionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a built unsigned transaction payload, from a set of intended actions.
         * @summary Build Transaction
         * @param {TransactionBuildRequest} transactionBuildRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionBuildPost: (transactionBuildRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'transactionBuildRequest' is not null or undefined
            (0, common_1.assertParamExists)('transactionBuildPost', 'transactionBuildRequest', transactionBuildRequest);
            const localVarPath = `/transaction/build`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionBuildRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.
         * @summary Finalize Transaction
         * @param {TransactionFinalizeRequest} transactionFinalizeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionFinalizePost: (transactionFinalizeRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'transactionFinalizeRequest' is not null or undefined
            (0, common_1.assertParamExists)('transactionFinalizePost', 'transactionFinalizeRequest', transactionFinalizeRequest);
            const localVarPath = `/transaction/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionFinalizeRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.
         * @summary Get Recent Transactions
         * @param {RecentTransactionsRequest} recentTransactionsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRecentPost: (recentTransactionsRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'recentTransactionsRequest' is not null or undefined
            (0, common_1.assertParamExists)('transactionRecentPost', 'recentTransactionsRequest', recentTransactionsRequest);
            const localVarPath = `/transaction/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(recentTransactionsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the current rules used to build and validate transactions in the Radix Engine.
         * @summary Get Transaction Rules
         * @param {TransactionRulesRequest} transactionRulesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRulesPost: (transactionRulesRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'transactionRulesRequest' is not null or undefined
            (0, common_1.assertParamExists)('transactionRulesPost', 'transactionRulesRequest', transactionRulesRequest);
            const localVarPath = `/transaction/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionRulesRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.
         * @summary Transaction Status
         * @param {TransactionStatusRequest} transactionStatusRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionStatusPost: (transactionStatusRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'transactionStatusRequest' is not null or undefined
            (0, common_1.assertParamExists)('transactionStatusPost', 'transactionStatusRequest', transactionStatusRequest);
            const localVarPath = `/transaction/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionStatusRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.
         * @summary Submit Transaction
         * @param {TransactionSubmitRequest} transactionSubmitRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionSubmitPost: (transactionSubmitRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'transactionSubmitRequest' is not null or undefined
            (0, common_1.assertParamExists)('transactionSubmitPost', 'transactionSubmitRequest', transactionSubmitRequest);
            const localVarPath = `/transaction/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionSubmitRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TransactionApiAxiosParamCreator = TransactionApiAxiosParamCreator;
/**
 * TransactionApi - functional programming interface
 * @export
 */
const TransactionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransactionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a built unsigned transaction payload, from a set of intended actions.
         * @summary Build Transaction
         * @param {TransactionBuildRequest} transactionBuildRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionBuildPost(transactionBuildRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionBuildPost(transactionBuildRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.
         * @summary Finalize Transaction
         * @param {TransactionFinalizeRequest} transactionFinalizeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionFinalizePost(transactionFinalizeRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionFinalizePost(transactionFinalizeRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.
         * @summary Get Recent Transactions
         * @param {RecentTransactionsRequest} recentTransactionsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRecentPost(recentTransactionsRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionRecentPost(recentTransactionsRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the current rules used to build and validate transactions in the Radix Engine.
         * @summary Get Transaction Rules
         * @param {TransactionRulesRequest} transactionRulesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRulesPost(transactionRulesRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionRulesPost(transactionRulesRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.
         * @summary Transaction Status
         * @param {TransactionStatusRequest} transactionStatusRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionStatusPost(transactionStatusRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionStatusPost(transactionStatusRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.
         * @summary Submit Transaction
         * @param {TransactionSubmitRequest} transactionSubmitRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionSubmitPost(transactionSubmitRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionSubmitPost(transactionSubmitRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TransactionApiFp = TransactionApiFp;
/**
 * TransactionApi - factory interface
 * @export
 */
const TransactionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransactionApiFp)(configuration);
    return {
        /**
         * Returns a built unsigned transaction payload, from a set of intended actions.
         * @summary Build Transaction
         * @param {TransactionBuildRequest} transactionBuildRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionBuildPost(transactionBuildRequest, options) {
            return localVarFp
                .transactionBuildPost(transactionBuildRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.
         * @summary Finalize Transaction
         * @param {TransactionFinalizeRequest} transactionFinalizeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionFinalizePost(transactionFinalizeRequest, options) {
            return localVarFp
                .transactionFinalizePost(transactionFinalizeRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.
         * @summary Get Recent Transactions
         * @param {RecentTransactionsRequest} recentTransactionsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRecentPost(recentTransactionsRequest, options) {
            return localVarFp
                .transactionRecentPost(recentTransactionsRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns the current rules used to build and validate transactions in the Radix Engine.
         * @summary Get Transaction Rules
         * @param {TransactionRulesRequest} transactionRulesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRulesPost(transactionRulesRequest, options) {
            return localVarFp
                .transactionRulesPost(transactionRulesRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.
         * @summary Transaction Status
         * @param {TransactionStatusRequest} transactionStatusRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionStatusPost(transactionStatusRequest, options) {
            return localVarFp
                .transactionStatusPost(transactionStatusRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.
         * @summary Submit Transaction
         * @param {TransactionSubmitRequest} transactionSubmitRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionSubmitPost(transactionSubmitRequest, options) {
            return localVarFp
                .transactionSubmitPost(transactionSubmitRequest, options)
                .then(request => request(axios, basePath));
        },
    };
};
exports.TransactionApiFactory = TransactionApiFactory;
/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
class TransactionApi extends base_1.BaseAPI {
    /**
     * Returns a built unsigned transaction payload, from a set of intended actions.
     * @summary Build Transaction
     * @param {TransactionBuildRequest} transactionBuildRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    transactionBuildPost(transactionBuildRequest, options) {
        return (0, exports.TransactionApiFp)(this.configuration)
            .transactionBuildPost(transactionBuildRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.
     * @summary Finalize Transaction
     * @param {TransactionFinalizeRequest} transactionFinalizeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    transactionFinalizePost(transactionFinalizeRequest, options) {
        return (0, exports.TransactionApiFp)(this.configuration)
            .transactionFinalizePost(transactionFinalizeRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.
     * @summary Get Recent Transactions
     * @param {RecentTransactionsRequest} recentTransactionsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    transactionRecentPost(recentTransactionsRequest, options) {
        return (0, exports.TransactionApiFp)(this.configuration)
            .transactionRecentPost(recentTransactionsRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns the current rules used to build and validate transactions in the Radix Engine.
     * @summary Get Transaction Rules
     * @param {TransactionRulesRequest} transactionRulesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    transactionRulesPost(transactionRulesRequest, options) {
        return (0, exports.TransactionApiFp)(this.configuration)
            .transactionRulesPost(transactionRulesRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.
     * @summary Transaction Status
     * @param {TransactionStatusRequest} transactionStatusRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    transactionStatusPost(transactionStatusRequest, options) {
        return (0, exports.TransactionApiFp)(this.configuration)
            .transactionStatusPost(transactionStatusRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.
     * @summary Submit Transaction
     * @param {TransactionSubmitRequest} transactionSubmitRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    transactionSubmitPost(transactionSubmitRequest, options) {
        return (0, exports.TransactionApiFp)(this.configuration)
            .transactionSubmitPost(transactionSubmitRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
}
exports.TransactionApi = TransactionApi;
/**
 * ValidatorApi - axios parameter creator
 * @export
 */
const ValidatorApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the validator address associated with the given public key.
         * @summary Get Validator Identifier
         * @param {ValidatorDeriveRequest} validatorDeriveRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDerivePost: (validatorDeriveRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'validatorDeriveRequest' is not null or undefined
            (0, common_1.assertParamExists)('validatorDerivePost', 'validatorDeriveRequest', validatorDeriveRequest);
            const localVarPath = `/validator/derive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validatorDeriveRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.
         * @summary Get Validator
         * @param {ValidatorRequest} validatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorPost: (validatorRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'validatorRequest' is not null or undefined
            (0, common_1.assertParamExists)('validatorPost', 'validatorRequest', validatorRequest);
            const localVarPath = `/validator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validatorRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).
         * @summary Get Validator Stakes
         * @param {ValidatorStakesRequest} validatorStakesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorStakesPost: (validatorStakesRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'validatorStakesRequest' is not null or undefined
            (0, common_1.assertParamExists)('validatorStakesPost', 'validatorStakesRequest', validatorStakesRequest);
            const localVarPath = `/validator/stakes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validatorStakesRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns information about all validators.
         * @summary Get Validators
         * @param {ValidatorsRequest} validatorsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsPost: (validatorsRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // verify required parameter 'validatorsRequest' is not null or undefined
            (0, common_1.assertParamExists)('validatorsPost', 'validatorsRequest', validatorsRequest);
            const localVarPath = `/validators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validatorsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ValidatorApiAxiosParamCreator = ValidatorApiAxiosParamCreator;
/**
 * ValidatorApi - functional programming interface
 * @export
 */
const ValidatorApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ValidatorApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns the validator address associated with the given public key.
         * @summary Get Validator Identifier
         * @param {ValidatorDeriveRequest} validatorDeriveRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDerivePost(validatorDeriveRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.validatorDerivePost(validatorDeriveRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.
         * @summary Get Validator
         * @param {ValidatorRequest} validatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorPost(validatorRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.validatorPost(validatorRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).
         * @summary Get Validator Stakes
         * @param {ValidatorStakesRequest} validatorStakesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorStakesPost(validatorStakesRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.validatorStakesPost(validatorStakesRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns information about all validators.
         * @summary Get Validators
         * @param {ValidatorsRequest} validatorsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsPost(validatorsRequest, options) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.validatorsPost(validatorsRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ValidatorApiFp = ValidatorApiFp;
/**
 * ValidatorApi - factory interface
 * @export
 */
const ValidatorApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ValidatorApiFp)(configuration);
    return {
        /**
         * Returns the validator address associated with the given public key.
         * @summary Get Validator Identifier
         * @param {ValidatorDeriveRequest} validatorDeriveRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDerivePost(validatorDeriveRequest, options) {
            return localVarFp
                .validatorDerivePost(validatorDeriveRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.
         * @summary Get Validator
         * @param {ValidatorRequest} validatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorPost(validatorRequest, options) {
            return localVarFp
                .validatorPost(validatorRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).
         * @summary Get Validator Stakes
         * @param {ValidatorStakesRequest} validatorStakesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorStakesPost(validatorStakesRequest, options) {
            return localVarFp
                .validatorStakesPost(validatorStakesRequest, options)
                .then(request => request(axios, basePath));
        },
        /**
         * Returns information about all validators.
         * @summary Get Validators
         * @param {ValidatorsRequest} validatorsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsPost(validatorsRequest, options) {
            return localVarFp
                .validatorsPost(validatorsRequest, options)
                .then(request => request(axios, basePath));
        },
    };
};
exports.ValidatorApiFactory = ValidatorApiFactory;
/**
 * ValidatorApi - object-oriented interface
 * @export
 * @class ValidatorApi
 * @extends {BaseAPI}
 */
class ValidatorApi extends base_1.BaseAPI {
    /**
     * Returns the validator address associated with the given public key.
     * @summary Get Validator Identifier
     * @param {ValidatorDeriveRequest} validatorDeriveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    validatorDerivePost(validatorDeriveRequest, options) {
        return (0, exports.ValidatorApiFp)(this.configuration)
            .validatorDerivePost(validatorDeriveRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.
     * @summary Get Validator
     * @param {ValidatorRequest} validatorRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    validatorPost(validatorRequest, options) {
        return (0, exports.ValidatorApiFp)(this.configuration)
            .validatorPost(validatorRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).
     * @summary Get Validator Stakes
     * @param {ValidatorStakesRequest} validatorStakesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    validatorStakesPost(validatorStakesRequest, options) {
        return (0, exports.ValidatorApiFp)(this.configuration)
            .validatorStakesPost(validatorStakesRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
    /**
     * Returns information about all validators.
     * @summary Get Validators
     * @param {ValidatorsRequest} validatorsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    validatorsPost(validatorsRequest, options) {
        return (0, exports.ValidatorApiFp)(this.configuration)
            .validatorsPost(validatorsRequest, options)
            .then(request => request(this.axios, this.basePath));
    }
}
exports.ValidatorApi = ValidatorApi;
//# sourceMappingURL=api.js.map