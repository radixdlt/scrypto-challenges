"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCClient = void 0;
const tslib_1 = require("tslib");
const client_js_1 = require("@open-rpc/client-js");
const util_1 = require("@radixdlt/util");
const open_rpc_utils_1 = require("open-rpc-utils");
const uuid_1 = require("uuid");
const spec = require('@radixdlt/open-rpc-spec');
const validateMethod = open_rpc_utils_1.validate.bind(null, spec);
const defaultHeaders = ['X-Radixdlt-Method', 'X-Radixdlt-Correlation-Id'];
var Endpoint;
(function (Endpoint) {
    Endpoint["NETWORK_ID"] = "network.get_id";
    Endpoint["TOKEN_BALANCES"] = "account.get_balances";
    Endpoint["TRANSACTION_HISTORY"] = "account.get_transaction_history";
    Endpoint["STAKES"] = "account.get_stake_positions";
    Endpoint["UNSTAKES"] = "account.get_unstake_positions";
    Endpoint["TX_STATUS"] = "transactions.get_transaction_status";
    Endpoint["NETWORK_TX_THROUGHPUT"] = "network.get_throughput";
    Endpoint["NETWORK_TX_DEMAND"] = "network.get_demand";
    Endpoint["VALIDATORS"] = "validators.get_next_epoch_set";
    Endpoint["LOOKUP_TX"] = "transactions.lookup_transaction";
    Endpoint["LOOKUP_VALIDATOR"] = "validators.lookup_validator";
    Endpoint["NATIVE_TOKEN"] = "tokens.get_native_token";
    Endpoint["TOKEN_INFO"] = "tokens.get_info";
    Endpoint["BUILD_TX_FROM_INTENT"] = "construction.build_transaction";
    Endpoint["SUBMIT_TX"] = "construction.submit_transaction";
    Endpoint["FINALIZE_TX"] = "construction.finalize_transaction";
})(Endpoint || (Endpoint = {}));
var MethodLocation;
(function (MethodLocation) {
    MethodLocation["ARCHIVE"] = "archive";
    MethodLocation["CONSTRUCTION"] = "construction";
})(MethodLocation || (MethodLocation = {}));
const MethodEndpoints = {
    [Endpoint.NETWORK_ID]: MethodLocation.ARCHIVE,
    [Endpoint.TOKEN_BALANCES]: MethodLocation.ARCHIVE,
    [Endpoint.TRANSACTION_HISTORY]: MethodLocation.ARCHIVE,
    [Endpoint.STAKES]: MethodLocation.ARCHIVE,
    [Endpoint.UNSTAKES]: MethodLocation.ARCHIVE,
    [Endpoint.TX_STATUS]: MethodLocation.ARCHIVE,
    [Endpoint.NETWORK_TX_THROUGHPUT]: MethodLocation.ARCHIVE,
    [Endpoint.NETWORK_TX_DEMAND]: MethodLocation.ARCHIVE,
    [Endpoint.VALIDATORS]: MethodLocation.ARCHIVE,
    [Endpoint.LOOKUP_TX]: MethodLocation.ARCHIVE,
    [Endpoint.LOOKUP_VALIDATOR]: MethodLocation.ARCHIVE,
    [Endpoint.NATIVE_TOKEN]: MethodLocation.ARCHIVE,
    [Endpoint.TOKEN_INFO]: MethodLocation.ARCHIVE,
    [Endpoint.BUILD_TX_FROM_INTENT]: MethodLocation.CONSTRUCTION,
    [Endpoint.SUBMIT_TX]: MethodLocation.CONSTRUCTION,
    [Endpoint.FINALIZE_TX]: MethodLocation.CONSTRUCTION,
};
const correlationID = (0, uuid_1.v4)();
const RPCClient = (url) => {
    const call = (method, params, headers) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
        // @ts-ignore
        const endpoint = `${url.toString()}${MethodEndpoints[method]}`;
        const transport = new client_js_1.HTTPTransport(endpoint, {
            headers: Object.assign({ [defaultHeaders[0]]: method, [defaultHeaders[1]]: correlationID }, headers),
        });
        const requestManager = new client_js_1.RequestManager([transport]);
        const client = new client_js_1.Client(requestManager);
        const filteredParams = (0, util_1.isArray)(params)
            ? params.filter(item => !!item)
            : params;
        util_1.log.info(`Sending RPC request with method ${method}. ${JSON.stringify(filteredParams, null, 2)}`);
        const result = yield validateMethod(method, filteredParams);
        result.mapErr(err => {
            // need to disable this until rpc spec is fixed with the latest addresses and RRI's
            //	throw err
        });
        /*
        console.log(
            `calling ${method} at ${endpoint} with: ${JSON.stringify(
                filteredParams,
                null,
                2,
            )}`,
        )*/
        const response = yield client.request({
            method: method,
            params: filteredParams,
        });
        util_1.log.info(`Response from ${method} call: ${JSON.stringify(response, null, 2)}`);
        //console.log(`response for ${method} at ${endpoint}`, JSON.stringify(response, null, 2))
        // TODO validate response
        return response;
    });
    return {
        type: 'json-rpc',
        call,
    };
};
exports.RPCClient = RPCClient;
//# sourceMappingURL=open-rpc-client.js.map