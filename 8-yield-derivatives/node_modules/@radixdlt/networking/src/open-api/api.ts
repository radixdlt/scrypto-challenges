/* tslint:disable */
/* eslint-disable */
/**
 * Radix Gateway API
 * This API is designed to enable clients to efficiently query information on the RadixDLT ledger, and allow clients to simply build and submit transactions to the network.  The API is designed for use by the Radix Foundation\'s [Desktop Wallet](https://wallet.radixdlt.com/) and [Explorer](https://explorer.radixdlt.com/), and replaces the original Olympia \"Archive Node API\".  # Gateway API Overview  The Gateway API is separated into distinct groupings:  * `/gateway` - Information about the Gateway API status * `/account/_*` - To query account-related information * `/token/_*` - To query token-related information * `/validator/_*` and `/validators` - To query validator-related information * `/transaction/_*` - To build, finalize and submit transactions, and to read the status and content of submitted and on-ledger transactions.  The Gateway API is implemented by the [Network Gateway](https://github.com/radixdlt/radixdlt-network-gateway), which is configured to read from full node/s to extract and index data from the network.  # Gateway API Format  The API is designed in a JSON-RPC style, using HTTP as a transport layer, which means that:  * All requests are POST requests. * Any error is returned with an HTTP status code of 500, with a returned error object.   * The error object contains an HTTP-like `code`   * The error object also contains a structured/typed `details` sub-object, with a `type` discriminator, allowing for structured error interpretation in clients.  # Comparison to other Radix APIs  * [Core API](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/radixdlt/radixdlt/main/radixdlt-core/radixdlt/src/main/java/com/radixdlt/api/core/api.yaml) - The Core API is a low level API exposed by full nodes, and designed for use on internal networks. It is primarily designed for network integrations such as exchanges, ledger analytics providers, or hosted ledger data dashboards. The Core API provides endpoints for reading the mempool, constructing transactions and also exposes a stream of committed transactions.  * [System API](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/radixdlt/radixdlt/main/radixdlt-core/radixdlt/src/main/java/com/radixdlt/api/system/api.yaml) - The System API is a private API exposed by full nodes to read system status.  The Gateway API offers a much wider range of query options and is more performant than the Core API. It is built on top of the Core API, ingesting data via the Core API transaction stream into a relational database.  The Gateway API transaction/construction endpoints operate with the concept of \"actions\" - these are higher-levels of intent compared with the Core API, which makes it easier for clients to use. The Core API should be used if you require more power/flexiblity for managing UTXOs, or submitting transactions which can\'t be mapped to a Gateway API action.
 *
 * The version of the OpenAPI document: 1.1.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, {
	AxiosPromise,
	AxiosInstance,
	AxiosRequestConfig,
} from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction,
} from './common'
// @ts-ignore
import {
	BASE_PATH,
	COLLECTION_FORMATS,
	RequestArgs,
	BaseAPI,
	RequiredError,
} from './base'

/**
 *
 * @export
 * @interface AccountBalances
 */
export interface AccountBalances {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof AccountBalances
	 */
	staked_and_unstaking_balance: TokenAmount
	/**
	 * A list of all the token balances owned by the account.
	 * @type {Array<TokenAmount>}
	 * @memberof AccountBalances
	 */
	liquid_balances: Array<TokenAmount>
}
/**
 *
 * @export
 * @interface AccountBalancesRequest
 */
export interface AccountBalancesRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof AccountBalancesRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof AccountBalancesRequest
	 */
	account_identifier: AccountIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof AccountBalancesRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
}
/**
 *
 * @export
 * @interface AccountBalancesResponse
 */
export interface AccountBalancesResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof AccountBalancesResponse
	 */
	ledger_state: LedgerState
	/**
	 *
	 * @type {AccountBalances}
	 * @memberof AccountBalancesResponse
	 */
	account_balances: AccountBalances
}
/**
 *
 * @export
 * @interface AccountDeriveRequest
 */
export interface AccountDeriveRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof AccountDeriveRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {PublicKey}
	 * @memberof AccountDeriveRequest
	 */
	public_key: PublicKey
}
/**
 *
 * @export
 * @interface AccountDeriveResponse
 */
export interface AccountDeriveResponse {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof AccountDeriveResponse
	 */
	account_identifier: AccountIdentifier
}
/**
 *
 * @export
 * @interface AccountIdentifier
 */
export interface AccountIdentifier {
	/**
	 * The radix address of the account.
	 * @type {string}
	 * @memberof AccountIdentifier
	 */
	address: string
}
/**
 *
 * @export
 * @interface AccountStakeEntry
 */
export interface AccountStakeEntry {
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof AccountStakeEntry
	 */
	validator_identifier: ValidatorIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof AccountStakeEntry
	 */
	delegated_stake: TokenAmount
}
/**
 *
 * @export
 * @interface AccountStakesRequest
 */
export interface AccountStakesRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof AccountStakesRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof AccountStakesRequest
	 */
	account_identifier: AccountIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof AccountStakesRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
}
/**
 *
 * @export
 * @interface AccountStakesResponse
 */
export interface AccountStakesResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof AccountStakesResponse
	 */
	ledger_state: LedgerState
	/**
	 * The stake positions which will become staked at the next epoch change.
	 * @type {Array<AccountStakeEntry>}
	 * @memberof AccountStakesResponse
	 */
	pending_stakes: Array<AccountStakeEntry>
	/**
	 * The stake positions which are currently staked.
	 * @type {Array<AccountStakeEntry>}
	 * @memberof AccountStakesResponse
	 */
	stakes: Array<AccountStakeEntry>
}
/**
 *
 * @export
 * @interface AccountTransactionsRequest
 */
export interface AccountTransactionsRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof AccountTransactionsRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof AccountTransactionsRequest
	 */
	account_identifier: AccountIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof AccountTransactionsRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
	/**
	 * This cursor allows forward pagination, by providing the cursor from the previous request.
	 * @type {string}
	 * @memberof AccountTransactionsRequest
	 */
	cursor?: string
	/**
	 * The page size requested. The maximum value is 30 at present.
	 * @type {number}
	 * @memberof AccountTransactionsRequest
	 */
	limit?: number
}
/**
 *
 * @export
 * @interface AccountTransactionsResponse
 */
export interface AccountTransactionsResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof AccountTransactionsResponse
	 */
	ledger_state: LedgerState
	/**
	 * The total number of transactions under the account.
	 * @type {number}
	 * @memberof AccountTransactionsResponse
	 */
	total_count?: number
	/**
	 * The cursor to be provided for the next page of results. If missing, this is the last page of results.
	 * @type {string}
	 * @memberof AccountTransactionsResponse
	 */
	next_cursor?: string
	/**
	 * The page of transactions.
	 * @type {Array<TransactionInfo>}
	 * @memberof AccountTransactionsResponse
	 */
	transactions: Array<TransactionInfo>
}
/**
 *
 * @export
 * @interface AccountUnstakeEntry
 */
export interface AccountUnstakeEntry {
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof AccountUnstakeEntry
	 */
	validator_identifier: ValidatorIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof AccountUnstakeEntry
	 */
	unstaking_amount: TokenAmount
	/**
	 * The number of epochs until the XRD in this unstake will be released back to the account. This delay is to enable stake to be slashed, if the validator misbehaves.
	 * @type {number}
	 * @memberof AccountUnstakeEntry
	 */
	epochs_until_unlocked: number
}
/**
 *
 * @export
 * @interface AccountUnstakesRequest
 */
export interface AccountUnstakesRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof AccountUnstakesRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof AccountUnstakesRequest
	 */
	account_identifier: AccountIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof AccountUnstakesRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
}
/**
 *
 * @export
 * @interface AccountUnstakesResponse
 */
export interface AccountUnstakesResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof AccountUnstakesResponse
	 */
	ledger_state: LedgerState
	/**
	 *
	 * @type {Array<AccountUnstakeEntry>}
	 * @memberof AccountUnstakesResponse
	 */
	pending_unstakes: Array<AccountUnstakeEntry>
	/**
	 *
	 * @type {Array<AccountUnstakeEntry>}
	 * @memberof AccountUnstakesResponse
	 */
	unstakes: Array<AccountUnstakeEntry>
}
/**
 *
 * @export
 * @interface Action
 */
export interface Action {
	/**
	 *
	 * @type {string}
	 * @memberof Action
	 */
	type: string
}
/**
 *
 * @export
 * @interface BelowMinimumStakeError
 */
export interface BelowMinimumStakeError extends GatewayError {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof BelowMinimumStakeError
	 */
	requested_amount: TokenAmount
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof BelowMinimumStakeError
	 */
	minimum_amount: TokenAmount
}
/**
 *
 * @export
 * @interface BelowMinimumStakeErrorAllOf
 */
export interface BelowMinimumStakeErrorAllOf {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof BelowMinimumStakeErrorAllOf
	 */
	requested_amount: TokenAmount
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof BelowMinimumStakeErrorAllOf
	 */
	minimum_amount: TokenAmount
}
/**
 *
 * @export
 * @interface BurnTokens
 */
export interface BurnTokens extends Action {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof BurnTokens
	 */
	from_account: AccountIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof BurnTokens
	 */
	amount: TokenAmount
}
/**
 *
 * @export
 * @interface BurnTokensAllOf
 */
export interface BurnTokensAllOf {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof BurnTokensAllOf
	 */
	from_account: AccountIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof BurnTokensAllOf
	 */
	amount: TokenAmount
}
/**
 *
 * @export
 * @interface CannotStakeError
 */
export interface CannotStakeError extends GatewayError {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof CannotStakeError
	 */
	owner: AccountIdentifier
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof CannotStakeError
	 */
	user: AccountIdentifier
}
/**
 *
 * @export
 * @interface CannotStakeErrorAllOf
 */
export interface CannotStakeErrorAllOf {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof CannotStakeErrorAllOf
	 */
	owner: AccountIdentifier
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof CannotStakeErrorAllOf
	 */
	user: AccountIdentifier
}
/**
 *
 * @export
 * @interface CouldNotConstructFeesError
 */
export interface CouldNotConstructFeesError extends GatewayError {
	/**
	 * The number of attempts the system tried and failed to create a consistent transaction fee.
	 * @type {number}
	 * @memberof CouldNotConstructFeesError
	 */
	attempts: number
}
/**
 *
 * @export
 * @interface CouldNotConstructFeesErrorAllOf
 */
export interface CouldNotConstructFeesErrorAllOf {
	/**
	 * The number of attempts the system tried and failed to create a consistent transaction fee.
	 * @type {number}
	 * @memberof CouldNotConstructFeesErrorAllOf
	 */
	attempts: number
}
/**
 *
 * @export
 * @interface CreateTokenDefinition
 */
export interface CreateTokenDefinition extends Action {
	/**
	 *
	 * @type {TokenProperties}
	 * @memberof CreateTokenDefinition
	 */
	token_properties: TokenProperties
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof CreateTokenDefinition
	 */
	token_supply: TokenAmount
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof CreateTokenDefinition
	 */
	to_account?: AccountIdentifier
}
/**
 *
 * @export
 * @interface CreateTokenDefinitionAllOf
 */
export interface CreateTokenDefinitionAllOf {
	/**
	 *
	 * @type {TokenProperties}
	 * @memberof CreateTokenDefinitionAllOf
	 */
	token_properties: TokenProperties
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof CreateTokenDefinitionAllOf
	 */
	token_supply: TokenAmount
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof CreateTokenDefinitionAllOf
	 */
	to_account?: AccountIdentifier
}
/**
 *
 * @export
 * @interface EpochRange
 */
export interface EpochRange {
	/**
	 * The first epoch considered (inclusive).
	 * @type {number}
	 * @memberof EpochRange
	 */
	from: number
	/**
	 * The last epoch considered (inclusive).
	 * @type {number}
	 * @memberof EpochRange
	 */
	to: number
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
	/**
	 * A numeric code corresponding to the given error type, roughly aligned with HTTP Status Code semantics (eg 400/404/500).
	 * @type {number}
	 * @memberof ErrorResponse
	 */
	code: number
	/**
	 * A human-readable error message.
	 * @type {string}
	 * @memberof ErrorResponse
	 */
	message: string
	/**
	 *
	 * @type {GatewayError}
	 * @memberof ErrorResponse
	 */
	details?: GatewayError
	/**
	 * A GUID to be used when reporting errors, to allow correlation with the Gateway API\'s error logs.
	 * @type {string}
	 * @memberof ErrorResponse
	 */
	trace_id?: string
}
/**
 *
 * @export
 * @interface GatewayApiVersions
 */
export interface GatewayApiVersions {
	/**
	 * The release that is currently deployed to the Gateway API.
	 * @type {string}
	 * @memberof GatewayApiVersions
	 */
	version: string
	/**
	 * The open api schema version that was used to generate the API models.
	 * @type {string}
	 * @memberof GatewayApiVersions
	 */
	open_api_schema_version: string
}
/**
 *
 * @export
 * @interface GatewayError
 */
export interface GatewayError {
	/**
	 * The type of error. Each subtype may have its own additional structured fields.
	 * @type {string}
	 * @memberof GatewayError
	 */
	type: string
}
/**
 *
 * @export
 * @interface GatewayResponse
 */
export interface GatewayResponse {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof GatewayResponse
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {GatewayApiVersions}
	 * @memberof GatewayResponse
	 */
	gateway_api: GatewayApiVersions
	/**
	 *
	 * @type {LedgerState}
	 * @memberof GatewayResponse
	 */
	ledger_state: LedgerState
	/**
	 *
	 * @type {TargetLedgerState}
	 * @memberof GatewayResponse
	 */
	target_ledger_state?: TargetLedgerState
}
/**
 *
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError extends GatewayError {
	/**
	 * Gives an error type which occurred within the Gateway API when serving the request.
	 * @type {string}
	 * @memberof InternalServerError
	 */
	exception: string
	/**
	 * Gives a human readable message - likely just a trace ID for reporting the error.
	 * @type {string}
	 * @memberof InternalServerError
	 */
	cause: string
}
/**
 *
 * @export
 * @interface InternalServerErrorAllOf
 */
export interface InternalServerErrorAllOf {
	/**
	 * Gives an error type which occurred within the Gateway API when serving the request.
	 * @type {string}
	 * @memberof InternalServerErrorAllOf
	 */
	exception: string
	/**
	 * Gives a human readable message - likely just a trace ID for reporting the error.
	 * @type {string}
	 * @memberof InternalServerErrorAllOf
	 */
	cause: string
}
/**
 *
 * @export
 * @interface InvalidAccountAddressError
 */
export interface InvalidAccountAddressError extends GatewayError {
	/**
	 * The account address which was invalid. A descriptive reason is given in the main error message.
	 * @type {string}
	 * @memberof InvalidAccountAddressError
	 */
	invalid_account_address: string
}
/**
 *
 * @export
 * @interface InvalidAccountAddressErrorAllOf
 */
export interface InvalidAccountAddressErrorAllOf {
	/**
	 * The account address which was invalid. A descriptive reason is given in the main error message.
	 * @type {string}
	 * @memberof InvalidAccountAddressErrorAllOf
	 */
	invalid_account_address: string
}
/**
 *
 * @export
 * @interface InvalidActionError
 */
export interface InvalidActionError extends GatewayError {
	/**
	 *
	 * @type {Action}
	 * @memberof InvalidActionError
	 */
	invalid_action: Action
}
/**
 *
 * @export
 * @interface InvalidActionErrorAllOf
 */
export interface InvalidActionErrorAllOf {
	/**
	 *
	 * @type {Action}
	 * @memberof InvalidActionErrorAllOf
	 */
	invalid_action: Action
}
/**
 *
 * @export
 * @interface InvalidPublicKeyError
 */
export interface InvalidPublicKeyError extends GatewayError {
	/**
	 * The public key which was invalid. A descriptive reason is given in the main error message.
	 * @type {string}
	 * @memberof InvalidPublicKeyError
	 */
	invalid_public_key: string
}
/**
 *
 * @export
 * @interface InvalidPublicKeyErrorAllOf
 */
export interface InvalidPublicKeyErrorAllOf {
	/**
	 * The public key which was invalid. A descriptive reason is given in the main error message.
	 * @type {string}
	 * @memberof InvalidPublicKeyErrorAllOf
	 */
	invalid_public_key: string
}
/**
 *
 * @export
 * @interface InvalidRequestError
 */
export interface InvalidRequestError extends GatewayError {
	/**
	 * One or more validation errors which occurred when validating the request.
	 * @type {Array<ValidationErrorsAtPath>}
	 * @memberof InvalidRequestError
	 */
	validation_errors: Array<ValidationErrorsAtPath>
}
/**
 *
 * @export
 * @interface InvalidRequestErrorAllOf
 */
export interface InvalidRequestErrorAllOf {
	/**
	 * One or more validation errors which occurred when validating the request.
	 * @type {Array<ValidationErrorsAtPath>}
	 * @memberof InvalidRequestErrorAllOf
	 */
	validation_errors: Array<ValidationErrorsAtPath>
}
/**
 *
 * @export
 * @interface InvalidSignatureError
 */
export interface InvalidSignatureError extends GatewayError {
	/**
	 *
	 * @type {Signature}
	 * @memberof InvalidSignatureError
	 */
	invalid_signature: Signature
}
/**
 *
 * @export
 * @interface InvalidSignatureErrorAllOf
 */
export interface InvalidSignatureErrorAllOf {
	/**
	 *
	 * @type {Signature}
	 * @memberof InvalidSignatureErrorAllOf
	 */
	invalid_signature: Signature
}
/**
 *
 * @export
 * @interface InvalidTokenRRIError
 */
export interface InvalidTokenRRIError extends GatewayError {
	/**
	 * The token rri which was invalid. A descriptive reason is given in the main error message.
	 * @type {string}
	 * @memberof InvalidTokenRRIError
	 */
	invalid_rri: string
}
/**
 *
 * @export
 * @interface InvalidTokenRRIErrorAllOf
 */
export interface InvalidTokenRRIErrorAllOf {
	/**
	 * The token rri which was invalid. A descriptive reason is given in the main error message.
	 * @type {string}
	 * @memberof InvalidTokenRRIErrorAllOf
	 */
	invalid_rri: string
}
/**
 *
 * @export
 * @interface InvalidTokenSymbolError
 */
export interface InvalidTokenSymbolError extends GatewayError {
	/**
	 * The token symbol which was invalid. A descriptive reason is given in the main error message.
	 * @type {string}
	 * @memberof InvalidTokenSymbolError
	 */
	invalid_token_symbol: string
}
/**
 *
 * @export
 * @interface InvalidTokenSymbolErrorAllOf
 */
export interface InvalidTokenSymbolErrorAllOf {
	/**
	 * The token symbol which was invalid. A descriptive reason is given in the main error message.
	 * @type {string}
	 * @memberof InvalidTokenSymbolErrorAllOf
	 */
	invalid_token_symbol: string
}
/**
 *
 * @export
 * @interface InvalidTransactionError
 */
export interface InvalidTransactionError extends GatewayError {
	/**
	 * The transaction payload which was invalid.
	 * @type {string}
	 * @memberof InvalidTransactionError
	 */
	invalid_transaction: string
	/**
	 * A descriptive reason for the invalid transaction.
	 * @type {string}
	 * @memberof InvalidTransactionError
	 */
	message: string
}
/**
 *
 * @export
 * @interface InvalidTransactionErrorAllOf
 */
export interface InvalidTransactionErrorAllOf {
	/**
	 * The transaction payload which was invalid.
	 * @type {string}
	 * @memberof InvalidTransactionErrorAllOf
	 */
	invalid_transaction: string
	/**
	 * A descriptive reason for the invalid transaction.
	 * @type {string}
	 * @memberof InvalidTransactionErrorAllOf
	 */
	message: string
}
/**
 *
 * @export
 * @interface InvalidValidatorAddressError
 */
export interface InvalidValidatorAddressError extends GatewayError {
	/**
	 * The validator address which was invalid. A descriptive reason is given in the main error message.
	 * @type {string}
	 * @memberof InvalidValidatorAddressError
	 */
	invalid_account_address?: string
}
/**
 *
 * @export
 * @interface InvalidValidatorAddressErrorAllOf
 */
export interface InvalidValidatorAddressErrorAllOf {
	/**
	 * The validator address which was invalid. A descriptive reason is given in the main error message.
	 * @type {string}
	 * @memberof InvalidValidatorAddressErrorAllOf
	 */
	invalid_account_address?: string
}
/**
 * The ledger state against which the response was generated. Can be used to detect if the Network Gateway is returning up-to-date information.
 * @export
 * @interface LedgerState
 */
export interface LedgerState {
	/**
	 * The state version of the ledger. Each transaction increments the state version by 1.
	 * @type {number}
	 * @memberof LedgerState
	 */
	version: number
	/**
	 * The round timestamp of the consensus round when this transaction was committed to ledger. This is not guaranteed to be strictly increasing, as it is computed as an average across the validator set. If this is significantly behind the current timestamp, the Network Gateway is likely reporting out-dated information, or the network has stalled.
	 * @type {string}
	 * @memberof LedgerState
	 */
	timestamp: string
	/**
	 * The epoch number of the ledger at this state version.
	 * @type {number}
	 * @memberof LedgerState
	 */
	epoch: number
	/**
	 * The consensus round in the epoch that this state version was committed in.
	 * @type {number}
	 * @memberof LedgerState
	 */
	round: number
}
/**
 *
 * @export
 * @interface MessageTooLongError
 */
export interface MessageTooLongError extends GatewayError {
	/**
	 * The maximum byte length of the message, as per current transaction rules.
	 * @type {number}
	 * @memberof MessageTooLongError
	 */
	length_limit: number
	/**
	 * The byte length of the message in the transaction.
	 * @type {number}
	 * @memberof MessageTooLongError
	 */
	attempted_length: number
}
/**
 *
 * @export
 * @interface MessageTooLongErrorAllOf
 */
export interface MessageTooLongErrorAllOf {
	/**
	 * The maximum byte length of the message, as per current transaction rules.
	 * @type {number}
	 * @memberof MessageTooLongErrorAllOf
	 */
	length_limit: number
	/**
	 * The byte length of the message in the transaction.
	 * @type {number}
	 * @memberof MessageTooLongErrorAllOf
	 */
	attempted_length: number
}
/**
 *
 * @export
 * @interface MintTokens
 */
export interface MintTokens extends Action {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof MintTokens
	 */
	to_account: AccountIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof MintTokens
	 */
	amount: TokenAmount
}
/**
 *
 * @export
 * @interface MintTokensAllOf
 */
export interface MintTokensAllOf {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof MintTokensAllOf
	 */
	to_account: AccountIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof MintTokensAllOf
	 */
	amount: TokenAmount
}
/**
 *
 * @export
 * @interface NetworkIdentifier
 */
export interface NetworkIdentifier {
	/**
	 * The name of the network against which the request is made.
	 * @type {string}
	 * @memberof NetworkIdentifier
	 */
	network: string
}
/**
 *
 * @export
 * @interface NetworkNotSupportedError
 */
export interface NetworkNotSupportedError extends GatewayError {
	/**
	 * The networks actually supported by the gateway - one of these needs to be used in the NetworkIdentifier of the request.
	 * @type {Array<string>}
	 * @memberof NetworkNotSupportedError
	 */
	networks_supported: Array<string>
}
/**
 *
 * @export
 * @interface NetworkNotSupportedErrorAllOf
 */
export interface NetworkNotSupportedErrorAllOf {
	/**
	 * The networks actually supported by the gateway - one of these needs to be used in the NetworkIdentifier of the request.
	 * @type {Array<string>}
	 * @memberof NetworkNotSupportedErrorAllOf
	 */
	networks_supported: Array<string>
}
/**
 *
 * @export
 * @interface NotEnoughNativeTokensForFeesError
 */
export interface NotEnoughNativeTokensForFeesError extends GatewayError {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughNativeTokensForFeesError
	 */
	required_amount: TokenAmount
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughNativeTokensForFeesError
	 */
	available_amount: TokenAmount
}
/**
 *
 * @export
 * @interface NotEnoughNativeTokensForFeesErrorAllOf
 */
export interface NotEnoughNativeTokensForFeesErrorAllOf {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughNativeTokensForFeesErrorAllOf
	 */
	required_amount: TokenAmount
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughNativeTokensForFeesErrorAllOf
	 */
	available_amount: TokenAmount
}
/**
 *
 * @export
 * @interface NotEnoughTokensForStakeError
 */
export interface NotEnoughTokensForStakeError extends GatewayError {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughTokensForStakeError
	 */
	requested_amount: TokenAmount
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughTokensForStakeError
	 */
	available_amount: TokenAmount
}
/**
 *
 * @export
 * @interface NotEnoughTokensForTransferError
 */
export interface NotEnoughTokensForTransferError extends GatewayError {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughTokensForTransferError
	 */
	requested_amount: TokenAmount
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughTokensForTransferError
	 */
	available_amount: TokenAmount
}
/**
 *
 * @export
 * @interface NotEnoughTokensForTransferErrorAllOf
 */
export interface NotEnoughTokensForTransferErrorAllOf {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughTokensForTransferErrorAllOf
	 */
	requested_amount: TokenAmount
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughTokensForTransferErrorAllOf
	 */
	available_amount: TokenAmount
}
/**
 *
 * @export
 * @interface NotEnoughTokensForUnstakeError
 */
export interface NotEnoughTokensForUnstakeError extends GatewayError {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughTokensForUnstakeError
	 */
	requested_amount: TokenAmount
	/**
	 *
	 * @type {AccountStakeEntry}
	 * @memberof NotEnoughTokensForUnstakeError
	 */
	stake: AccountStakeEntry
	/**
	 *
	 * @type {AccountStakeEntry}
	 * @memberof NotEnoughTokensForUnstakeError
	 */
	pending_stake: AccountStakeEntry
}
/**
 *
 * @export
 * @interface NotEnoughTokensForUnstakeErrorAllOf
 */
export interface NotEnoughTokensForUnstakeErrorAllOf {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof NotEnoughTokensForUnstakeErrorAllOf
	 */
	requested_amount: TokenAmount
	/**
	 *
	 * @type {AccountStakeEntry}
	 * @memberof NotEnoughTokensForUnstakeErrorAllOf
	 */
	stake: AccountStakeEntry
	/**
	 *
	 * @type {AccountStakeEntry}
	 * @memberof NotEnoughTokensForUnstakeErrorAllOf
	 */
	pending_stake: AccountStakeEntry
}
/**
 *
 * @export
 * @interface NotSyncedUpError
 */
export interface NotSyncedUpError extends GatewayError {
	/**
	 * The request type that triggered this exception.
	 * @type {string}
	 * @memberof NotSyncedUpError
	 */
	request_type: string
	/**
	 * The current delay between the Gateway DB and the network ledger round timestamp.
	 * @type {number}
	 * @memberof NotSyncedUpError
	 */
	current_sync_delay_seconds: number
	/**
	 * The maximum allowed delay between the Gateway DB and the network ledger round timestamp for this `request_type`.
	 * @type {number}
	 * @memberof NotSyncedUpError
	 */
	max_allowed_sync_delay_seconds: number
}
/**
 *
 * @export
 * @interface NotSyncedUpErrorAllOf
 */
export interface NotSyncedUpErrorAllOf {
	/**
	 * The request type that triggered this exception.
	 * @type {string}
	 * @memberof NotSyncedUpErrorAllOf
	 */
	request_type: string
	/**
	 * The current delay between the Gateway DB and the network ledger round timestamp.
	 * @type {number}
	 * @memberof NotSyncedUpErrorAllOf
	 */
	current_sync_delay_seconds: number
	/**
	 * The maximum allowed delay between the Gateway DB and the network ledger round timestamp for this `request_type`.
	 * @type {number}
	 * @memberof NotSyncedUpErrorAllOf
	 */
	max_allowed_sync_delay_seconds: number
}
/**
 * Optional. Allows a client to request a response referencing an earlier ledger state.
 * @export
 * @interface PartialLedgerStateIdentifier
 */
export interface PartialLedgerStateIdentifier {
	/**
	 * If the version is provided, the latest ledger state <= the given version is returned.
	 * @type {number}
	 * @memberof PartialLedgerStateIdentifier
	 */
	version?: number
	/**
	 * If a timestamp is provided, the latest ledger state <= the given timestamp is returned.
	 * @type {string}
	 * @memberof PartialLedgerStateIdentifier
	 */
	timestamp?: string
	/**
	 * If an epoch is provided, the ledger state at the given epoch <= the given round (else round 0) is returned.
	 * @type {number}
	 * @memberof PartialLedgerStateIdentifier
	 */
	epoch?: number
	/**
	 *
	 * @type {number}
	 * @memberof PartialLedgerStateIdentifier
	 */
	round?: number
}
/**
 *
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
	/**
	 * The compressed public key (33 bytes), hex-encoded.
	 * @type {string}
	 * @memberof PublicKey
	 */
	hex: string
}
/**
 *
 * @export
 * @interface RecentTransactionsRequest
 */
export interface RecentTransactionsRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof RecentTransactionsRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof RecentTransactionsRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
	/**
	 * This cursor allows forward pagination, by providing the cursor from the previous request.
	 * @type {string}
	 * @memberof RecentTransactionsRequest
	 */
	cursor?: string
	/**
	 * The page size requested. The maximum value is 30 at present.
	 * @type {number}
	 * @memberof RecentTransactionsRequest
	 */
	limit?: number
}
/**
 *
 * @export
 * @interface RecentTransactionsResponse
 */
export interface RecentTransactionsResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof RecentTransactionsResponse
	 */
	ledger_state: LedgerState
	/**
	 * The cursor to be provided for the next page of results. If missing, this is the last page of results.
	 * @type {string}
	 * @memberof RecentTransactionsResponse
	 */
	next_cursor?: string
	/**
	 * The page of user transactions.
	 * @type {Array<TransactionInfo>}
	 * @memberof RecentTransactionsResponse
	 */
	transactions: Array<TransactionInfo>
}
/**
 *
 * @export
 * @interface RegisterValidator
 */
export interface RegisterValidator extends Action {
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof RegisterValidator
	 */
	validator: ValidatorIdentifier
}
/**
 *
 * @export
 * @interface RegisterValidatorAllOf
 */
export interface RegisterValidatorAllOf {
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof RegisterValidatorAllOf
	 */
	validator: ValidatorIdentifier
}
/**
 *
 * @export
 * @interface Signature
 */
export interface Signature {
	/**
	 *
	 * @type {PublicKey}
	 * @memberof Signature
	 */
	public_key: PublicKey
	/**
	 * An ECDSA signature of the payload to sign with the given `public_key`. The ECDSA signature should be created using the secp256k1 curve and should be encoded in DER format, and then encoded as a hex string.
	 * @type {string}
	 * @memberof Signature
	 */
	bytes: string
}
/**
 *
 * @export
 * @interface StakeTokens
 */
export interface StakeTokens extends Action {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof StakeTokens
	 */
	from_account: AccountIdentifier
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof StakeTokens
	 */
	to_validator: ValidatorIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof StakeTokens
	 */
	amount: TokenAmount
}
/**
 *
 * @export
 * @interface StakeTokensAllOf
 */
export interface StakeTokensAllOf {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof StakeTokensAllOf
	 */
	from_account: AccountIdentifier
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof StakeTokensAllOf
	 */
	to_validator: ValidatorIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof StakeTokensAllOf
	 */
	amount: TokenAmount
}
/**
 *
 * @export
 * @interface TargetLedgerState
 */
export interface TargetLedgerState {
	/**
	 * The latest-seen state version of the tip of the network\'s ledger. If this is singificantly ahead of the current LedgerState version, the Network Gateway is possibly behind and may be reporting outdated information.
	 * @type {number}
	 * @memberof TargetLedgerState
	 */
	version: number
}
/**
 *
 * @export
 * @interface Token
 */
export interface Token {
	/**
	 *
	 * @type {TokenIdentifier}
	 * @memberof Token
	 */
	token_identifier: TokenIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof Token
	 */
	token_supply: TokenAmount
	/**
	 *
	 * @type {TokenInfo}
	 * @memberof Token
	 */
	info: TokenInfo
	/**
	 *
	 * @type {TokenProperties}
	 * @memberof Token
	 */
	token_properties: TokenProperties
}
/**
 *
 * @export
 * @interface TokenAmount
 */
export interface TokenAmount {
	/**
	 *
	 * @type {string}
	 * @memberof TokenAmount
	 */
	value: string
	/**
	 *
	 * @type {TokenIdentifier}
	 * @memberof TokenAmount
	 */
	token_identifier: TokenIdentifier
}
/**
 *
 * @export
 * @interface TokenDeriveRequest
 */
export interface TokenDeriveRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof TokenDeriveRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {PublicKey}
	 * @memberof TokenDeriveRequest
	 */
	public_key: PublicKey
	/**
	 *
	 * @type {string}
	 * @memberof TokenDeriveRequest
	 */
	symbol: string
}
/**
 *
 * @export
 * @interface TokenDeriveResponse
 */
export interface TokenDeriveResponse {
	/**
	 *
	 * @type {TokenIdentifier}
	 * @memberof TokenDeriveResponse
	 */
	token_identifier: TokenIdentifier
}
/**
 *
 * @export
 * @interface TokenIdentifier
 */
export interface TokenIdentifier {
	/**
	 * The radix resource identifier of the token.
	 * @type {string}
	 * @memberof TokenIdentifier
	 */
	rri: string
}
/**
 *
 * @export
 * @interface TokenInfo
 */
export interface TokenInfo {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof TokenInfo
	 */
	total_minted: TokenAmount
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof TokenInfo
	 */
	total_burned: TokenAmount
}
/**
 *
 * @export
 * @interface TokenNativeRequest
 */
export interface TokenNativeRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof TokenNativeRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof TokenNativeRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
}
/**
 *
 * @export
 * @interface TokenNativeResponse
 */
export interface TokenNativeResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof TokenNativeResponse
	 */
	ledger_state: LedgerState
	/**
	 *
	 * @type {Token}
	 * @memberof TokenNativeResponse
	 */
	token: Token
}
/**
 *
 * @export
 * @interface TokenNotFoundError
 */
export interface TokenNotFoundError extends GatewayError {
	/**
	 *
	 * @type {TokenIdentifier}
	 * @memberof TokenNotFoundError
	 */
	token_not_found: TokenIdentifier
}
/**
 *
 * @export
 * @interface TokenNotFoundErrorAllOf
 */
export interface TokenNotFoundErrorAllOf {
	/**
	 *
	 * @type {TokenIdentifier}
	 * @memberof TokenNotFoundErrorAllOf
	 */
	token_not_found: TokenIdentifier
}
/**
 *
 * @export
 * @interface TokenProperties
 */
export interface TokenProperties {
	/**
	 *
	 * @type {string}
	 * @memberof TokenProperties
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof TokenProperties
	 */
	description: string
	/**
	 *
	 * @type {string}
	 * @memberof TokenProperties
	 */
	icon_url: string
	/**
	 *
	 * @type {string}
	 * @memberof TokenProperties
	 */
	url: string
	/**
	 *
	 * @type {string}
	 * @memberof TokenProperties
	 */
	symbol: string
	/**
	 * If true, the token is allowed to be minted/burned by the owner.
	 * @type {boolean}
	 * @memberof TokenProperties
	 */
	is_supply_mutable: boolean
	/**
	 *
	 * @type {string}
	 * @memberof TokenProperties
	 */
	granularity: string
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof TokenProperties
	 */
	owner?: AccountIdentifier
}
/**
 *
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof TokenRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {TokenIdentifier}
	 * @memberof TokenRequest
	 */
	token_identifier: TokenIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof TokenRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
}
/**
 *
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof TokenResponse
	 */
	ledger_state: LedgerState
	/**
	 *
	 * @type {Token}
	 * @memberof TokenResponse
	 */
	token: Token
}
/**
 *
 * @export
 * @interface TransactionBuild
 */
export interface TransactionBuild {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof TransactionBuild
	 */
	fee: TokenAmount
	/**
	 * The unsigned transaction payload, hex encoded.
	 * @type {string}
	 * @memberof TransactionBuild
	 */
	unsigned_transaction: string
	/**
	 * The payload which needs signing, hex encoded. This is `SHA256(SHA256(unsigned_transaction_bytes))`.
	 * @type {string}
	 * @memberof TransactionBuild
	 */
	payload_to_sign: string
}
/**
 *
 * @export
 * @interface TransactionBuildRequest
 */
export interface TransactionBuildRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof TransactionBuildRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof TransactionBuildRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
	/**
	 *
	 * @type {Array<Action>}
	 * @memberof TransactionBuildRequest
	 */
	actions: Array<Action>
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof TransactionBuildRequest
	 */
	fee_payer: AccountIdentifier
	/**
	 * The hex-encoded message bytes.
	 * @type {string}
	 * @memberof TransactionBuildRequest
	 */
	message?: string
	/**
	 * If true, mints and burns (aside from fee payments) are not permitted during transaction execution.
	 * @type {boolean}
	 * @memberof TransactionBuildRequest
	 */
	disable_token_mint_and_burn?: boolean
}
/**
 *
 * @export
 * @interface TransactionBuildResponse
 */
export interface TransactionBuildResponse {
	/**
	 *
	 * @type {TransactionBuild}
	 * @memberof TransactionBuildResponse
	 */
	transaction_build: TransactionBuild
}
/**
 *
 * @export
 * @interface TransactionFinalizeRequest
 */
export interface TransactionFinalizeRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof TransactionFinalizeRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 * The unsigned transaction payload, hex encoded.
	 * @type {string}
	 * @memberof TransactionFinalizeRequest
	 */
	unsigned_transaction: string
	/**
	 *
	 * @type {Signature}
	 * @memberof TransactionFinalizeRequest
	 */
	signature: Signature
	/**
	 * If true, the transaction is immediately submitted after finalization. However, we recommend that a transaction is submitted in a step after finalization. This ensures that you have a transaction identifier on hand to monitor the transaction status, even if the submission request failed with an uncertain error.
	 * @type {boolean}
	 * @memberof TransactionFinalizeRequest
	 */
	submit?: boolean
}
/**
 *
 * @export
 * @interface TransactionFinalizeResponse
 */
export interface TransactionFinalizeResponse {
	/**
	 * The signed transaction payload which can be submitted, hex encoded.
	 * @type {string}
	 * @memberof TransactionFinalizeResponse
	 */
	signed_transaction: string
	/**
	 *
	 * @type {TransactionIdentifier}
	 * @memberof TransactionFinalizeResponse
	 */
	transaction_identifier: TransactionIdentifier
}
/**
 *
 * @export
 * @interface TransactionIdentifier
 */
export interface TransactionIdentifier {
	/**
	 * The transaction identifier hash.
	 * @type {string}
	 * @memberof TransactionIdentifier
	 */
	hash: string
}
/**
 *
 * @export
 * @interface TransactionInfo
 */
export interface TransactionInfo {
	/**
	 *
	 * @type {TransactionStatus}
	 * @memberof TransactionInfo
	 */
	transaction_status: TransactionStatus
	/**
	 *
	 * @type {TransactionIdentifier}
	 * @memberof TransactionInfo
	 */
	transaction_identifier: TransactionIdentifier
	/**
	 *
	 * @type {Array<Action>}
	 * @memberof TransactionInfo
	 */
	actions: Array<Action>
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof TransactionInfo
	 */
	fee_paid: TokenAmount
	/**
	 *
	 * @type {TransactionMetadata}
	 * @memberof TransactionInfo
	 */
	metadata: TransactionMetadata
}
/**
 *
 * @export
 * @interface TransactionMetadata
 */
export interface TransactionMetadata {
	/**
	 * The transaction payload, hex encoded.
	 * @type {string}
	 * @memberof TransactionMetadata
	 */
	hex: string
	/**
	 * The message bytes, hex encoded.
	 * @type {string}
	 * @memberof TransactionMetadata
	 */
	message?: string
}
/**
 *
 * @export
 * @interface TransactionNotFoundError
 */
export interface TransactionNotFoundError extends GatewayError {
	/**
	 *
	 * @type {TransactionIdentifier}
	 * @memberof TransactionNotFoundError
	 */
	transaction_not_found: TransactionIdentifier
}
/**
 *
 * @export
 * @interface TransactionNotFoundErrorAllOf
 */
export interface TransactionNotFoundErrorAllOf {
	/**
	 *
	 * @type {TransactionIdentifier}
	 * @memberof TransactionNotFoundErrorAllOf
	 */
	transaction_not_found: TransactionIdentifier
}
/**
 *
 * @export
 * @interface TransactionRules
 */
export interface TransactionRules {
	/**
	 *
	 * @type {number}
	 * @memberof TransactionRules
	 */
	maximum_message_length?: number
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof TransactionRules
	 */
	minimum_stake?: TokenAmount
}
/**
 *
 * @export
 * @interface TransactionRulesRequest
 */
export interface TransactionRulesRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof TransactionRulesRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof TransactionRulesRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
}
/**
 *
 * @export
 * @interface TransactionRulesResponse
 */
export interface TransactionRulesResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof TransactionRulesResponse
	 */
	ledger_state: LedgerState
	/**
	 *
	 * @type {TransactionRules}
	 * @memberof TransactionRulesResponse
	 */
	transaction_rules: TransactionRules
}
/**
 *
 * @export
 * @interface TransactionStatus
 */
export interface TransactionStatus {
	/**
	 *
	 * @type {string}
	 * @memberof TransactionStatus
	 */
	status: TransactionStatusStatusEnum
	/**
	 *
	 * @type {string}
	 * @memberof TransactionStatus
	 */
	confirmed_time?: string
	/**
	 *
	 * @type {number}
	 * @memberof TransactionStatus
	 */
	ledger_state_version?: number
}

/**
 * @export
 * @enum {string}
 */
export enum TransactionStatusStatusEnum {
	Pending = 'PENDING',
	Confirmed = 'CONFIRMED',
	Failed = 'FAILED',
}

/**
 *
 * @export
 * @interface TransactionStatusRequest
 */
export interface TransactionStatusRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof TransactionStatusRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {TransactionIdentifier}
	 * @memberof TransactionStatusRequest
	 */
	transaction_identifier: TransactionIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof TransactionStatusRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
}
/**
 *
 * @export
 * @interface TransactionStatusResponse
 */
export interface TransactionStatusResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof TransactionStatusResponse
	 */
	ledger_state: LedgerState
	/**
	 *
	 * @type {TransactionInfo}
	 * @memberof TransactionStatusResponse
	 */
	transaction: TransactionInfo
}
/**
 *
 * @export
 * @interface TransactionSubmitRequest
 */
export interface TransactionSubmitRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof TransactionSubmitRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 * The signed transaction payload which can be submitted, hex encoded.
	 * @type {string}
	 * @memberof TransactionSubmitRequest
	 */
	signed_transaction: string
}
/**
 *
 * @export
 * @interface TransactionSubmitResponse
 */
export interface TransactionSubmitResponse {
	/**
	 *
	 * @type {TransactionIdentifier}
	 * @memberof TransactionSubmitResponse
	 */
	transaction_identifier: TransactionIdentifier
}
/**
 *
 * @export
 * @interface TransferTokens
 */
export interface TransferTokens extends Action {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof TransferTokens
	 */
	from_account: AccountIdentifier
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof TransferTokens
	 */
	to_account: AccountIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof TransferTokens
	 */
	amount: TokenAmount
}
/**
 *
 * @export
 * @interface TransferTokensAllOf
 */
export interface TransferTokensAllOf {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof TransferTokensAllOf
	 */
	from_account: AccountIdentifier
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof TransferTokensAllOf
	 */
	to_account: AccountIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof TransferTokensAllOf
	 */
	amount: TokenAmount
}
/**
 *
 * @export
 * @interface UnregisterValidator
 */
export interface UnregisterValidator extends Action {
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof UnregisterValidator
	 */
	validator: ValidatorIdentifier
}
/**
 * An action to unstake tokens. Exactly one of amount or unstake_percentage is required.
 * @export
 * @interface UnstakeTokens
 */
export interface UnstakeTokens extends Action {
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof UnstakeTokens
	 */
	from_validator: ValidatorIdentifier
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof UnstakeTokens
	 */
	to_account: AccountIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof UnstakeTokens
	 */
	amount?: TokenAmount
	/**
	 * The percentage of currently staked XRD to unstake, where the proportion is a proportion of the current active stake at the given LedgerState. To be explicit, the referenced active state does not include pending stake, pending unstake or locked unstake.
	 * @type {number}
	 * @memberof UnstakeTokens
	 */
	unstake_percentage?: number
}
/**
 *
 * @export
 * @interface UnstakeTokensAllOf
 */
export interface UnstakeTokensAllOf {
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof UnstakeTokensAllOf
	 */
	from_validator: ValidatorIdentifier
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof UnstakeTokensAllOf
	 */
	to_account: AccountIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof UnstakeTokensAllOf
	 */
	amount?: TokenAmount
	/**
	 * The percentage of currently staked XRD to unstake, where the proportion is a proportion of the current active stake at the given LedgerState. To be explicit, the referenced active state does not include pending stake, pending unstake or locked unstake.
	 * @type {number}
	 * @memberof UnstakeTokensAllOf
	 */
	unstake_percentage?: number
}
/**
 *
 * @export
 * @interface ValidationErrorsAtPath
 */
export interface ValidationErrorsAtPath {
	/**
	 *
	 * @type {string}
	 * @memberof ValidationErrorsAtPath
	 */
	path: string
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ValidationErrorsAtPath
	 */
	errors: Array<string>
}
/**
 *
 * @export
 * @interface Validator
 */
export interface Validator {
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof Validator
	 */
	validator_identifier: ValidatorIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof Validator
	 */
	stake: TokenAmount
	/**
	 *
	 * @type {ValidatorInfo}
	 * @memberof Validator
	 */
	info: ValidatorInfo
	/**
	 *
	 * @type {ValidatorProperties}
	 * @memberof Validator
	 */
	properties: ValidatorProperties
	/**
	 *
	 * @type {ValidatorForkSignal}
	 * @memberof Validator
	 */
	latest_fork_readiness_signal?: ValidatorForkSignal
}
/**
 *
 * @export
 * @interface ValidatorAccountStake
 */
export interface ValidatorAccountStake {
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof ValidatorAccountStake
	 */
	account: AccountIdentifier
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof ValidatorAccountStake
	 */
	validator: ValidatorIdentifier
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof ValidatorAccountStake
	 */
	total_pending_stake?: TokenAmount
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof ValidatorAccountStake
	 */
	total_stake?: TokenAmount
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof ValidatorAccountStake
	 */
	total_pending_unstake?: TokenAmount
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof ValidatorAccountStake
	 */
	total_unstaking?: TokenAmount
}
/**
 *
 * @export
 * @interface ValidatorDeriveRequest
 */
export interface ValidatorDeriveRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof ValidatorDeriveRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {PublicKey}
	 * @memberof ValidatorDeriveRequest
	 */
	public_key: PublicKey
}
/**
 *
 * @export
 * @interface ValidatorDeriveResponse
 */
export interface ValidatorDeriveResponse {
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof ValidatorDeriveResponse
	 */
	account_identifier: ValidatorIdentifier
}
/**
 *
 * @export
 * @interface ValidatorForkSignal
 */
export interface ValidatorForkSignal {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof ValidatorForkSignal
	 */
	signalled_at: LedgerState
	/**
	 * The logical fork id, which is used for counting votes. The logical id encodes the name, as well as the thresholds when the fork would activate. If a signal is cleared, this field may be empty.
	 * @type {string}
	 * @memberof ValidatorForkSignal
	 */
	fork_id?: string
	/**
	 * The human-readable fork name. If a signal is cleared, this field may be empty.
	 * @type {string}
	 * @memberof ValidatorForkSignal
	 */
	fork_name?: string
}
/**
 *
 * @export
 * @interface ValidatorIdentifier
 */
export interface ValidatorIdentifier {
	/**
	 * The radix address of the validator.
	 * @type {string}
	 * @memberof ValidatorIdentifier
	 */
	address: string
}
/**
 *
 * @export
 * @interface ValidatorInfo
 */
export interface ValidatorInfo {
	/**
	 *
	 * @type {TokenAmount}
	 * @memberof ValidatorInfo
	 */
	owner_stake: TokenAmount
	/**
	 *
	 * @type {ValidatorUptime}
	 * @memberof ValidatorInfo
	 */
	uptime: ValidatorUptime
}
/**
 *
 * @export
 * @interface ValidatorProperties
 */
export interface ValidatorProperties {
	/**
	 *
	 * @type {string}
	 * @memberof ValidatorProperties
	 */
	url: string
	/**
	 *
	 * @type {number}
	 * @memberof ValidatorProperties
	 */
	validator_fee_percentage: number
	/**
	 *
	 * @type {string}
	 * @memberof ValidatorProperties
	 */
	name: string
	/**
	 *
	 * @type {boolean}
	 * @memberof ValidatorProperties
	 */
	registered: boolean
	/**
	 *
	 * @type {AccountIdentifier}
	 * @memberof ValidatorProperties
	 */
	owner_account_identifier: AccountIdentifier
	/**
	 *
	 * @type {boolean}
	 * @memberof ValidatorProperties
	 */
	external_stake_accepted: boolean
}
/**
 *
 * @export
 * @interface ValidatorRequest
 */
export interface ValidatorRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof ValidatorRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof ValidatorRequest
	 */
	validator_identifier: ValidatorIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof ValidatorRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
}
/**
 *
 * @export
 * @interface ValidatorResponse
 */
export interface ValidatorResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof ValidatorResponse
	 */
	ledger_state: LedgerState
	/**
	 *
	 * @type {Validator}
	 * @memberof ValidatorResponse
	 */
	validator: Validator
}
/**
 *
 * @export
 * @interface ValidatorStakesRequest
 */
export interface ValidatorStakesRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof ValidatorStakesRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof ValidatorStakesRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
	/**
	 *
	 * @type {ValidatorIdentifier}
	 * @memberof ValidatorStakesRequest
	 */
	validator_identifier: ValidatorIdentifier
	/**
	 * This cursor allows forward pagination, by providing the cursor from the previous request.
	 * @type {string}
	 * @memberof ValidatorStakesRequest
	 */
	cursor?: string
	/**
	 * The page size requested. The maximum value is 30 at present.
	 * @type {number}
	 * @memberof ValidatorStakesRequest
	 */
	limit?: number
}
/**
 *
 * @export
 * @interface ValidatorStakesResponse
 */
export interface ValidatorStakesResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof ValidatorStakesResponse
	 */
	ledger_state: LedgerState
	/**
	 * The total number of accounts delegating stake to the validator in some state.
	 * @type {number}
	 * @memberof ValidatorStakesResponse
	 */
	total_count: number
	/**
	 * The cursor to be provided for the next page of results. If missing, this is the last page of results.
	 * @type {string}
	 * @memberof ValidatorStakesResponse
	 */
	next_cursor?: string
	/**
	 * The page of account stake delegations.
	 * @type {Array<ValidatorAccountStake>}
	 * @memberof ValidatorStakesResponse
	 */
	account_stake_delegations: Array<ValidatorAccountStake>
}
/**
 *
 * @export
 * @interface ValidatorUptime
 */
export interface ValidatorUptime {
	/**
	 *
	 * @type {EpochRange}
	 * @memberof ValidatorUptime
	 */
	epoch_range: EpochRange
	/**
	 * The percentage of proposals completed, compared with the total of proposals completed/missed, in the given epoch range.
	 * @type {number}
	 * @memberof ValidatorUptime
	 */
	uptime_percentage: number
	/**
	 * The number of proposals the validator failed to share with the network in time, in the given epoch range.
	 * @type {number}
	 * @memberof ValidatorUptime
	 */
	proposals_missed: number
	/**
	 * The number of proposals the validator completed successfully, in the given epoch range.
	 * @type {number}
	 * @memberof ValidatorUptime
	 */
	proposals_completed: number
}
/**
 *
 * @export
 * @interface ValidatorsRequest
 */
export interface ValidatorsRequest {
	/**
	 *
	 * @type {NetworkIdentifier}
	 * @memberof ValidatorsRequest
	 */
	network_identifier: NetworkIdentifier
	/**
	 *
	 * @type {PartialLedgerStateIdentifier}
	 * @memberof ValidatorsRequest
	 */
	at_state_identifier?: PartialLedgerStateIdentifier
}
/**
 *
 * @export
 * @interface ValidatorsResponse
 */
export interface ValidatorsResponse {
	/**
	 *
	 * @type {LedgerState}
	 * @memberof ValidatorsResponse
	 */
	ledger_state: LedgerState
	/**
	 *
	 * @type {Array<Validator>}
	 * @memberof ValidatorsResponse
	 */
	validators: Array<Validator>
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * Returns an account\'s available and staked token balances, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Account Balances
		 * @param {AccountBalancesRequest} accountBalancesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountBalancesPost: async (
			accountBalancesRequest: AccountBalancesRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'accountBalancesRequest' is not null or undefined
			assertParamExists(
				'accountBalancesPost',
				'accountBalancesRequest',
				accountBalancesRequest,
			)
			const localVarPath = `/account/balances`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				accountBalancesRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns the account address associated with the given public key.
		 * @summary Derive Account Identifier
		 * @param {AccountDeriveRequest} accountDeriveRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountDerivePost: async (
			accountDeriveRequest: AccountDeriveRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'accountDeriveRequest' is not null or undefined
			assertParamExists(
				'accountDerivePost',
				'accountDeriveRequest',
				accountDeriveRequest,
			)
			const localVarPath = `/account/derive`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				accountDeriveRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Stake Positions
		 * @param {AccountStakesRequest} accountStakesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountStakesPost: async (
			accountStakesRequest: AccountStakesRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'accountStakesRequest' is not null or undefined
			assertParamExists(
				'accountStakesPost',
				'accountStakesRequest',
				accountStakesRequest,
			)
			const localVarPath = `/account/stakes`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				accountStakesRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Account Transactions
		 * @param {AccountTransactionsRequest} accountTransactionsRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountTransactionsPost: async (
			accountTransactionsRequest: AccountTransactionsRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'accountTransactionsRequest' is not null or undefined
			assertParamExists(
				'accountTransactionsPost',
				'accountTransactionsRequest',
				accountTransactionsRequest,
			)
			const localVarPath = `/account/transactions`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				accountTransactionsRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Unstake Positions
		 * @param {AccountUnstakesRequest} accountUnstakesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountUnstakesPost: async (
			accountUnstakesRequest: AccountUnstakesRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'accountUnstakesRequest' is not null or undefined
			assertParamExists(
				'accountUnstakesPost',
				'accountUnstakesRequest',
				accountUnstakesRequest,
			)
			const localVarPath = `/account/unstakes`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				accountUnstakesRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
	return {
		/**
		 * Returns an account\'s available and staked token balances, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Account Balances
		 * @param {AccountBalancesRequest} accountBalancesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async accountBalancesPost(
			accountBalancesRequest: AccountBalancesRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<AccountBalancesResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.accountBalancesPost(
				accountBalancesRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns the account address associated with the given public key.
		 * @summary Derive Account Identifier
		 * @param {AccountDeriveRequest} accountDeriveRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async accountDerivePost(
			accountDeriveRequest: AccountDeriveRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<AccountDeriveResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.accountDerivePost(
				accountDeriveRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Stake Positions
		 * @param {AccountStakesRequest} accountStakesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async accountStakesPost(
			accountStakesRequest: AccountStakesRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<AccountStakesResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.accountStakesPost(
				accountStakesRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Account Transactions
		 * @param {AccountTransactionsRequest} accountTransactionsRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async accountTransactionsPost(
			accountTransactionsRequest: AccountTransactionsRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<AccountTransactionsResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.accountTransactionsPost(
				accountTransactionsRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Unstake Positions
		 * @param {AccountUnstakesRequest} accountUnstakesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async accountUnstakesPost(
			accountUnstakesRequest: AccountUnstakesRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<AccountUnstakesResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.accountUnstakesPost(
				accountUnstakesRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
	}
}

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = AccountApiFp(configuration)
	return {
		/**
		 * Returns an account\'s available and staked token balances, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Account Balances
		 * @param {AccountBalancesRequest} accountBalancesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountBalancesPost(
			accountBalancesRequest: AccountBalancesRequest,
			options?: any,
		): AxiosPromise<AccountBalancesResponse> {
			return localVarFp
				.accountBalancesPost(accountBalancesRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns the account address associated with the given public key.
		 * @summary Derive Account Identifier
		 * @param {AccountDeriveRequest} accountDeriveRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountDerivePost(
			accountDeriveRequest: AccountDeriveRequest,
			options?: any,
		): AxiosPromise<AccountDeriveResponse> {
			return localVarFp
				.accountDerivePost(accountDeriveRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Stake Positions
		 * @param {AccountStakesRequest} accountStakesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountStakesPost(
			accountStakesRequest: AccountStakesRequest,
			options?: any,
		): AxiosPromise<AccountStakesResponse> {
			return localVarFp
				.accountStakesPost(accountStakesRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Account Transactions
		 * @param {AccountTransactionsRequest} accountTransactionsRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountTransactionsPost(
			accountTransactionsRequest: AccountTransactionsRequest,
			options?: any,
		): AxiosPromise<AccountTransactionsResponse> {
			return localVarFp
				.accountTransactionsPost(accountTransactionsRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
		 * @summary Get Unstake Positions
		 * @param {AccountUnstakesRequest} accountUnstakesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountUnstakesPost(
			accountUnstakesRequest: AccountUnstakesRequest,
			options?: any,
		): AxiosPromise<AccountUnstakesResponse> {
			return localVarFp
				.accountUnstakesPost(accountUnstakesRequest, options)
				.then(request => request(axios, basePath))
		},
	}
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
	/**
	 * Returns an account\'s available and staked token balances, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
	 * @summary Get Account Balances
	 * @param {AccountBalancesRequest} accountBalancesRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApi
	 */
	public accountBalancesPost(
		accountBalancesRequest: AccountBalancesRequest,
		options?: AxiosRequestConfig,
	) {
		return AccountApiFp(this.configuration)
			.accountBalancesPost(accountBalancesRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns the account address associated with the given public key.
	 * @summary Derive Account Identifier
	 * @param {AccountDeriveRequest} accountDeriveRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApi
	 */
	public accountDerivePost(
		accountDeriveRequest: AccountDeriveRequest,
		options?: AxiosRequestConfig,
	) {
		return AccountApiFp(this.configuration)
			.accountDerivePost(accountDeriveRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
	 * @summary Get Stake Positions
	 * @param {AccountStakesRequest} accountStakesRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApi
	 */
	public accountStakesPost(
		accountStakesRequest: AccountStakesRequest,
		options?: AxiosRequestConfig,
	) {
		return AccountApiFp(this.configuration)
			.accountStakesPost(accountStakesRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
	 * @summary Get Account Transactions
	 * @param {AccountTransactionsRequest} accountTransactionsRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApi
	 */
	public accountTransactionsPost(
		accountTransactionsRequest: AccountTransactionsRequest,
		options?: AxiosRequestConfig,
	) {
		return AccountApiFp(this.configuration)
			.accountTransactionsPost(accountTransactionsRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\'t have any ledger transactions against it, this endpoint still returns a successful response.
	 * @summary Get Unstake Positions
	 * @param {AccountUnstakesRequest} accountUnstakesRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApi
	 */
	public accountUnstakesPost(
		accountUnstakesRequest: AccountUnstakesRequest,
		options?: AxiosRequestConfig,
	) {
		return AccountApiFp(this.configuration)
			.accountUnstakesPost(accountUnstakesRequest, options)
			.then(request => request(this.axios, this.basePath))
	}
}

/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * Returns the Gateway API version, network and current ledger state.
		 * @summary Get Gateway Info
		 * @param {object} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gatewayPost: async (
			body: object,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'body' is not null or undefined
			assertParamExists('gatewayPost', 'body', body)
			const localVarPath = `/gateway`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				body,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
	return {
		/**
		 * Returns the Gateway API version, network and current ledger state.
		 * @summary Get Gateway Info
		 * @param {object} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async gatewayPost(
			body: object,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<GatewayResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayPost(
				body,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
	}
}

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = StatusApiFp(configuration)
	return {
		/**
		 * Returns the Gateway API version, network and current ledger state.
		 * @summary Get Gateway Info
		 * @param {object} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gatewayPost(
			body: object,
			options?: any,
		): AxiosPromise<GatewayResponse> {
			return localVarFp
				.gatewayPost(body, options)
				.then(request => request(axios, basePath))
		},
	}
}

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
	/**
	 * Returns the Gateway API version, network and current ledger state.
	 * @summary Get Gateway Info
	 * @param {object} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StatusApi
	 */
	public gatewayPost(body: object, options?: AxiosRequestConfig) {
		return StatusApiFp(this.configuration)
			.gatewayPost(body, options)
			.then(request => request(this.axios, this.basePath))
	}
}

/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.
		 * @summary Derive Token Identifier
		 * @param {TokenDeriveRequest} tokenDeriveRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tokenDerivePost: async (
			tokenDeriveRequest: TokenDeriveRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'tokenDeriveRequest' is not null or undefined
			assertParamExists(
				'tokenDerivePost',
				'tokenDeriveRequest',
				tokenDeriveRequest,
			)
			const localVarPath = `/token/derive`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				tokenDeriveRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns information about XRD, including its Radix Resource Identifier.
		 * @summary Get Native Token Info
		 * @param {TokenNativeRequest} tokenNativeRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tokenNativePost: async (
			tokenNativeRequest: TokenNativeRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'tokenNativeRequest' is not null or undefined
			assertParamExists(
				'tokenNativePost',
				'tokenNativeRequest',
				tokenNativeRequest,
			)
			const localVarPath = `/token/native`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				tokenNativeRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns information about any token, given its Radix Resource Identifier.
		 * @summary Get Token Info
		 * @param {TokenRequest} tokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tokenPost: async (
			tokenRequest: TokenRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'tokenRequest' is not null or undefined
			assertParamExists('tokenPost', 'tokenRequest', tokenRequest)
			const localVarPath = `/token`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				tokenRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = TokenApiAxiosParamCreator(configuration)
	return {
		/**
		 * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.
		 * @summary Derive Token Identifier
		 * @param {TokenDeriveRequest} tokenDeriveRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async tokenDerivePost(
			tokenDeriveRequest: TokenDeriveRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<TokenDeriveResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.tokenDerivePost(
				tokenDeriveRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns information about XRD, including its Radix Resource Identifier.
		 * @summary Get Native Token Info
		 * @param {TokenNativeRequest} tokenNativeRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async tokenNativePost(
			tokenNativeRequest: TokenNativeRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<TokenNativeResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.tokenNativePost(
				tokenNativeRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns information about any token, given its Radix Resource Identifier.
		 * @summary Get Token Info
		 * @param {TokenRequest} tokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async tokenPost(
			tokenRequest: TokenRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<TokenResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPost(
				tokenRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
	}
}

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = TokenApiFp(configuration)
	return {
		/**
		 * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.
		 * @summary Derive Token Identifier
		 * @param {TokenDeriveRequest} tokenDeriveRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tokenDerivePost(
			tokenDeriveRequest: TokenDeriveRequest,
			options?: any,
		): AxiosPromise<TokenDeriveResponse> {
			return localVarFp
				.tokenDerivePost(tokenDeriveRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns information about XRD, including its Radix Resource Identifier.
		 * @summary Get Native Token Info
		 * @param {TokenNativeRequest} tokenNativeRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tokenNativePost(
			tokenNativeRequest: TokenNativeRequest,
			options?: any,
		): AxiosPromise<TokenNativeResponse> {
			return localVarFp
				.tokenNativePost(tokenNativeRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns information about any token, given its Radix Resource Identifier.
		 * @summary Get Token Info
		 * @param {TokenRequest} tokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tokenPost(
			tokenRequest: TokenRequest,
			options?: any,
		): AxiosPromise<TokenResponse> {
			return localVarFp
				.tokenPost(tokenRequest, options)
				.then(request => request(axios, basePath))
		},
	}
}

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
	/**
	 * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.
	 * @summary Derive Token Identifier
	 * @param {TokenDeriveRequest} tokenDeriveRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TokenApi
	 */
	public tokenDerivePost(
		tokenDeriveRequest: TokenDeriveRequest,
		options?: AxiosRequestConfig,
	) {
		return TokenApiFp(this.configuration)
			.tokenDerivePost(tokenDeriveRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns information about XRD, including its Radix Resource Identifier.
	 * @summary Get Native Token Info
	 * @param {TokenNativeRequest} tokenNativeRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TokenApi
	 */
	public tokenNativePost(
		tokenNativeRequest: TokenNativeRequest,
		options?: AxiosRequestConfig,
	) {
		return TokenApiFp(this.configuration)
			.tokenNativePost(tokenNativeRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns information about any token, given its Radix Resource Identifier.
	 * @summary Get Token Info
	 * @param {TokenRequest} tokenRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TokenApi
	 */
	public tokenPost(tokenRequest: TokenRequest, options?: AxiosRequestConfig) {
		return TokenApiFp(this.configuration)
			.tokenPost(tokenRequest, options)
			.then(request => request(this.axios, this.basePath))
	}
}

/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * Returns a built unsigned transaction payload, from a set of intended actions.
		 * @summary Build Transaction
		 * @param {TransactionBuildRequest} transactionBuildRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionBuildPost: async (
			transactionBuildRequest: TransactionBuildRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'transactionBuildRequest' is not null or undefined
			assertParamExists(
				'transactionBuildPost',
				'transactionBuildRequest',
				transactionBuildRequest,
			)
			const localVarPath = `/transaction/build`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				transactionBuildRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.
		 * @summary Finalize Transaction
		 * @param {TransactionFinalizeRequest} transactionFinalizeRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionFinalizePost: async (
			transactionFinalizeRequest: TransactionFinalizeRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'transactionFinalizeRequest' is not null or undefined
			assertParamExists(
				'transactionFinalizePost',
				'transactionFinalizeRequest',
				transactionFinalizeRequest,
			)
			const localVarPath = `/transaction/finalize`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				transactionFinalizeRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.
		 * @summary Get Recent Transactions
		 * @param {RecentTransactionsRequest} recentTransactionsRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionRecentPost: async (
			recentTransactionsRequest: RecentTransactionsRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'recentTransactionsRequest' is not null or undefined
			assertParamExists(
				'transactionRecentPost',
				'recentTransactionsRequest',
				recentTransactionsRequest,
			)
			const localVarPath = `/transaction/recent`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				recentTransactionsRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns the current rules used to build and validate transactions in the Radix Engine.
		 * @summary Get Transaction Rules
		 * @param {TransactionRulesRequest} transactionRulesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionRulesPost: async (
			transactionRulesRequest: TransactionRulesRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'transactionRulesRequest' is not null or undefined
			assertParamExists(
				'transactionRulesPost',
				'transactionRulesRequest',
				transactionRulesRequest,
			)
			const localVarPath = `/transaction/rules`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				transactionRulesRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.
		 * @summary Transaction Status
		 * @param {TransactionStatusRequest} transactionStatusRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionStatusPost: async (
			transactionStatusRequest: TransactionStatusRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'transactionStatusRequest' is not null or undefined
			assertParamExists(
				'transactionStatusPost',
				'transactionStatusRequest',
				transactionStatusRequest,
			)
			const localVarPath = `/transaction/status`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				transactionStatusRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.
		 * @summary Submit Transaction
		 * @param {TransactionSubmitRequest} transactionSubmitRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionSubmitPost: async (
			transactionSubmitRequest: TransactionSubmitRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'transactionSubmitRequest' is not null or undefined
			assertParamExists(
				'transactionSubmitPost',
				'transactionSubmitRequest',
				transactionSubmitRequest,
			)
			const localVarPath = `/transaction/submit`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				transactionSubmitRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(
		configuration,
	)
	return {
		/**
		 * Returns a built unsigned transaction payload, from a set of intended actions.
		 * @summary Build Transaction
		 * @param {TransactionBuildRequest} transactionBuildRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async transactionBuildPost(
			transactionBuildRequest: TransactionBuildRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<TransactionBuildResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.transactionBuildPost(
				transactionBuildRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.
		 * @summary Finalize Transaction
		 * @param {TransactionFinalizeRequest} transactionFinalizeRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async transactionFinalizePost(
			transactionFinalizeRequest: TransactionFinalizeRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<TransactionFinalizeResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.transactionFinalizePost(
				transactionFinalizeRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.
		 * @summary Get Recent Transactions
		 * @param {RecentTransactionsRequest} recentTransactionsRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async transactionRecentPost(
			recentTransactionsRequest: RecentTransactionsRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<RecentTransactionsResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.transactionRecentPost(
				recentTransactionsRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns the current rules used to build and validate transactions in the Radix Engine.
		 * @summary Get Transaction Rules
		 * @param {TransactionRulesRequest} transactionRulesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async transactionRulesPost(
			transactionRulesRequest: TransactionRulesRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<TransactionRulesResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.transactionRulesPost(
				transactionRulesRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.
		 * @summary Transaction Status
		 * @param {TransactionStatusRequest} transactionStatusRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async transactionStatusPost(
			transactionStatusRequest: TransactionStatusRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<TransactionStatusResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.transactionStatusPost(
				transactionStatusRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.
		 * @summary Submit Transaction
		 * @param {TransactionSubmitRequest} transactionSubmitRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async transactionSubmitPost(
			transactionSubmitRequest: TransactionSubmitRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<TransactionSubmitResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.transactionSubmitPost(
				transactionSubmitRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
	}
}

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = TransactionApiFp(configuration)
	return {
		/**
		 * Returns a built unsigned transaction payload, from a set of intended actions.
		 * @summary Build Transaction
		 * @param {TransactionBuildRequest} transactionBuildRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionBuildPost(
			transactionBuildRequest: TransactionBuildRequest,
			options?: any,
		): AxiosPromise<TransactionBuildResponse> {
			return localVarFp
				.transactionBuildPost(transactionBuildRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.
		 * @summary Finalize Transaction
		 * @param {TransactionFinalizeRequest} transactionFinalizeRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionFinalizePost(
			transactionFinalizeRequest: TransactionFinalizeRequest,
			options?: any,
		): AxiosPromise<TransactionFinalizeResponse> {
			return localVarFp
				.transactionFinalizePost(transactionFinalizeRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.
		 * @summary Get Recent Transactions
		 * @param {RecentTransactionsRequest} recentTransactionsRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionRecentPost(
			recentTransactionsRequest: RecentTransactionsRequest,
			options?: any,
		): AxiosPromise<RecentTransactionsResponse> {
			return localVarFp
				.transactionRecentPost(recentTransactionsRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns the current rules used to build and validate transactions in the Radix Engine.
		 * @summary Get Transaction Rules
		 * @param {TransactionRulesRequest} transactionRulesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionRulesPost(
			transactionRulesRequest: TransactionRulesRequest,
			options?: any,
		): AxiosPromise<TransactionRulesResponse> {
			return localVarFp
				.transactionRulesPost(transactionRulesRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.
		 * @summary Transaction Status
		 * @param {TransactionStatusRequest} transactionStatusRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionStatusPost(
			transactionStatusRequest: TransactionStatusRequest,
			options?: any,
		): AxiosPromise<TransactionStatusResponse> {
			return localVarFp
				.transactionStatusPost(transactionStatusRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.
		 * @summary Submit Transaction
		 * @param {TransactionSubmitRequest} transactionSubmitRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transactionSubmitPost(
			transactionSubmitRequest: TransactionSubmitRequest,
			options?: any,
		): AxiosPromise<TransactionSubmitResponse> {
			return localVarFp
				.transactionSubmitPost(transactionSubmitRequest, options)
				.then(request => request(axios, basePath))
		},
	}
}

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
	/**
	 * Returns a built unsigned transaction payload, from a set of intended actions.
	 * @summary Build Transaction
	 * @param {TransactionBuildRequest} transactionBuildRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TransactionApi
	 */
	public transactionBuildPost(
		transactionBuildRequest: TransactionBuildRequest,
		options?: AxiosRequestConfig,
	) {
		return TransactionApiFp(this.configuration)
			.transactionBuildPost(transactionBuildRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.
	 * @summary Finalize Transaction
	 * @param {TransactionFinalizeRequest} transactionFinalizeRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TransactionApi
	 */
	public transactionFinalizePost(
		transactionFinalizeRequest: TransactionFinalizeRequest,
		options?: AxiosRequestConfig,
	) {
		return TransactionApiFp(this.configuration)
			.transactionFinalizePost(transactionFinalizeRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.
	 * @summary Get Recent Transactions
	 * @param {RecentTransactionsRequest} recentTransactionsRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TransactionApi
	 */
	public transactionRecentPost(
		recentTransactionsRequest: RecentTransactionsRequest,
		options?: AxiosRequestConfig,
	) {
		return TransactionApiFp(this.configuration)
			.transactionRecentPost(recentTransactionsRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns the current rules used to build and validate transactions in the Radix Engine.
	 * @summary Get Transaction Rules
	 * @param {TransactionRulesRequest} transactionRulesRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TransactionApi
	 */
	public transactionRulesPost(
		transactionRulesRequest: TransactionRulesRequest,
		options?: AxiosRequestConfig,
	) {
		return TransactionApiFp(this.configuration)
			.transactionRulesPost(transactionRulesRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.
	 * @summary Transaction Status
	 * @param {TransactionStatusRequest} transactionStatusRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TransactionApi
	 */
	public transactionStatusPost(
		transactionStatusRequest: TransactionStatusRequest,
		options?: AxiosRequestConfig,
	) {
		return TransactionApiFp(this.configuration)
			.transactionStatusPost(transactionStatusRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.
	 * @summary Submit Transaction
	 * @param {TransactionSubmitRequest} transactionSubmitRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TransactionApi
	 */
	public transactionSubmitPost(
		transactionSubmitRequest: TransactionSubmitRequest,
		options?: AxiosRequestConfig,
	) {
		return TransactionApiFp(this.configuration)
			.transactionSubmitPost(transactionSubmitRequest, options)
			.then(request => request(this.axios, this.basePath))
	}
}

/**
 * ValidatorApi - axios parameter creator
 * @export
 */
export const ValidatorApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * Returns the validator address associated with the given public key.
		 * @summary Get Validator Identifier
		 * @param {ValidatorDeriveRequest} validatorDeriveRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validatorDerivePost: async (
			validatorDeriveRequest: ValidatorDeriveRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'validatorDeriveRequest' is not null or undefined
			assertParamExists(
				'validatorDerivePost',
				'validatorDeriveRequest',
				validatorDeriveRequest,
			)
			const localVarPath = `/validator/derive`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				validatorDeriveRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.
		 * @summary Get Validator
		 * @param {ValidatorRequest} validatorRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validatorPost: async (
			validatorRequest: ValidatorRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'validatorRequest' is not null or undefined
			assertParamExists(
				'validatorPost',
				'validatorRequest',
				validatorRequest,
			)
			const localVarPath = `/validator`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				validatorRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).
		 * @summary Get Validator Stakes
		 * @param {ValidatorStakesRequest} validatorStakesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validatorStakesPost: async (
			validatorStakesRequest: ValidatorStakesRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'validatorStakesRequest' is not null or undefined
			assertParamExists(
				'validatorStakesPost',
				'validatorStakesRequest',
				validatorStakesRequest,
			)
			const localVarPath = `/validator/stakes`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				validatorStakesRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Returns information about all validators.
		 * @summary Get Validators
		 * @param {ValidatorsRequest} validatorsRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validatorsPost: async (
			validatorsRequest: ValidatorsRequest,
			options: AxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'validatorsRequest' is not null or undefined
			assertParamExists(
				'validatorsPost',
				'validatorsRequest',
				validatorsRequest,
			)
			const localVarPath = `/validators`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				validatorsRequest,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ValidatorApi - functional programming interface
 * @export
 */
export const ValidatorApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ValidatorApiAxiosParamCreator(
		configuration,
	)
	return {
		/**
		 * Returns the validator address associated with the given public key.
		 * @summary Get Validator Identifier
		 * @param {ValidatorDeriveRequest} validatorDeriveRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async validatorDerivePost(
			validatorDeriveRequest: ValidatorDeriveRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<ValidatorDeriveResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.validatorDerivePost(
				validatorDeriveRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.
		 * @summary Get Validator
		 * @param {ValidatorRequest} validatorRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async validatorPost(
			validatorRequest: ValidatorRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<ValidatorResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.validatorPost(
				validatorRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).
		 * @summary Get Validator Stakes
		 * @param {ValidatorStakesRequest} validatorStakesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async validatorStakesPost(
			validatorStakesRequest: ValidatorStakesRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<ValidatorStakesResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.validatorStakesPost(
				validatorStakesRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
		/**
		 * Returns information about all validators.
		 * @summary Get Validators
		 * @param {ValidatorsRequest} validatorsRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async validatorsPost(
			validatorsRequest: ValidatorsRequest,
			options?: AxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<ValidatorsResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.validatorsPost(
				validatorsRequest,
				options,
			)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			)
		},
	}
}

/**
 * ValidatorApi - factory interface
 * @export
 */
export const ValidatorApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = ValidatorApiFp(configuration)
	return {
		/**
		 * Returns the validator address associated with the given public key.
		 * @summary Get Validator Identifier
		 * @param {ValidatorDeriveRequest} validatorDeriveRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validatorDerivePost(
			validatorDeriveRequest: ValidatorDeriveRequest,
			options?: any,
		): AxiosPromise<ValidatorDeriveResponse> {
			return localVarFp
				.validatorDerivePost(validatorDeriveRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.
		 * @summary Get Validator
		 * @param {ValidatorRequest} validatorRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validatorPost(
			validatorRequest: ValidatorRequest,
			options?: any,
		): AxiosPromise<ValidatorResponse> {
			return localVarFp
				.validatorPost(validatorRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).
		 * @summary Get Validator Stakes
		 * @param {ValidatorStakesRequest} validatorStakesRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validatorStakesPost(
			validatorStakesRequest: ValidatorStakesRequest,
			options?: any,
		): AxiosPromise<ValidatorStakesResponse> {
			return localVarFp
				.validatorStakesPost(validatorStakesRequest, options)
				.then(request => request(axios, basePath))
		},
		/**
		 * Returns information about all validators.
		 * @summary Get Validators
		 * @param {ValidatorsRequest} validatorsRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validatorsPost(
			validatorsRequest: ValidatorsRequest,
			options?: any,
		): AxiosPromise<ValidatorsResponse> {
			return localVarFp
				.validatorsPost(validatorsRequest, options)
				.then(request => request(axios, basePath))
		},
	}
}

/**
 * ValidatorApi - object-oriented interface
 * @export
 * @class ValidatorApi
 * @extends {BaseAPI}
 */
export class ValidatorApi extends BaseAPI {
	/**
	 * Returns the validator address associated with the given public key.
	 * @summary Get Validator Identifier
	 * @param {ValidatorDeriveRequest} validatorDeriveRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ValidatorApi
	 */
	public validatorDerivePost(
		validatorDeriveRequest: ValidatorDeriveRequest,
		options?: AxiosRequestConfig,
	) {
		return ValidatorApiFp(this.configuration)
			.validatorDerivePost(validatorDeriveRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.
	 * @summary Get Validator
	 * @param {ValidatorRequest} validatorRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ValidatorApi
	 */
	public validatorPost(
		validatorRequest: ValidatorRequest,
		options?: AxiosRequestConfig,
	) {
		return ValidatorApiFp(this.configuration)
			.validatorPost(validatorRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).
	 * @summary Get Validator Stakes
	 * @param {ValidatorStakesRequest} validatorStakesRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ValidatorApi
	 */
	public validatorStakesPost(
		validatorStakesRequest: ValidatorStakesRequest,
		options?: AxiosRequestConfig,
	) {
		return ValidatorApiFp(this.configuration)
			.validatorStakesPost(validatorStakesRequest, options)
			.then(request => request(this.axios, this.basePath))
	}

	/**
	 * Returns information about all validators.
	 * @summary Get Validators
	 * @param {ValidatorsRequest} validatorsRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ValidatorApi
	 */
	public validatorsPost(
		validatorsRequest: ValidatorsRequest,
		options?: AxiosRequestConfig,
	) {
		return ValidatorApiFp(this.configuration)
			.validatorsPost(validatorsRequest, options)
			.then(request => request(this.axios, this.basePath))
	}
}
