import { ResultAsync } from 'neverthrow';
import { ZodError, ZodObject, ZodRawShape } from 'zod';
export declare const parseAsync: <T extends ZodRawShape>(schema: ZodObject<T, import("zod").UnknownKeysParam, import("zod").ZodTypeAny, import("zod").objectUtil.addQuestionMarks<import("zod").baseObjectOutputType<T>, { [k_1 in keyof import("zod").baseObjectOutputType<T>]: undefined extends import("zod").baseObjectOutputType<T>[k_1] ? never : k_1; }[keyof T]> extends infer T_1 ? { [k in keyof T_1]: import("zod").objectUtil.addQuestionMarks<import("zod").baseObjectOutputType<T>, { [k_1 in keyof import("zod").baseObjectOutputType<T>]: undefined extends import("zod").baseObjectOutputType<T>[k_1] ? never : k_1; }[keyof T]>[k]; } : never, import("zod").baseObjectInputType<T> extends infer T_2 ? { [k_2 in keyof T_2]: import("zod").baseObjectInputType<T>[k_2]; } : never>, data: unknown) => ResultAsync<import("zod").objectUtil.addQuestionMarks<import("zod").baseObjectOutputType<T>, { [k_1 in keyof import("zod").baseObjectOutputType<T>]: undefined extends import("zod").baseObjectOutputType<T>[k_1] ? never : k_1; }[keyof T]> extends infer T_3 ? { [k in keyof T_3]: import("zod").objectUtil.addQuestionMarks<import("zod").baseObjectOutputType<T>, { [k_1 in keyof import("zod").baseObjectOutputType<T>]: undefined extends import("zod").baseObjectOutputType<T>[k_1] ? never : k_1; }[keyof T]>[k]; } : never, ZodError<any>[]>;
