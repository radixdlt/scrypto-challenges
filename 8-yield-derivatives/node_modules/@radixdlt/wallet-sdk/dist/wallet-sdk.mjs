function lt(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(l) {
      try {
        u(n.next(l));
      } catch (h) {
        a(h);
      }
    }
    function c(l) {
      try {
        u(n.throw(l));
      } catch (h) {
        a(h);
      }
    }
    function u(l) {
      l.done ? s(l.value) : i(l.value).then(o, c);
    }
    u((n = n.apply(r, e || [])).next());
  });
}
function dt(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (n = 1, i && (s = u[0] & 2 ? i.return : u[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, u[1])).done)
          return s;
        switch (i = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return t.label++, { value: u[1], done: !1 };
          case 5:
            t.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              t = 0;
              continue;
            }
            if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
              t.label = u[1];
              break;
            }
            if (u[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = u;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(u);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        u = e.call(r, t);
      } catch (l) {
        u = [6, l], i = 0;
      } finally {
        n = s = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Fe(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t)
    return r;
  var n = t.call(r), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return s;
}
function de(r, e, t) {
  if (t || arguments.length === 2)
    for (var n = 0, i = e.length, s; n < i; n++)
      (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return r.concat(s || Array.prototype.slice.call(e));
}
var en = {
  withStackTrace: !1
}, hr = function(r, e, t) {
  t === void 0 && (t = en);
  var n = e.isOk() ? { type: "Ok", value: e.value } : { type: "Err", value: e.error }, i = t.withStackTrace ? new Error().stack : void 0;
  return {
    data: n,
    message: r,
    stack: i
  };
}, M = (
  /** @class */
  function() {
    function r(e) {
      this._promise = e;
    }
    return r.fromSafePromise = function(e) {
      var t = e.then(function(n) {
        return new ae(n);
      });
      return new r(t);
    }, r.fromPromise = function(e, t) {
      var n = e.then(function(i) {
        return new ae(i);
      }).catch(function(i) {
        return new ue(t(i));
      });
      return new r(n);
    }, r.combine = function(e) {
      return rn(e);
    }, r.combineWithAllErrors = function(e) {
      return nn(e);
    }, r.prototype.map = function(e) {
      var t = this;
      return new r(this._promise.then(function(n) {
        return lt(t, void 0, void 0, function() {
          var i;
          return dt(this, function(s) {
            switch (s.label) {
              case 0:
                return n.isErr() ? [2, new ue(n.error)] : (i = ae.bind, [4, e(n.value)]);
              case 1:
                return [2, new (i.apply(ae, [void 0, s.sent()]))()];
            }
          });
        });
      }));
    }, r.prototype.mapErr = function(e) {
      var t = this;
      return new r(this._promise.then(function(n) {
        return lt(t, void 0, void 0, function() {
          var i;
          return dt(this, function(s) {
            switch (s.label) {
              case 0:
                return n.isOk() ? [2, new ae(n.value)] : (i = ue.bind, [4, e(n.error)]);
              case 1:
                return [2, new (i.apply(ue, [void 0, s.sent()]))()];
            }
          });
        });
      }));
    }, r.prototype.andThen = function(e) {
      return new r(this._promise.then(function(t) {
        if (t.isErr())
          return new ue(t.error);
        var n = e(t.value);
        return n instanceof r ? n._promise : n;
      }));
    }, r.prototype.orElse = function(e) {
      var t = this;
      return new r(this._promise.then(function(n) {
        return lt(t, void 0, void 0, function() {
          return dt(this, function(i) {
            return n.isErr() ? [2, e(n.error)] : [2, new ae(n.value)];
          });
        });
      }));
    }, r.prototype.match = function(e, t) {
      return this._promise.then(function(n) {
        return n.match(e, t);
      });
    }, r.prototype.unwrapOr = function(e) {
      return this._promise.then(function(t) {
        return t.unwrapOr(e);
      });
    }, r.prototype.then = function(e, t) {
      return this._promise.then(e, t);
    }, r;
  }()
), Jt = function(r) {
  return new M(Promise.resolve(new ue(r)));
};
M.fromPromise;
M.fromSafePromise;
var tn = function(r) {
  return function(e) {
    return de(de([], Fe(e), !1), [r], !1);
  };
}, pr = function(r) {
  return r.reduce(function(e, t) {
    return e.isOk() ? t.isErr() ? B(t.error) : e.map(tn(t.value)) : e;
  }, H([]));
}, rn = function(r) {
  return M.fromSafePromise(Promise.all(r)).andThen(pr);
}, mr = function(r) {
  return r.reduce(function(e, t) {
    return t.isErr() ? e.isErr() ? B(de(de([], Fe(e.error), !1), [t.error], !1)) : B([t.error]) : e.isErr() ? e : H(de(de([], Fe(e.value), !1), [t.value], !1));
  }, H([]));
}, nn = function(r) {
  return M.fromSafePromise(Promise.all(r)).andThen(mr);
}, gt;
(function(r) {
  function e(i, s) {
    return function() {
      for (var a = [], o = 0; o < arguments.length; o++)
        a[o] = arguments[o];
      try {
        var c = i.apply(void 0, de([], Fe(a), !1));
        return H(c);
      } catch (u) {
        return B(s ? s(u) : u);
      }
    };
  }
  r.fromThrowable = e;
  function t(i) {
    return pr(i);
  }
  r.combine = t;
  function n(i) {
    return mr(i);
  }
  r.combineWithAllErrors = n;
})(gt || (gt = {}));
var H = function(r) {
  return new ae(r);
}, B = function(r) {
  return new ue(r);
}, ae = (
  /** @class */
  function() {
    function r(e) {
      this.value = e;
    }
    return r.prototype.isOk = function() {
      return !0;
    }, r.prototype.isErr = function() {
      return !this.isOk();
    }, r.prototype.map = function(e) {
      return H(e(this.value));
    }, r.prototype.mapErr = function(e) {
      return H(this.value);
    }, r.prototype.andThen = function(e) {
      return e(this.value);
    }, r.prototype.orElse = function(e) {
      return H(this.value);
    }, r.prototype.asyncAndThen = function(e) {
      return e(this.value);
    }, r.prototype.asyncMap = function(e) {
      return M.fromSafePromise(e(this.value));
    }, r.prototype.unwrapOr = function(e) {
      return this.value;
    }, r.prototype.match = function(e, t) {
      return e(this.value);
    }, r.prototype._unsafeUnwrap = function(e) {
      return this.value;
    }, r.prototype._unsafeUnwrapErr = function(e) {
      throw hr("Called `_unsafeUnwrapErr` on an Ok", this, e);
    }, r;
  }()
), ue = (
  /** @class */
  function() {
    function r(e) {
      this.error = e;
    }
    return r.prototype.isOk = function() {
      return !1;
    }, r.prototype.isErr = function() {
      return !this.isOk();
    }, r.prototype.map = function(e) {
      return B(this.error);
    }, r.prototype.mapErr = function(e) {
      return B(e(this.error));
    }, r.prototype.andThen = function(e) {
      return B(this.error);
    }, r.prototype.orElse = function(e) {
      return e(this.error);
    }, r.prototype.asyncAndThen = function(e) {
      return Jt(this.error);
    }, r.prototype.asyncMap = function(e) {
      return Jt(this.error);
    }, r.prototype.unwrapOr = function(e) {
      return e;
    }, r.prototype.match = function(e, t) {
      return t(this.error);
    }, r.prototype._unsafeUnwrap = function(e) {
      throw hr("Called `_unsafeUnwrap` on an Err", this, e);
    }, r.prototype._unsafeUnwrapErr = function(e) {
      return this.error;
    }, r;
  }()
);
gt.fromThrowable;
var T;
(function(r) {
  r.assertEqual = (i) => i;
  function e(i) {
  }
  r.assertIs = e;
  function t(i) {
    throw new Error();
  }
  r.assertNever = t, r.arrayToEnum = (i) => {
    const s = {};
    for (const a of i)
      s[a] = a;
    return s;
  }, r.getValidEnumValues = (i) => {
    const s = r.objectKeys(i).filter((o) => typeof i[i[o]] != "number"), a = {};
    for (const o of s)
      a[o] = i[o];
    return r.objectValues(a);
  }, r.objectValues = (i) => r.objectKeys(i).map(function(s) {
    return i[s];
  }), r.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const s = [];
    for (const a in i)
      Object.prototype.hasOwnProperty.call(i, a) && s.push(a);
    return s;
  }, r.find = (i, s) => {
    for (const a of i)
      if (s(a))
        return a;
  }, r.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function n(i, s = " | ") {
    return i.map((a) => typeof a == "string" ? `'${a}'` : a).join(s);
  }
  r.joinValues = n, r.jsonStringifyReplacer = (i, s) => typeof s == "bigint" ? s.toString() : s;
})(T || (T = {}));
var Mt;
(function(r) {
  r.mergeShapes = (e, t) => ({
    ...e,
    ...t
    // second overwrites first
  });
})(Mt || (Mt = {}));
const f = T.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), le = (r) => {
  switch (typeof r) {
    case "undefined":
      return f.undefined;
    case "string":
      return f.string;
    case "number":
      return isNaN(r) ? f.nan : f.number;
    case "boolean":
      return f.boolean;
    case "function":
      return f.function;
    case "bigint":
      return f.bigint;
    case "symbol":
      return f.symbol;
    case "object":
      return Array.isArray(r) ? f.array : r === null ? f.null : r.then && typeof r.then == "function" && r.catch && typeof r.catch == "function" ? f.promise : typeof Map < "u" && r instanceof Map ? f.map : typeof Set < "u" && r instanceof Set ? f.set : typeof Date < "u" && r instanceof Date ? f.date : f.object;
    default:
      return f.unknown;
  }
}, d = T.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Y extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const t = e || function(s) {
      return s.message;
    }, n = { _errors: [] }, i = (s) => {
      for (const a of s.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(i);
        else if (a.code === "invalid_return_type")
          i(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          i(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(t(a));
        else {
          let o = n, c = 0;
          for (; c < a.path.length; ) {
            const u = a.path[c];
            c === a.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(t(a))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return i(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, T.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (t) => t.message) {
    const t = {}, n = [];
    for (const i of this.issues)
      i.path.length > 0 ? (t[i.path[0]] = t[i.path[0]] || [], t[i.path[0]].push(e(i))) : n.push(e(i));
    return { formErrors: n, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
}
Y.create = (r) => new Y(r);
const Ke = (r, e) => {
  let t;
  switch (r.code) {
    case d.invalid_type:
      r.received === f.undefined ? t = "Required" : t = `Expected ${r.expected}, received ${r.received}`;
      break;
    case d.invalid_literal:
      t = `Invalid literal value, expected ${JSON.stringify(r.expected, T.jsonStringifyReplacer)}`;
      break;
    case d.unrecognized_keys:
      t = `Unrecognized key(s) in object: ${T.joinValues(r.keys, ", ")}`;
      break;
    case d.invalid_union:
      t = "Invalid input";
      break;
    case d.invalid_union_discriminator:
      t = `Invalid discriminator value. Expected ${T.joinValues(r.options)}`;
      break;
    case d.invalid_enum_value:
      t = `Invalid enum value. Expected ${T.joinValues(r.options)}, received '${r.received}'`;
      break;
    case d.invalid_arguments:
      t = "Invalid function arguments";
      break;
    case d.invalid_return_type:
      t = "Invalid function return type";
      break;
    case d.invalid_date:
      t = "Invalid date";
      break;
    case d.invalid_string:
      typeof r.validation == "object" ? "includes" in r.validation ? (t = `Invalid input: must include "${r.validation.includes}"`, typeof r.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${r.validation.position}`)) : "startsWith" in r.validation ? t = `Invalid input: must start with "${r.validation.startsWith}"` : "endsWith" in r.validation ? t = `Invalid input: must end with "${r.validation.endsWith}"` : T.assertNever(r.validation) : r.validation !== "regex" ? t = `Invalid ${r.validation}` : t = "Invalid";
      break;
    case d.too_small:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "more than"} ${r.minimum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "over"} ${r.minimum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${r.minimum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(r.minimum))}` : t = "Invalid input";
      break;
    case d.too_big:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "less than"} ${r.maximum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "under"} ${r.maximum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "bigint" ? t = `BigInt must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly" : r.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(r.maximum))}` : t = "Invalid input";
      break;
    case d.custom:
      t = "Invalid input";
      break;
    case d.invalid_intersection_types:
      t = "Intersection results could not be merged";
      break;
    case d.not_multiple_of:
      t = `Number must be a multiple of ${r.multipleOf}`;
      break;
    case d.not_finite:
      t = "Number must be finite";
      break;
    default:
      t = e.defaultError, T.assertNever(r);
  }
  return { message: t };
};
let sn = Ke;
function _t() {
  return sn;
}
const wt = (r) => {
  const { data: e, path: t, errorMaps: n, issueData: i } = r, s = [...t, ...i.path || []], a = {
    ...i,
    path: s
  };
  let o = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(a, { data: e, defaultError: o }).message;
  return {
    ...i,
    path: s,
    message: i.message || o
  };
};
function p(r, e) {
  const t = wt({
    issueData: e,
    data: r.data,
    path: r.path,
    errorMaps: [
      r.common.contextualErrorMap,
      r.schemaErrorMap,
      _t(),
      Ke
      // then global default map
    ].filter((n) => !!n)
  });
  r.common.issues.push(t);
}
class O {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, t) {
    const n = [];
    for (const i of t) {
      if (i.status === "aborted")
        return g;
      i.status === "dirty" && e.dirty(), n.push(i.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, t) {
    const n = [];
    for (const i of t)
      n.push({
        key: await i.key,
        value: await i.value
      });
    return O.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, t) {
    const n = {};
    for (const i of t) {
      const { key: s, value: a } = i;
      if (s.status === "aborted" || a.status === "aborted")
        return g;
      s.status === "dirty" && e.dirty(), a.status === "dirty" && e.dirty(), (typeof a.value < "u" || i.alwaysSet) && (n[s.value] = a.value);
    }
    return { status: e.value, value: n };
  }
}
const g = Object.freeze({
  status: "aborted"
}), an = (r) => ({ status: "dirty", value: r }), Z = (r) => ({ status: "valid", value: r }), Xt = (r) => r.status === "aborted", Qt = (r) => r.status === "dirty", bt = (r) => r.status === "valid", xt = (r) => typeof Promise < "u" && r instanceof Promise;
var m;
(function(r) {
  r.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, r.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(m || (m = {}));
class J {
  constructor(e, t, n, i) {
    this._cachedPath = [], this.parent = e, this.data = t, this._path = n, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const er = (r, e) => {
  if (bt(e))
    return { success: !0, data: e.value };
  if (!r.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const t = new Y(r.common.issues);
      return this._error = t, this._error;
    }
  };
};
function _(r) {
  if (!r)
    return {};
  const { errorMap: e, invalid_type_error: t, required_error: n, description: i } = r;
  if (e && (t || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: i } : { errorMap: (a, o) => a.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: n ?? o.defaultError } : { message: t ?? o.defaultError }, description: i };
}
class w {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return le(e.data);
  }
  _getOrReturnCtx(e, t) {
    return t || {
      common: e.parent.common,
      data: e.data,
      parsedType: le(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new O(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: le(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const t = this._parse(e);
    if (xt(t))
      throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e) {
    const t = this._parse(e);
    return Promise.resolve(t);
  }
  parse(e, t) {
    const n = this.safeParse(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, t) {
    var n;
    const i = {
      common: {
        issues: [],
        async: (n = t == null ? void 0 : t.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: t == null ? void 0 : t.errorMap
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: le(e)
    }, s = this._parseSync({ data: e, path: i.path, parent: i });
    return er(i, s);
  }
  async parseAsync(e, t) {
    const n = await this.safeParseAsync(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, t) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: t == null ? void 0 : t.errorMap,
        async: !0
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: le(e)
    }, i = this._parse({ data: e, path: n.path, parent: n }), s = await (xt(i) ? i : Promise.resolve(i));
    return er(n, s);
  }
  refine(e, t) {
    const n = (i) => typeof t == "string" || typeof t > "u" ? { message: t } : typeof t == "function" ? t(i) : t;
    return this._refinement((i, s) => {
      const a = e(i), o = () => s.addIssue({
        code: d.custom,
        ...n(i)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? !0 : (o(), !1)) : a ? !0 : (o(), !1);
    });
  }
  refinement(e, t) {
    return this._refinement((n, i) => e(n) ? !0 : (i.addIssue(typeof t == "function" ? t(n, i) : t), !1));
  }
  _refinement(e) {
    return new ee({
      schema: this,
      typeName: y.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return re.create(this, this._def);
  }
  nullable() {
    return Te.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return G.create(this, this._def);
  }
  promise() {
    return De.create(this, this._def);
  }
  or(e) {
    return Ge.create([this, e], this._def);
  }
  and(e) {
    return Je.create(this, e, this._def);
  }
  transform(e) {
    return new ee({
      ..._(this._def),
      schema: this,
      typeName: y.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const t = typeof e == "function" ? e : () => e;
    return new tt({
      ..._(this._def),
      innerType: this,
      defaultValue: t,
      typeName: y.ZodDefault
    });
  }
  brand() {
    return new gn({
      typeName: y.ZodBranded,
      type: this,
      ..._(this._def)
    });
  }
  catch(e) {
    const t = typeof e == "function" ? e : () => e;
    return new At({
      ..._(this._def),
      innerType: this,
      catchValue: t,
      typeName: y.ZodCatch
    });
  }
  describe(e) {
    const t = this.constructor;
    return new t({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return st.create(this, e);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const on = /^c[^\s-]{8,}$/i, cn = /^[a-z][a-z0-9]*$/, un = /[0-9A-HJKMNP-TV-Z]{26}/, ln = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, dn = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, fn = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, hn = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, pn = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, mn = (r) => r.precision ? r.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${r.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${r.precision}}Z$`) : r.precision === 0 ? r.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : r.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function yn(r, e) {
  return !!((e === "v4" || !e) && hn.test(r) || (e === "v6" || !e) && pn.test(r));
}
class X extends w {
  constructor() {
    super(...arguments), this._regex = (e, t, n) => this.refinement((i) => e.test(i), {
      validation: t,
      code: d.invalid_string,
      ...m.errToObj(n)
    }), this.nonempty = (e) => this.min(1, m.errToObj(e)), this.trim = () => new X({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new X({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new X({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== f.string) {
      const s = this._getOrReturnCtx(e);
      return p(
        s,
        {
          code: d.invalid_type,
          expected: f.string,
          received: s.parsedType
        }
        //
      ), g;
    }
    const n = new O();
    let i;
    for (const s of this._def.checks)
      if (s.kind === "min")
        e.data.length < s.value && (i = this._getOrReturnCtx(e, i), p(i, {
          code: d.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), n.dirty());
      else if (s.kind === "max")
        e.data.length > s.value && (i = this._getOrReturnCtx(e, i), p(i, {
          code: d.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), n.dirty());
      else if (s.kind === "length") {
        const a = e.data.length > s.value, o = e.data.length < s.value;
        (a || o) && (i = this._getOrReturnCtx(e, i), a ? p(i, {
          code: d.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }) : o && p(i, {
          code: d.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }), n.dirty());
      } else if (s.kind === "email")
        dn.test(e.data) || (i = this._getOrReturnCtx(e, i), p(i, {
          validation: "email",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "emoji")
        fn.test(e.data) || (i = this._getOrReturnCtx(e, i), p(i, {
          validation: "emoji",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "uuid")
        ln.test(e.data) || (i = this._getOrReturnCtx(e, i), p(i, {
          validation: "uuid",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid")
        on.test(e.data) || (i = this._getOrReturnCtx(e, i), p(i, {
          validation: "cuid",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid2")
        cn.test(e.data) || (i = this._getOrReturnCtx(e, i), p(i, {
          validation: "cuid2",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "ulid")
        un.test(e.data) || (i = this._getOrReturnCtx(e, i), p(i, {
          validation: "ulid",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "url")
        try {
          new URL(e.data);
        } catch {
          i = this._getOrReturnCtx(e, i), p(i, {
            validation: "url",
            code: d.invalid_string,
            message: s.message
          }), n.dirty();
        }
      else
        s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(e.data) || (i = this._getOrReturnCtx(e, i), p(i, {
          validation: "regex",
          code: d.invalid_string,
          message: s.message
        }), n.dirty())) : s.kind === "trim" ? e.data = e.data.trim() : s.kind === "includes" ? e.data.includes(s.value, s.position) || (i = this._getOrReturnCtx(e, i), p(i, {
          code: d.invalid_string,
          validation: { includes: s.value, position: s.position },
          message: s.message
        }), n.dirty()) : s.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : s.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : s.kind === "startsWith" ? e.data.startsWith(s.value) || (i = this._getOrReturnCtx(e, i), p(i, {
          code: d.invalid_string,
          validation: { startsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "endsWith" ? e.data.endsWith(s.value) || (i = this._getOrReturnCtx(e, i), p(i, {
          code: d.invalid_string,
          validation: { endsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "datetime" ? mn(s).test(e.data) || (i = this._getOrReturnCtx(e, i), p(i, {
          code: d.invalid_string,
          validation: "datetime",
          message: s.message
        }), n.dirty()) : s.kind === "ip" ? yn(e.data, s.version) || (i = this._getOrReturnCtx(e, i), p(i, {
          validation: "ip",
          code: d.invalid_string,
          message: s.message
        }), n.dirty()) : T.assertNever(s);
    return { status: n.value, value: e.data };
  }
  _addCheck(e) {
    return new X({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...m.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...m.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...m.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...m.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...m.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...m.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...m.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...m.errToObj(e) });
  }
  datetime(e) {
    var t;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (t = e == null ? void 0 : e.offset) !== null && t !== void 0 ? t : !1,
      ...m.errToObj(e == null ? void 0 : e.message)
    });
  }
  regex(e, t) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...m.errToObj(t)
    });
  }
  includes(e, t) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: t == null ? void 0 : t.position,
      ...m.errToObj(t == null ? void 0 : t.message)
    });
  }
  startsWith(e, t) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...m.errToObj(t)
    });
  }
  endsWith(e, t) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...m.errToObj(t)
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...m.errToObj(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...m.errToObj(t)
    });
  }
  length(e, t) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...m.errToObj(t)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
X.create = (r) => {
  var e;
  return new X({
    checks: [],
    typeName: y.ZodString,
    coerce: (e = r == null ? void 0 : r.coerce) !== null && e !== void 0 ? e : !1,
    ..._(r)
  });
};
function vn(r, e) {
  const t = (r.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, i = t > n ? t : n, s = parseInt(r.toFixed(i).replace(".", "")), a = parseInt(e.toFixed(i).replace(".", ""));
  return s % a / Math.pow(10, i);
}
class xe extends w {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== f.number) {
      const s = this._getOrReturnCtx(e);
      return p(s, {
        code: d.invalid_type,
        expected: f.number,
        received: s.parsedType
      }), g;
    }
    let n;
    const i = new O();
    for (const s of this._def.checks)
      s.kind === "int" ? T.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), p(n, {
        code: d.invalid_type,
        expected: "integer",
        received: "float",
        message: s.message
      }), i.dirty()) : s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: d.too_small,
        minimum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: d.too_big,
        maximum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), i.dirty()) : s.kind === "multipleOf" ? vn(e.data, s.value) !== 0 && (n = this._getOrReturnCtx(e, n), p(n, {
        code: d.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), i.dirty()) : s.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), p(n, {
        code: d.not_finite,
        message: s.message
      }), i.dirty()) : T.assertNever(s);
    return { status: i.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, m.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, m.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, m.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, m.toString(t));
  }
  setLimit(e, t, n, i) {
    return new xe({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: m.toString(i)
        }
      ]
    });
  }
  _addCheck(e) {
    return new xe({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: m.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: m.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: m.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: m.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: m.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: m.toString(t)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: m.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: m.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: m.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && T.isInteger(e.value));
  }
  get isFinite() {
    let e = null, t = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (t === null || n.value > t) && (t = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(t) && Number.isFinite(e);
  }
}
xe.create = (r) => new xe({
  checks: [],
  typeName: y.ZodNumber,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ..._(r)
});
class ke extends w {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== f.bigint) {
      const s = this._getOrReturnCtx(e);
      return p(s, {
        code: d.invalid_type,
        expected: f.bigint,
        received: s.parsedType
      }), g;
    }
    let n;
    const i = new O();
    for (const s of this._def.checks)
      s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: d.too_small,
        type: "bigint",
        minimum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: d.too_big,
        type: "bigint",
        maximum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), i.dirty()) : s.kind === "multipleOf" ? e.data % s.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: d.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), i.dirty()) : T.assertNever(s);
    return { status: i.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, m.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, m.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, m.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, m.toString(t));
  }
  setLimit(e, t, n, i) {
    return new ke({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: m.toString(i)
        }
      ]
    });
  }
  _addCheck(e) {
    return new ke({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: m.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: m.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: m.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: m.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: m.toString(t)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
ke.create = (r) => {
  var e;
  return new ke({
    checks: [],
    typeName: y.ZodBigInt,
    coerce: (e = r == null ? void 0 : r.coerce) !== null && e !== void 0 ? e : !1,
    ..._(r)
  });
};
class kt extends w {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== f.boolean) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: d.invalid_type,
        expected: f.boolean,
        received: n.parsedType
      }), g;
    }
    return Z(e.data);
  }
}
kt.create = (r) => new kt({
  typeName: y.ZodBoolean,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ..._(r)
});
class Oe extends w {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== f.date) {
      const s = this._getOrReturnCtx(e);
      return p(s, {
        code: d.invalid_type,
        expected: f.date,
        received: s.parsedType
      }), g;
    }
    if (isNaN(e.data.getTime())) {
      const s = this._getOrReturnCtx(e);
      return p(s, {
        code: d.invalid_date
      }), g;
    }
    const n = new O();
    let i;
    for (const s of this._def.checks)
      s.kind === "min" ? e.data.getTime() < s.value && (i = this._getOrReturnCtx(e, i), p(i, {
        code: d.too_small,
        message: s.message,
        inclusive: !0,
        exact: !1,
        minimum: s.value,
        type: "date"
      }), n.dirty()) : s.kind === "max" ? e.data.getTime() > s.value && (i = this._getOrReturnCtx(e, i), p(i, {
        code: d.too_big,
        message: s.message,
        inclusive: !0,
        exact: !1,
        maximum: s.value,
        type: "date"
      }), n.dirty()) : T.assertNever(s);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Oe({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: m.toString(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: m.toString(t)
    });
  }
  get minDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
}
Oe.create = (r) => new Oe({
  checks: [],
  coerce: (r == null ? void 0 : r.coerce) || !1,
  typeName: y.ZodDate,
  ..._(r)
});
class St extends w {
  _parse(e) {
    if (this._getType(e) !== f.symbol) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: d.invalid_type,
        expected: f.symbol,
        received: n.parsedType
      }), g;
    }
    return Z(e.data);
  }
}
St.create = (r) => new St({
  typeName: y.ZodSymbol,
  ..._(r)
});
class He extends w {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: d.invalid_type,
        expected: f.undefined,
        received: n.parsedType
      }), g;
    }
    return Z(e.data);
  }
}
He.create = (r) => new He({
  typeName: y.ZodUndefined,
  ..._(r)
});
class Ye extends w {
  _parse(e) {
    if (this._getType(e) !== f.null) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: d.invalid_type,
        expected: f.null,
        received: n.parsedType
      }), g;
    }
    return Z(e.data);
  }
}
Ye.create = (r) => new Ye({
  typeName: y.ZodNull,
  ..._(r)
});
class Tt extends w {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Z(e.data);
  }
}
Tt.create = (r) => new Tt({
  typeName: y.ZodAny,
  ..._(r)
});
class we extends w {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Z(e.data);
  }
}
we.create = (r) => new we({
  typeName: y.ZodUnknown,
  ..._(r)
});
class ie extends w {
  _parse(e) {
    const t = this._getOrReturnCtx(e);
    return p(t, {
      code: d.invalid_type,
      expected: f.never,
      received: t.parsedType
    }), g;
  }
}
ie.create = (r) => new ie({
  typeName: y.ZodNever,
  ..._(r)
});
class Et extends w {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: d.invalid_type,
        expected: f.void,
        received: n.parsedType
      }), g;
    }
    return Z(e.data);
  }
}
Et.create = (r) => new Et({
  typeName: y.ZodVoid,
  ..._(r)
});
class G extends w {
  _parse(e) {
    const { ctx: t, status: n } = this._processInputParams(e), i = this._def;
    if (t.parsedType !== f.array)
      return p(t, {
        code: d.invalid_type,
        expected: f.array,
        received: t.parsedType
      }), g;
    if (i.exactLength !== null) {
      const a = t.data.length > i.exactLength.value, o = t.data.length < i.exactLength.value;
      (a || o) && (p(t, {
        code: a ? d.too_big : d.too_small,
        minimum: o ? i.exactLength.value : void 0,
        maximum: a ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), n.dirty());
    }
    if (i.minLength !== null && t.data.length < i.minLength.value && (p(t, {
      code: d.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), n.dirty()), i.maxLength !== null && t.data.length > i.maxLength.value && (p(t, {
      code: d.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), n.dirty()), t.common.async)
      return Promise.all([...t.data].map((a, o) => i.type._parseAsync(new J(t, a, t.path, o)))).then((a) => O.mergeArray(n, a));
    const s = [...t.data].map((a, o) => i.type._parseSync(new J(t, a, t.path, o)));
    return O.mergeArray(n, s);
  }
  get element() {
    return this._def.type;
  }
  min(e, t) {
    return new G({
      ...this._def,
      minLength: { value: e, message: m.toString(t) }
    });
  }
  max(e, t) {
    return new G({
      ...this._def,
      maxLength: { value: e, message: m.toString(t) }
    });
  }
  length(e, t) {
    return new G({
      ...this._def,
      exactLength: { value: e, message: m.toString(t) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
G.create = (r, e) => new G({
  type: r,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: y.ZodArray,
  ..._(e)
});
function ve(r) {
  if (r instanceof A) {
    const e = {};
    for (const t in r.shape) {
      const n = r.shape[t];
      e[t] = re.create(ve(n));
    }
    return new A({
      ...r._def,
      shape: () => e
    });
  } else
    return r instanceof G ? new G({
      ...r._def,
      type: ve(r.element)
    }) : r instanceof re ? re.create(ve(r.unwrap())) : r instanceof Te ? Te.create(ve(r.unwrap())) : r instanceof Q ? Q.create(r.items.map((e) => ve(e))) : r;
}
class A extends w {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), t = T.objectKeys(e);
    return this._cached = { shape: e, keys: t };
  }
  _parse(e) {
    if (this._getType(e) !== f.object) {
      const u = this._getOrReturnCtx(e);
      return p(u, {
        code: d.invalid_type,
        expected: f.object,
        received: u.parsedType
      }), g;
    }
    const { status: n, ctx: i } = this._processInputParams(e), { shape: s, keys: a } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof ie && this._def.unknownKeys === "strip"))
      for (const u in i.data)
        a.includes(u) || o.push(u);
    const c = [];
    for (const u of a) {
      const l = s[u], h = i.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: l._parse(new J(i, h, i.path, u)),
        alwaysSet: u in i.data
      });
    }
    if (this._def.catchall instanceof ie) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of o)
          c.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: i.data[l] }
          });
      else if (u === "strict")
        o.length > 0 && (p(i, {
          code: d.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of o) {
        const h = i.data[l];
        c.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new J(i, h, i.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of c) {
        const h = await l.key;
        u.push({
          key: h,
          value: await l.value,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => O.mergeObjectSync(n, u)) : O.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return m.errToObj, new A({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (t, n) => {
          var i, s, a, o;
          const c = (a = (s = (i = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(i, t, n).message) !== null && a !== void 0 ? a : n.defaultError;
          return t.code === "unrecognized_keys" ? {
            message: (o = m.errToObj(e).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new A({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new A({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new A({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new A({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: y.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, t) {
    return this.augment({ [e]: t });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new A({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const t = {};
    return T.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (t[n] = this.shape[n]);
    }), new A({
      ...this._def,
      shape: () => t
    });
  }
  omit(e) {
    const t = {};
    return T.objectKeys(this.shape).forEach((n) => {
      e[n] || (t[n] = this.shape[n]);
    }), new A({
      ...this._def,
      shape: () => t
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ve(this);
  }
  partial(e) {
    const t = {};
    return T.objectKeys(this.shape).forEach((n) => {
      const i = this.shape[n];
      e && !e[n] ? t[n] = i : t[n] = i.optional();
    }), new A({
      ...this._def,
      shape: () => t
    });
  }
  required(e) {
    const t = {};
    return T.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        t[n] = this.shape[n];
      else {
        let s = this.shape[n];
        for (; s instanceof re; )
          s = s._def.innerType;
        t[n] = s;
      }
    }), new A({
      ...this._def,
      shape: () => t
    });
  }
  keyof() {
    return yr(T.objectKeys(this.shape));
  }
}
A.create = (r, e) => new A({
  shape: () => r,
  unknownKeys: "strip",
  catchall: ie.create(),
  typeName: y.ZodObject,
  ..._(e)
});
A.strictCreate = (r, e) => new A({
  shape: () => r,
  unknownKeys: "strict",
  catchall: ie.create(),
  typeName: y.ZodObject,
  ..._(e)
});
A.lazycreate = (r, e) => new A({
  shape: r,
  unknownKeys: "strip",
  catchall: ie.create(),
  typeName: y.ZodObject,
  ..._(e)
});
class Ge extends w {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = this._def.options;
    function i(s) {
      for (const o of s)
        if (o.result.status === "valid")
          return o.result;
      for (const o of s)
        if (o.result.status === "dirty")
          return t.common.issues.push(...o.ctx.common.issues), o.result;
      const a = s.map((o) => new Y(o.ctx.common.issues));
      return p(t, {
        code: d.invalid_union,
        unionErrors: a
      }), g;
    }
    if (t.common.async)
      return Promise.all(n.map(async (s) => {
        const a = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: t.data,
            path: t.path,
            parent: a
          }),
          ctx: a
        };
      })).then(i);
    {
      let s;
      const a = [];
      for (const c of n) {
        const u = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: t.data,
          path: t.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !s && (s = { result: l, ctx: u }), u.common.issues.length && a.push(u.common.issues);
      }
      if (s)
        return t.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((c) => new Y(c));
      return p(t, {
        code: d.invalid_union,
        unionErrors: o
      }), g;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ge.create = (r, e) => new Ge({
  options: r,
  typeName: y.ZodUnion,
  ..._(e)
});
const Be = (r) => r instanceof Xe ? Be(r.schema) : r instanceof ee ? Be(r.innerType()) : r instanceof Qe ? [r.value] : r instanceof he ? r.options : r instanceof et ? Object.keys(r.enum) : r instanceof tt ? Be(r._def.innerType) : r instanceof He ? [void 0] : r instanceof Ye ? [null] : null;
class zt extends w {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== f.object)
      return p(t, {
        code: d.invalid_type,
        expected: f.object,
        received: t.parsedType
      }), g;
    const n = this.discriminator, i = t.data[n], s = this.optionsMap.get(i);
    return s ? t.common.async ? s._parseAsync({
      data: t.data,
      path: t.path,
      parent: t
    }) : s._parseSync({
      data: t.data,
      path: t.path,
      parent: t
    }) : (p(t, {
      code: d.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), g);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, t, n) {
    const i = /* @__PURE__ */ new Map();
    for (const s of t) {
      const a = Be(s.shape[e]);
      if (!a)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o of a) {
        if (i.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        i.set(o, s);
      }
    }
    return new zt({
      typeName: y.ZodDiscriminatedUnion,
      discriminator: e,
      options: t,
      optionsMap: i,
      ..._(n)
    });
  }
}
function It(r, e) {
  const t = le(r), n = le(e);
  if (r === e)
    return { valid: !0, data: r };
  if (t === f.object && n === f.object) {
    const i = T.objectKeys(e), s = T.objectKeys(r).filter((o) => i.indexOf(o) !== -1), a = { ...r, ...e };
    for (const o of s) {
      const c = It(r[o], e[o]);
      if (!c.valid)
        return { valid: !1 };
      a[o] = c.data;
    }
    return { valid: !0, data: a };
  } else if (t === f.array && n === f.array) {
    if (r.length !== e.length)
      return { valid: !1 };
    const i = [];
    for (let s = 0; s < r.length; s++) {
      const a = r[s], o = e[s], c = It(a, o);
      if (!c.valid)
        return { valid: !1 };
      i.push(c.data);
    }
    return { valid: !0, data: i };
  } else
    return t === f.date && n === f.date && +r == +e ? { valid: !0, data: r } : { valid: !1 };
}
class Je extends w {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), i = (s, a) => {
      if (Xt(s) || Xt(a))
        return g;
      const o = It(s.value, a.value);
      return o.valid ? ((Qt(s) || Qt(a)) && t.dirty(), { status: t.value, value: o.data }) : (p(n, {
        code: d.invalid_intersection_types
      }), g);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([s, a]) => i(s, a)) : i(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
Je.create = (r, e, t) => new Je({
  left: r,
  right: e,
  typeName: y.ZodIntersection,
  ..._(t)
});
class Q extends w {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.array)
      return p(n, {
        code: d.invalid_type,
        expected: f.array,
        received: n.parsedType
      }), g;
    if (n.data.length < this._def.items.length)
      return p(n, {
        code: d.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), g;
    !this._def.rest && n.data.length > this._def.items.length && (p(n, {
      code: d.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), t.dirty());
    const s = [...n.data].map((a, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new J(n, a, n.path, o)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(s).then((a) => O.mergeArray(t, a)) : O.mergeArray(t, s);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Q({
      ...this._def,
      rest: e
    });
  }
}
Q.create = (r, e) => {
  if (!Array.isArray(r))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Q({
    items: r,
    typeName: y.ZodTuple,
    rest: null,
    ..._(e)
  });
};
class Me extends w {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.object)
      return p(n, {
        code: d.invalid_type,
        expected: f.object,
        received: n.parsedType
      }), g;
    const i = [], s = this._def.keyType, a = this._def.valueType;
    for (const o in n.data)
      i.push({
        key: s._parse(new J(n, o, n.path, o)),
        value: a._parse(new J(n, n.data[o], n.path, o))
      });
    return n.common.async ? O.mergeObjectAsync(t, i) : O.mergeObjectSync(t, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, t, n) {
    return t instanceof w ? new Me({
      keyType: e,
      valueType: t,
      typeName: y.ZodRecord,
      ..._(n)
    }) : new Me({
      keyType: X.create(),
      valueType: e,
      typeName: y.ZodRecord,
      ..._(t)
    });
  }
}
class Ct extends w {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.map)
      return p(n, {
        code: d.invalid_type,
        expected: f.map,
        received: n.parsedType
      }), g;
    const i = this._def.keyType, s = this._def.valueType, a = [...n.data.entries()].map(([o, c], u) => ({
      key: i._parse(new J(n, o, n.path, [u, "key"])),
      value: s._parse(new J(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return g;
          (u.status === "dirty" || l.status === "dirty") && t.dirty(), o.set(u.value, l.value);
        }
        return { status: t.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of a) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return g;
        (u.status === "dirty" || l.status === "dirty") && t.dirty(), o.set(u.value, l.value);
      }
      return { status: t.value, value: o };
    }
  }
}
Ct.create = (r, e, t) => new Ct({
  valueType: e,
  keyType: r,
  typeName: y.ZodMap,
  ..._(t)
});
class Se extends w {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.set)
      return p(n, {
        code: d.invalid_type,
        expected: f.set,
        received: n.parsedType
      }), g;
    const i = this._def;
    i.minSize !== null && n.data.size < i.minSize.value && (p(n, {
      code: d.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), t.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (p(n, {
      code: d.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), t.dirty());
    const s = this._def.valueType;
    function a(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return g;
        l.status === "dirty" && t.dirty(), u.add(l.value);
      }
      return { status: t.value, value: u };
    }
    const o = [...n.data.values()].map((c, u) => s._parse(new J(n, c, n.path, u)));
    return n.common.async ? Promise.all(o).then((c) => a(c)) : a(o);
  }
  min(e, t) {
    return new Se({
      ...this._def,
      minSize: { value: e, message: m.toString(t) }
    });
  }
  max(e, t) {
    return new Se({
      ...this._def,
      maxSize: { value: e, message: m.toString(t) }
    });
  }
  size(e, t) {
    return this.min(e, t).max(e, t);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Se.create = (r, e) => new Se({
  valueType: r,
  minSize: null,
  maxSize: null,
  typeName: y.ZodSet,
  ..._(e)
});
class Ne extends w {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== f.function)
      return p(t, {
        code: d.invalid_type,
        expected: f.function,
        received: t.parsedType
      }), g;
    function n(o, c) {
      return wt({
        data: o,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          _t(),
          Ke
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function i(o, c) {
      return wt({
        data: o,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          _t(),
          Ke
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const s = { errorMap: t.common.contextualErrorMap }, a = t.data;
    return this._def.returns instanceof De ? Z(async (...o) => {
      const c = new Y([]), u = await this._def.args.parseAsync(o, s).catch((v) => {
        throw c.addIssue(n(o, v)), c;
      }), l = await a(...u);
      return await this._def.returns._def.type.parseAsync(l, s).catch((v) => {
        throw c.addIssue(i(l, v)), c;
      });
    }) : Z((...o) => {
      const c = this._def.args.safeParse(o, s);
      if (!c.success)
        throw new Y([n(o, c.error)]);
      const u = a(...c.data), l = this._def.returns.safeParse(u, s);
      if (!l.success)
        throw new Y([i(u, l.error)]);
      return l.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new Ne({
      ...this._def,
      args: Q.create(e).rest(we.create())
    });
  }
  returns(e) {
    return new Ne({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, t, n) {
    return new Ne({
      args: e || Q.create([]).rest(we.create()),
      returns: t || we.create(),
      typeName: y.ZodFunction,
      ..._(n)
    });
  }
}
class Xe extends w {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
}
Xe.create = (r, e) => new Xe({
  getter: r,
  typeName: y.ZodLazy,
  ..._(e)
});
class Qe extends w {
  _parse(e) {
    if (e.data !== this._def.value) {
      const t = this._getOrReturnCtx(e);
      return p(t, {
        received: t.data,
        code: d.invalid_literal,
        expected: this._def.value
      }), g;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Qe.create = (r, e) => new Qe({
  value: r,
  typeName: y.ZodLiteral,
  ..._(e)
});
function yr(r, e) {
  return new he({
    values: r,
    typeName: y.ZodEnum,
    ..._(e)
  });
}
class he extends w {
  _parse(e) {
    if (typeof e.data != "string") {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return p(t, {
        expected: T.joinValues(n),
        received: t.parsedType,
        code: d.invalid_type
      }), g;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return p(t, {
        received: t.data,
        code: d.invalid_enum_value,
        options: n
      }), g;
    }
    return Z(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Values() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  extract(e) {
    return he.create(e);
  }
  exclude(e) {
    return he.create(this.options.filter((t) => !e.includes(t)));
  }
}
he.create = yr;
class et extends w {
  _parse(e) {
    const t = T.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== f.string && n.parsedType !== f.number) {
      const i = T.objectValues(t);
      return p(n, {
        expected: T.joinValues(i),
        received: n.parsedType,
        code: d.invalid_type
      }), g;
    }
    if (t.indexOf(e.data) === -1) {
      const i = T.objectValues(t);
      return p(n, {
        received: n.data,
        code: d.invalid_enum_value,
        options: i
      }), g;
    }
    return Z(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
et.create = (r, e) => new et({
  values: r,
  typeName: y.ZodNativeEnum,
  ..._(e)
});
class De extends w {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== f.promise && t.common.async === !1)
      return p(t, {
        code: d.invalid_type,
        expected: f.promise,
        received: t.parsedType
      }), g;
    const n = t.parsedType === f.promise ? t.data : Promise.resolve(t.data);
    return Z(n.then((i) => this._def.type.parseAsync(i, {
      path: t.path,
      errorMap: t.common.contextualErrorMap
    })));
  }
}
De.create = (r, e) => new De({
  type: r,
  typeName: y.ZodPromise,
  ..._(e)
});
class ee extends w {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === y.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), i = this._def.effect || null;
    if (i.type === "preprocess") {
      const a = i.transform(n.data);
      return n.common.async ? Promise.resolve(a).then((o) => this._def.schema._parseAsync({
        data: o,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: a,
        path: n.path,
        parent: n
      });
    }
    const s = {
      addIssue: (a) => {
        p(n, a), a.fatal ? t.abort() : t.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), i.type === "refinement") {
      const a = (o) => {
        const c = i.refinement(o, s);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? g : (o.status === "dirty" && t.dirty(), a(o.value), { status: t.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? g : (o.status === "dirty" && t.dirty(), a(o.value).then(() => ({ status: t.value, value: o.value }))));
    }
    if (i.type === "transform")
      if (n.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!bt(a))
          return a;
        const o = i.transform(a.value, s);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => bt(a) ? Promise.resolve(i.transform(a.value, s)).then((o) => ({ status: t.value, value: o })) : a);
    T.assertNever(i);
  }
}
ee.create = (r, e, t) => new ee({
  schema: r,
  typeName: y.ZodEffects,
  effect: e,
  ..._(t)
});
ee.createWithPreprocess = (r, e, t) => new ee({
  schema: e,
  effect: { type: "preprocess", transform: r },
  typeName: y.ZodEffects,
  ..._(t)
});
class re extends w {
  _parse(e) {
    return this._getType(e) === f.undefined ? Z(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
re.create = (r, e) => new re({
  innerType: r,
  typeName: y.ZodOptional,
  ..._(e)
});
class Te extends w {
  _parse(e) {
    return this._getType(e) === f.null ? Z(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Te.create = (r, e) => new Te({
  innerType: r,
  typeName: y.ZodNullable,
  ..._(e)
});
class tt extends w {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    let n = t.data;
    return t.parsedType === f.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
tt.create = (r, e) => new tt({
  innerType: r,
  typeName: y.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ..._(e)
});
class At extends w {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = {
      ...t,
      common: {
        ...t.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return xt(i) ? i.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Y(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Y(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
At.create = (r, e) => new At({
  innerType: r,
  typeName: y.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ..._(e)
});
class Rt extends w {
  _parse(e) {
    if (this._getType(e) !== f.nan) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: d.invalid_type,
        expected: f.nan,
        received: n.parsedType
      }), g;
    }
    return { status: "valid", value: e.data };
  }
}
Rt.create = (r) => new Rt({
  typeName: y.ZodNaN,
  ..._(r)
});
class gn extends w {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = t.data;
    return this._def.type._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class st extends w {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? g : s.status === "dirty" ? (t.dirty(), an(s.value)) : this._def.out._parseAsync({
          data: s.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return i.status === "aborted" ? g : i.status === "dirty" ? (t.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, t) {
    return new st({
      in: e,
      out: t,
      typeName: y.ZodPipeline
    });
  }
}
A.lazycreate;
var y;
(function(r) {
  r.ZodString = "ZodString", r.ZodNumber = "ZodNumber", r.ZodNaN = "ZodNaN", r.ZodBigInt = "ZodBigInt", r.ZodBoolean = "ZodBoolean", r.ZodDate = "ZodDate", r.ZodSymbol = "ZodSymbol", r.ZodUndefined = "ZodUndefined", r.ZodNull = "ZodNull", r.ZodAny = "ZodAny", r.ZodUnknown = "ZodUnknown", r.ZodNever = "ZodNever", r.ZodVoid = "ZodVoid", r.ZodArray = "ZodArray", r.ZodObject = "ZodObject", r.ZodUnion = "ZodUnion", r.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", r.ZodIntersection = "ZodIntersection", r.ZodTuple = "ZodTuple", r.ZodRecord = "ZodRecord", r.ZodMap = "ZodMap", r.ZodSet = "ZodSet", r.ZodFunction = "ZodFunction", r.ZodLazy = "ZodLazy", r.ZodLiteral = "ZodLiteral", r.ZodEnum = "ZodEnum", r.ZodEffects = "ZodEffects", r.ZodNativeEnum = "ZodNativeEnum", r.ZodOptional = "ZodOptional", r.ZodNullable = "ZodNullable", r.ZodDefault = "ZodDefault", r.ZodCatch = "ZodCatch", r.ZodPromise = "ZodPromise", r.ZodBranded = "ZodBranded", r.ZodPipeline = "ZodPipeline";
})(y || (y = {}));
const E = X.create, at = xe.create;
Rt.create;
ke.create;
const Ze = kt.create;
Oe.create;
St.create;
He.create;
Ye.create;
Tt.create;
we.create;
ie.create;
Et.create;
const Ve = G.create, x = A.create;
A.strictCreate;
const $ = Ge.create;
zt.create;
Je.create;
Q.create;
Me.create;
Ct.create;
Se.create;
Ne.create;
Xe.create;
const I = Qe.create;
he.create;
et.create;
De.create;
ee.create;
re.create;
Te.create;
ee.createWithPreprocess;
st.create;
const _n = x({
  address: E(),
  label: E(),
  appearanceId: at()
}), jt = x({
  publicKey: E(),
  signature: E(),
  curve: $([I("curve25519"), I("secp256k1")])
}), wn = x({
  accountAddress: E(),
  proof: jt
}), ot = x({ identityAddress: E(), label: E() }), tr = {
  western: "western",
  eastern: "eastern"
}, bn = $([
  I(tr.eastern),
  I(tr.western)
]), xn = x({
  variant: bn,
  familyName: E(),
  nickname: E(),
  givenNames: E()
}), Pt = x({
  quantifier: $([I("exactly"), I("atLeast")]),
  quantity: at().gte(0)
}), Nt = x({
  challenge: E().optional(),
  numberOfAccounts: Pt
}), Lt = x({
  accounts: Ve(_n),
  challenge: E().optional(),
  proofs: Ve(wn).optional()
}).refine((r) => {
  var e;
  return r.challenge || r != null && r.proofs ? r.challenge && ((e = r == null ? void 0 : r.proofs) == null ? void 0 : e.length) : !0;
}, "missing challenge or proofs"), Ot = x({
  isRequestingName: Ze().optional(),
  numberOfRequestedEmailAddresses: Pt.optional(),
  numberOfRequestedPhoneNumbers: Pt.optional()
}), Dt = x({
  name: xn.optional(),
  emailAddresses: Ve(E()).optional(),
  phoneNumbers: Ve(E()).optional()
}), kn = x({
  accounts: Ze(),
  personaData: Ze()
}), hs = x({
  persona: ot,
  challenge: E().optional(),
  proof: jt.optional()
}).refine((r) => r.challenge || r.proof ? r.challenge && r.proof : !0, "missing challenge or proof"), Sn = x({
  discriminator: I("unauthorizedRequest"),
  oneTimeAccounts: Nt.optional(),
  oneTimePersonaData: Ot.optional()
}), Tn = x({
  discriminator: I("usePersona"),
  identityAddress: E()
}), En = x({
  discriminator: I("loginWithoutChallenge")
}), In = x({
  discriminator: I("loginWithChallenge"),
  challenge: E()
}), Cn = $([
  En,
  In
]), An = $([
  Tn,
  Cn
]), Rn = x({
  discriminator: I("authorizedRequest"),
  auth: An,
  reset: kn.optional(),
  oneTimeAccounts: Nt.optional(),
  ongoingAccounts: Nt.optional(),
  oneTimePersonaData: Ot.optional(),
  ongoingPersonaData: Ot.optional()
}), Pn = $([
  Sn,
  Rn
]), Nn = x({
  transactionManifest: E(),
  version: at(),
  blobs: Ve(E()).optional(),
  message: E().optional()
}), Ln = x({
  discriminator: I("transaction"),
  send: Nn
}), On = x({
  transactionIntentHash: E()
}), Dn = x({
  discriminator: I("transaction"),
  send: On
}), Zn = x({
  discriminator: I("cancelRequest")
}), Vn = $([
  Pn,
  Ln,
  Zn
]), vr = x({
  version: I(2),
  networkId: at(),
  dAppDefinitionAddress: E()
}), $n = x({
  interactionId: E(),
  metadata: vr,
  items: Vn
}), Un = x({
  discriminator: I("unauthorizedRequest"),
  oneTimeAccounts: Lt.optional(),
  oneTimePersonaData: Dt.optional()
}), Wn = x({
  discriminator: I("loginWithoutChallenge"),
  persona: ot
}), qn = x({
  discriminator: I("loginWithChallenge"),
  persona: ot,
  challenge: E(),
  proof: jt
}), Bn = $([
  Wn,
  qn
]), zn = x({
  discriminator: I("usePersona"),
  persona: ot
}), jn = $([
  zn,
  Bn
]), Fn = x({
  discriminator: I("authorizedRequest"),
  auth: jn,
  oneTimeAccounts: Lt.optional(),
  ongoingAccounts: Lt.optional(),
  oneTimePersonaData: Dt.optional(),
  ongoingPersonaData: Dt.optional()
}), Kn = $([
  Un,
  Fn
]), Hn = $([
  Kn,
  Dn
]), Yn = x({
  discriminator: I("success"),
  interactionId: E(),
  items: Hn
}), Gn = x({
  discriminator: I("failure"),
  interactionId: E(),
  error: E(),
  message: E().optional()
}), gr = $([
  Yn,
  Gn
]), ps = x({
  interactionId: E(),
  discriminator: I("extensionStatus")
}), ge = {
  extensionStatus: "extensionStatus",
  receivedByExtension: "receivedByExtension",
  receivedByWallet: "receivedByWallet",
  requestCancelSuccess: "requestCancelSuccess",
  requestCancelFail: "requestCancelFail"
}, ms = x({
  eventType: I(ge.extensionStatus),
  interactionId: E(),
  isWalletLinked: Ze(),
  isExtensionAvailable: Ze()
}), Jn = x({
  eventType: $([
    I(ge.extensionStatus),
    I(ge.receivedByExtension),
    I(ge.receivedByWallet),
    I(ge.requestCancelSuccess),
    I(ge.requestCancelFail)
  ]),
  interactionId: E()
});
$([
  Jn,
  gr
]);
const Ue = {
  outgoingMessage: "radix#chromeExtension#send",
  incomingMessage: "radix#chromeExtension#receive"
}, Mn = (r, e) => M.fromPromise(
  r.parseAsync(e),
  (t) => t.issues
), _r = (r) => (e, t, n = crypto.randomUUID()) => {
  const i = {
    items: t,
    interactionId: n,
    metadata: e
  };
  return Mn($n, i).mapErr((s) => (r == null || r.error("🔵⬆️❌ invalidWalletInteraction", s), Le(
    ze.walletRequestValidation,
    i.interactionId
  )));
}, ys = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  walletInteractionFactory: _r
}, Symbol.toStringTag, { value: "Module" })), Xn = (r) => r, ze = {
  rejectedByUser: "rejectedByUser",
  missingExtension: "missingExtension",
  canceledByUser: "canceledByUser",
  walletRequestValidation: "walletRequestValidation",
  walletResponseValidation: "walletResponseValidation",
  wrongNetwork: "wrongNetwork",
  failedToPrepareTransaction: "failedToPrepareTransaction",
  failedToCompileTransaction: "failedToCompileTransaction",
  failedToSignTransaction: "failedToSignTransaction",
  failedToSubmitTransaction: "failedToSubmitTransaction",
  failedToPollSubmittedTransaction: "failedToPollSubmittedTransaction",
  submittedTransactionWasDuplicate: "submittedTransactionWasDuplicate",
  submittedTransactionHasFailedTransactionStatus: "submittedTransactionHasFailedTransactionStatus",
  submittedTransactionHasRejectedTransactionStatus: "submittedTransactionHasRejectedTransactionStatus",
  failedToFindAccountWithEnoughFundsToLockFee: "failedToFindAccountWithEnoughFundsToLockFee",
  wrongAccountType: "wrongAccountType",
  unknownWebsite: "unknownWebsite",
  radixJsonNotFound: "radixJsonNotFound",
  unknownDappDefinitionAddress: "unknownDappDefinitionAddress",
  invalidPersona: "invalidPersona"
}, Qn = (/* @__PURE__ */ new Map()).set(ze.missingExtension, "extension could not be found").set(ze.rejectedByUser, "user rejected request").set(ze.canceledByUser, "user has canceled the request"), Le = (r, e, t) => ({
  error: r,
  interactionId: e,
  message: t || Qn.get(r) || ""
}), rr = (r) => M.fromPromise(
  gr.parseAsync(r),
  (e) => e.issues
).andThen(
  (e) => e.discriminator === "success" ? H(e) : B(e)
).mapErr(() => Le("walletResponseValidation", "")), ei = (r, e) => {
  const t = r.logger, n = _r(t);
  return {
    request: (a, o = {}) => n(r, a).andThen(
      (c) => e.send(c, o)
    ).andThen(rr).map((c) => c.items),
    sendTransaction: (a, o = {}) => n(r, {
      discriminator: "transaction",
      send: a
    }).andThen(
      (c) => e.send(c, o)
    ).andThen(rr).map(
      (c) => c.items.send
    ),
    extensionStatus$: e.extensionStatus$,
    openPopup: e.openPopup
  };
};
var Zt = function(r, e) {
  return Zt = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, Zt(r, e);
};
function se(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Zt(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function ti(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(l) {
      try {
        u(n.next(l));
      } catch (h) {
        a(h);
      }
    }
    function c(l) {
      try {
        u(n.throw(l));
      } catch (h) {
        a(h);
      }
    }
    function u(l) {
      l.done ? s(l.value) : i(l.value).then(o, c);
    }
    u((n = n.apply(r, e || [])).next());
  });
}
function wr(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, u[0] && (t = 0)), t; )
      try {
        if (n = 1, i && (s = u[0] & 2 ? i.return : u[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, u[1])).done)
          return s;
        switch (i = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return t.label++, { value: u[1], done: !1 };
          case 5:
            t.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              t = 0;
              continue;
            }
            if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
              t.label = u[1];
              break;
            }
            if (u[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = u;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(u);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        u = e.call(r, t);
      } catch (l) {
        u = [6, l], i = 0;
      } finally {
        n = s = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Ee(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t)
    return t.call(r);
  if (r && typeof r.length == "number")
    return {
      next: function() {
        return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function pe(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t)
    return r;
  var n = t.call(r), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return s;
}
function me(r, e, t) {
  if (t || arguments.length === 2)
    for (var n = 0, i = e.length, s; n < i; n++)
      (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return r.concat(s || Array.prototype.slice.call(e));
}
function be(r) {
  return this instanceof be ? (this.v = r, this) : new be(r);
}
function ri(r, e, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = t.apply(r, e || []), i, s = [];
  return i = {}, a("next"), a("throw"), a("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function a(v) {
    n[v] && (i[v] = function(S) {
      return new Promise(function(C, k) {
        s.push([v, S, C, k]) > 1 || o(v, S);
      });
    });
  }
  function o(v, S) {
    try {
      c(n[v](S));
    } catch (C) {
      h(s[0][3], C);
    }
  }
  function c(v) {
    v.value instanceof be ? Promise.resolve(v.value.v).then(u, l) : h(s[0][2], v);
  }
  function u(v) {
    o("next", v);
  }
  function l(v) {
    o("throw", v);
  }
  function h(v, S) {
    v(S), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
function ni(r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = r[Symbol.asyncIterator], t;
  return e ? e.call(r) : (r = typeof Ee == "function" ? Ee(r) : r[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function n(s) {
    t[s] = r[s] && function(a) {
      return new Promise(function(o, c) {
        a = r[s](a), i(o, c, a.done, a.value);
      });
    };
  }
  function i(s, a, o, c) {
    Promise.resolve(c).then(function(u) {
      s({ value: u, done: o });
    }, a);
  }
}
function R(r) {
  return typeof r == "function";
}
function Ft(r) {
  var e = function(n) {
    Error.call(n), n.stack = new Error().stack;
  }, t = r(e);
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t;
}
var ft = Ft(function(r) {
  return function(t) {
    r(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(n, i) {
      return i + 1 + ") " + n.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function rt(r, e) {
  if (r) {
    var t = r.indexOf(e);
    0 <= t && r.splice(t, 1);
  }
}
var Ce = function() {
  function r(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return r.prototype.unsubscribe = function() {
    var e, t, n, i, s;
    if (!this.closed) {
      this.closed = !0;
      var a = this._parentage;
      if (a)
        if (this._parentage = null, Array.isArray(a))
          try {
            for (var o = Ee(a), c = o.next(); !c.done; c = o.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (k) {
            e = { error: k };
          } finally {
            try {
              c && !c.done && (t = o.return) && t.call(o);
            } finally {
              if (e)
                throw e.error;
            }
          }
        else
          a.remove(this);
      var l = this.initialTeardown;
      if (R(l))
        try {
          l();
        } catch (k) {
          s = k instanceof ft ? k.errors : [k];
        }
      var h = this._finalizers;
      if (h) {
        this._finalizers = null;
        try {
          for (var v = Ee(h), S = v.next(); !S.done; S = v.next()) {
            var C = S.value;
            try {
              nr(C);
            } catch (k) {
              s = s ?? [], k instanceof ft ? s = me(me([], pe(s)), pe(k.errors)) : s.push(k);
            }
          }
        } catch (k) {
          n = { error: k };
        } finally {
          try {
            S && !S.done && (i = v.return) && i.call(v);
          } finally {
            if (n)
              throw n.error;
          }
        }
      }
      if (s)
        throw new ft(s);
    }
  }, r.prototype.add = function(e) {
    var t;
    if (e && e !== this)
      if (this.closed)
        nr(e);
      else {
        if (e instanceof r) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (t = this._finalizers) !== null && t !== void 0 ? t : []).push(e);
      }
  }, r.prototype._hasParent = function(e) {
    var t = this._parentage;
    return t === e || Array.isArray(t) && t.includes(e);
  }, r.prototype._addParent = function(e) {
    var t = this._parentage;
    this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
  }, r.prototype._removeParent = function(e) {
    var t = this._parentage;
    t === e ? this._parentage = null : Array.isArray(t) && rt(t, e);
  }, r.prototype.remove = function(e) {
    var t = this._finalizers;
    t && rt(t, e), e instanceof r && e._removeParent(this);
  }, r.EMPTY = function() {
    var e = new r();
    return e.closed = !0, e;
  }(), r;
}(), br = Ce.EMPTY;
function xr(r) {
  return r instanceof Ce || r && "closed" in r && R(r.remove) && R(r.add) && R(r.unsubscribe);
}
function nr(r) {
  R(r) ? r() : r.unsubscribe();
}
var kr = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, Vt = {
  setTimeout: function(r, e) {
    for (var t = [], n = 2; n < arguments.length; n++)
      t[n - 2] = arguments[n];
    var i = Vt.delegate;
    return i != null && i.setTimeout ? i.setTimeout.apply(i, me([r, e], pe(t))) : setTimeout.apply(void 0, me([r, e], pe(t)));
  },
  clearTimeout: function(r) {
    var e = Vt.delegate;
    return ((e == null ? void 0 : e.clearTimeout) || clearTimeout)(r);
  },
  delegate: void 0
};
function Sr(r) {
  Vt.setTimeout(function() {
    throw r;
  });
}
function $t() {
}
function je(r) {
  r();
}
var Kt = function(r) {
  se(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n.isStopped = !1, t ? (n.destination = t, xr(t) && t.add(n)) : n.destination = oi, n;
  }
  return e.create = function(t, n, i) {
    return new Ie(t, n, i);
  }, e.prototype.next = function(t) {
    this.isStopped || this._next(t);
  }, e.prototype.error = function(t) {
    this.isStopped || (this.isStopped = !0, this._error(t));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, r.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(t) {
    this.destination.next(t);
  }, e.prototype._error = function(t) {
    try {
      this.destination.error(t);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(Ce), ii = Function.prototype.bind;
function ht(r, e) {
  return ii.call(r, e);
}
var si = function() {
  function r(e) {
    this.partialObserver = e;
  }
  return r.prototype.next = function(e) {
    var t = this.partialObserver;
    if (t.next)
      try {
        t.next(e);
      } catch (n) {
        We(n);
      }
  }, r.prototype.error = function(e) {
    var t = this.partialObserver;
    if (t.error)
      try {
        t.error(e);
      } catch (n) {
        We(n);
      }
    else
      We(e);
  }, r.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (t) {
        We(t);
      }
  }, r;
}(), Ie = function(r) {
  se(e, r);
  function e(t, n, i) {
    var s = r.call(this) || this, a;
    if (R(t) || !t)
      a = {
        next: t ?? void 0,
        error: n ?? void 0,
        complete: i ?? void 0
      };
    else {
      var o;
      s && kr.useDeprecatedNextContext ? (o = Object.create(t), o.unsubscribe = function() {
        return s.unsubscribe();
      }, a = {
        next: t.next && ht(t.next, o),
        error: t.error && ht(t.error, o),
        complete: t.complete && ht(t.complete, o)
      }) : a = t;
    }
    return s.destination = new si(a), s;
  }
  return e;
}(Kt);
function We(r) {
  Sr(r);
}
function ai(r) {
  throw r;
}
var oi = {
  closed: !0,
  next: $t,
  error: ai,
  complete: $t
}, Ht = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function ct(r) {
  return r;
}
function ci(r) {
  return r.length === 0 ? ct : r.length === 1 ? r[0] : function(t) {
    return r.reduce(function(n, i) {
      return i(n);
    }, t);
  };
}
var V = function() {
  function r(e) {
    e && (this._subscribe = e);
  }
  return r.prototype.lift = function(e) {
    var t = new r();
    return t.source = this, t.operator = e, t;
  }, r.prototype.subscribe = function(e, t, n) {
    var i = this, s = li(e) ? e : new Ie(e, t, n);
    return je(function() {
      var a = i, o = a.operator, c = a.source;
      s.add(o ? o.call(s, c) : c ? i._subscribe(s) : i._trySubscribe(s));
    }), s;
  }, r.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (t) {
      e.error(t);
    }
  }, r.prototype.forEach = function(e, t) {
    var n = this;
    return t = ir(t), new t(function(i, s) {
      var a = new Ie({
        next: function(o) {
          try {
            e(o);
          } catch (c) {
            s(c), a.unsubscribe();
          }
        },
        error: s,
        complete: i
      });
      n.subscribe(a);
    });
  }, r.prototype._subscribe = function(e) {
    var t;
    return (t = this.source) === null || t === void 0 ? void 0 : t.subscribe(e);
  }, r.prototype[Ht] = function() {
    return this;
  }, r.prototype.pipe = function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return ci(e)(this);
  }, r.prototype.toPromise = function(e) {
    var t = this;
    return e = ir(e), new e(function(n, i) {
      var s;
      t.subscribe(function(a) {
        return s = a;
      }, function(a) {
        return i(a);
      }, function() {
        return n(s);
      });
    });
  }, r.create = function(e) {
    return new r(e);
  }, r;
}();
function ir(r) {
  var e;
  return (e = r ?? kr.Promise) !== null && e !== void 0 ? e : Promise;
}
function ui(r) {
  return r && R(r.next) && R(r.error) && R(r.complete);
}
function li(r) {
  return r && r instanceof Kt || ui(r) && xr(r);
}
function di(r) {
  return R(r == null ? void 0 : r.lift);
}
function z(r) {
  return function(e) {
    if (di(e))
      return e.lift(function(t) {
        try {
          return r(t, this);
        } catch (n) {
          this.error(n);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function U(r, e, t, n, i) {
  return new fi(r, e, t, n, i);
}
var fi = function(r) {
  se(e, r);
  function e(t, n, i, s, a, o) {
    var c = r.call(this, t) || this;
    return c.onFinalize = a, c.shouldUnsubscribe = o, c._next = n ? function(u) {
      try {
        n(u);
      } catch (l) {
        t.error(l);
      }
    } : r.prototype._next, c._error = s ? function(u) {
      try {
        s(u);
      } catch (l) {
        t.error(l);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._error, c._complete = i ? function() {
      try {
        i();
      } catch (u) {
        t.error(u);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._complete, c;
  }
  return e.prototype.unsubscribe = function() {
    var t;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var n = this.closed;
      r.prototype.unsubscribe.call(this), !n && ((t = this.onFinalize) === null || t === void 0 || t.call(this));
    }
  }, e;
}(Kt), hi = Ft(function(r) {
  return function() {
    r(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), fe = function(r) {
  se(e, r);
  function e() {
    var t = r.call(this) || this;
    return t.closed = !1, t.currentObservers = null, t.observers = [], t.isStopped = !1, t.hasError = !1, t.thrownError = null, t;
  }
  return e.prototype.lift = function(t) {
    var n = new sr(this, this);
    return n.operator = t, n;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new hi();
  }, e.prototype.next = function(t) {
    var n = this;
    je(function() {
      var i, s;
      if (n._throwIfClosed(), !n.isStopped) {
        n.currentObservers || (n.currentObservers = Array.from(n.observers));
        try {
          for (var a = Ee(n.currentObservers), o = a.next(); !o.done; o = a.next()) {
            var c = o.value;
            c.next(t);
          }
        } catch (u) {
          i = { error: u };
        } finally {
          try {
            o && !o.done && (s = a.return) && s.call(a);
          } finally {
            if (i)
              throw i.error;
          }
        }
      }
    });
  }, e.prototype.error = function(t) {
    var n = this;
    je(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.hasError = n.isStopped = !0, n.thrownError = t;
        for (var i = n.observers; i.length; )
          i.shift().error(t);
      }
    });
  }, e.prototype.complete = function() {
    var t = this;
    je(function() {
      if (t._throwIfClosed(), !t.isStopped) {
        t.isStopped = !0;
        for (var n = t.observers; n.length; )
          n.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var t;
      return ((t = this.observers) === null || t === void 0 ? void 0 : t.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(t) {
    return this._throwIfClosed(), r.prototype._trySubscribe.call(this, t);
  }, e.prototype._subscribe = function(t) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t);
  }, e.prototype._innerSubscribe = function(t) {
    var n = this, i = this, s = i.hasError, a = i.isStopped, o = i.observers;
    return s || a ? br : (this.currentObservers = null, o.push(t), new Ce(function() {
      n.currentObservers = null, rt(o, t);
    }));
  }, e.prototype._checkFinalizedStatuses = function(t) {
    var n = this, i = n.hasError, s = n.thrownError, a = n.isStopped;
    i ? t.error(s) : a && t.complete();
  }, e.prototype.asObservable = function() {
    var t = new V();
    return t.source = this, t;
  }, e.create = function(t, n) {
    return new sr(t, n);
  }, e;
}(V), sr = function(r) {
  se(e, r);
  function e(t, n) {
    var i = r.call(this) || this;
    return i.destination = t, i.source = n, i;
  }
  return e.prototype.next = function(t) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || i === void 0 || i.call(n, t);
  }, e.prototype.error = function(t) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || i === void 0 || i.call(n, t);
  }, e.prototype.complete = function() {
    var t, n;
    (n = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || n === void 0 || n.call(t);
  }, e.prototype._subscribe = function(t) {
    var n, i;
    return (i = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t)) !== null && i !== void 0 ? i : br;
  }, e;
}(fe), Tr = {
  now: function() {
    return (Tr.delegate || Date).now();
  },
  delegate: void 0
}, pi = function(r) {
  se(e, r);
  function e(t, n) {
    return r.call(this) || this;
  }
  return e.prototype.schedule = function(t, n) {
    return this;
  }, e;
}(Ce), nt = {
  setInterval: function(r, e) {
    for (var t = [], n = 2; n < arguments.length; n++)
      t[n - 2] = arguments[n];
    var i = nt.delegate;
    return i != null && i.setInterval ? i.setInterval.apply(i, me([r, e], pe(t))) : setInterval.apply(void 0, me([r, e], pe(t)));
  },
  clearInterval: function(r) {
    var e = nt.delegate;
    return ((e == null ? void 0 : e.clearInterval) || clearInterval)(r);
  },
  delegate: void 0
}, mi = function(r) {
  se(e, r);
  function e(t, n) {
    var i = r.call(this, t, n) || this;
    return i.scheduler = t, i.work = n, i.pending = !1, i;
  }
  return e.prototype.schedule = function(t, n) {
    var i;
    if (n === void 0 && (n = 0), this.closed)
      return this;
    this.state = t;
    var s = this.id, a = this.scheduler;
    return s != null && (this.id = this.recycleAsyncId(a, s, n)), this.pending = !0, this.delay = n, this.id = (i = this.id) !== null && i !== void 0 ? i : this.requestAsyncId(a, this.id, n), this;
  }, e.prototype.requestAsyncId = function(t, n, i) {
    return i === void 0 && (i = 0), nt.setInterval(t.flush.bind(t, this), i);
  }, e.prototype.recycleAsyncId = function(t, n, i) {
    if (i === void 0 && (i = 0), i != null && this.delay === i && this.pending === !1)
      return n;
    n != null && nt.clearInterval(n);
  }, e.prototype.execute = function(t, n) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var i = this._execute(t, n);
    if (i)
      return i;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, e.prototype._execute = function(t, n) {
    var i = !1, s;
    try {
      this.work(t);
    } catch (a) {
      i = !0, s = a || new Error("Scheduled action threw falsy error");
    }
    if (i)
      return this.unsubscribe(), s;
  }, e.prototype.unsubscribe = function() {
    if (!this.closed) {
      var t = this, n = t.id, i = t.scheduler, s = i.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, rt(s, this), n != null && (this.id = this.recycleAsyncId(i, n, null)), this.delay = null, r.prototype.unsubscribe.call(this);
    }
  }, e;
}(pi), ar = function() {
  function r(e, t) {
    t === void 0 && (t = r.now), this.schedulerActionCtor = e, this.now = t;
  }
  return r.prototype.schedule = function(e, t, n) {
    return t === void 0 && (t = 0), new this.schedulerActionCtor(this, e).schedule(n, t);
  }, r.now = Tr.now, r;
}(), yi = function(r) {
  se(e, r);
  function e(t, n) {
    n === void 0 && (n = ar.now);
    var i = r.call(this, t, n) || this;
    return i.actions = [], i._active = !1, i;
  }
  return e.prototype.flush = function(t) {
    var n = this.actions;
    if (this._active) {
      n.push(t);
      return;
    }
    var i;
    this._active = !0;
    do
      if (i = t.execute(t.state, t.delay))
        break;
    while (t = n.shift());
    if (this._active = !1, i) {
      for (; t = n.shift(); )
        t.unsubscribe();
      throw i;
    }
  }, e;
}(ar), vi = new yi(mi), gi = vi, Er = new V(function(r) {
  return r.complete();
});
function Ir(r) {
  return r && R(r.schedule);
}
function Cr(r) {
  return r[r.length - 1];
}
function Ar(r) {
  return Ir(Cr(r)) ? r.pop() : void 0;
}
function _i(r, e) {
  return typeof Cr(r) == "number" ? r.pop() : e;
}
var Rr = function(r) {
  return r && typeof r.length == "number" && typeof r != "function";
};
function Pr(r) {
  return R(r == null ? void 0 : r.then);
}
function Nr(r) {
  return R(r[Ht]);
}
function Lr(r) {
  return Symbol.asyncIterator && R(r == null ? void 0 : r[Symbol.asyncIterator]);
}
function Or(r) {
  return new TypeError("You provided " + (r !== null && typeof r == "object" ? "an invalid object" : "'" + r + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function wi() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var Dr = wi();
function Zr(r) {
  return R(r == null ? void 0 : r[Dr]);
}
function Vr(r) {
  return ri(this, arguments, function() {
    var t, n, i, s;
    return wr(this, function(a) {
      switch (a.label) {
        case 0:
          t = r.getReader(), a.label = 1;
        case 1:
          a.trys.push([1, , 9, 10]), a.label = 2;
        case 2:
          return [4, be(t.read())];
        case 3:
          return n = a.sent(), i = n.value, s = n.done, s ? [4, be(void 0)] : [3, 5];
        case 4:
          return [2, a.sent()];
        case 5:
          return [4, be(i)];
        case 6:
          return [4, a.sent()];
        case 7:
          return a.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return t.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function $r(r) {
  return R(r == null ? void 0 : r.getReader);
}
function j(r) {
  if (r instanceof V)
    return r;
  if (r != null) {
    if (Nr(r))
      return bi(r);
    if (Rr(r))
      return xi(r);
    if (Pr(r))
      return ki(r);
    if (Lr(r))
      return Ur(r);
    if (Zr(r))
      return Si(r);
    if ($r(r))
      return Ti(r);
  }
  throw Or(r);
}
function bi(r) {
  return new V(function(e) {
    var t = r[Ht]();
    if (R(t.subscribe))
      return t.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function xi(r) {
  return new V(function(e) {
    for (var t = 0; t < r.length && !e.closed; t++)
      e.next(r[t]);
    e.complete();
  });
}
function ki(r) {
  return new V(function(e) {
    r.then(function(t) {
      e.closed || (e.next(t), e.complete());
    }, function(t) {
      return e.error(t);
    }).then(null, Sr);
  });
}
function Si(r) {
  return new V(function(e) {
    var t, n;
    try {
      for (var i = Ee(r), s = i.next(); !s.done; s = i.next()) {
        var a = s.value;
        if (e.next(a), e.closed)
          return;
      }
    } catch (o) {
      t = { error: o };
    } finally {
      try {
        s && !s.done && (n = i.return) && n.call(i);
      } finally {
        if (t)
          throw t.error;
      }
    }
    e.complete();
  });
}
function Ur(r) {
  return new V(function(e) {
    Ei(r, e).catch(function(t) {
      return e.error(t);
    });
  });
}
function Ti(r) {
  return Ur(Vr(r));
}
function Ei(r, e) {
  var t, n, i, s;
  return ti(this, void 0, void 0, function() {
    var a, o;
    return wr(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), t = ni(r), c.label = 1;
        case 1:
          return [4, t.next()];
        case 2:
          if (n = c.sent(), !!n.done)
            return [3, 4];
          if (a = n.value, e.next(a), e.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return o = c.sent(), i = { error: o }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), n && !n.done && (s = t.return) ? [4, s.call(t)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (i)
            throw i.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function ne(r, e, t, n, i) {
  n === void 0 && (n = 0), i === void 0 && (i = !1);
  var s = e.schedule(function() {
    t(), i ? r.add(this.schedule(null, n)) : this.unsubscribe();
  }, n);
  if (r.add(s), !i)
    return s;
}
function Wr(r, e) {
  return e === void 0 && (e = 0), z(function(t, n) {
    t.subscribe(U(n, function(i) {
      return ne(n, r, function() {
        return n.next(i);
      }, e);
    }, function() {
      return ne(n, r, function() {
        return n.complete();
      }, e);
    }, function(i) {
      return ne(n, r, function() {
        return n.error(i);
      }, e);
    }));
  });
}
function qr(r, e) {
  return e === void 0 && (e = 0), z(function(t, n) {
    n.add(r.schedule(function() {
      return t.subscribe(n);
    }, e));
  });
}
function Ii(r, e) {
  return j(r).pipe(qr(e), Wr(e));
}
function Ci(r, e) {
  return j(r).pipe(qr(e), Wr(e));
}
function Ai(r, e) {
  return new V(function(t) {
    var n = 0;
    return e.schedule(function() {
      n === r.length ? t.complete() : (t.next(r[n++]), t.closed || this.schedule());
    });
  });
}
function Ri(r, e) {
  return new V(function(t) {
    var n;
    return ne(t, e, function() {
      n = r[Dr](), ne(t, e, function() {
        var i, s, a;
        try {
          i = n.next(), s = i.value, a = i.done;
        } catch (o) {
          t.error(o);
          return;
        }
        a ? t.complete() : t.next(s);
      }, 0, !0);
    }), function() {
      return R(n == null ? void 0 : n.return) && n.return();
    };
  });
}
function Br(r, e) {
  if (!r)
    throw new Error("Iterable cannot be null");
  return new V(function(t) {
    ne(t, e, function() {
      var n = r[Symbol.asyncIterator]();
      ne(t, e, function() {
        n.next().then(function(i) {
          i.done ? t.complete() : t.next(i.value);
        });
      }, 0, !0);
    });
  });
}
function Pi(r, e) {
  return Br(Vr(r), e);
}
function Ni(r, e) {
  if (r != null) {
    if (Nr(r))
      return Ii(r, e);
    if (Rr(r))
      return Ai(r, e);
    if (Pr(r))
      return Ci(r, e);
    if (Lr(r))
      return Br(r, e);
    if (Zr(r))
      return Ri(r, e);
    if ($r(r))
      return Pi(r, e);
  }
  throw Or(r);
}
function zr(r, e) {
  return e ? Ni(r, e) : j(r);
}
function or() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = Ar(r);
  return zr(r, t);
}
var Yt = Ft(function(r) {
  return function() {
    r(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function jr(r, e) {
  var t = typeof e == "object";
  return new Promise(function(n, i) {
    var s = new Ie({
      next: function(a) {
        n(a), s.unsubscribe();
      },
      error: i,
      complete: function() {
        t ? n(e.defaultValue) : i(new Yt());
      }
    });
    r.subscribe(s);
  });
}
function Li(r) {
  return r instanceof Date && !isNaN(r);
}
function oe(r, e) {
  return z(function(t, n) {
    var i = 0;
    t.subscribe(U(n, function(s) {
      n.next(r.call(e, s, i++));
    }));
  });
}
function Oi(r, e, t, n, i, s, a, o) {
  var c = [], u = 0, l = 0, h = !1, v = function() {
    h && !c.length && !u && e.complete();
  }, S = function(k) {
    return u < n ? C(k) : c.push(k);
  }, C = function(k) {
    s && e.next(k), u++;
    var L = !1;
    j(t(k, l++)).subscribe(U(e, function(P) {
      i == null || i(P), s ? S(P) : e.next(P);
    }, function() {
      L = !0;
    }, void 0, function() {
      if (L)
        try {
          u--;
          for (var P = function() {
            var D = c.shift();
            a ? ne(e, a, function() {
              return C(D);
            }) : C(D);
          }; c.length && u < n; )
            P();
          v();
        } catch (D) {
          e.error(D);
        }
    }));
  };
  return r.subscribe(U(e, S, function() {
    h = !0, v();
  })), function() {
    o == null || o();
  };
}
function Fr(r, e, t) {
  return t === void 0 && (t = 1 / 0), R(e) ? Fr(function(n, i) {
    return oe(function(s, a) {
      return e(n, s, i, a);
    })(j(r(n, i)));
  }, t) : (typeof e == "number" && (t = e), z(function(n, i) {
    return Oi(n, i, r, t);
  }));
}
function Di(r) {
  return r === void 0 && (r = 1 / 0), Fr(ct, r);
}
function cr(r, e, t) {
  r === void 0 && (r = 0), t === void 0 && (t = gi);
  var n = -1;
  return e != null && (Ir(e) ? t = e : n = e), new V(function(i) {
    var s = Li(r) ? +r - t.now() : r;
    s < 0 && (s = 0);
    var a = 0;
    return t.schedule(function() {
      i.closed || (i.next(a++), 0 <= n ? this.schedule(void 0, n) : i.complete());
    }, s);
  });
}
function Pe() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = Ar(r), n = _i(r, 1 / 0), i = r;
  return i.length ? i.length === 1 ? j(i[0]) : Di(n)(zr(i, t)) : Er;
}
var Zi = Array.isArray;
function Vi(r) {
  return r.length === 1 && Zi(r[0]) ? r[0] : r;
}
function ce(r, e) {
  return z(function(t, n) {
    var i = 0;
    t.subscribe(U(n, function(s) {
      return r.call(e, s, i++) && n.next(s);
    }));
  });
}
function $i() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return r = Vi(r), r.length === 1 ? j(r[0]) : new V(Ui(r));
}
function Ui(r) {
  return function(e) {
    for (var t = [], n = function(s) {
      t.push(j(r[s]).subscribe(U(e, function(a) {
        if (t) {
          for (var o = 0; o < t.length; o++)
            o !== s && t[o].unsubscribe();
          t = null;
        }
        e.next(a);
      })));
    }, i = 0; t && !e.closed && i < r.length; i++)
      n(i);
  };
}
function Wi(r) {
  return z(function(e, t) {
    var n = !1;
    e.subscribe(U(t, function(i) {
      n = !0, t.next(i);
    }, function() {
      n || t.next(r), t.complete();
    }));
  });
}
function qi(r) {
  return r <= 0 ? function() {
    return Er;
  } : z(function(e, t) {
    var n = 0;
    e.subscribe(U(t, function(i) {
      ++n <= r && (t.next(i), r <= n && t.complete());
    }));
  });
}
function Bi(r) {
  return r === void 0 && (r = zi), z(function(e, t) {
    var n = !1;
    e.subscribe(U(t, function(i) {
      n = !0, t.next(i);
    }, function() {
      return n ? t.complete() : t.error(r());
    }));
  });
}
function zi() {
  return new Yt();
}
function ur(r, e) {
  var t = arguments.length >= 2;
  return function(n) {
    return n.pipe(r ? ce(function(i, s) {
      return r(i, s, n);
    }) : ct, qi(1), t ? Wi(e) : Bi(function() {
      return new Yt();
    }));
  };
}
function ji(r) {
  r === void 0 && (r = {});
  var e = r.connector, t = e === void 0 ? function() {
    return new fe();
  } : e, n = r.resetOnError, i = n === void 0 ? !0 : n, s = r.resetOnComplete, a = s === void 0 ? !0 : s, o = r.resetOnRefCountZero, c = o === void 0 ? !0 : o;
  return function(u) {
    var l, h, v, S = 0, C = !1, k = !1, L = function() {
      h == null || h.unsubscribe(), h = void 0;
    }, P = function() {
      L(), l = v = void 0, C = k = !1;
    }, D = function() {
      var b = l;
      P(), b == null || b.unsubscribe();
    };
    return z(function(b, W) {
      S++, !k && !C && L();
      var F = v = v ?? t();
      W.add(function() {
        S--, S === 0 && !k && !C && (h = pt(D, c));
      }), F.subscribe(W), !l && S > 0 && (l = new Ie({
        next: function(K) {
          return F.next(K);
        },
        error: function(K) {
          k = !0, L(), h = pt(P, i, K), F.error(K);
        },
        complete: function() {
          C = !0, L(), h = pt(P, a), F.complete();
        }
      }), j(b).subscribe(l));
    })(u);
  };
}
function pt(r, e) {
  for (var t = [], n = 2; n < arguments.length; n++)
    t[n - 2] = arguments[n];
  if (e === !0) {
    r();
    return;
  }
  if (e !== !1) {
    var i = new Ie({
      next: function() {
        i.unsubscribe(), r();
      }
    });
    return j(e.apply(void 0, me([], pe(t)))).subscribe(i);
  }
}
function Fi(r, e) {
  return z(function(t, n) {
    var i = null, s = 0, a = !1, o = function() {
      return a && !i && n.complete();
    };
    t.subscribe(U(n, function(c) {
      i == null || i.unsubscribe();
      var u = 0, l = s++;
      j(r(c, l)).subscribe(i = U(n, function(h) {
        return n.next(e ? e(c, h, l, u++) : h);
      }, function() {
        i = null, o();
      }));
    }, function() {
      a = !0, o();
    }));
  });
}
function Ki(r) {
  return z(function(e, t) {
    j(r).subscribe(U(t, function() {
      return t.complete();
    }, $t)), !t.closed && e.subscribe(t);
  });
}
function ye(r, e, t) {
  var n = R(r) || e || t ? { next: r, error: e, complete: t } : r;
  return n ? z(function(i, s) {
    var a;
    (a = n.subscribe) === null || a === void 0 || a.call(n);
    var o = !0;
    i.subscribe(U(s, function(c) {
      var u;
      (u = n.next) === null || u === void 0 || u.call(n, c), s.next(c);
    }, function() {
      var c;
      o = !1, (c = n.complete) === null || c === void 0 || c.call(n), s.complete();
    }, function(c) {
      var u;
      o = !1, (u = n.error) === null || u === void 0 || u.call(n, c), s.error(c);
    }, function() {
      var c, u;
      o && ((c = n.unsubscribe) === null || c === void 0 || c.call(n)), (u = n.finalize) === null || u === void 0 || u.call(n);
    }));
  }) : ct;
}
const Hi = () => ({
  outgoingMessageSubject: new fe(),
  incomingMessageSubject: new fe(),
  responseSubject: new fe(),
  messageLifeCycleEventSubject: new fe()
}), Yi = (r) => M.fromPromise(jr(r), Xn).andThen(
  (e) => e
), lr = {
  extensionDetectionTime: 100
}, Gi = (r) => {
  const e = r == null ? void 0 : r.logger, t = (r == null ? void 0 : r.subjects) ?? Hi(), n = new Ce();
  n.add(
    t.incomingMessageSubject.pipe(
      ye((o) => {
        "eventType" in o ? (e == null || e.debug("🔵💬⬇️ messageLifecycleEvent", o), t.messageLifeCycleEventSubject.next(o)) : (e == null || e.debug("🔵⬇️ walletResponse", o), t.responseSubject.next(o));
      })
    ).subscribe()
  ), n.add(
    t.outgoingMessageSubject.pipe(
      ye((o) => {
        e == null || e.debug("🔵⬆️ walletRequest", o), window.dispatchEvent(
          new CustomEvent(Ue.outgoingMessage, {
            detail: o
          })
        );
      })
    ).subscribe()
  );
  const i = (o) => {
    const c = o.detail;
    t.incomingMessageSubject.next(c);
  };
  addEventListener(Ue.incomingMessage, i);
  const s = (o, c) => {
    const u = new fe(), l = t.responseSubject.pipe(
      ce(
        (b) => b.interactionId === o.interactionId
      ),
      oe(
        (b) => b.discriminator === "success" ? H(b) : B(b)
      )
    ), h = t.messageLifeCycleEventSubject.pipe(
      ce(
        ({ interactionId: b, eventType: W }) => o.interactionId === b && ["requestCancelSuccess", "requestCancelFail"].includes(W)
      ),
      oe((b) => {
        const W = Le("canceledByUser", b.interactionId);
        return e == null || e.debug("🔵⬆️❌ walletRequestCanceled", W), b;
      })
    ), v = () => (t.outgoingMessageSubject.next({
      interactionId: o.interactionId,
      items: { discriminator: "cancelRequest" },
      metadata: o.metadata
    }), setTimeout(() => {
      u.next(
        B(Le("canceledByUser", o.interactionId))
      );
    }), M.fromSafePromise(
      jr(
        Pe(
          l.pipe(oe(() => "requestCancelFail")),
          h.pipe(oe(({ eventType: b }) => b))
        )
      )
    ));
    c.requestControl && c.requestControl({
      cancelRequest: () => v().andThen(
        (b) => b === "requestCancelSuccess" ? H("requestCancelSuccess") : B("requestCancelFail")
      ),
      getRequest: () => o
    });
    const S = Pe(
      l,
      u
    ).pipe(ur()), C = t.messageLifeCycleEventSubject.pipe(
      ce(
        ({ interactionId: b }) => o.interactionId === b
      ),
      ye((b) => {
        c.eventCallback && c.eventCallback(b.eventType);
      }),
      Ki(l),
      ji()
    ), k = C.subscribe(), L = cr(lr.extensionDetectionTime).pipe(
      oe(
        () => B(Le("missingExtension", o.interactionId))
      )
    ), P = Pe(
      L,
      C
    ).pipe(
      ur(),
      ce((b) => !("eventType" in b))
    ), D = or(o).pipe(
      ye((b) => {
        t.outgoingMessageSubject.next(b);
      }),
      ce((b) => !1)
    );
    return Yi(
      Pe(
        S,
        P,
        D
      ).pipe(
        ye(() => {
          k.unsubscribe();
        })
      )
    );
  }, a = t.messageLifeCycleEventSubject.pipe(
    ce(
      (o) => o.eventType === "extensionStatus"
    )
  );
  return {
    send: s,
    destroy: () => {
      n.unsubscribe(), removeEventListener(Ue.incomingMessage, i);
    },
    openPopup: () => {
      window.dispatchEvent(
        new CustomEvent(Ue.outgoingMessage, {
          detail: { discriminator: "openPopup" }
        })
      );
    },
    extensionStatus$: or(!0).pipe(
      ye(() => {
        t.outgoingMessageSubject.next({
          interactionId: crypto.randomUUID(),
          discriminator: "extensionStatus"
        });
      }),
      Fi(
        () => $i(
          a,
          Pe(
            a,
            cr(lr.extensionDetectionTime).pipe(
              oe(
                () => ({
                  eventType: "extensionStatus",
                  isWalletLinked: !1,
                  isExtensionAvailable: !1
                })
              )
            )
          )
        )
      )
    )
  };
}, Ut = {
  reset: [0, 0],
  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  overline: [53, 55],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
};
function Wt(r, e, t, n = !1) {
  const i = String(e), s = (o, c) => `\x1B[${c[0]}m${o}\x1B[${c[1]}m`, a = (o, c) => c != null && typeof c == "string" ? s(o, Ut[c]) : c != null && Array.isArray(c) ? c.reduce((u, l) => a(u, l), o) : c != null && c[o.trim()] != null ? a(o, c[o.trim()]) : c != null && c["*"] != null ? a(o, c["*"]) : o;
  return i.replace(/{{(.+?)}}/g, (o, c) => {
    var l;
    const u = t[c] != null ? t[c] : n ? "" : o;
    return r.stylePrettyLogs ? a(u, (l = r == null ? void 0 : r.prettyLogStyles) == null ? void 0 : l[c]) + s("", Ut.reset) : u;
  });
}
function Kr(r) {
  const e = /* @__PURE__ */ new Set();
  return JSON.stringify(r, (t, n) => {
    if (typeof n == "object" && n !== null) {
      if (e.has(n))
        return "[Circular]";
      e.add(n);
    }
    return n;
  });
}
function N(r, e) {
  const t = {
    seen: [],
    stylize: Hr
  };
  return e != null && Mr(t, e), _e(t.showHidden) && (t.showHidden = !1), _e(t.depth) && (t.depth = 2), _e(t.colors) && (t.colors = !0), _e(t.customInspect) && (t.customInspect = !0), t.colors && (t.stylize = Mi), it(t, r, t.depth);
}
N.colors = Ut;
N.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  regexp: "red"
};
function Ji(r) {
  return typeof r == "boolean";
}
function _e(r) {
  return r == null;
}
function Hr(r) {
  return r;
}
function Mi(r, e) {
  var n, i, s, a;
  const t = N.styles[e];
  return t != null && ((i = (n = N == null ? void 0 : N.colors) == null ? void 0 : n[t]) == null ? void 0 : i[0]) != null && ((a = (s = N == null ? void 0 : N.colors) == null ? void 0 : s[t]) == null ? void 0 : a[1]) != null ? "\x1B[" + N.colors[t][0] + "m" + r + "\x1B[" + N.colors[t][1] + "m" : r;
}
function qe(r) {
  return typeof r == "function";
}
function Yr(r) {
  return typeof r == "string";
}
function Xi(r) {
  return typeof r == "number";
}
function Gr(r) {
  return r === null;
}
function Jr(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function mt(r) {
  return ut(r) && Gt(r) === "[object RegExp]";
}
function ut(r) {
  return typeof r == "object" && r !== null;
}
function yt(r) {
  return ut(r) && (Gt(r) === "[object Error]" || r instanceof Error);
}
function dr(r) {
  return ut(r) && Gt(r) === "[object Date]";
}
function Gt(r) {
  return Object.prototype.toString.call(r);
}
function Qi(r) {
  const e = {};
  return r.forEach((t) => {
    e[t] = !0;
  }), e;
}
function es(r, e, t, n, i) {
  const s = [];
  for (let a = 0, o = e.length; a < o; ++a)
    Jr(e, String(a)) ? s.push(qt(r, e, t, n, String(a), !0)) : s.push("");
  return i.forEach((a) => {
    a.match(/^\d+$/) || s.push(qt(r, e, t, n, a, !0));
  }), s;
}
function vt(r) {
  return "[" + Error.prototype.toString.call(r) + "]";
}
function it(r, e, t = 0) {
  if (r.customInspect && e != null && qe(e) && (e == null ? void 0 : e.inspect) !== N && !(e != null && e.constructor && (e == null ? void 0 : e.constructor.prototype) === e)) {
    if (typeof e.inspect != "function" && e.toString != null)
      return e.toString();
    let l = e == null ? void 0 : e.inspect(t, r);
    return Yr(l) || (l = it(r, l, t)), l;
  }
  const n = te(r, e);
  if (n)
    return n;
  let i = Object.keys(e);
  const s = Qi(i);
  try {
    r.showHidden && Object.getOwnPropertyNames && (i = Object.getOwnPropertyNames(e));
  } catch {
  }
  if (yt(e) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0))
    return vt(e);
  if (i.length === 0)
    if (qe(r.stylize)) {
      if (qe(e)) {
        const l = e.name ? ": " + e.name : "";
        return r.stylize("[Function" + l + "]", "special");
      }
      if (mt(e))
        return r.stylize(RegExp.prototype.toString.call(e), "regexp");
      if (dr(e))
        return r.stylize(Date.prototype.toString.call(e), "date");
      if (yt(e))
        return vt(e);
    } else
      return e;
  let a = "", o = !1, c = [`{
`, `
}`];
  if (Array.isArray(e) && (o = !0, c = [`[
`, `
]`]), qe(e) && (a = " [Function" + (e.name ? ": " + e.name : "") + "]"), mt(e) && (a = " " + RegExp.prototype.toString.call(e)), dr(e) && (a = " " + Date.prototype.toUTCString.call(e)), yt(e) && (a = " " + vt(e)), i.length === 0 && (!o || e.length == 0))
    return c[0] + a + c[1];
  if (t < 0)
    return mt(e) ? r.stylize(RegExp.prototype.toString.call(e), "regexp") : r.stylize("[Object]", "special");
  r.seen.push(e);
  let u;
  return o ? u = es(r, e, t, s, i) : u = i.map((l) => qt(r, e, t, s, l, o)), r.seen.pop(), ts(u, a, c);
}
function qt(r, e, t, n, i, s) {
  let a, o, c;
  c = { value: void 0 };
  try {
    c.value = e[i];
  } catch {
  }
  try {
    Object.getOwnPropertyDescriptor && (c = Object.getOwnPropertyDescriptor(e, i) || c);
  } catch {
  }
  if (c.get ? c.set ? o = r.stylize("[Getter/Setter]", "special") : o = r.stylize("[Getter]", "special") : c.set && (o = r.stylize("[Setter]", "special")), Jr(n, i) || (a = "[" + i + "]"), o || (r.seen.indexOf(c.value) < 0 ? (Gr(t) ? o = it(r, c.value, void 0) : o = it(r, c.value, t - 1), o.indexOf(`
`) > -1 && (s ? o = o.split(`
`).map((u) => "  " + u).join(`
`).substr(2) : o = `
` + o.split(`
`).map((u) => "   " + u).join(`
`))) : o = r.stylize("[Circular]", "special")), _e(a)) {
    if (s && i.match(/^\d+$/))
      return o;
    a = JSON.stringify("" + i), a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.substr(1, a.length - 2), a = r.stylize(a, "name")) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, "\\'").replace(/(^"|"$)/g, "'"), a = r.stylize(a, "string"));
  }
  return a + ": " + o;
}
function te(r, e) {
  if (_e(e))
    return r.stylize("undefined", "undefined");
  if (Yr(e)) {
    const t = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, "\\'") + "'";
    return r.stylize(t, "string");
  }
  if (Xi(e))
    return r.stylize("" + e, "number");
  if (Ji(e))
    return r.stylize("" + e, "boolean");
  if (Gr(e))
    return r.stylize("null", "null");
}
function ts(r, e, t) {
  return t[0] + (e === "" ? "" : e + `
`) + "  " + r.join(`,
  `) + " " + t[1];
}
function Mr(r, e) {
  if (!e || !ut(e))
    return r;
  const t = Object.keys(e);
  let n = t.length;
  for (; n--; )
    r[t[n]] = e[t[n]];
  return r;
}
function rs(r, ...e) {
  const t = {
    seen: [],
    stylize: Hr
  };
  r != null && Mr(t, r);
  const n = e[0];
  let i = 0, s = "", a = "";
  if (typeof n == "string") {
    if (e.length === 1)
      return n;
    let o, c = 0;
    for (let u = 0; u < n.length - 1; u++)
      if (n.charCodeAt(u) === 37) {
        const l = n.charCodeAt(++u);
        if (i + 1 !== e.length) {
          switch (l) {
            case 115: {
              const h = e[++i];
              typeof h == "number" || typeof h == "bigint" ? o = te(t, h) : typeof h != "object" || h === null ? o = String(h) : o = N(h, {
                ...r,
                compact: 3,
                colors: !1,
                depth: 0
              });
              break;
            }
            case 106:
              o = Kr(e[++i]);
              break;
            case 100: {
              const h = e[++i];
              typeof h == "bigint" ? o = te(t, h) : typeof h == "symbol" ? o = "NaN" : o = te(t, h);
              break;
            }
            case 79:
              o = N(e[++i], r);
              break;
            case 111:
              o = N(e[++i], {
                ...r,
                showHidden: !0,
                showProxy: !0,
                depth: 4
              });
              break;
            case 105: {
              const h = e[++i];
              typeof h == "bigint" ? o = te(t, h) : typeof h == "symbol" ? o = "NaN" : o = te(t, parseInt(o));
              break;
            }
            case 102: {
              const h = e[++i];
              typeof h == "symbol" ? o = "NaN" : o = te(t, parseInt(h));
              break;
            }
            case 99:
              i += 1, o = "";
              break;
            case 37:
              s += n.slice(c, u), c = u + 1;
              continue;
            default:
              continue;
          }
          c !== u - 1 && (s += n.slice(c, u - 1)), s += o, c = u + 1;
        } else
          l === 37 && (s += n.slice(c, u), c = u + 1);
      }
    c !== 0 && (i++, a = " ", c < n.length && (s += n.slice(c)));
  }
  for (; i < e.length; ) {
    const o = e[i];
    s += a, s += typeof o != "string" ? N(o, r) : o, a = " ", i++;
  }
  return s;
}
var fr;
const ns = {
  runtime: [typeof window, typeof document].includes("undefined") ? "Generic" : "Browser",
  browser: (fr = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : fr.userAgent
}, is = /(?:(?:file|https?|global code|[^@]+)@)?(?:file:)?((?:\/[^:/]+){2,})(?::(\d+))?(?::(\d+))?/;
function ss(r, e, t, n, i, s) {
  return Object.assign({}, ns, {
    name: i,
    parentNames: s,
    date: /* @__PURE__ */ new Date(),
    logLevelId: r,
    logLevelName: e,
    path: n ? void 0 : as(t)
  });
}
function as(r, e = Error()) {
  var t, n, i;
  return Qr((i = (n = (t = e == null ? void 0 : e.stack) == null ? void 0 : t.split(`
`)) == null ? void 0 : n.filter((s) => !s.includes("Error: "))) == null ? void 0 : i[r]);
}
function Xr(r) {
  var e, t, n;
  return (n = (t = (e = r == null ? void 0 : r.stack) == null ? void 0 : e.split(`
`)) == null ? void 0 : t.filter((i) => !i.includes("Error: "))) == null ? void 0 : n.reduce((i, s) => (i.push(Qr(s)), i), []);
}
function Qr(r) {
  const e = globalThis.location.origin, t = {
    fullFilePath: void 0,
    fileName: void 0,
    fileNameWithLine: void 0,
    fileColumn: void 0,
    fileLine: void 0,
    filePath: void 0,
    filePathWithLine: void 0,
    method: void 0
  };
  if (r != null) {
    const n = r.match(is);
    if (n) {
      t.filePath = n[1].replace(/\?.*$/, ""), t.fullFilePath = `${e}${t.filePath}`;
      const i = t.filePath.split("/");
      t.fileName = i[i.length - 1], t.fileLine = n[2], t.fileColumn = n[3], t.filePathWithLine = `${t.filePath}:${t.fileLine}`, t.fileNameWithLine = `${t.fileName}:${t.fileLine}`;
    }
  }
  return t;
}
function Bt(r) {
  return r instanceof Error;
}
function os(r, e) {
  return r.reduce((t, n) => (Bt(n) ? t.errors.push(cs(n, e)) : t.args.push(n), t), { args: [], errors: [] });
}
function cs(r, e) {
  const t = Xr(r).map((i) => Wt(e, e.prettyErrorStackTemplate, { ...i }, !0)), n = {
    errorName: ` ${r.name} `,
    errorMessage: r.message,
    errorStack: t.join(`
`)
  };
  return Wt(e, e.prettyErrorTemplate, n);
}
function us(r, e, t, n) {
  const i = (t.length > 0 && e.length > 0 ? `
` : "") + t.join(`
`);
  n.prettyInspectOptions.colors = n.stylePrettyLogs, console.log(r + rs(n.prettyInspectOptions, ...e) + i);
}
function ls(r) {
  console.log(Kr(r));
}
function q(r, e = 2, t = 0) {
  return r != null && isNaN(r) ? "" : (r = r != null ? r + t : r, e === 2 ? r == null ? "--" : r < 10 ? "0" + r : r.toString() : r == null ? "---" : r < 10 ? "00" + r : r < 100 ? "0" + r : r.toString());
}
class ds {
  constructor(e, t, n = 4) {
    var c, u, l, h, v, S, C;
    this.logObj = t, this.stackDepthLevel = n;
    const i = ![typeof window, typeof document].includes("undefined"), s = Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
    this.runtime = i ? "browser" : s ? "nodejs" : "unknown";
    const a = i ? (((window == null ? void 0 : window.chrome) || window.Intl && (Intl == null ? void 0 : Intl.v8BreakIterator)) && "CSS" in window) != null : !1, o = i ? /^((?!chrome|android).)*safari/i.test(navigator == null ? void 0 : navigator.userAgent) : !1;
    this.stackDepthLevel = o ? 4 : this.stackDepthLevel, this.settings = {
      type: (e == null ? void 0 : e.type) ?? "pretty",
      name: e == null ? void 0 : e.name,
      parentNames: e == null ? void 0 : e.parentNames,
      minLevel: (e == null ? void 0 : e.minLevel) ?? 0,
      argumentsArrayName: e == null ? void 0 : e.argumentsArrayName,
      hideLogPositionForProduction: (e == null ? void 0 : e.hideLogPositionForProduction) ?? !1,
      prettyLogTemplate: (e == null ? void 0 : e.prettyLogTemplate) ?? "{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}	{{logLevelName}}	{{filePathWithLine}}{{nameWithDelimiterPrefix}}	",
      prettyErrorTemplate: (e == null ? void 0 : e.prettyErrorTemplate) ?? `
{{errorName}} {{errorMessage}}
error stack:
{{errorStack}}`,
      prettyErrorStackTemplate: (e == null ? void 0 : e.prettyErrorStackTemplate) ?? `  • {{fileName}}	{{method}}
	{{filePathWithLine}}`,
      prettyErrorParentNamesSeparator: (e == null ? void 0 : e.prettyErrorParentNamesSeparator) ?? ":",
      prettyErrorLoggerNameDelimiter: (e == null ? void 0 : e.prettyErrorLoggerNameDelimiter) ?? "	",
      stylePrettyLogs: (e == null ? void 0 : e.stylePrettyLogs) ?? !0,
      prettyLogTimeZone: (e == null ? void 0 : e.prettyLogTimeZone) ?? "UTC",
      prettyLogStyles: (e == null ? void 0 : e.prettyLogStyles) ?? {
        logLevelName: {
          "*": ["bold", "black", "bgWhiteBright", "dim"],
          SILLY: ["bold", "white"],
          TRACE: ["bold", "whiteBright"],
          DEBUG: ["bold", "green"],
          INFO: ["bold", "blue"],
          WARN: ["bold", "yellow"],
          ERROR: ["bold", "red"],
          FATAL: ["bold", "redBright"]
        },
        dateIsoStr: "white",
        filePathWithLine: "white",
        name: ["white", "bold"],
        nameWithDelimiterPrefix: ["white", "bold"],
        nameWithDelimiterSuffix: ["white", "bold"],
        errorName: ["bold", "bgRedBright", "whiteBright"],
        fileName: ["yellow"],
        fileNameWithLine: "white"
      },
      prettyInspectOptions: (e == null ? void 0 : e.prettyInspectOptions) ?? {
        colors: !0,
        compact: !1,
        depth: 1 / 0
      },
      metaProperty: (e == null ? void 0 : e.metaProperty) ?? "_meta",
      maskPlaceholder: (e == null ? void 0 : e.maskPlaceholder) ?? "[***]",
      maskValuesOfKeys: (e == null ? void 0 : e.maskValuesOfKeys) ?? ["password"],
      maskValuesOfKeysCaseInsensitive: (e == null ? void 0 : e.maskValuesOfKeysCaseInsensitive) ?? !1,
      maskValuesRegEx: e == null ? void 0 : e.maskValuesRegEx,
      prefix: [...(e == null ? void 0 : e.prefix) ?? []],
      attachedTransports: [...(e == null ? void 0 : e.attachedTransports) ?? []],
      overwrite: {
        mask: (c = e == null ? void 0 : e.overwrite) == null ? void 0 : c.mask,
        toLogObj: (u = e == null ? void 0 : e.overwrite) == null ? void 0 : u.toLogObj,
        addMeta: (l = e == null ? void 0 : e.overwrite) == null ? void 0 : l.addMeta,
        formatMeta: (h = e == null ? void 0 : e.overwrite) == null ? void 0 : h.formatMeta,
        formatLogObj: (v = e == null ? void 0 : e.overwrite) == null ? void 0 : v.formatLogObj,
        transportFormatted: (S = e == null ? void 0 : e.overwrite) == null ? void 0 : S.transportFormatted,
        transportJSON: (C = e == null ? void 0 : e.overwrite) == null ? void 0 : C.transportJSON
      }
    }, this.settings.stylePrettyLogs = this.settings.stylePrettyLogs && i && !a ? !1 : this.settings.stylePrettyLogs;
  }
  log(e, t, ...n) {
    var h, v, S, C, k, L, P, D, b, W, F, K, Ae, Re;
    if (e < this.settings.minLevel)
      return;
    const i = [...this.settings.prefix, ...n], s = ((h = this.settings.overwrite) == null ? void 0 : h.mask) != null ? (v = this.settings.overwrite) == null ? void 0 : v.mask(i) : this.settings.maskValuesOfKeys != null && this.settings.maskValuesOfKeys.length > 0 ? this._mask(i) : i, a = this.logObj != null ? this._recursiveCloneAndExecuteFunctions(this.logObj) : void 0, o = ((S = this.settings.overwrite) == null ? void 0 : S.toLogObj) != null ? (C = this.settings.overwrite) == null ? void 0 : C.toLogObj(s, a) : this._toLogObj(s, a), c = ((k = this.settings.overwrite) == null ? void 0 : k.addMeta) != null ? (L = this.settings.overwrite) == null ? void 0 : L.addMeta(o, e, t) : this._addMetaToLogObj(o, e, t);
    let u, l;
    return ((P = this.settings.overwrite) == null ? void 0 : P.formatMeta) != null && (u = (D = this.settings.overwrite) == null ? void 0 : D.formatMeta(c == null ? void 0 : c[this.settings.metaProperty])), ((b = this.settings.overwrite) == null ? void 0 : b.formatLogObj) != null && (l = (W = this.settings.overwrite) == null ? void 0 : W.formatLogObj(s, this.settings)), this.settings.type === "pretty" && (u = u ?? this._prettyFormatLogObjMeta(c == null ? void 0 : c[this.settings.metaProperty]), l = l ?? os(s, this.settings)), u != null && l != null ? ((F = this.settings.overwrite) == null ? void 0 : F.transportFormatted) != null ? (K = this.settings.overwrite) == null || K.transportFormatted(u, l.args, l.errors, this.settings) : us(u, l.args, l.errors, this.settings) : ((Ae = this.settings.overwrite) == null ? void 0 : Ae.transportJSON) != null ? (Re = this.settings.overwrite) == null || Re.transportJSON(c) : this.settings.type !== "hidden" && ls(c), this.settings.attachedTransports != null && this.settings.attachedTransports.length > 0 && this.settings.attachedTransports.forEach(($e) => {
      $e(c);
    }), c;
  }
  attachTransport(e) {
    this.settings.attachedTransports.push(e);
  }
  getSubLogger(e, t) {
    var s, a, o;
    const n = {
      ...this.settings,
      ...e,
      parentNames: ((s = this.settings) == null ? void 0 : s.parentNames) != null && ((a = this.settings) == null ? void 0 : a.name) != null ? [...this.settings.parentNames, this.settings.name] : ((o = this.settings) == null ? void 0 : o.name) != null ? [this.settings.name] : void 0,
      prefix: [...this.settings.prefix, ...(e == null ? void 0 : e.prefix) ?? []]
    };
    return new this.constructor(n, t ?? this.logObj, this.stackDepthLevel);
  }
  _mask(e) {
    const t = this.settings.maskValuesOfKeysCaseInsensitive !== !0 ? this.settings.maskValuesOfKeys : this.settings.maskValuesOfKeys.map((n) => n.toLowerCase());
    return e == null ? void 0 : e.map((n) => this._recursiveCloneAndMaskValuesOfKeys(n, t));
  }
  _recursiveCloneAndMaskValuesOfKeys(e, t, n = []) {
    return n.includes(e) ? { ...e } : (typeof e == "object" && e != null && n.push(e), void 0 ? e : e instanceof Map ? new Map(e) : e instanceof Set ? new Set(e) : Array.isArray(e) ? e.map((i) => this._recursiveCloneAndMaskValuesOfKeys(i, t, n)) : e instanceof Date ? new Date(e.getTime()) : Bt(e) ? Object.getOwnPropertyNames(e).reduce((i, s) => {
      var a;
      return i[s] = t.includes(((a = this.settings) == null ? void 0 : a.maskValuesOfKeysCaseInsensitive) !== !0 ? s : s.toLowerCase()) ? this.settings.maskPlaceholder : this._recursiveCloneAndMaskValuesOfKeys(e[s], t, n), i;
    }, this._cloneError(e)) : e != null && typeof e == "object" ? Object.getOwnPropertyNames(e).reduce((i, s) => {
      var a;
      return i[s] = t.includes(((a = this.settings) == null ? void 0 : a.maskValuesOfKeysCaseInsensitive) !== !0 ? s : s.toLowerCase()) ? this.settings.maskPlaceholder : this._recursiveCloneAndMaskValuesOfKeys(e[s], t, n), i;
    }, Object.create(Object.getPrototypeOf(e))) : ((i) => {
      var s, a;
      return (a = (s = this.settings) == null ? void 0 : s.maskValuesRegEx) == null || a.forEach((o) => {
        var c;
        i = (c = i == null ? void 0 : i.toString()) == null ? void 0 : c.replace(o, this.settings.maskPlaceholder);
      }), i;
    })(e));
  }
  _recursiveCloneAndExecuteFunctions(e, t = []) {
    return t.includes(e) ? { ...e } : (typeof e == "object" && t.push(e), Array.isArray(e) ? e.map((n) => this._recursiveCloneAndExecuteFunctions(n, t)) : e instanceof Date ? new Date(e.getTime()) : e && typeof e == "object" ? Object.getOwnPropertyNames(e).reduce((n, i) => (Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(e, i)), n[i] = typeof e[i] == "function" ? e[i]() : this._recursiveCloneAndExecuteFunctions(e[i], t), n), Object.create(Object.getPrototypeOf(e))) : e);
  }
  _toLogObj(e, t = {}) {
    return e = e == null ? void 0 : e.map((n) => Bt(n) ? this._toErrorObject(n) : n), this.settings.argumentsArrayName == null ? e.length === 1 && !Array.isArray(e[0]) && (e[0], void 0) !== !0 && !(e[0] instanceof Date) ? t = typeof e[0] == "object" && e[0] != null ? { ...e[0], ...t } : { 0: e[0], ...t } : t = { ...t, ...e } : t = {
      ...t,
      [this.settings.argumentsArrayName]: e
    }, t;
  }
  _cloneError(e) {
    const t = e.constructor, n = new t(e.message);
    Object.assign(n, e);
    const i = Object.getOwnPropertyNames(n);
    for (const s of i) {
      const a = Object.getOwnPropertyDescriptor(n, s);
      a && (a.writable = !0, Object.defineProperty(n, s, a));
    }
    return n;
  }
  _toErrorObject(e) {
    return {
      nativeError: e,
      name: e.name ?? "Error",
      message: e.message,
      stack: Xr(e)
    };
  }
  _addMetaToLogObj(e, t, n) {
    return {
      ...e,
      [this.settings.metaProperty]: ss(t, n, this.stackDepthLevel, this.settings.hideLogPositionForProduction, this.settings.name, this.settings.parentNames)
    };
  }
  _prettyFormatLogObjMeta(e) {
    var a, o, c, u, l, h, v, S, C, k, L, P, D, b, W, F, K, Ae, Re, $e;
    if (e == null)
      return "";
    let t = this.settings.prettyLogTemplate;
    const n = {};
    t.includes("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}") ? t = t.replace("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}", "{{dateIsoStr}}") : this.settings.prettyLogTimeZone === "UTC" ? (n.yyyy = ((a = e == null ? void 0 : e.date) == null ? void 0 : a.getUTCFullYear()) ?? "----", n.mm = q((o = e == null ? void 0 : e.date) == null ? void 0 : o.getUTCMonth(), 2, 1), n.dd = q((c = e == null ? void 0 : e.date) == null ? void 0 : c.getUTCDate(), 2), n.hh = q((u = e == null ? void 0 : e.date) == null ? void 0 : u.getUTCHours(), 2), n.MM = q((l = e == null ? void 0 : e.date) == null ? void 0 : l.getUTCMinutes(), 2), n.ss = q((h = e == null ? void 0 : e.date) == null ? void 0 : h.getUTCSeconds(), 2), n.ms = q((v = e == null ? void 0 : e.date) == null ? void 0 : v.getUTCMilliseconds(), 3)) : (n.yyyy = ((S = e == null ? void 0 : e.date) == null ? void 0 : S.getFullYear()) ?? "----", n.mm = q((C = e == null ? void 0 : e.date) == null ? void 0 : C.getMonth(), 2, 1), n.dd = q((k = e == null ? void 0 : e.date) == null ? void 0 : k.getDate(), 2), n.hh = q((L = e == null ? void 0 : e.date) == null ? void 0 : L.getHours(), 2), n.MM = q((P = e == null ? void 0 : e.date) == null ? void 0 : P.getMinutes(), 2), n.ss = q((D = e == null ? void 0 : e.date) == null ? void 0 : D.getSeconds(), 2), n.ms = q((b = e == null ? void 0 : e.date) == null ? void 0 : b.getMilliseconds(), 3));
    const i = this.settings.prettyLogTimeZone === "UTC" ? e == null ? void 0 : e.date : new Date(((W = e == null ? void 0 : e.date) == null ? void 0 : W.getTime()) - ((F = e == null ? void 0 : e.date) == null ? void 0 : F.getTimezoneOffset()) * 6e4);
    n.rawIsoStr = i == null ? void 0 : i.toISOString(), n.dateIsoStr = i == null ? void 0 : i.toISOString().replace("T", " ").replace("Z", ""), n.logLevelName = e == null ? void 0 : e.logLevelName, n.fileNameWithLine = ((K = e == null ? void 0 : e.path) == null ? void 0 : K.fileNameWithLine) ?? "", n.filePathWithLine = ((Ae = e == null ? void 0 : e.path) == null ? void 0 : Ae.filePathWithLine) ?? "", n.fullFilePath = ((Re = e == null ? void 0 : e.path) == null ? void 0 : Re.fullFilePath) ?? "";
    let s = ($e = this.settings.parentNames) == null ? void 0 : $e.join(this.settings.prettyErrorParentNamesSeparator);
    return s = s != null && (e == null ? void 0 : e.name) != null ? s + this.settings.prettyErrorParentNamesSeparator : void 0, n.name = (e == null ? void 0 : e.name) != null || s != null ? (s ?? "") + (e == null ? void 0 : e.name) : "", n.nameWithDelimiterPrefix = n.name.length > 0 ? this.settings.prettyErrorLoggerNameDelimiter + n.name : "", n.nameWithDelimiterSuffix = n.name.length > 0 ? n.name + this.settings.prettyErrorLoggerNameDelimiter : "", Wt(this.settings, t, n);
  }
}
class fs extends ds {
  constructor(e, t) {
    super(e, t, 5);
  }
  log(e, t, ...n) {
    return super.log(e, t, ...n);
  }
  silly(...e) {
    return super.log(0, "SILLY", ...e);
  }
  trace(...e) {
    return super.log(1, "TRACE", ...e);
  }
  debug(...e) {
    return super.log(2, "DEBUG", ...e);
  }
  info(...e) {
    return super.log(3, "INFO", ...e);
  }
  warn(...e) {
    return super.log(4, "WARN", ...e);
  }
  error(...e) {
    return super.log(5, "ERROR", ...e);
  }
  fatal(...e) {
    return super.log(6, "FATAL", ...e);
  }
  getSubLogger(e, t) {
    return super.getSubLogger(e, t);
  }
}
const vs = (r) => new fs({
  minLevel: r,
  prettyLogTemplate: "{{hh}}:{{MM}}:{{ss}}:{{ms}}	{{logLevelName}}	"
}), gs = (r) => {
  var i, s;
  const e = {
    version: 2,
    dAppDefinitionAddress: r.dAppDefinitionAddress,
    networkId: r.networkId
  };
  vr.parse(e), (i = r.logger) == null || i.debug("🔵 walletSdkInstantiated", e);
  const t = r.logger, n = ((s = r.providers) == null ? void 0 : s.connectorExtensionClient) ?? Gi({ logger: t });
  return {
    ...ei(
      {
        version: 2,
        logger: r.logger,
        dAppDefinitionAddress: r.dAppDefinitionAddress,
        networkId: r.networkId
      },
      n
    ),
    destroy: () => {
      t == null || t.debug("🔵🧹 walletSdkInstantiatedDestroyed"), n.destroy();
    }
  };
};
export {
  _n as Account,
  wn as AccountProof,
  Nt as AccountsRequestItem,
  Lt as AccountsRequestResponseItem,
  Cn as AuthLoginRequestItem,
  Bn as AuthLoginRequestResponseItem,
  In as AuthLoginWithChallengeRequestItem,
  qn as AuthLoginWithChallengeRequestResponseItem,
  En as AuthLoginWithoutChallengeRequestItem,
  Wn as AuthLoginWithoutChallengeRequestResponseItem,
  An as AuthRequestItem,
  jn as AuthRequestResponseItem,
  Tn as AuthUsePersonaRequestItem,
  Zn as CancelRequest,
  ps as ExtensionInteraction,
  hs as LoginRequestResponseItem,
  Jn as MessageLifeCycleEvent,
  ms as MessageLifeCycleExtensionStatusEvent,
  vr as Metadata,
  Pt as NumberOfValues,
  ot as Persona,
  xn as PersonaDataName,
  bn as PersonaDataNameVariant,
  Ot as PersonaDataRequestItem,
  Dt as PersonaDataRequestResponseItem,
  jt as Proof,
  kn as ResetRequestItem,
  Nn as SendTransactionItem,
  On as SendTransactionResponseItem,
  Rn as WalletAuthorizedRequestItems,
  Fn as WalletAuthorizedRequestResponseItems,
  $n as WalletInteraction,
  Gn as WalletInteractionFailureResponse,
  Vn as WalletInteractionItems,
  gr as WalletInteractionResponse,
  Yn as WalletInteractionSuccessResponse,
  Pn as WalletRequestItems,
  Kn as WalletRequestResponseItems,
  gs as WalletSdk,
  Ln as WalletTransactionItems,
  Sn as WalletUnauthorizedRequestItems,
  vs as createLogger,
  Le as createSdkError,
  ze as errorType,
  Ue as eventType,
  ge as messageLifeCycleEventType,
  tr as personaDataFullNameVariant,
  Xn as sdkError,
  ys as walletInteractionFactoryV2
};
