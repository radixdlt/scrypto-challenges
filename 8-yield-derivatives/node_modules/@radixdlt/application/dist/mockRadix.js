"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockedAPI = exports.mockRadixCoreAPI = exports.makeThrowingRadixCoreAPI = exports.deterministicRandomStakesForAddr = exports.deterministicRandomUnstakesForAddr = exports.deterministicRandomLookupTX = exports.deterministicRandomTXHistory = exports.deterministicRandomBalances = exports.deterministicRandomTxHistoryWithInput = exports.deterministicRandomStakesForAddress = exports.deterministicRandomUnstakesForAddress = exports.deterministicRandomBalancesForAddress = exports.erin = exports.dan = exports.carol = exports.bob = exports.alice = exports.castOfCharacters = exports.tokenByRRIMap = exports.balancesFor = exports.balanceOfFor = exports.__fallBackAlexToken = exports.radixWrappedEtherToken = exports.radixWrappedBitcoinToken = exports.goldToken = exports.barToken = exports.fooToken = exports.xrd = void 0;
const primitives_1 = require("@radixdlt/primitives");
const account_1 = require("@radixdlt/account");
const rxjs_1 = require("rxjs");
const dto_1 = require("./dto");
const operators_1 = require("rxjs/operators");
const crypto_1 = require("@radixdlt/crypto");
const actions_1 = require("./actions");
const primitives_2 = require("@radixdlt/primitives");
exports.xrd = {
    name: 'Rad',
    rri: account_1.ResourceIdentifier.fromUnsafe('xrd_tr1qyf0x76s')._unsafeUnwrap(),
    symbol: 'XRD',
    description: 'The native coin of Radix network',
    granularity: primitives_2.Amount.fromUnsafe(1)._unsafeUnwrap(),
    isSupplyMutable: false,
    currentSupply: primitives_1.uint256Max,
    tokenInfoURL: new URL('https://www.radixdlt.com'),
    iconURL: new URL('https://www.image.radixdlt.com/'),
};
exports.fooToken = {
    name: 'Foo token',
    rri: account_1.ResourceIdentifier.fromUnsafe('xrd_tr1qyf0x76s')._unsafeUnwrap(),
    symbol: 'FOO',
    description: 'FOOest token.',
    granularity: primitives_2.Amount.fromUnsafe(1)._unsafeUnwrap(),
    isSupplyMutable: false,
    currentSupply: primitives_1.uint256Max,
    tokenInfoURL: new URL('https://www.footoken.com'),
    iconURL: new URL('https://www.image.footoken.com/'),
};
exports.barToken = {
    name: 'Bar token',
    rri: account_1.ResourceIdentifier.fromUnsafe('xrd_tr1qyf0x76s')._unsafeUnwrap(),
    symbol: 'BAR',
    description: 'Bar token. Granularity E-3.',
    granularity: primitives_2.Amount.fromUnsafe(1000)._unsafeUnwrap(),
    isSupplyMutable: true,
    currentSupply: primitives_1.uint256Max,
    tokenInfoURL: new URL('https://www.bartoken.com'),
    iconURL: new URL('https://www.image.bartoken.com/'),
};
exports.goldToken = {
    name: 'Gold token',
    rri: account_1.ResourceIdentifier.fromUnsafe('xrd_tr1qyf0x76s')._unsafeUnwrap(),
    symbol: 'GOLD',
    description: 'Gold token. Granularity E-12.',
    granularity: primitives_2.Amount.fromUnsafe(1000000)._unsafeUnwrap(),
    isSupplyMutable: false,
    currentSupply: primitives_1.uint256Max,
    tokenInfoURL: new URL('https://www.goldtoken.com'),
    iconURL: new URL('https://www.image.goldtoken.com/'),
};
exports.radixWrappedBitcoinToken = {
    name: 'Bitcoin (wrapped on Radix)',
    rri: account_1.ResourceIdentifier.fromUnsafe('xrd_tr1qyf0x76s')._unsafeUnwrap(),
    symbol: 'BTCRW',
    description: 'Radix wrapped Bitcoin. Granularity E-18.',
    granularity: primitives_2.Amount.fromUnsafe(1)._unsafeUnwrap(),
    isSupplyMutable: true,
    currentSupply: primitives_1.uint256Max,
    tokenInfoURL: new URL('https://www.bitcoin.radix.com'),
    iconURL: new URL('https://www.image.bitcoin.radix.com/'),
};
exports.radixWrappedEtherToken = {
    name: 'Ether (wrapped on Radix)',
    rri: account_1.ResourceIdentifier.fromUnsafe('xrd_tr1qyf0x76s')._unsafeUnwrap(),
    symbol: 'ETHRW',
    description: 'Radix wrapped Ether. Granularity E-9.',
    granularity: primitives_2.Amount.fromUnsafe(1000000000)._unsafeUnwrap(),
    isSupplyMutable: true,
    currentSupply: primitives_1.uint256Max,
    tokenInfoURL: new URL('https://www.ether.radix.com'),
    iconURL: new URL('https://www.image.ether.radix.com/'),
};
exports.__fallBackAlexToken = {
    name: 'Alex token',
    rri: account_1.ResourceIdentifier.fromUnsafe('xrd_tr1qyf0x76s')._unsafeUnwrap(),
    symbol: 'ALEX',
    description: 'Fallback token for when token for requested symbol was not found.',
    granularity: primitives_2.Amount.fromUnsafe(1)._unsafeUnwrap(),
    isSupplyMutable: true,
    currentSupply: primitives_1.uint256Max,
    tokenInfoURL: new URL('https://www.alex.token.com'),
    iconURL: new URL('https://www.image.alex.token.com/'),
};
const balanceOfFor = (input) => {
    const amt = primitives_2.Amount.fromUnsafe(input.amount)._unsafeUnwrap();
    return {
        tokenIdentifier: input.token.rri,
        amount: amt.lt(input.token.currentSupply)
            ? amt
            : input.token.currentSupply,
    };
};
exports.balanceOfFor = balanceOfFor;
const balancesFor = (address, amount) => ({
    owner: address,
    tokenBalances: [
        (0, exports.balanceOfFor)({
            token: exports.xrd,
            amount,
        }),
    ],
});
exports.balancesFor = balancesFor;
const differentTokens = [
    exports.xrd,
    exports.fooToken,
    exports.barToken,
    exports.radixWrappedBitcoinToken,
    exports.radixWrappedEtherToken,
    exports.goldToken,
];
// PLEASE KEEP - used as Cast of characters: https://en.wikipedia.org/wiki/Alice_and_Bob#Cast_of_characters
exports.tokenByRRIMap = differentTokens.reduce((a, b) => a.set(b.rri, b), new Map());
const detPRNGWithBuffer = (buffer) => {
    const bufCopy = Buffer.from(buffer);
    let bytes = Buffer.from(buffer);
    return () => {
        if (bytes.length === 0) {
            bytes = (0, crypto_1.sha256)(bufCopy);
        }
        const lengthToSlice = 2;
        const buf = bytes.slice(0, lengthToSlice);
        bytes = bytes.slice(lengthToSlice, bytes.length);
        return Number.parseInt(buf.toString('hex'), 16);
    };
};
const addressesString = [
    'tdx1qspksqs77z9e24e2dr9t5de6a9kymzhszp9k7jmr2ldkzl4hvn45xsqk409dt',
    'tdx1qspksqs77z9e24e2dr9t5de6a9kymzhszp9k7jmr2ldkzl4hvn45xsqk409dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
    'rdx1qsps28kdn4epn0c9ej2rcmwfz5a4jdhq2ez03x7h6jefvr4fnwnrtqqjaj7dt',
];
const characterNames = [
    'alice',
    'bob',
    'carol',
    'dan',
    'erin',
    'frank',
    'grace',
    'heidi',
    'ivan',
    'judy',
    'klara',
    'leonard',
    'mallory',
    'niaj',
    'olivia',
    'peggy',
    'quentin',
    'rupert',
    'stella',
    'ted',
    'ursula',
    'victor',
    'webdy',
    'xerxez',
    'yara',
    'zelda',
];
/*
* [Property in keyof ReturnType<typeof getAPI>]: ReturnType<
        typeof getAPI
    >[Property]
* */
exports.castOfCharacters = addressesString
    .map(s => account_1.AccountAddress.fromUnsafe(s)._unsafeUnwrap({ withStackTrace: true }))
    .slice(0, characterNames.length);
exports.alice = exports.castOfCharacters[0];
exports.bob = exports.castOfCharacters[1];
exports.carol = exports.castOfCharacters[2];
exports.dan = exports.castOfCharacters[3];
exports.erin = exports.castOfCharacters[4];
const makeListOfValidatorAddresses = () => {
    const stringAddresses = [
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
        'tv1qdqft0u899axwce955fkh9rundr5s2sgvhpp8wzfe3ty0rn0rgqj2x6y86p',
    ];
    return stringAddresses.map(s => account_1.ValidatorAddress.fromUnsafe(s)._unsafeUnwrap({ withStackTrace: true }));
};
const listOfValidatorAddresses = makeListOfValidatorAddresses();
const detRandomValidatorAddressWithPRNG = (anInt) => () => {
    const randomInt = anInt();
    const index = randomInt % (listOfValidatorAddresses.length - 1);
    return listOfValidatorAddresses[index];
};
const randomValidatorList = (size, validatorAddress) => {
    const validatorList = [];
    const randomBuf = validatorAddress !== undefined
        ? (0, crypto_1.sha256)(validatorAddress.toString())
        : (0, crypto_1.sha256)(size.toString(16));
    const prng = detPRNGWithBuffer(randomBuf);
    const detRandomValidatorAddress = detRandomValidatorAddressWithPRNG(prng);
    const listSize = prng() % 5 === 1 ? size - Math.round(size / 2) : size;
    for (let i = 0; i < listSize; i++) {
        const random = prng();
        const ownerAddress = exports.castOfCharacters[random % exports.castOfCharacters.length];
        const name = characterNames[random % characterNames.length];
        const amount = primitives_2.Amount.fromUnsafe(random)._unsafeUnwrap();
        const bool = random % 2 === 0;
        validatorList.push({
            address: detRandomValidatorAddress(),
            ownerAddress,
            name,
            infoURL: new URL('https://rewards.radixtokens.comcom'),
            totalDelegatedStake: amount,
            ownerDelegation: amount,
            validatorFee: 2.5,
            registered: bool,
            isExternalStakeAccepted: bool,
            uptimePercentage: 100.0,
            proposalsMissed: 10,
            proposalsCompleted: 20,
        });
    }
    return validatorList;
};
const randomUnsignedTransaction = (transactionIntent) => {
    const transactionIntentDet = Object.assign(Object.assign({}, transactionIntent), { actions: transactionIntent.actions.map(a => (Object.assign({}, a))) });
    const detBlob = JSON.stringify(transactionIntentDet, null, 4);
    const blobBytes = Buffer.from(detBlob);
    const bytes32 = (0, crypto_1.sha256)(blobBytes);
    const anInt = detPRNGWithBuffer(bytes32);
    return {
        transaction: {
            blob: blobBytes.toString('hex'),
            hashOfBlobToSign: bytes32.toString('hex'),
        },
        fee: primitives_2.Amount.fromUnsafe(anInt())._unsafeUnwrap(),
    };
};
const randomPendingTransaction = (signedTx) => ({
    txID: dto_1.TransactionIdentifier.create((0, crypto_1.sha256)(Buffer.from(signedTx.transaction.blob)))._unsafeUnwrap(),
    blob: 'awd',
});
const detRandomSignedUnconfirmedTransaction = (signedTransaction) => (Object.assign({}, randomPendingTransaction(signedTransaction)));
const rndDemand = detPRNGWithBuffer(Buffer.from('dmnd'));
const randomDemand = () => ({
    tps: rndDemand() % 200,
});
const rndThroughput = detPRNGWithBuffer(Buffer.from('trpt'));
const randomThroughput = () => ({
    tps: rndThroughput() % 200,
});
const detPRNGWithPubKey = (pubKey) => {
    // cannot use first, since it is always 02 or 03
    const bytes = pubKey.asData({ compressed: true }).slice(1, 33);
    return detPRNGWithBuffer(bytes);
};
const detRandBalanceOfTokenWithInfo = (png) => {
    const anInt = png;
    const availableTokens = [...differentTokens];
    const deterministicRandomToken = () => {
        const tokenCount = availableTokens.length;
        const tokenIndex = anInt() % tokenCount;
        const token = availableTokens[tokenIndex];
        availableTokens.splice(tokenIndex, 1);
        return token;
    };
    const size = Math.max(anInt() % availableTokens.length, 1);
    return Array(size)
        .fill(undefined)
        .map((_) => {
        const token = deterministicRandomToken();
        const amtOrZero = anInt() % 10000;
        const amtFactor = primitives_2.Amount.fromUnsafe(Math.max(10, amtOrZero))._unsafeUnwrap();
        const amount = primitives_2.Amount.fromUnsafe(token.granularity.mul(amtFactor))._unsafeUnwrap();
        return {
            token,
            amount,
        };
    });
};
const deterministicRandomBalancesForAddress = (address) => {
    const anInt = detPRNGWithPubKey(address.publicKey);
    const tokenBalances = detRandBalanceOfTokenWithInfo(anInt).map(bti => (0, exports.balanceOfFor)(bti));
    return {
        owner: address,
        tokenBalances,
    };
};
exports.deterministicRandomBalancesForAddress = deterministicRandomBalancesForAddress;
const deterministicRandomUnstakesForAddress = (address) => {
    const anInt = detPRNGWithPubKey(address.publicKey);
    const size = anInt() % 7;
    return Array(size)
        .fill(undefined)
        .map((_, index) => {
        const detRandomValidatorAddress = detRandomValidatorAddressWithPRNG(anInt);
        const validator = detRandomValidatorAddress();
        const amount = primitives_2.Amount.fromUnsafe(anInt())._unsafeUnwrap();
        const bytesFromIndex = Buffer.allocUnsafe(2);
        bytesFromIndex.writeUInt16BE(index);
        const txIDBuffer = (0, crypto_1.sha256)(Buffer.concat([
            address.publicKey.asData({ compressed: true }),
            bytesFromIndex,
        ]));
        const withdrawTxID = dto_1.TransactionIdentifier.create(txIDBuffer)._unsafeUnwrap();
        const epochsUntil = anInt() % 5;
        return {
            amount,
            validator,
            epochsUntil: epochsUntil > 60 ? 0 : epochsUntil,
            withdrawTxID,
        };
    });
};
exports.deterministicRandomUnstakesForAddress = deterministicRandomUnstakesForAddress;
const deterministicRandomStakesForAddress = (address) => (0, exports.deterministicRandomUnstakesForAddress)(address).map((un) => (Object.assign({}, un)));
exports.deterministicRandomStakesForAddress = deterministicRandomStakesForAddress;
const deterministicRandomTxHistoryWithInput = (input) => {
    const address = input.address;
    const anInt = detPRNGWithPubKey(address.publicKey);
    const pubKeyBytes = address.publicKey
        .asData({ compressed: true })
        .slice(1, 33);
    const detRandomAddress = () => exports.castOfCharacters[anInt() % exports.castOfCharacters.length];
    const detRandomValidatorAddress = detRandomValidatorAddressWithPRNG(anInt);
    const tokenAndAmounts = detRandBalanceOfTokenWithInfo(anInt);
    const deterministicRandomExecutedTransactions = () => Array(input.size)
        .fill(undefined)
        .map((_, index) => {
        const bytesFromIndex = Buffer.allocUnsafe(2);
        bytesFromIndex.writeUInt16BE(index);
        const txIDBuffer = (0, crypto_1.sha256)(Buffer.concat([pubKeyBytes, bytesFromIndex]));
        const date = new Date('2020-03-14T15:32:05');
        date.setMonth(index % 12);
        const txID = dto_1.TransactionIdentifier.create(txIDBuffer)._unsafeUnwrap();
        const detMakeActionForTx = () => {
            // mock max 5 actions per tx in history, min 1.
            const actionCount = Math.max(anInt() % 5, 1);
            return Array(actionCount)
                .fill(undefined)
                .map((_, actionIndex) => {
                const v = anInt() % 4; // Transfer, Stake, Unstake, Other
                const actionType = v === 0
                    ? actions_1.ActionType.TOKEN_TRANSFER
                    : v === 1
                        ? actions_1.ActionType.STAKE_TOKENS
                        : v === 2
                            ? actions_1.ActionType.UNSTAKE_TOKENS
                            : actions_1.ActionType.OTHER;
                let executedAction;
                const tokenAndAmount = tokenAndAmounts[actionIndex % tokenAndAmounts.length];
                switch (actionType) {
                    case actions_1.ActionType.OTHER:
                        executedAction = {
                            type: actions_1.ActionType.OTHER,
                        };
                        break;
                    case actions_1.ActionType.STAKE_TOKENS:
                        executedAction = {
                            type: actions_1.ActionType.STAKE_TOKENS,
                            from: address,
                            amount: primitives_2.Amount.fromUnsafe(anInt())._unsafeUnwrap(),
                            validator: detRandomValidatorAddress(),
                        };
                        break;
                    case actions_1.ActionType.UNSTAKE_TOKENS:
                        executedAction = {
                            type: actions_1.ActionType.UNSTAKE_TOKENS,
                            from: address,
                            amount: primitives_2.Amount.fromUnsafe(anInt())._unsafeUnwrap(),
                            validator: detRandomValidatorAddress(),
                        };
                        break;
                    case actions_1.ActionType.TOKEN_TRANSFER:
                        executedAction = {
                            type: actions_1.ActionType.TOKEN_TRANSFER,
                            from_account: address.toString(),
                            to_account: detRandomAddress().toString(),
                            amount: tokenAndAmount.amount,
                            rri: tokenAndAmount.token.rri,
                        };
                        break;
                }
                return executedAction;
            });
        };
        const rndTxTypeInt = anInt() % 3;
        const transactionType = rndTxTypeInt === 0
            ? dto_1.TransactionType.INCOMING
            : rndTxTypeInt === 1
                ? dto_1.TransactionType.FROM_ME_TO_ME
                : dto_1.TransactionType.OUTGOING;
        return {
            txID,
            sentAt: date,
            transactionType,
            fee: primitives_2.Amount.fromUnsafe(anInt())._unsafeUnwrap(),
            // message?: {
            // 	msg: string
            // 	encryptionScheme: string
            // }
            actions: detMakeActionForTx(),
        };
    });
    const updatedCursor = (0, crypto_1.sha256)(input.cursor !== undefined ? Buffer.from(input.cursor) : pubKeyBytes).toString('hex');
    return {
        cursor: updatedCursor,
        transactions: deterministicRandomExecutedTransactions(),
    };
};
exports.deterministicRandomTxHistoryWithInput = deterministicRandomTxHistoryWithInput;
const deterministicRandomLookupTXUsingHist = (txID) => {
    const seed = (0, crypto_1.sha256)(Buffer.from(txID.__hex, 'hex'));
    const addressWithTXIdBytesAsSeed = account_1.AccountAddress.fromPublicKeyAndNetwork({
        publicKey: crypto_1.PrivateKey.fromBuffer(seed)._unsafeUnwrap().publicKey(),
        network: primitives_1.Network.MAINNET,
    });
    const txs = (0, exports.deterministicRandomTxHistoryWithInput)({
        size: 1,
        address: addressWithTXIdBytesAsSeed,
    }).transactions;
    if (txs.length === 0) {
        throw new Error('Expected at least one tx...');
    }
    return Object.assign(Object.assign({}, txs[0]), { txID });
};
const deterministicRandomBalances = (address) => (0, rxjs_1.of)((0, exports.deterministicRandomBalancesForAddress)(address));
exports.deterministicRandomBalances = deterministicRandomBalances;
const deterministicRandomTXHistory = (input) => (0, rxjs_1.of)((0, exports.deterministicRandomTxHistoryWithInput)(input));
exports.deterministicRandomTXHistory = deterministicRandomTXHistory;
const deterministicRandomLookupTX = (txID) => (0, rxjs_1.of)(deterministicRandomLookupTXUsingHist(txID));
exports.deterministicRandomLookupTX = deterministicRandomLookupTX;
const deterministicRandomUnstakesForAddr = (address) => (0, rxjs_1.of)((0, exports.deterministicRandomUnstakesForAddress)(address));
exports.deterministicRandomUnstakesForAddr = deterministicRandomUnstakesForAddr;
const deterministicRandomStakesForAddr = (address) => (0, rxjs_1.of)((0, exports.deterministicRandomStakesForAddress)(address));
exports.deterministicRandomStakesForAddr = deterministicRandomStakesForAddr;
const makeThrowingRadixCoreAPI = (nodeUrl) => ({
    node: { url: new URL(nodeUrl !== null && nodeUrl !== void 0 ? nodeUrl : 'https://www.radixdlt.com/') },
    networkId: () => {
        throw Error('Not implemented');
    },
    tokenBalancesForAddress: (_address) => {
        throw Error('Not implemented');
    },
    lookupTransaction: (_txID) => {
        throw Error('Not implemented');
    },
    validators: (_input) => {
        throw Error('Not implemented');
    },
    lookupValidator: (_input) => {
        throw Error('Not implemented');
    },
    transactionHistory: (_input) => {
        throw Error('Not implemented');
    },
    nativeToken: () => {
        throw Error('Not implemented');
    },
    tokenInfo: (_rri) => {
        throw Error('Not implemented');
    },
    stakesForAddress: (_address) => {
        throw Error('Not implemented');
    },
    unstakesForAddress: (_address) => {
        throw Error('Not implemented');
    },
    transactionStatus: (_txID) => {
        throw Error('Not implemented');
    },
    NetworkTransactionThroughput: () => {
        throw Error('Not implemented');
    },
    NetworkTransactionDemand: () => {
        throw Error('Not implemented');
    },
    buildTransaction: (_transactionIntent) => {
        throw Error('Not implemented');
    },
    submitSignedTransaction: (_signedTransaction) => {
        throw Error('Not implemented');
    },
    finalizeTransaction: (_signedUnconfirmedTransaction) => {
        throw Error('Not implemented');
    },
});
exports.makeThrowingRadixCoreAPI = makeThrowingRadixCoreAPI;
let txStatusMapCounter = undefined;
const mockRadixCoreAPI = (input) => {
    var _a;
    txStatusMapCounter = new Map();
    return {
        node: { url: new URL((_a = input === null || input === void 0 ? void 0 : input.nodeUrl) !== null && _a !== void 0 ? _a : 'https://www.radixdlt.com/') },
        networkId: () => { var _a; return (0, rxjs_1.of)((_a = input === null || input === void 0 ? void 0 : input.network) !== null && _a !== void 0 ? _a : primitives_1.Network.MAINNET).pipe((0, operators_1.shareReplay)(1)); },
        nativeToken: () => (0, rxjs_1.of)(exports.xrd),
        tokenInfo: (rri) => { var _a; return (0, rxjs_1.of)((_a = exports.tokenByRRIMap.get(rri)) !== null && _a !== void 0 ? _a : exports.__fallBackAlexToken); },
        tokenBalancesForAddress: exports.deterministicRandomBalances,
        transactionStatus: (txID) => {
            var _a;
            const last = (_a = txStatusMapCounter.get(txID)) !== null && _a !== void 0 ? _a : 0;
            const incremented = last + 1;
            txStatusMapCounter.set(txID, incremented);
            const status = last <= 1
                ? dto_1.TransactionStatus.PENDING
                : dto_1.TransactionStatus.CONFIRMED;
            return (0, rxjs_1.of)({
                txID,
                status, // when TransactionStatus.FAIL ?
            });
        },
        validators: (input) => (0, rxjs_1.of)({
            cursor: 'cursor',
            validators: randomValidatorList(input.size),
        }),
        lookupValidator: (validatorAddress) => {
            const validatorRnd = randomValidatorList(1, validatorAddress)[0];
            const validator = Object.assign(Object.assign({}, validatorRnd), { address: validatorAddress });
            return (0, rxjs_1.of)(validator);
        },
        buildTransaction: (transactionIntent) => (0, rxjs_1.of)(randomUnsignedTransaction(transactionIntent)),
        finalizeTransaction: (signedTransaction) => (0, rxjs_1.of)(detRandomSignedUnconfirmedTransaction(signedTransaction)),
        submitSignedTransaction: (signedUnconfirmedTX) => (0, rxjs_1.of)(signedUnconfirmedTX),
        NetworkTransactionDemand: () => (0, rxjs_1.of)(randomDemand()),
        NetworkTransactionThroughput: () => (0, rxjs_1.of)(randomThroughput()),
        transactionHistory: exports.deterministicRandomTXHistory,
        lookupTransaction: exports.deterministicRandomLookupTX,
        unstakesForAddress: exports.deterministicRandomUnstakesForAddr,
        stakesForAddress: exports.deterministicRandomStakesForAddr,
    };
};
exports.mockRadixCoreAPI = mockRadixCoreAPI;
exports.mockedAPI = (0, rxjs_1.of)((0, exports.mockRadixCoreAPI)());
//# sourceMappingURL=mockRadix.js.map