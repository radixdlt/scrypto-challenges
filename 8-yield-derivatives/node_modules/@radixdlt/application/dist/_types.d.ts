import { SigningKeyT, AccountAddressT, DeriveNextInput, Signing, Encrypting, Decrypting, SwitchToIndex, AddSigningKeyByPrivateKeyInput, DeriveHWSigningKeyInput } from '@radixdlt/account';
import { PublicKeyT, HDPathRadixT, MnemomicT, KeystoreT } from '@radixdlt/crypto';
import { Network } from '@radixdlt/primitives';
import { Observable, ReplaySubject } from 'rxjs';
import { BuiltTransaction, ExecutedTransaction, SimpleExecutedTransaction, StakePositions, StatusOfTransaction, TokenBalances, TransactionHistory, TransactionHistoryActiveAccountRequestInput, TransactionIdentifierT, TransactionTracking, UnstakePositions } from './dto';
import { StakeTokensInput, TransferTokensInput, UnstakeTokensInput } from './actions';
import { Option } from 'prelude-ts';
import { SigningKeychainT, SigningKeyTypeT } from '@radixdlt/account/src/_types';
import { NodeT, RadixAPI, RadixCoreAPI } from './api';
import { LogLevel } from 'packages/account/node_modules/@radixdlt/util/dist';
import { ErrorT } from './errors';
export declare type ManualUserConfirmTX = {
    txToConfirm: BuiltTransaction;
    confirm: () => void;
};
export declare type TransactionConfirmationBeforeFinalization = 'skip' | ReplaySubject<ManualUserConfirmTX>;
export declare type MessageInTransaction = Readonly<{
    plaintext: string;
    encrypt: boolean;
}>;
export declare type MakeTransactionOptions = Readonly<{
    userConfirmation: TransactionConfirmationBeforeFinalization;
    pollTXStatusTrigger?: Observable<unknown>;
}>;
export declare type TransferTokensOptions = MakeTransactionOptions & Readonly<{
    message?: MessageInTransaction;
    transferInput: TransferTokensInput;
}>;
export declare type StakeOptions = MakeTransactionOptions & Readonly<{
    stakeInput: StakeTokensInput;
}>;
export declare type UnstakeOptions = MakeTransactionOptions & Readonly<{
    unstakeInput: UnstakeTokensInput;
}>;
export declare type AccountT = Signing & Encrypting & Decrypting & Readonly<{
    equals: (other: AccountT) => boolean;
    signingKey: SigningKeyT;
    address: AccountAddressT;
    publicKey: PublicKeyT;
    network: Network;
    type: SigningKeyTypeT;
    hdPath?: HDPathRadixT;
}>;
export declare type AccountsT = Readonly<{
    getAccountWithHDSigningKeyByHDPath: (hdPath: HDPathRadixT) => Option<AccountT>;
    getAnyAccountByPublicKey: (publicKey: PublicKeyT) => Option<AccountT>;
    all: AccountT[];
    accountsWithNonHDSigningKeys: () => AccountT[];
    accountsWithLocalHDSigningKeys: () => AccountT[];
    accountsWithHardwareHDSigningKeys: () => AccountT[];
    accountsWithHDSigningKeys: () => AccountT[];
    size: () => number;
}>;
export declare type SwitchToAccount = Readonly<{
    toAccount: AccountT;
}>;
export declare type SwitchAccountInput = 'first' | 'last' | SwitchToAccount | SwitchToIndex;
export declare type WalletT = Readonly<{
    __unsafeGetAccount: () => AccountT;
    revealMnemonic: () => MnemomicT;
    restoreLocalHDAccountsToIndex: (index: number) => Observable<AccountsT>;
    deriveNextLocalHDAccount: (input?: DeriveNextInput) => Observable<AccountT>;
    deriveHWAccount: (input: DeriveHWSigningKeyInput) => Observable<AccountT>;
    displayAddressForActiveHWAccountOnHWDeviceForVerification: () => Observable<void>;
    addAccountFromPrivateKey: (input: AddAccountByPrivateKeyInput) => Observable<AccountT>;
    switchAccount: (input: SwitchAccountInput) => AccountT;
    observeActiveAccount: () => Observable<AccountT>;
    observeAccounts: () => Observable<AccountsT>;
}>;
export declare type AddAccountByPrivateKeyInput = AddSigningKeyByPrivateKeyInput;
export declare type RadixT = Readonly<{
    ledger: RadixAPI;
    connect: (url: string) => Promise<void>;
    __withAPI: (radixCoreAPI$: Observable<RadixCoreAPI>) => RadixT;
    __withNodeConnection: (node$: Observable<NodeT>) => RadixT;
    __withWallet: (wallet: WalletT) => RadixT;
    login: (password: string, loadKeystore: () => Promise<KeystoreT>) => RadixT;
    /**
     * Restores accounts in wallet up to and excluding `targetIndex`.
     *
     * @param {number} targetIndex - The index to restore account up to, this method will restore accounts from index 0 up to but excluding this index.
     */
    restoreLocalHDAccountsToIndex: (index: number) => Observable<AccountsT>;
    deriveNextAccount: (input?: DeriveNextInput) => RadixT;
    deriveHWAccount: (input: DeriveHWSigningKeyInput) => Observable<AccountT>;
    displayAddressForActiveHWAccountOnHWDeviceForVerification: () => Observable<void>;
    addAccountFromPrivateKey: (input: AddAccountByPrivateKeyInput) => RadixT;
    switchAccount: (input: SwitchAccountInput) => RadixT;
    revealMnemonic: () => Observable<MnemomicT>;
    activeAddress: Observable<AccountAddressT>;
    activeAccount: Observable<AccountT>;
    accounts: Observable<AccountsT>;
    tokenBalances: Observable<TokenBalances>;
    stakingPositions: Observable<StakePositions>;
    unstakingPositions: Observable<UnstakePositions>;
    logLevel: (level: LogLevel) => RadixT;
    /**
     * Specify a trigger for when to fetch the token balances for the active address.
     *
     * @param {Observable<number>} trigger - An observable that signals when to fetch.
     */
    withTokenBalanceFetchTrigger: (trigger: Observable<number>) => RadixT;
    /**
     * Specify a trigger for when to fetch the stakes and unstakes for the active address.
     *
     * @param {Observable<number>} trigger - An observable that signals when to fetch.
     */
    withStakingFetchTrigger: (trigger: Observable<number>) => RadixT;
    /**
     * Transaction history of active signingKey.
     *
     * @param {TransactionHistoryActiveAccountRequestInput} input - Pagination input, size and cursor.
     * @returns {TransactionHistory} A page from the transaction history.
     */
    transactionHistory: (input: TransactionHistoryActiveAccountRequestInput) => Observable<TransactionHistory>;
    /**
     * A decorated variant of RadixApi's lookupTransaction, this decorated variant returns
     * `ExecutedTransaction` instead of `SimpleExecutedTransaction` which includes `transctionType`.
     */
    lookupTransaction: (txID: TransactionIdentifierT) => Observable<ExecutedTransaction>;
    transferTokens: (input: TransferTokensOptions) => TransactionTracking;
    transactionStatus: (txID: TransactionIdentifierT, trigger: Observable<number>) => Observable<StatusOfTransaction>;
    stakeTokens: (input: StakeOptions) => TransactionTracking;
    unstakeTokens: (input: UnstakeOptions) => TransactionTracking;
    decryptTransaction: (input: SimpleExecutedTransaction) => Observable<string>;
    errors: Observable<ErrorT<any>>;
    __wallet: Observable<WalletT>;
    __node: Observable<NodeT>;
    __reset: () => void;
    __withKeychain: (signingKeychain: SigningKeychainT) => RadixT;
}>;
//# sourceMappingURL=_types.d.ts.map