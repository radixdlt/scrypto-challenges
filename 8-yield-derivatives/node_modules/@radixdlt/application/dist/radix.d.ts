/// <reference types="node" />
import { AccountAddressT, DeriveHWSigningKeyInput, DeriveNextInput, SigningKeychainT } from '@radixdlt/account';
import { Network } from '@radixdlt/primitives';
import { NodeT, RadixCoreAPI } from './api';
import { Observable } from 'rxjs';
import { KeystoreT, MnemomicT } from '@radixdlt/crypto';
import { AddAccountByPrivateKeyInput, AccountsT, WalletT, AccountT, MakeTransactionOptions, SwitchAccountInput, TransferTokensOptions } from './_types';
import { LogLevel } from '@radixdlt/util';
import { ExecutedTransaction, SimpleExecutedTransaction, TransactionHistory, TransactionHistoryActiveAccountRequestInput, TransactionIdentifierT, TransactionStateUpdate, TransactionTracking, TransactionStatus } from './dto';
import { ExecutedAction, StakeTokensInput, UnstakeTokensInput } from './actions';
export declare const Radix: {
    create: () => {
        ledger: {
            networkId: () => Observable<Network>;
            tokenBalancesForAddress: (address: AccountAddressT) => Observable<import("./api/open-api/_types").AccountBalancesEndpoint.DecodedResponse>;
            transactionHistory: (input: import("./dto").TransactionHistoryRequestInput) => Observable<Readonly<{
                cursor: string;
                transactions: Readonly<{
                    txID: Readonly<{
                        __witness: "isTXId";
                        __hex: string;
                        toString: () => string;
                        equals: (other: Readonly<any>) => boolean;
                    }>;
                    sentAt: Date;
                    status: TransactionStatus;
                    fee: import("@radixdlt/uint256").UInt256;
                    message?: string | undefined;
                    actions: ExecutedAction[];
                }>[];
            }>>;
            recentTransactions: (input: Readonly<{
                network: Network;
                cursor?: string | undefined;
            }>) => Observable<Readonly<{
                cursor: string;
                transactions: Readonly<{
                    txID: Readonly<{
                        __witness: "isTXId";
                        __hex: string;
                        toString: () => string;
                        equals: (other: Readonly<any>) => boolean;
                    }>;
                    sentAt: Date;
                    status: TransactionStatus;
                    fee: import("@radixdlt/uint256").UInt256;
                    message?: string | undefined;
                    actions: ExecutedAction[];
                }>[];
            }>>;
            nativeToken: (network: string) => Observable<Readonly<{
                name: string;
                rri: Readonly<{
                    hash: Buffer;
                    __witness: "isRRI";
                    network: Network;
                    name: string;
                    toString: () => string;
                    equals: (other: Readonly<any>) => boolean;
                }>;
                symbol: string;
                description?: string | undefined;
                granularity: import("@radixdlt/uint256").UInt256;
                isSupplyMutable: boolean;
                currentSupply: import("@radixdlt/uint256").UInt256;
                tokenInfoURL?: URL | undefined;
                iconURL?: URL | undefined;
            }>>;
            tokenInfo: (rri: Readonly<{
                hash: Buffer;
                __witness: "isRRI";
                network: Network;
                name: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>) => Observable<Readonly<{
                name: string;
                rri: Readonly<{
                    hash: Buffer;
                    __witness: "isRRI";
                    network: Network;
                    name: string;
                    toString: () => string;
                    equals: (other: Readonly<any>) => boolean;
                }>;
                symbol: string;
                description?: string | undefined;
                granularity: import("@radixdlt/uint256").UInt256;
                isSupplyMutable: boolean;
                currentSupply: import("@radixdlt/uint256").UInt256;
                tokenInfoURL?: URL | undefined;
                iconURL?: URL | undefined;
            }>>;
            stakesForAddress: (address: AccountAddressT) => Observable<import("./api/open-api/_types").StakePositionsEndpoint.DecodedResponse>;
            unstakesForAddress: (address: AccountAddressT) => Observable<import("./api/open-api/_types").UnstakePositionsEndpoint.DecodedResponse>;
            validators: (input: string) => Observable<import("./api/open-api/_types").ValidatorsEndpoint.DecodedResponse>;
            lookupValidator: (input: import("@radixdlt/account").ValidatorAddressT) => Observable<{
                address: import("@radixdlt/account").ValidatorAddressT;
                ownerAddress: AccountAddressT;
                name: string;
                infoURL?: URL | undefined;
                totalDelegatedStake: import("@radixdlt/uint256").UInt256;
                ownerDelegation: import("@radixdlt/uint256").UInt256;
                validatorFee: number;
                registered: boolean;
                isExternalStakeAccepted: boolean;
                uptimePercentage: number;
                proposalsMissed: number;
                proposalsCompleted: number;
            }>;
            getTransaction: (txID: Readonly<{
                __witness: "isTXId";
                __hex: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>, network: string) => Observable<Readonly<{
                txID: Readonly<{
                    __witness: "isTXId";
                    __hex: string;
                    toString: () => string;
                    equals: (other: Readonly<any>) => boolean;
                }>;
                sentAt: Date;
                status: TransactionStatus;
                fee: import("@radixdlt/uint256").UInt256;
                message?: string | undefined;
                actions: ExecutedAction[];
            }>>;
            buildTransaction: (transactionIntent: Readonly<{
                actions: import("./actions").IntendedAction[];
                message?: Buffer | undefined;
            }>, from: AccountAddressT) => Observable<Readonly<{
                transaction: Readonly<{
                    blob: string;
                    hashOfBlobToSign: string;
                }>;
                fee: import("@radixdlt/uint256").UInt256;
            }>>;
            finalizeTransaction: (network: string, signedTransaction: Readonly<{
                transaction: Readonly<{
                    blob: string;
                    hashOfBlobToSign: string;
                }>;
                publicKeyOfSigner: Readonly<{
                    __hex: string;
                    asData: (input: {
                        readonly compressed: boolean;
                    }) => Buffer;
                    toString: (compressed?: boolean | undefined) => string;
                    isValidSignature: (input: Readonly<{
                        signature: Readonly<{
                            r: import("@radixdlt/uint256").UInt256;
                            s: import("@radixdlt/uint256").UInt256;
                            toDER: () => string;
                            equals: (other: Readonly<any>) => boolean;
                        }>;
                        hashedMessage: Buffer;
                    }>) => boolean;
                    decodeToPointOnCurve: () => Readonly<{
                        x: import("@radixdlt/uint256").UInt256;
                        y: import("@radixdlt/uint256").UInt256;
                        toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                        toString: (includePrefixByte?: boolean | undefined) => string;
                        equals: (other: Readonly<any>) => boolean;
                        add: (other: Readonly<any>) => Readonly<any>;
                        multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                        multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
                    }>;
                    equals: (other: Readonly<any>) => boolean;
                }>;
                signature: Readonly<{
                    r: import("@radixdlt/uint256").UInt256;
                    s: import("@radixdlt/uint256").UInt256;
                    toDER: () => string;
                    equals: (other: Readonly<any>) => boolean;
                }>;
            }>) => Observable<Readonly<{
                blob: string;
                txID: Readonly<{
                    __witness: "isTXId";
                    __hex: string;
                    toString: () => string;
                    equals: (other: Readonly<any>) => boolean;
                }>;
            }>>;
            submitSignedTransaction: (network: string, finalizedTx: Readonly<{
                blob: string;
                txID: Readonly<{
                    __witness: "isTXId";
                    __hex: string;
                    toString: () => string;
                    equals: (other: Readonly<any>) => boolean;
                }>;
            }>) => Observable<Readonly<{
                txID: Readonly<{
                    __witness: "isTXId";
                    __hex: string;
                    toString: () => string;
                    equals: (other: Readonly<any>) => boolean;
                }>;
            }>>;
        };
        __wallet: Observable<Readonly<{
            __unsafeGetAccount: () => AccountT;
            revealMnemonic: () => MnemomicT;
            restoreLocalHDAccountsToIndex: (index: number) => Observable<Readonly<{
                getAccountWithHDSigningKeyByHDPath: (hdPath: import("@radixdlt/crypto").HDPathRadixT) => import("prelude-ts").Option<AccountT>;
                getAnyAccountByPublicKey: (publicKey: Readonly<{
                    __hex: string;
                    asData: (input: {
                        readonly compressed: boolean;
                    }) => Buffer;
                    toString: (compressed?: boolean | undefined) => string;
                    isValidSignature: (input: Readonly<{
                        signature: Readonly<{
                            r: import("@radixdlt/uint256").UInt256;
                            s: import("@radixdlt/uint256").UInt256;
                            toDER: () => string;
                            equals: (other: Readonly<any>) => boolean;
                        }>;
                        hashedMessage: Buffer;
                    }>) => boolean;
                    decodeToPointOnCurve: () => Readonly<{
                        x: import("@radixdlt/uint256").UInt256;
                        y: import("@radixdlt/uint256").UInt256;
                        toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                        toString: (includePrefixByte?: boolean | undefined) => string;
                        equals: (other: Readonly<any>) => boolean;
                        add: (other: Readonly<any>) => Readonly<any>;
                        multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                        multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
                    }>;
                    equals: (other: Readonly<any>) => boolean;
                }>) => import("prelude-ts").Option<AccountT>;
                all: AccountT[];
                accountsWithNonHDSigningKeys: () => AccountT[];
                accountsWithLocalHDSigningKeys: () => AccountT[];
                accountsWithHardwareHDSigningKeys: () => AccountT[];
                accountsWithHDSigningKeys: () => AccountT[];
                size: () => number;
            }>>;
            deriveNextLocalHDAccount: (input?: DeriveNextInput) => Observable<AccountT>;
            deriveHWAccount: (input: Readonly<{
                keyDerivation: import("@radixdlt/account").HWSigningKeyDerivation;
                hardwareWalletConnection: Observable<Readonly<{
                    getVersion: () => Observable<Readonly<{
                        major: number;
                        minor: number;
                        patch: number;
                        equals: (other: Readonly<any>) => boolean;
                        toString: () => string;
                    }>>;
                    getPublicKey: (input: import("packages/hardware-wallet/dist").GetPublicKeyInput) => Observable<Readonly<{
                        __hex: string;
                        asData: (input: {
                            readonly compressed: boolean;
                        }) => Buffer;
                        toString: (compressed?: boolean | undefined) => string;
                        isValidSignature: (input: Readonly<{
                            signature: Readonly<{
                                r: import("@radixdlt/uint256").UInt256;
                                s: import("@radixdlt/uint256").UInt256;
                                toDER: () => string;
                                equals: (other: Readonly<any>) => boolean;
                            }>;
                            hashedMessage: Buffer;
                        }>) => boolean;
                        decodeToPointOnCurve: () => Readonly<{
                            x: import("@radixdlt/uint256").UInt256;
                            y: import("@radixdlt/uint256").UInt256;
                            toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                            toString: (includePrefixByte?: boolean | undefined) => string;
                            equals: (other: Readonly<any>) => boolean;
                            add: (other: Readonly<any>) => Readonly<any>;
                            multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                            multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
                        }>;
                        equals: (other: Readonly<any>) => boolean;
                    }>>;
                    doSignHash: (input: import("packages/hardware-wallet/dist").SignHashInput) => Observable<Readonly<{
                        r: import("@radixdlt/uint256").UInt256;
                        s: import("@radixdlt/uint256").UInt256;
                        toDER: () => string;
                        equals: (other: Readonly<any>) => boolean;
                    }>>;
                    doSignTransaction: (input: Readonly<{
                        tx: Readonly<{
                            blob: string;
                            hashOfBlobToSign: string;
                        }>;
                        path: import("@radixdlt/crypto").HDPathRadixT;
                        nonXrdHRP?: string | undefined;
                    }>) => Observable<Readonly<{
                        signature: Readonly<{
                            r: import("@radixdlt/uint256").UInt256;
                            s: import("@radixdlt/uint256").UInt256;
                            toDER: () => string;
                            equals: (other: Readonly<any>) => boolean;
                        }>;
                        signatureV: number;
                        hashCalculatedByLedger: Buffer;
                    }>>;
                    doKeyExchange: (input: import("packages/hardware-wallet/dist").KeyExchangeInput) => Observable<Readonly<{
                        x: import("@radixdlt/uint256").UInt256;
                        y: import("@radixdlt/uint256").UInt256;
                        toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                        toString: (includePrefixByte?: boolean | undefined) => string;
                        equals: (other: Readonly<any>) => boolean;
                        add: (other: Readonly<any>) => Readonly<any>;
                        multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                        multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
                    }>>;
                    makeSigningKey: (path: import("@radixdlt/crypto").HDPathRadixT, verificationPrompt?: boolean | undefined) => Observable<Readonly<{
                        keyExchange: (publicKeyOfOtherParty: Readonly<{
                            __hex: string;
                            asData: (input: {
                                readonly compressed: boolean;
                            }) => Buffer;
                            toString: (compressed?: boolean | undefined) => string;
                            isValidSignature: (input: Readonly<{
                                signature: Readonly<{
                                    r: import("@radixdlt/uint256").UInt256;
                                    s: import("@radixdlt/uint256").UInt256;
                                    toDER: () => string;
                                    equals: (other: Readonly<any>) => boolean;
                                }>;
                                hashedMessage: Buffer;
                            }>) => boolean;
                            decodeToPointOnCurve: () => Readonly<{
                                x: import("@radixdlt/uint256").UInt256;
                                y: import("@radixdlt/uint256").UInt256;
                                toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                                toString: (includePrefixByte?: boolean | undefined) => string;
                                equals: (other: Readonly<any>) => boolean;
                                add: (other: Readonly<any>) => Readonly<any>;
                                multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                                multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
                            }>;
                            equals: (other: Readonly<any>) => boolean;
                        }>, display?: "encrypt" | "decrypt" | undefined) => Observable<Readonly<{
                            x: import("@radixdlt/uint256").UInt256;
                            y: import("@radixdlt/uint256").UInt256;
                            toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                            toString: (includePrefixByte?: boolean | undefined) => string;
                            equals: (other: Readonly<any>) => boolean;
                            add: (other: Readonly<any>) => Readonly<any>;
                            multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                            multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
                        }>>;
                        publicKey: Readonly<{
                            __hex: string;
                            asData: (input: {
                                readonly compressed: boolean;
                            }) => Buffer;
                            toString: (compressed?: boolean | undefined) => string;
                            isValidSignature: (input: Readonly<{
                                signature: Readonly<{
                                    r: import("@radixdlt/uint256").UInt256;
                                    s: import("@radixdlt/uint256").UInt256;
                                    toDER: () => string;
                                    equals: (other: Readonly<any>) => boolean;
                                }>;
                                hashedMessage: Buffer;
                            }>) => boolean;
                            decodeToPointOnCurve: () => Readonly<{
                                x: import("@radixdlt/uint256").UInt256;
                                y: import("@radixdlt/uint256").UInt256;
                                toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                                toString: (includePrefixByte?: boolean | undefined) => string;
                                equals: (other: Readonly<any>) => boolean;
                                add: (other: Readonly<any>) => Readonly<any>;
                                multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                                multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
                            }>;
                            equals: (other: Readonly<any>) => boolean;
                        }>;
                        getPublicKeyDisplayOnlyAddress: () => Observable<Readonly<{
                            __hex: string;
                            asData: (input: {
                                readonly compressed: boolean;
                            }) => Buffer;
                            toString: (compressed?: boolean | undefined) => string;
                            isValidSignature: (input: Readonly<{
                                signature: Readonly<{
                                    r: import("@radixdlt/uint256").UInt256;
                                    s: import("@radixdlt/uint256").UInt256;
                                    toDER: () => string;
                                    equals: (other: Readonly<any>) => boolean;
                                }>;
                                hashedMessage: Buffer;
                            }>) => boolean;
                            decodeToPointOnCurve: () => Readonly<{
                                x: import("@radixdlt/uint256").UInt256;
                                y: import("@radixdlt/uint256").UInt256;
                                toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                                toString: (includePrefixByte?: boolean | undefined) => string;
                                equals: (other: Readonly<any>) => boolean;
                                add: (other: Readonly<any>) => Readonly<any>;
                                multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                                multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
                            }>;
                            equals: (other: Readonly<any>) => boolean;
                        }>>;
                        signHash: (hashedMessage: Buffer) => Observable<Readonly<{
                            r: import("@radixdlt/uint256").UInt256;
                            s: import("@radixdlt/uint256").UInt256;
                            toDER: () => string;
                            equals: (other: Readonly<any>) => boolean;
                        }>>;
                        sign: (tx: Readonly<{
                            blob: string;
                            hashOfBlobToSign: string;
                        }>, nonXrdHRP?: string | undefined) => Observable<Readonly<{
                            r: import("@radixdlt/uint256").UInt256;
                            s: import("@radixdlt/uint256").UInt256;
                            toDER: () => string;
                            equals: (other: Readonly<any>) => boolean;
                        }>>;
                    }>>;
                }>>;
                alsoSwitchTo: boolean;
                verificationPrompt?: boolean | undefined;
            }>) => Observable<AccountT>;
            displayAddressForActiveHWAccountOnHWDeviceForVerification: () => Observable<void>;
            addAccountFromPrivateKey: (input: import("@radixdlt/account").AddSigningKeyByPrivateKeyInput) => Observable<AccountT>;
            switchAccount: (input: SwitchAccountInput) => AccountT;
            observeActiveAccount: () => Observable<AccountT>;
            observeAccounts: () => Observable<Readonly<{
                getAccountWithHDSigningKeyByHDPath: (hdPath: import("@radixdlt/crypto").HDPathRadixT) => import("prelude-ts").Option<AccountT>;
                getAnyAccountByPublicKey: (publicKey: Readonly<{
                    __hex: string;
                    asData: (input: {
                        readonly compressed: boolean;
                    }) => Buffer;
                    toString: (compressed?: boolean | undefined) => string;
                    isValidSignature: (input: Readonly<{
                        signature: Readonly<{
                            r: import("@radixdlt/uint256").UInt256;
                            s: import("@radixdlt/uint256").UInt256;
                            toDER: () => string;
                            equals: (other: Readonly<any>) => boolean;
                        }>;
                        hashedMessage: Buffer;
                    }>) => boolean;
                    decodeToPointOnCurve: () => Readonly<{
                        x: import("@radixdlt/uint256").UInt256;
                        y: import("@radixdlt/uint256").UInt256;
                        toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                        toString: (includePrefixByte?: boolean | undefined) => string;
                        equals: (other: Readonly<any>) => boolean;
                        add: (other: Readonly<any>) => Readonly<any>;
                        multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                        multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
                    }>;
                    equals: (other: Readonly<any>) => boolean;
                }>) => import("prelude-ts").Option<AccountT>;
                all: AccountT[];
                accountsWithNonHDSigningKeys: () => AccountT[];
                accountsWithLocalHDSigningKeys: () => AccountT[];
                accountsWithHardwareHDSigningKeys: () => AccountT[];
                accountsWithHDSigningKeys: () => AccountT[];
                size: () => number;
            }>>;
        }>>;
        __node: Observable<Readonly<{
            url: URL;
        }>>;
        __reset: () => void;
        __withNodeConnection: (node$: Observable<NodeT>) => any;
        __withAPI: (radixCoreAPI$: Observable<RadixCoreAPI>) => any;
        __withWallet: (wallet: WalletT) => any;
        __withKeychain: (signingKeychain: SigningKeychainT) => any;
        connect: (url: string) => Promise<void>;
        login: (password: string, loadKeystore: () => Promise<KeystoreT>) => any;
        errors: Observable<import("./api/open-api/_types").Decoded.TransactionBuildError>;
        deriveNextAccount: (input?: DeriveNextInput) => any;
        deriveHWAccount: (input: DeriveHWSigningKeyInput) => Observable<AccountT>;
        displayAddressForActiveHWAccountOnHWDeviceForVerification: () => Observable<void>;
        addAccountFromPrivateKey: (input: AddAccountByPrivateKeyInput) => any;
        switchAccount: (input: SwitchAccountInput) => any;
        restoreLocalHDAccountsToIndex: (index: number) => Observable<AccountsT>;
        decryptTransaction: (input: SimpleExecutedTransaction) => Observable<string>;
        logLevel: (level: LogLevel) => any;
        transactionStatus: (txID: TransactionIdentifierT, trigger: Observable<number>) => Observable<Readonly<{
            txID: Readonly<{
                __witness: "isTXId";
                __hex: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>;
            sentAt: Date;
            status: TransactionStatus;
            fee: import("@radixdlt/uint256").UInt256;
            message?: string | undefined;
            actions: ExecutedAction[];
        }>>;
        withTokenBalanceFetchTrigger: (trigger: Observable<number>) => any;
        withStakingFetchTrigger: (trigger: Observable<number>) => any;
        revealMnemonic: () => Observable<MnemomicT>;
        activeAddress: Observable<Readonly<{
            addressType: import("@radixdlt/account").AddressTypeT;
            network: Network;
            publicKey: Readonly<{
                __hex: string;
                asData: (input: {
                    readonly compressed: boolean;
                }) => Buffer;
                toString: (compressed?: boolean | undefined) => string;
                isValidSignature: (input: Readonly<{
                    signature: Readonly<{
                        r: import("@radixdlt/uint256").UInt256;
                        s: import("@radixdlt/uint256").UInt256;
                        toDER: () => string;
                        equals: (other: Readonly<any>) => boolean;
                    }>;
                    hashedMessage: Buffer;
                }>) => boolean;
                decodeToPointOnCurve: () => Readonly<{
                    x: import("@radixdlt/uint256").UInt256;
                    y: import("@radixdlt/uint256").UInt256;
                    toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                    toString: (includePrefixByte?: boolean | undefined) => string;
                    equals: (other: Readonly<any>) => boolean;
                    add: (other: Readonly<any>) => Readonly<any>;
                    multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                    multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
                }>;
                equals: (other: Readonly<any>) => boolean;
            }>;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }> & Readonly<{
            addressType: import("@radixdlt/account").AddressTypeT.ACCOUNT;
            equals: (other: AccountAddressT) => boolean;
        }>>;
        activeAccount: Observable<AccountT>;
        accounts: Observable<Readonly<{
            getAccountWithHDSigningKeyByHDPath: (hdPath: import("@radixdlt/crypto").HDPathRadixT) => import("prelude-ts").Option<AccountT>;
            getAnyAccountByPublicKey: (publicKey: Readonly<{
                __hex: string;
                asData: (input: {
                    readonly compressed: boolean;
                }) => Buffer;
                toString: (compressed?: boolean | undefined) => string;
                isValidSignature: (input: Readonly<{
                    signature: Readonly<{
                        r: import("@radixdlt/uint256").UInt256;
                        s: import("@radixdlt/uint256").UInt256;
                        toDER: () => string;
                        equals: (other: Readonly<any>) => boolean;
                    }>;
                    hashedMessage: Buffer;
                }>) => boolean;
                decodeToPointOnCurve: () => Readonly<{
                    x: import("@radixdlt/uint256").UInt256;
                    y: import("@radixdlt/uint256").UInt256;
                    toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
                    toString: (includePrefixByte?: boolean | undefined) => string;
                    equals: (other: Readonly<any>) => boolean;
                    add: (other: Readonly<any>) => Readonly<any>;
                    multiply: (by: import("@radixdlt/uint256").UInt256) => Readonly<any>;
                    multiplyWithPrivateKey: (privateKey: import("@radixdlt/crypto").PrivateKeyT) => Readonly<any>;
                }>;
                equals: (other: Readonly<any>) => boolean;
            }>) => import("prelude-ts").Option<AccountT>;
            all: AccountT[];
            accountsWithNonHDSigningKeys: () => AccountT[];
            accountsWithLocalHDSigningKeys: () => AccountT[];
            accountsWithHardwareHDSigningKeys: () => AccountT[];
            accountsWithHDSigningKeys: () => AccountT[];
            size: () => number;
        }>>;
        tokenBalances: Observable<import("./api/open-api/_types").AccountBalancesEndpoint.DecodedResponse>;
        stakingPositions: Observable<import("./api/open-api/_types").StakePositionsEndpoint.DecodedResponse>;
        unstakingPositions: Observable<import("./api/open-api/_types").UnstakePositionsEndpoint.DecodedResponse>;
        lookupTransaction: (txID: TransactionIdentifierT) => Observable<ExecutedTransaction>;
        transactionHistory: (input: TransactionHistoryActiveAccountRequestInput) => Observable<TransactionHistory>;
        transferTokens: (input: Omit<TransferTokensOptions, 'from_account'>) => TransactionTracking;
        stakeTokens: (input: MakeTransactionOptions & {
            stakeInput: Omit<StakeTokensInput, 'tokenIdentifier'>;
        }) => Promise<Readonly<{
            events: Observable<TransactionStateUpdate<import("./dto").TransactionState>>;
            completion: Observable<Readonly<{
                __witness: "isTXId";
                __hex: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>>;
        }>>;
        unstakeTokens: (input: MakeTransactionOptions & {
            unstakeInput: Omit<UnstakeTokensInput, 'tokenIdentifier'>;
        }) => Promise<Readonly<{
            events: Observable<TransactionStateUpdate<import("./dto").TransactionState>>;
            completion: Observable<Readonly<{
                __witness: "isTXId";
                __hex: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>>;
        }>>;
        getTransaction: (txID: TransactionIdentifierT) => Observable<Readonly<{
            txID: Readonly<{
                __witness: "isTXId";
                __hex: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>;
            sentAt: Date;
            status: TransactionStatus;
            fee: import("@radixdlt/uint256").UInt256;
            message?: string | undefined;
            actions: ExecutedAction[];
        }>>;
        validators: () => Observable<import("./api/open-api/_types").ValidatorsEndpoint.DecodedResponse>;
        setHeaders: (headers: Record<string, string>) => void;
        targetApiVersion: string;
    };
};
//# sourceMappingURL=radix.d.ts.map