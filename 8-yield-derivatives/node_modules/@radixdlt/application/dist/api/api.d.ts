/// <reference types="node" />
export declare const nodeAPI: (url: URL) => {
    gateway: (params: object, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<import("./open-api/_types").GatewayEndpoint.DecodedResponse, Error[]>;
    tokenInfo: (params: import("@radixdlt/networking").TokenRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<Readonly<{
        name: string;
        rri: Readonly<{
            hash: Buffer;
            __witness: "isRRI";
            network: import("packages/primitives/dist").Network;
            name: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
        symbol: string;
        description?: string | undefined;
        granularity: import("@radixdlt/uint256").UInt256;
        isSupplyMutable: boolean;
        currentSupply: import("@radixdlt/uint256").UInt256;
        tokenInfoURL?: URL | undefined;
        iconURL?: URL | undefined;
    }>, Error[]>;
    nativeTokenInfo: (params: import("@radixdlt/networking").TokenNativeRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<Readonly<{
        name: string;
        rri: Readonly<{
            hash: Buffer;
            __witness: "isRRI";
            network: import("packages/primitives/dist").Network;
            name: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
        symbol: string;
        description?: string | undefined;
        granularity: import("@radixdlt/uint256").UInt256;
        isSupplyMutable: boolean;
        currentSupply: import("@radixdlt/uint256").UInt256;
        tokenInfoURL?: URL | undefined;
        iconURL?: URL | undefined;
    }>, Error[]>;
    stakePositions: (params: import("@radixdlt/networking").AccountStakesRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<import("./open-api/_types").StakePositionsEndpoint.DecodedResponse, Error[]>;
    unstakePositions: (params: import("@radixdlt/networking").AccountUnstakesRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<import("./open-api/_types").UnstakePositionsEndpoint.DecodedResponse, Error[]>;
    accountBalances: (params: import("@radixdlt/networking").AccountBalancesRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<import("./open-api/_types").AccountBalancesEndpoint.DecodedResponse, Error[]>;
    accountTransactions: (params: import("@radixdlt/networking").AccountTransactionsRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<Readonly<{
        cursor: string;
        transactions: Readonly<{
            txID: Readonly<{
                __witness: "isTXId";
                __hex: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>;
            sentAt: Date;
            status: import("..").TransactionStatus;
            fee: import("@radixdlt/uint256").UInt256;
            message?: string | undefined;
            actions: import("..").ExecutedAction[];
        }>[];
    }>, Error[]>;
    validator: (params: import("@radixdlt/networking").ValidatorRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<{
        address: import("packages/account/dist").ValidatorAddressT;
        ownerAddress: import("packages/account/dist").AccountAddressT;
        name: string;
        infoURL?: URL | undefined;
        totalDelegatedStake: import("@radixdlt/uint256").UInt256;
        ownerDelegation: import("@radixdlt/uint256").UInt256;
        validatorFee: number;
        registered: boolean;
        isExternalStakeAccepted: boolean;
        uptimePercentage: number;
        proposalsMissed: number;
        proposalsCompleted: number;
    }, Error[]>;
    validators: (params: import("@radixdlt/networking").ValidatorsRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<import("./open-api/_types").ValidatorsEndpoint.DecodedResponse, Error[]>;
    buildTransaction: (params: import("@radixdlt/networking").TransactionBuildRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<Readonly<{
        transaction: Readonly<{
            blob: string;
            hashOfBlobToSign: string;
        }>;
        fee: import("@radixdlt/uint256").UInt256;
    }>, Error[]>;
    finalizeTransaction: (params: import("@radixdlt/networking").TransactionFinalizeRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<Readonly<{
        blob: string;
        txID: Readonly<{
            __witness: "isTXId";
            __hex: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
    }>, Error[]>;
    submitTransaction: (params: import("@radixdlt/networking").TransactionSubmitRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<{
        txID: Readonly<{
            __witness: "isTXId";
            __hex: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
    }, Error[]>;
    getTransaction: (params: import("@radixdlt/networking").TransactionStatusRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<Readonly<{
        txID: Readonly<{
            __witness: "isTXId";
            __hex: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
        sentAt: Date;
        status: import("..").TransactionStatus;
        fee: import("@radixdlt/uint256").UInt256;
        message?: string | undefined;
        actions: import("..").ExecutedAction[];
    }>, Error[]>;
    recentTransactions: (params: import("@radixdlt/networking").RecentTransactionsRequest, headers?: Record<string, string> | undefined) => import("neverthrow").ResultAsync<Readonly<{
        cursor: string;
        transactions: Readonly<{
            txID: Readonly<{
                __witness: "isTXId";
                __hex: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>;
            sentAt: Date;
            status: import("..").TransactionStatus;
            fee: import("@radixdlt/uint256").UInt256;
            message?: string | undefined;
            actions: import("..").ExecutedAction[];
        }>[];
    }>, Error[]>;
};
//# sourceMappingURL=api.d.ts.map