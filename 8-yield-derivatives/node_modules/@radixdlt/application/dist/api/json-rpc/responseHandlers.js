"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleSubmitTransactionResponse = exports.handleFinalizeTransactionResponse = exports.handleBuildTransactionResponse = exports.handleNetworkxDemandResponse = exports.handleNetworkxThroughputResponse = exports.handleTransactionStatusResponse = exports.handleUnstakesResponse = exports.handleStakesResponse = exports.handleTokenInfoResponse = exports.handleLookupValidatorResponse = exports.handleValidatorsResponse = exports.handleTokenBalancesResponse = exports.handleNetworkIdResponse = exports.handleLookupTXResponse = exports.handleTransactionHistoryResponse = void 0;
const data_formats_1 = require("@radixdlt/data-formats");
const neverthrow_1 = require("neverthrow");
const ramda_1 = require("ramda");
const crypto_1 = require("@radixdlt/crypto");
const decoders_1 = require("../decoders");
const executedTXDecoders = data_formats_1.JSONDecoding.withDecoders((0, decoders_1.amountDecoder)('amount', 'fee'), (0, decoders_1.dateDecoder)('sentAt'), (0, decoders_1.addressDecoder)('from', 'to'), (0, decoders_1.validatorAddressDecoder)('validator'), (0, decoders_1.transactionIdentifierDecoder)('txID'), (0, decoders_1.RRIDecoder)('rri'));
const isRPCRequestFailureResponse = (something) => {
    const inspection = something;
    return inspection.failure !== undefined;
};
const hasRequiredProps = (methodName, obj, props) => {
    for (const prop of props) {
        if (obj[prop] === undefined) {
            return (0, neverthrow_1.err)([
                Error(`Prop validation failed for ${methodName} response. ${prop} was undefined.`),
            ]);
        }
    }
    return (0, neverthrow_1.ok)(obj);
};
const handleTransactionHistoryResponse = (json) => executedTXDecoders
    .create()(json)
    .andThen(decoded => (0, neverthrow_1.ok)(Object.assign(Object.assign({}, decoded), { transactions: decoded.transactions.map(tx => (Object.assign(Object.assign({}, tx), { message: (() => {
            if (!tx.message)
                return undefined;
            // Check format
            if (!/^(00|01)[0-9a-fA-F]+$/.test(tx.message))
                return '<Failed to interpret message>';
            return crypto_1.Message.isPlaintext(tx.message)
                ? crypto_1.Message.plaintextToString(Buffer.from(tx.message, 'hex'))
                : tx.message;
        })() }))) })));
exports.handleTransactionHistoryResponse = handleTransactionHistoryResponse;
const handleLookupTXResponse = (json) => executedTXDecoders
    .create()(json)
    .andThen(decoded => (0, neverthrow_1.ok)(Object.assign(Object.assign({}, decoded), { message: (() => {
        if (!decoded.message)
            return undefined;
        // Check format
        if (!/^(00|01)[0-9a-fA-F]+$/.test(decoded.message))
            return '<Failed to interpret message>';
        return crypto_1.Message.isPlaintext(decoded.message)
            ? crypto_1.Message.plaintextToString(Buffer.from(decoded.message, 'hex'))
            : decoded.message;
    })() })));
exports.handleLookupTXResponse = handleLookupTXResponse;
const handleNetworkIdResponse = (json) => data_formats_1.JSONDecoding.withDecoders((0, decoders_1.networkDecoder)('networkId'))
    .create()(json)
    .andThen(decoded => hasRequiredProps('networkId', decoded, ['networkId']));
exports.handleNetworkIdResponse = handleNetworkIdResponse;
const handleTokenBalancesResponse = (json) => (0, ramda_1.pipe)((json) => ({
    owner: json.owner,
    tokenBalances: json.tokenBalances.map(balance => ({
        tokenIdentifier: balance.rri,
        amount: balance.amount,
    })),
}), data_formats_1.JSONDecoding.withDecoders((0, decoders_1.addressDecoder)('owner'), (0, decoders_1.RRIDecoder)('tokenIdentifier'), (0, decoders_1.amountDecoder)('amount')).create())(json).andThen(decoded => hasRequiredProps('tokenBalances', decoded, ['owner', 'tokenBalances']));
exports.handleTokenBalancesResponse = handleTokenBalancesResponse;
const validatorDecoders = data_formats_1.JSONDecoding.withDecoders((0, decoders_1.validatorAddressDecoder)('address'), (0, decoders_1.addressDecoder)('ownerAddress'), (0, decoders_1.URLDecoder)('infoURL'), (0, decoders_1.amountDecoder)('totalDelegatedStake', 'ownerDelegation'));
const handleValidatorsResponse = (json) => validatorDecoders
    .create()(json)
    .andThen(decoded => hasRequiredProps('validators', decoded, ['cursor', 'validators']));
exports.handleValidatorsResponse = handleValidatorsResponse;
exports.handleLookupValidatorResponse = validatorDecoders.create();
const handleTokenInfoResponse = (json) => data_formats_1.JSONDecoding.withDecoders((0, decoders_1.RRIDecoder)('rri'), (0, decoders_1.amountDecoder)('granularity', 'currentSupply'), (0, decoders_1.URLDecoder)('tokenInfoURL', 'iconURL'))
    .create()(json)
    .andThen(decoded => hasRequiredProps('tokenInfo', decoded, [
    'name',
    'rri',
    'symbol',
    'granularity',
    'isSupplyMutable',
    'currentSupply',
    'tokenInfoURL',
    'iconURL',
]));
exports.handleTokenInfoResponse = handleTokenInfoResponse;
exports.handleStakesResponse = data_formats_1.JSONDecoding.withDecoders((0, decoders_1.validatorAddressDecoder)('validator'), (0, decoders_1.amountDecoder)('amount')).create();
exports.handleUnstakesResponse = data_formats_1.JSONDecoding.withDecoders((0, decoders_1.validatorAddressDecoder)('validator'), (0, decoders_1.amountDecoder)('amount'), (0, decoders_1.transactionIdentifierDecoder)('withdrawTxID')).create();
const handleTransactionStatusResponse = (json) => isRPCRequestFailureResponse(json)
    ? (0, neverthrow_1.err)([new Error(json.failure)])
    : data_formats_1.JSONDecoding.withDecoders((0, decoders_1.transactionIdentifierDecoder)('txID'))
        .create()(json)
        .andThen(decoded => hasRequiredProps('transactionStatus', decoded, [
        'txID',
        'status',
    ]));
exports.handleTransactionStatusResponse = handleTransactionStatusResponse;
const handleNetworkxThroughputResponse = (json) => data_formats_1.JSONDecoding.create()(json).andThen(decoded => hasRequiredProps('NetworkTransactionThroughput', decoded, ['tps']));
exports.handleNetworkxThroughputResponse = handleNetworkxThroughputResponse;
const handleNetworkxDemandResponse = (json) => data_formats_1.JSONDecoding.create()(json).andThen(decoded => hasRequiredProps('NetworkTransactionDemand', decoded, ['tps']));
exports.handleNetworkxDemandResponse = handleNetworkxDemandResponse;
const handleBuildTransactionResponse = (json) => data_formats_1.JSONDecoding.withDecoders((0, decoders_1.amountDecoder)('fee'))
    .create()(json)
    .andThen(decoded => hasRequiredProps('buildTransaction', decoded, [
    'transaction',
    'fee',
]));
exports.handleBuildTransactionResponse = handleBuildTransactionResponse;
const handleFinalizeTransactionResponse = (json) => isRPCRequestFailureResponse(json)
    ? (0, neverthrow_1.err)([new Error(json.failure)])
    : data_formats_1.JSONDecoding.withDecoders((0, decoders_1.transactionIdentifierDecoder)('txID'))
        .create()(json)
        .andThen(decoded => hasRequiredProps('finalizeTransaction', decoded, ['txID']));
exports.handleFinalizeTransactionResponse = handleFinalizeTransactionResponse;
const handleSubmitTransactionResponse = (json) => isRPCRequestFailureResponse(json)
    ? (0, neverthrow_1.err)([new Error(json.failure)])
    : data_formats_1.JSONDecoding.withDecoders((0, decoders_1.transactionIdentifierDecoder)('txID'))
        .create()(json)
        .andThen(decoded => hasRequiredProps('submitTransaction', decoded, ['txID']));
exports.handleSubmitTransactionResponse = handleSubmitTransactionResponse;
//# sourceMappingURL=responseHandlers.js.map