/// <reference types="node" />
import { ResultAsync } from 'neverthrow';
import { ApiMethod, BuildTransactionEndpoint, SubmitTransactionEndpoint, LookupTransactionEndpoint, NativeTokenEndpoint, NetworkIdEndpoint, NetworkTransactionDemandEndpoint, NetworkTransactionThroughputEndpoint, StakePositionsEndpoint, FinalizeTransactionEndpoint, TokenBalancesEndpoint, TokenInfoEndpoint, TransactionHistoryEndpoint, TransactionStatusEndpoint, UnstakePositionsEndpoint, ValidatorsEndpoint, LookupValidatorEndpoint } from './_types';
export declare const getAPI: (call: (endpoint: ApiMethod, params: Record<string, unknown>, headers?: Record<string, string> | undefined) => Promise<unknown>) => {
    "network.get_id": (params: NetworkIdEndpoint.Input) => ResultAsync<NetworkIdEndpoint.DecodedResponse, Error[]>;
    "account.get_balances": (params: TokenBalancesEndpoint.Input) => ResultAsync<Readonly<{
        owner: import("packages/account/dist").AccountAddressT;
        tokenBalances: Readonly<{
            tokenIdentifier: Readonly<{
                hash: Buffer;
                __witness: "isRRI";
                network: import("packages/primitives/dist").Network;
                name: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>;
            amount: import("@radixdlt/uint256").UInt256;
        }>[];
    }>, Error[]>;
    "validators.get_next_epoch_set": (params: ValidatorsEndpoint.Input) => ResultAsync<Readonly<{
        validators: Readonly<{
            address: import("packages/account/dist").ValidatorAddressT;
            ownerAddress: import("packages/account/dist").AccountAddressT;
            name: string;
            infoURL: URL;
            totalDelegatedStake: import("@radixdlt/uint256").UInt256;
            ownerDelegation: import("@radixdlt/uint256").UInt256;
            validatorFee: number;
            registered: boolean;
            isExternalStakeAccepted: boolean;
            uptimePercentage: number;
            proposalsMissed: number;
            proposalsCompleted: number;
        }>[];
    }>, Error[]>;
    "transactions.lookup_transaction": (params: LookupTransactionEndpoint.Input) => ResultAsync<Readonly<{
        txID: Readonly<{
            __witness: "isTXId";
            __hex: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
        sentAt: Date;
        status: import("../..").TransactionStatus;
        fee: import("@radixdlt/uint256").UInt256;
        message?: string | undefined;
        actions: import("../..").ExecutedAction[];
    }>, Error[]>;
    "validators.lookup_validator": (params: LookupValidatorEndpoint.Input) => ResultAsync<Readonly<{
        address: import("packages/account/dist").ValidatorAddressT;
        ownerAddress: import("packages/account/dist").AccountAddressT;
        name: string;
        infoURL: URL;
        totalDelegatedStake: import("@radixdlt/uint256").UInt256;
        ownerDelegation: import("@radixdlt/uint256").UInt256;
        validatorFee: number;
        registered: boolean;
        isExternalStakeAccepted: boolean;
        uptimePercentage: number;
        proposalsMissed: number;
        proposalsCompleted: number;
    }>, Error[]>;
    "account.get_transaction_history": (params: TransactionHistoryEndpoint.Input) => ResultAsync<Readonly<{
        cursor: string;
        transactions: Readonly<{
            txID: Readonly<{
                __witness: "isTXId";
                __hex: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>;
            sentAt: Date;
            status: import("../..").TransactionStatus;
            fee: import("@radixdlt/uint256").UInt256;
            message?: string | undefined;
            actions: import("../..").ExecutedAction[];
        }>[];
    }>, Error[]>;
    "tokens.get_native_token": (params: NativeTokenEndpoint.Input) => ResultAsync<Readonly<{
        name: string;
        rri: Readonly<{
            hash: Buffer;
            __witness: "isRRI";
            network: import("packages/primitives/dist").Network;
            name: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
        symbol: string;
        description?: string | undefined;
        granularity: import("@radixdlt/uint256").UInt256;
        isSupplyMutable: boolean;
        currentSupply: import("@radixdlt/uint256").UInt256;
        tokenInfoURL?: URL | undefined;
        iconURL?: URL | undefined;
    }>, Error[]>;
    "tokens.get_info": (params: TokenInfoEndpoint.Input) => ResultAsync<Readonly<{
        name: string;
        rri: Readonly<{
            hash: Buffer;
            __witness: "isRRI";
            network: import("packages/primitives/dist").Network;
            name: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
        symbol: string;
        description?: string | undefined;
        granularity: import("@radixdlt/uint256").UInt256;
        isSupplyMutable: boolean;
        currentSupply: import("@radixdlt/uint256").UInt256;
        tokenInfoURL?: URL | undefined;
        iconURL?: URL | undefined;
    }>, Error[]>;
    "account.get_stake_positions": (params: StakePositionsEndpoint.Input) => ResultAsync<import("../..").StakePositions, Error[]>;
    "account.get_unstake_positions": (params: UnstakePositionsEndpoint.Input) => ResultAsync<import("../..").UnstakePositions, Error[]>;
    "transactions.get_transaction_status": (params: TransactionStatusEndpoint.Input) => ResultAsync<Readonly<{
        txID: Readonly<{
            __witness: "isTXId";
            __hex: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
        status: import("../..").TransactionStatus;
    }>, Error[]>;
    "network.get_throughput": (params: NetworkTransactionThroughputEndpoint.Input) => ResultAsync<Readonly<{
        tps: number;
    }>, Error[]>;
    "network.get_demand": (params: NetworkTransactionDemandEndpoint.Input) => ResultAsync<Readonly<{
        tps: number;
    }>, Error[]>;
    "construction.build_transaction": (params: BuildTransactionEndpoint.Input) => ResultAsync<Readonly<{
        transaction: Readonly<{
            blob: string;
            hashOfBlobToSign: string;
        }>;
        fee: import("@radixdlt/uint256").UInt256;
    }>, Error[]>;
    "construction.finalize_transaction": (params: FinalizeTransactionEndpoint.Input) => ResultAsync<Readonly<{
        blob: string;
        txID: Readonly<{
            __witness: "isTXId";
            __hex: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
    }>, Error[]>;
    "construction.submit_transaction": (params: SubmitTransactionEndpoint.Input) => ResultAsync<Readonly<{
        txID: Readonly<{
            __witness: "isTXId";
            __hex: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
    }>, Error[]>;
};
//# sourceMappingURL=interface.d.ts.map