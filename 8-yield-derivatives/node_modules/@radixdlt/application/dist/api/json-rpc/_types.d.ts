import { Network } from '@radixdlt/primitives';
import { ActionType } from '../../actions';
import { SimpleExecutedTransaction, NetworkTransactionDemand, NetworkTransactionThroughput, PendingTransaction, RawExecutedTransaction, RawToken, FinalizedTransaction, StakePositions, StatusOfTransaction, Token, SimpleTransactionHistory, TransactionStatus, BuiltTransaction, UnstakePositions, Validators, SimpleTokenBalances, Validator, RawValidatorResponse } from '../../dto';
export declare enum ApiMethod {
    NETWORK_ID = "network.get_id",
    TOKEN_BALANCES = "account.get_balances",
    TRANSACTION_HISTORY = "account.get_transaction_history",
    STAKES = "account.get_stake_positions",
    UNSTAKES = "account.get_unstake_positions",
    TX_STATUS = "transactions.get_transaction_status",
    NETWORK_TX_THROUGHPUT = "network.get_throughput",
    NETWORK_TX_DEMAND = "network.get_demand",
    VALIDATORS = "validators.get_next_epoch_set",
    LOOKUP_TX = "transactions.lookup_transaction",
    LOOKUP_VALIDATOR = "validators.lookup_validator",
    NATIVE_TOKEN = "tokens.get_native_token",
    TOKEN_INFO = "tokens.get_info",
    BUILD_TX_FROM_INTENT = "construction.build_transaction",
    SUBMIT_TX = "construction.submit_transaction",
    FINALIZE_TX = "construction.finalize_transaction"
}
export declare namespace NetworkIdEndpoint {
    type Input = Record<string, never>;
    type Response = {
        networkId: number;
    };
    type DecodedResponse = {
        networkId: Network;
    };
}
export declare namespace TokenBalancesEndpoint {
    type Input = {
        address: string;
    };
    type Response = {
        owner: string;
        tokenBalances: {
            rri: string;
            amount: string;
        }[];
    };
    type DecodedResponse = SimpleTokenBalances;
}
export declare namespace TransactionHistoryEndpoint {
    type Input = {
        address: string;
        size: number;
        cursor?: string;
    };
    type Response = Readonly<{
        cursor: string;
        transactions: RawExecutedTransaction[];
    }>;
    type DecodedResponse = SimpleTransactionHistory;
}
export declare namespace LookupTransactionEndpoint {
    type Input = {
        txID: string;
    };
    type Response = RawExecutedTransaction;
    type DecodedResponse = SimpleExecutedTransaction;
}
export declare namespace TokenInfoEndpoint {
    type Input = {
        rri: string;
    };
    type Response = RawToken;
    type DecodedResponse = Token;
}
export declare namespace NativeTokenEndpoint {
    type Input = Record<string, never>;
    type Response = RawToken;
    type DecodedResponse = Token;
}
export declare namespace StakePositionsEndpoint {
    type Input = {
        address: string;
    };
    type Response = {
        validator: string;
        amount: string;
    }[];
    type DecodedResponse = StakePositions;
}
export declare namespace UnstakePositionsEndpoint {
    type Input = {
        address: string;
    };
    type Response = {
        amount: string;
        validator: string;
        epochsUntil: number;
        withdrawTxID: string;
    }[];
    type DecodedResponse = UnstakePositions;
}
export declare namespace TransactionStatusEndpoint {
    type Input = {
        txID: string;
    };
    type Response = {
        txID: string;
        status: TransactionStatus;
        failure?: string;
    };
    type DecodedResponse = StatusOfTransaction;
}
export declare namespace NetworkTransactionThroughputEndpoint {
    type Input = Record<string, never>;
    type Response = {
        tps: number;
    };
    type DecodedResponse = NetworkTransactionThroughput;
}
export declare namespace NetworkTransactionDemandEndpoint {
    type Input = Record<string, never>;
    type Response = {
        tps: number;
    };
    type DecodedResponse = NetworkTransactionDemand;
}
export declare namespace ValidatorsEndpoint {
    type Input = {
        size: number;
        cursor?: string;
    };
    type Response = Readonly<{
        cursor: string;
        validators: RawValidatorResponse[];
    }>;
    type DecodedResponse = Validators;
}
export declare namespace LookupValidatorEndpoint {
    type Input = {
        validatorAddress: string;
    };
    type Response = RawValidatorResponse;
    type DecodedResponse = Validator;
}
export declare namespace BuildTransactionEndpoint {
    type Failure = 'MALFORMED_TX' | 'INSUFFICIENT_FUNDS' | 'NOT_PERMITTED';
    type Input = {
        actions: ({
            type: ActionType.TOKEN_TRANSFER;
            from: string;
            to: string;
            amount: string;
            rri: string;
        } | {
            type: ActionType.STAKE_TOKENS;
            from: string;
            validator: string;
            amount: string;
        } | {
            type: ActionType.UNSTAKE_TOKENS;
            from: string;
            validator: string;
            amount: string;
        })[];
        feePayer: string;
        disableResourceAllocationAndDestroy?: boolean;
        message?: string;
    };
    type Response = {
        transaction: Readonly<{
            blob: string;
            hashOfBlobToSign: string;
        }>;
        fee: string;
    };
    type DecodedResponse = BuiltTransaction;
}
export declare namespace FinalizeTransactionEndpoint {
    type Input = {
        blob: string;
        publicKeyOfSigner: string;
        signatureDER: string;
    };
    type Response = {
        blob: string;
        txID: string;
    };
    type DecodedResponse = FinalizedTransaction;
}
export declare namespace SubmitTransactionEndpoint {
    type Input = {
        blob: string;
        txID: string;
    };
    type Response = {
        txID: string;
    };
    type DecodedResponse = PendingTransaction;
}
//# sourceMappingURL=_types.d.ts.map