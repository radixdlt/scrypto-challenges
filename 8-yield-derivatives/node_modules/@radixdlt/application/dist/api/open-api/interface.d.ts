/// <reference types="node" />
import { InputOfAPICall, ReturnOfAPICall } from '@radixdlt/networking';
import { ResultAsync } from 'neverthrow';
export declare const getAPI: (x0: <M extends "accountBalancesPost" | "accountDerivePost" | "accountStakesPost" | "accountTransactionsPost" | "accountUnstakesPost" | "validatorDerivePost" | "validatorPost" | "validatorStakesPost" | "validatorsPost" | "transactionBuildPost" | "transactionFinalizePost" | "transactionRecentPost" | "transactionRulesPost" | "transactionStatusPost" | "transactionSubmitPost" | "tokenDerivePost" | "tokenNativePost" | "tokenPost" | "gatewayPost">(method: M, params: InputOfAPICall<M>, headers?: Record<string, string> | undefined) => ResultAsync<ReturnOfAPICall<M>, Error>) => {
    gateway: (params: object, headers?: Record<string, string> | undefined) => ResultAsync<import("./_types").GatewayEndpoint.DecodedResponse, Error[]>;
    tokenInfo: (params: import("@radixdlt/networking").TokenRequest, headers?: Record<string, string> | undefined) => ResultAsync<Readonly<{
        name: string;
        rri: Readonly<{
            hash: Buffer;
            __witness: "isRRI";
            network: import("packages/primitives/dist").Network;
            name: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
        symbol: string;
        description?: string | undefined;
        granularity: import("@radixdlt/uint256").UInt256;
        isSupplyMutable: boolean;
        currentSupply: import("@radixdlt/uint256").UInt256;
        tokenInfoURL?: URL | undefined;
        iconURL?: URL | undefined;
    }>, Error[]>;
    nativeTokenInfo: (params: import("@radixdlt/networking").TokenNativeRequest, headers?: Record<string, string> | undefined) => ResultAsync<Readonly<{
        name: string;
        rri: Readonly<{
            hash: Buffer;
            __witness: "isRRI";
            network: import("packages/primitives/dist").Network;
            name: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
        symbol: string;
        description?: string | undefined;
        granularity: import("@radixdlt/uint256").UInt256;
        isSupplyMutable: boolean;
        currentSupply: import("@radixdlt/uint256").UInt256;
        tokenInfoURL?: URL | undefined;
        iconURL?: URL | undefined;
    }>, Error[]>;
    stakePositions: (params: import("@radixdlt/networking").AccountStakesRequest, headers?: Record<string, string> | undefined) => ResultAsync<import("./_types").StakePositionsEndpoint.DecodedResponse, Error[]>;
    unstakePositions: (params: import("@radixdlt/networking").AccountUnstakesRequest, headers?: Record<string, string> | undefined) => ResultAsync<import("./_types").UnstakePositionsEndpoint.DecodedResponse, Error[]>;
    accountBalances: (params: import("@radixdlt/networking").AccountBalancesRequest, headers?: Record<string, string> | undefined) => ResultAsync<import("./_types").AccountBalancesEndpoint.DecodedResponse, Error[]>;
    accountTransactions: (params: import("@radixdlt/networking").AccountTransactionsRequest, headers?: Record<string, string> | undefined) => ResultAsync<Readonly<{
        cursor: string;
        transactions: Readonly<{
            txID: Readonly<{
                __witness: "isTXId";
                __hex: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>;
            sentAt: Date;
            status: import("../..").TransactionStatus;
            fee: import("@radixdlt/uint256").UInt256;
            message?: string | undefined;
            actions: import("../..").ExecutedAction[];
        }>[];
    }>, Error[]>;
    validator: (params: import("@radixdlt/networking").ValidatorRequest, headers?: Record<string, string> | undefined) => ResultAsync<{
        address: import("packages/account/dist").ValidatorAddressT;
        ownerAddress: import("packages/account/dist").AccountAddressT;
        name: string;
        infoURL?: URL | undefined;
        totalDelegatedStake: import("@radixdlt/uint256").UInt256;
        ownerDelegation: import("@radixdlt/uint256").UInt256;
        validatorFee: number;
        registered: boolean;
        isExternalStakeAccepted: boolean;
        uptimePercentage: number;
        proposalsMissed: number;
        proposalsCompleted: number;
    }, Error[]>;
    validators: (params: import("@radixdlt/networking").ValidatorsRequest, headers?: Record<string, string> | undefined) => ResultAsync<import("./_types").ValidatorsEndpoint.DecodedResponse, Error[]>;
    buildTransaction: (params: import("@radixdlt/networking").TransactionBuildRequest, headers?: Record<string, string> | undefined) => ResultAsync<Readonly<{
        transaction: Readonly<{
            blob: string;
            hashOfBlobToSign: string;
        }>;
        fee: import("@radixdlt/uint256").UInt256;
    }>, Error[]>;
    finalizeTransaction: (params: import("@radixdlt/networking").TransactionFinalizeRequest, headers?: Record<string, string> | undefined) => ResultAsync<Readonly<{
        blob: string;
        txID: Readonly<{
            __witness: "isTXId";
            __hex: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
    }>, Error[]>;
    submitTransaction: (params: import("@radixdlt/networking").TransactionSubmitRequest, headers?: Record<string, string> | undefined) => ResultAsync<{
        txID: Readonly<{
            __witness: "isTXId";
            __hex: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
    }, Error[]>;
    getTransaction: (params: import("@radixdlt/networking").TransactionStatusRequest, headers?: Record<string, string> | undefined) => ResultAsync<Readonly<{
        txID: Readonly<{
            __witness: "isTXId";
            __hex: string;
            toString: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
        sentAt: Date;
        status: import("../..").TransactionStatus;
        fee: import("@radixdlt/uint256").UInt256;
        message?: string | undefined;
        actions: import("../..").ExecutedAction[];
    }>, Error[]>;
    recentTransactions: (params: import("@radixdlt/networking").RecentTransactionsRequest, headers?: Record<string, string> | undefined) => ResultAsync<Readonly<{
        cursor: string;
        transactions: Readonly<{
            txID: Readonly<{
                __witness: "isTXId";
                __hex: string;
                toString: () => string;
                equals: (other: Readonly<any>) => boolean;
            }>;
            sentAt: Date;
            status: import("../..").TransactionStatus;
            fee: import("@radixdlt/uint256").UInt256;
            message?: string | undefined;
            actions: import("../..").ExecutedAction[];
        }>[];
    }>, Error[]>;
};
//# sourceMappingURL=interface.d.ts.map