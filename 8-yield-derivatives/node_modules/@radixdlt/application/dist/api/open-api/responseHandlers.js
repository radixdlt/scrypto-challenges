"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleTransactionResponse = exports.handleSubmitTransactionResponse = exports.handleFinalizeTransactionResponse = exports.handleBuildTransactionResponse = exports.handleValidatorsResponse = exports.handleValidatorResponse = exports.handleAccountBalancesResponse = exports.handleRecentTransactionResponse = exports.handleAccountTransactionsResponse = exports.handleUnstakePositionsResponse = exports.handleStakePositionsResponse = exports.handleNativeTokenResponse = exports.handleTokenInfoResponse = exports.handleGatewayResponse = void 0;
const account_1 = require("@radixdlt/account");
const primitives_1 = require("@radixdlt/primitives");
const __1 = require("../..");
const neverthrow_1 = require("neverthrow");
const transformTokenAmount = (amount) => [
    primitives_1.Amount.fromUnsafe(amount.value),
    account_1.ResourceIdentifier.fromUnsafe(amount.token_identifier.rri),
];
const handleGatewayResponse = (json) => (0, neverthrow_1.ok)({
    // @ts-ignore
    network: json.data.network_identifier.network,
}).mapErr(e => [e]);
exports.handleGatewayResponse = handleGatewayResponse;
const handleTokenInfoResponse = (json) => (0, neverthrow_1.combine)([
    account_1.ResourceIdentifier.fromUnsafe(json.data.token.token_identifier.rri),
    primitives_1.Amount.fromUnsafe(json.data.token.token_properties.granularity),
    primitives_1.Amount.fromUnsafe(json.data.token.token_supply.value),
])
    .map(values => {
    var _a;
    return ({
        name: (_a = json.data.token.token_properties.name) !== null && _a !== void 0 ? _a : '',
        rri: values[0],
        symbol: json.data.token.token_properties.symbol,
        description: json.data.token.token_properties.description,
        granularity: values[1],
        isSupplyMutable: json.data.token.token_properties.is_supply_mutable,
        currentSupply: values[2],
        tokenInfoURL: json.data.token.token_properties.url
            ? new URL(json.data.token.token_properties.url)
            : undefined,
        iconURL: json.data.token.token_properties.icon_url
            ? new URL(json.data.token.token_properties.icon_url)
            : undefined,
    });
})
    .mapErr(e => [e]);
exports.handleTokenInfoResponse = handleTokenInfoResponse;
const handleNativeTokenResponse = (json) => (0, neverthrow_1.combine)([
    account_1.ResourceIdentifier.fromUnsafe(json.data.token.token_identifier.rri),
    primitives_1.Amount.fromUnsafe(json.data.token.token_properties.granularity),
    primitives_1.Amount.fromUnsafe(json.data.token.token_supply.value),
])
    .map(values => {
    var _a;
    return ({
        name: (_a = json.data.token.token_properties.name) !== null && _a !== void 0 ? _a : '',
        rri: values[0],
        symbol: json.data.token.token_properties.symbol,
        description: json.data.token.token_properties.description,
        granularity: values[1],
        isSupplyMutable: json.data.token.token_properties.is_supply_mutable,
        currentSupply: values[2],
        tokenInfoURL: json.data.token.token_properties.url
            ? new URL(json.data.token.token_properties.url)
            : undefined,
        iconURL: json.data.token.token_properties.icon_url
            ? new URL(json.data.token.token_properties.icon_url)
            : undefined,
    });
})
    .mapErr(e => [e]);
exports.handleNativeTokenResponse = handleNativeTokenResponse;
const transformStakeEntry = (stake) => (0, neverthrow_1.combine)([
    account_1.ValidatorAddress.fromUnsafe(stake.validator_identifier.address),
    primitives_1.Amount.fromUnsafe(stake.delegated_stake.value),
]).map(value => ({
    validator: value[0],
    amount: value[1],
}));
const transformUnstakeEntry = (unstake) => (0, neverthrow_1.combine)([
    account_1.ValidatorAddress.fromUnsafe(unstake.validator_identifier.address),
    primitives_1.Amount.fromUnsafe(unstake.unstaking_amount.value),
    (0, neverthrow_1.ok)(unstake.epochs_until_unlocked),
]).map(value => ({
    validator: value[0],
    amount: value[1],
    epochsUntil: value[2],
}));
const handleStakePositionsResponse = (json) => (0, neverthrow_1.combine)(json.data.stakes.map(transformStakeEntry))
    .andThen(stakes => (0, neverthrow_1.combine)(json.data.pending_stakes.map(transformStakeEntry)).map(pendingStakes => ({ stakes, pendingStakes })))
    .mapErr(e => [e]);
exports.handleStakePositionsResponse = handleStakePositionsResponse;
const handleUnstakePositionsResponse = (json) => {
    return (0, neverthrow_1.combine)(json.data.pending_unstakes.map(transformUnstakeEntry))
        .map(pendingUnstakes => (0, neverthrow_1.combine)(json.data.unstakes.map(transformUnstakeEntry)).map(unstakes => ({
        pendingUnstakes,
        unstakes,
    })))
        .andThen(res => res)
        .mapErr(e => [e]);
};
exports.handleUnstakePositionsResponse = handleUnstakePositionsResponse;
const handleAccountTransactionsResponse = (json) => (0, neverthrow_1.combine)(json.data.transactions.map(handleTx)).map((transactions) => ({
    cursor: json.data.next_cursor,
    // @ts-ignore
    transactions,
}));
exports.handleAccountTransactionsResponse = handleAccountTransactionsResponse;
const handleRecentTransactionResponse = (json) => (0, neverthrow_1.combine)(json.data.transactions.map(handleTx)).map((transactions) => ({
    cursor: json.data.next_cursor,
    // @ts-ignore
    transactions,
}));
exports.handleRecentTransactionResponse = handleRecentTransactionResponse;
// export const handleAccountTransactionsResponse = (
// 	json: ReturnOfAPICall<'accountTransactionsPost'>,
// ) =>
// 	JSONDecoding.withDecoders(
// 		transactionIdentifierDecoder('hash'),
// 		dateDecoder('timestamp'),
// 		...tokenDecoders,
// 	)
// 		.create<
// 			AccountTransactionsEndpoint.Response,
// 			AccountTransactionsEndpoint.DecodedResponse
// 		>()(json)
// 		.andThen(decoded =>
// 			hasRequiredProps('accountTransactions', decoded, [
// 				'ledger_state',
// 				'total_count',
// 				'transactions',
// 			]),
// 		)
/*
export const handleDerivetoken_identifierResponse = (
    json: ReturnOfAPICall<'tokenDerivePost'>,
) =>
    JSONDecoding.withDecoders(RRIDecoder('rri'))
        .create<
            DeriveTokenIdentifierEndpoint.Response,
            DeriveTokenIdentifierEndpoint.DecodedResponse
        >()(json)
        .andThen(decoded =>
            hasRequiredProps('deriveTokenIdentifier', decoded, [
                'token_identifier',
            ]),
        )
*/
const transformUrl = (url) => {
    try {
        return new URL(url);
    }
    catch (error) {
        return undefined;
    }
};
const transformValidator = (validator) => (0, neverthrow_1.combine)([
    account_1.ValidatorAddress.fromUnsafe(validator.validator_identifier.address),
    account_1.AccountAddress.fromUnsafe(validator.properties.owner_account_identifier.address),
    primitives_1.Amount.fromUnsafe(validator.stake.value),
    primitives_1.Amount.fromUnsafe(validator.info.owner_stake.value),
]).map((values) => ({
    address: values[0],
    ownerAddress: values[1],
    name: validator.properties.name,
    infoURL: transformUrl(validator.properties.url),
    totalDelegatedStake: values[2],
    ownerDelegation: values[3],
    validatorFee: validator.properties.validator_fee_percentage,
    registered: validator.properties.registered,
    isExternalStakeAccepted: validator.properties.external_stake_accepted,
    uptimePercentage: validator.info.uptime.uptime_percentage,
    proposalsMissed: validator.info.uptime.proposals_missed,
    proposalsCompleted: validator.info.uptime.proposals_completed,
}));
const handleAccountBalancesResponse = (json) => {
    const liquidBalancesResults = (0, neverthrow_1.combine)(json.data.account_balances.liquid_balances.map(balance => (0, neverthrow_1.combine)([
        primitives_1.Amount.fromUnsafe(balance.value),
        account_1.ResourceIdentifier.fromUnsafe(balance.token_identifier.rri),
    ]).map(values => ({
        value: values[0],
        token_identifier: {
            rri: values[1],
        },
    }))));
    return (0, neverthrow_1.combine)([
        liquidBalancesResults.map(balances => ({ balances })),
        account_1.ResourceIdentifier.fromUnsafe(json.data.account_balances.staked_and_unstaking_balance
            .token_identifier.rri),
        primitives_1.Amount.fromUnsafe(json.data.account_balances.staked_and_unstaking_balance.value),
    ])
        .map(values => ({
        ledger_state: Object.assign(Object.assign({}, json.data.ledger_state), { timestamp: new Date(json.data.ledger_state.timestamp) }),
        account_balances: {
            // @ts-ignore
            liquid_balances: values[0].balances,
            staked_and_unstaking_balance: {
                token_identifier: {
                    rri: values[1],
                },
                value: values[2],
            },
        },
    }))
        .mapErr(e => [e]);
};
exports.handleAccountBalancesResponse = handleAccountBalancesResponse;
const handleValidatorResponse = (json) => transformValidator(json.data.validator).mapErr(e => [e]);
exports.handleValidatorResponse = handleValidatorResponse;
const handleValidatorsResponse = (json) => (0, neverthrow_1.combine)(json.data.validators.map(transformValidator))
    .map(validators => ({ validators }))
    .mapErr(e => [e]);
exports.handleValidatorsResponse = handleValidatorsResponse;
/*

export const handleStakePositionsResponse = (
    json: ReturnOfAPICall<'accountStakesPost'>,
) => combine([

]).mapErr(e => [e])

json.stakes.map(stake => combine([
    ValidatorAddress.fromUnsafe(stake.validatorIdentifier.address),
    Amount.fromUnsafe(stake.delegatedStake.value)
]).map(values => ({
    validator: values[0] as ValidatorAddressT,
    amount: values[1] as AmountT
})

    export const handleUnstakePositionsResponse = (
        json: ReturnOfAPICall<'accountUnstakesPost'>,
    ) =>
        JSONDecoding.withDecoders(
            RRIDecoder('rri'),
            amountDecoder('value'),
            validatorAddressDecoder('address'),
            dateDecoder('timestamp'),
        )
            .create<
                UnstakePositionsEndpoint.Response,
                UnstakePositionsEndpoint.DecodedResponse
            >()(json)
            .andThen(decoded =>
                hasRequiredProps('unstakePositions', decoded, [
                    'ledger_state',
                    'unstakes',
                ]),
            )

    export const handleAccountTransactionsResponse = (
        json: ReturnOfAPICall<'accountTransactionsPost'>,
    ) =>
        JSONDecoding.withDecoders(
            transactionIdentifierDecoder('hash'),
            dateDecoder('timestamp'),
            ...tokenDecoders,
        )
            .create<
                AccountTransactionsEndpoint.Response,
                AccountTransactionsEndpoint.DecodedResponse
            >()(json)
            .andThen(decoded =>
                hasRequiredProps('accountTransactions', decoded, [
                    'ledger_state',
                    'total_count',
                    'transactions',
                ]),
            )

    export const handleValidatorResponse = (
        json: ReturnOfAPICall<'validatorPost'>,
    ) =>
        JSONDecoding.withDecoders(...validatorDecoders, dateDecoder('timestamp'))
            .create<
                ValidatorEndpoint.Response,
                ValidatorEndpoint.DecodedResponse
            >()(json)
            .andThen(decoded =>
                hasRequiredProps('validator', decoded, [
                    'ledger_state',
                    'validator',
                ]),
            )

    export const handleValidatorsResponse = (
        json: ReturnOfAPICall<'validatorsPost'>,
    ) =>
        JSONDecoding.withDecoders(...validatorDecoders, dateDecoder('timestamp'))
            .create<
                ValidatorsEndpoint.Response,
                ValidatorsEndpoint.DecodedResponse
            >()(json)
            .andThen(decoded =>
                hasRequiredProps('validators', decoded, [
                    'ledger_state',
                    'validators',
                ]),
            )

    export const handleTransactionRulesResponse = (
        json: ReturnOfAPICall<'transactionRulesPost'>,
    ) =>
        JSONDecoding.withDecoders(
            amountDecoder('value'),
            RRIDecoder('rri'),
            dateDecoder('timestamp'),
        )
            .create<
                TransactionRulesEndpoint.Response,
                TransactionRulesEndpoint.DecodedResponse
            >()(json)
            .andThen(decoded =>
                hasRequiredProps('transactionRules', decoded, [
                    'ledger_state',
                    'transaction_rules',
                ]),
            )
*/
const handleBuildTransactionResponse = (json) => primitives_1.Amount.fromUnsafe(json.data.transaction_build.fee.value)
    .map(amount => ({
    transaction: {
        blob: json.data.transaction_build.unsigned_transaction,
        hashOfBlobToSign: json.data.transaction_build.payload_to_sign,
    },
    fee: amount,
}))
    .mapErr(e => [e]);
exports.handleBuildTransactionResponse = handleBuildTransactionResponse;
const handleFinalizeTransactionResponse = (json) => __1.TransactionIdentifier.create(json.data.transaction_identifier.hash)
    .map(txID => ({
    blob: json.data.signed_transaction,
    txID,
}))
    .mapErr(e => [e]);
exports.handleFinalizeTransactionResponse = handleFinalizeTransactionResponse;
const handleSubmitTransactionResponse = (json) => __1.TransactionIdentifier.create(json.data.transaction_identifier.hash)
    .map(txID => ({
    txID,
}))
    .mapErr(e => [e]);
exports.handleSubmitTransactionResponse = handleSubmitTransactionResponse;
const handleTransactionResponse = (json) => handleTx(json.data.transaction);
exports.handleTransactionResponse = handleTransactionResponse;
const handleTx = (transaction) => {
    var _a;
    const transformAction = (action) => {
        const transformTransferTokenAction = (action) => (0, neverthrow_1.combine)([
            ...(action.amount ? transformTokenAmount(action.amount) : []),
        ]).map((actionValue) => ({
            type: __1.ActionType.TOKEN_TRANSFER,
            to_account: action.to_account.address,
            from_account: action.from_account.address,
            amount: actionValue[0],
            rri: actionValue[1],
        }));
        const transformStakeTokenAction = (type, action) => (0, neverthrow_1.combine)([...transformTokenAmount(action.amount)]).map((actionValue) => ({
            type,
            amount: actionValue[0],
            rri: actionValue[1],
            to_validator: action.to_validator.address,
            from_account: action.from_account.address,
        }));
        const transformUnstakeTokenAction = (type, action) => {
            var _a;
            return (0, neverthrow_1.combine)([
                primitives_1.Amount.fromUnsafe((_a = action.unstake_percentage) !== null && _a !== void 0 ? _a : 0),
                ...(action.amount ? transformTokenAmount(action.amount) : []),
            ]).map((actionValue) => ({
                type,
                from_validator: action.from_validator.address,
                to_account: action.to_account.address,
                unstake_percentage: actionValue[0],
                amount: actionValue[1],
                rri: actionValue[2],
            }));
        };
        const transformMintTokenAction = (type, action) => (0, neverthrow_1.combine)(transformTokenAmount(action.amount)).map((actionValue) => ({
            type: __1.ActionType.MINT_TOKENS,
            to_account: action.to_account.address,
            amount: actionValue[0],
            rri: actionValue[1],
        }));
        const transformBurnTokenAction = (type, action) => (0, neverthrow_1.combine)(transformTokenAmount(action.amount)).map((actionValue) => ({
            type: __1.ActionType.BURN_TOKENS,
            from_account: action.from_account.address,
            amount: actionValue[0],
            rri: actionValue[1],
        }));
        const transformCreateTokenDefinitionAction = (type, action) => (0, neverthrow_1.combine)(transformTokenAmount(action.token_supply)).map((actionValue) => {
            var _a, _b;
            return ({
                type: __1.ActionType.CREATE_TOKEN_DEFINITION,
                amount: actionValue[0],
                rri: actionValue[1],
                owner: (_a = action.token_properties.owner) === null || _a === void 0 ? void 0 : _a.address,
                to_account: (_b = action.to_account) === null || _b === void 0 ? void 0 : _b.address,
                name: action.token_properties.name,
                description: action.token_properties.description,
                icon_url: action.token_properties.icon_url,
                url: action.token_properties.url,
                symbol: action.token_properties.symbol,
                granularity: action.token_properties.granularity,
                is_supply_mutable: action.token_properties.is_supply_mutable,
            });
        });
        switch (action.type) {
            case 'TransferTokens':
                return transformTransferTokenAction(action);
            case 'StakeTokens':
                return transformStakeTokenAction(__1.ActionType.STAKE_TOKENS, action);
            case 'UnstakeTokens':
                return transformUnstakeTokenAction(__1.ActionType.UNSTAKE_TOKENS, action);
            case 'MintTokens':
                return transformMintTokenAction(__1.ActionType.MINT_TOKENS, action);
            case 'BurnTokens':
                return transformBurnTokenAction(__1.ActionType.BURN_TOKENS, action);
            case 'CreateTokenDefinition':
                return transformCreateTokenDefinitionAction(__1.ActionType.CREATE_TOKEN_DEFINITION, action);
            default:
                return (0, neverthrow_1.ok)(Object.assign(Object.assign({}, action), { type: __1.ActionType.OTHER }));
        }
    };
    return (0, neverthrow_1.combine)([
        __1.TransactionIdentifier.create(transaction.transaction_identifier.hash),
        (0, neverthrow_1.ok)(transaction.transaction_status.confirmed_time
            ? new Date(transaction.transaction_status.confirmed_time)
            : null),
        primitives_1.Amount.fromUnsafe(transaction.fee_paid.value),
        (0, neverthrow_1.ok)((_a = transaction.metadata.message) !== null && _a !== void 0 ? _a : ''),
        (0, neverthrow_1.combine)(transaction.actions.map(transformAction)).map(actions => ({
            actions,
        })),
        (0, neverthrow_1.ok)(transaction.transaction_status.status),
    ])
        .map(value => ({
        txID: value[0],
        sentAt: value[1],
        fee: value[2],
        message: value[3],
        // @ts-ignore
        actions: value[4].actions,
        status: value[5],
    }))
        .mapErr(e => [e]);
};
//# sourceMappingURL=responseHandlers.js.map