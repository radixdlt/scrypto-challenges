"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.radixCoreAPI = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const actions_1 = require("../actions");
const util_1 = require("../../../util");
const radixCoreAPI = (node, api) => {
    let headers;
    const toObs = (pickFn, input) => 
    // @ts-ignore
    (0, rxjs_1.defer)(() => {
        const fn = pickFn(api);
        // @ts-ignore
        return (0, util_1.toObservable)(fn(input, headers));
    });
    const toObsMap = (pickFn, mapOutput, input) => toObs(pickFn, input).pipe((0, operators_1.map)(o => mapOutput(o)));
    return {
        setHeaders: (newHeaders) => (headers = newHeaders),
        node,
        validators: (input) => toObs(a => a['validators'], {
            network_identifier: { network: input },
        }),
        lookupValidator: (input) => toObs(a => a['validator'], {
            network_identifier: { network: input.network },
            validator_identifier: {
                address: input.toString(),
            },
        }),
        networkId: () => toObsMap(a => a['gateway'], m => m.network, {
            body: {},
        }),
        tokenBalancesForAddress: (address) => toObs(a => a['accountBalances'], {
            network_identifier: { network: address.network },
            account_identifier: {
                address: address.toString(),
            },
        }),
        transactionHistory: (input) => {
            var _a;
            return toObs(a => a['accountTransactions'], {
                account_identifier: {
                    address: input.address.toString(),
                },
                network_identifier: { network: input.address.network },
                limit: input.size,
                cursor: (_a = input.cursor) === null || _a === void 0 ? void 0 : _a.toString(),
            });
        },
        recentTransactions: (input) => {
            var _a;
            return toObs(a => a['recentTransactions'], {
                cursor: (_a = input.cursor) === null || _a === void 0 ? void 0 : _a.toString(),
                network_identifier: { network: input.network },
            });
        },
        nativeToken: (network) => toObs(a => a['nativeTokenInfo'], {
            network_identifier: { network },
        }),
        tokenInfo: (rri) => toObs(a => a['tokenInfo'], {
            network_identifier: { network: rri.network },
            token_identifier: {
                rri: rri.toString(),
            },
        }),
        stakesForAddress: (address) => toObs(a => a['stakePositions'], {
            network_identifier: { network: address.network },
            account_identifier: {
                address: address.toString(),
            },
        }),
        unstakesForAddress: (address) => toObs(a => a['unstakePositions'], {
            network_identifier: { network: address.network },
            account_identifier: {
                address: address.toString(),
            },
        }),
        transactionStatus: (txID, network) => toObs(a => a['getTransaction'], {
            network_identifier: { network },
            transaction_identifier: {
                hash: txID.toString(),
            },
        }),
        buildTransaction: (transactionIntent, from) => toObs(a => a['buildTransaction'], {
            network_identifier: { network: from.network },
            actions: transactionIntent.actions.map(action => action.type === actions_1.ActionType.TOKEN_TRANSFER
                ? {
                    type: 'TransferTokens',
                    from_account: {
                        address: action.from_account.toString(),
                    },
                    to_account: {
                        address: action.to_account.toString(),
                    },
                    amount: {
                        value: action.amount.toString(),
                        token_identifier: {
                            rri: action.rri.toString(),
                        },
                    },
                }
                : action.type === actions_1.ActionType.STAKE_TOKENS
                    ? {
                        type: 'StakeTokens',
                        from_account: {
                            address: action.from_account.toString(),
                        },
                        to_validator: {
                            address: action.to_validator.toString(),
                        },
                        amount: {
                            value: action.amount.toString(),
                            token_identifier: {
                                rri: action.rri.toString(),
                            },
                        },
                    }
                    : Object.assign({
                        type: 'UnstakeTokens',
                        from_validator: {
                            address: action.from_validator.toString(),
                        },
                        to_account: {
                            address: action.to_account.toString(),
                        },
                    }, action.amount.valueOf() != 0
                        ? {
                            amount: {
                                value: action.amount.toString(),
                                token_identifier: {
                                    rri: action.rri.toString(),
                                },
                            },
                        }
                        : {
                            unstake_percentage: action.unstake_percentage.valueOf(),
                        })),
            fee_payer: {
                address: from.toString(),
            },
            message: transactionIntent.message
                ? transactionIntent.message.toString('hex')
                : undefined,
            disable_token_mint_and_burn: true,
        }),
        finalizeTransaction: (network, signedTransaction) => toObs(a => a['finalizeTransaction'], {
            network_identifier: { network },
            unsigned_transaction: signedTransaction.transaction.blob,
            signature: {
                bytes: signedTransaction.signature.toDER(),
                public_key: {
                    hex: signedTransaction.publicKeyOfSigner.toString(),
                },
            },
        }),
        submitSignedTransaction: (network, finalizedTx) => toObs(a => a['submitTransaction'], {
            network_identifier: { network },
            signed_transaction: finalizedTx.blob,
        }),
    };
};
exports.radixCoreAPI = radixCoreAPI;
//# sourceMappingURL=radixCoreAPI.js.map