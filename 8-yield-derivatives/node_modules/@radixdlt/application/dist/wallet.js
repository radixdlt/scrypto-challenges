"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = void 0;
const account_1 = require("@radixdlt/account");
const rxjs_1 = require("rxjs");
const account_2 = require("./account");
const operators_1 = require("rxjs/operators");
const create = (input) => {
    const { network, signingKeychain } = input;
    const skToAccountAddress = (signingKey) => account_1.AccountAddress.fromPublicKeyAndNetwork({
        network,
        publicKey: signingKey.publicKey,
    });
    const skToAccount = (signingKey) => account_2.Account.create({ signingKey, address: skToAccountAddress(signingKey) });
    const sksToAccounts = (signingKeys) => {
        const getAccountWithHDSigningKeyByHDPath = (hdPath) => signingKeys.getHDSigningKeyByHDPath(hdPath).map(skToAccount);
        const getAnyAccountByPublicKey = (publicKey) => signingKeys.getAnySigningKeyByPublicKey(publicKey).map(skToAccount);
        const all = signingKeys.all.map(skToAccount);
        return {
            all,
            getAccountWithHDSigningKeyByHDPath,
            getAnyAccountByPublicKey,
            accountsWithHDSigningKeys: () => signingKeys.hdSigningKeys().map(skToAccount),
            accountsWithHardwareHDSigningKeys: () => signingKeys.hardwareHDSigningKeys().map(skToAccount),
            accountsWithLocalHDSigningKeys: () => signingKeys.localHDSigningKeys().map(skToAccount),
            accountsWithNonHDSigningKeys: () => signingKeys.nonHDSigningKeys().map(skToAccount),
            size: () => all.length,
        };
    };
    const observeActiveAccount = () => signingKeychain.observeActiveSigningKey().pipe((0, operators_1.map)(skToAccount));
    return {
        __unsafeGetAccount: () => skToAccount(signingKeychain.__unsafeGetSigningKey()),
        revealMnemonic: signingKeychain.revealMnemonic,
        deriveNextLocalHDAccount: (input) => signingKeychain
            .deriveNextLocalHDSigningKey(input)
            .pipe((0, operators_1.map)(skToAccount)),
        deriveHWAccount: (input) => signingKeychain.deriveHWSigningKey(input).pipe((0, operators_1.map)(skToAccount)),
        displayAddressForActiveHWAccountOnHWDeviceForVerification: () => signingKeychain
            .__unsafeGetSigningKey()
            .getPublicKeyDisplayOnlyAddress()
            .pipe((0, operators_1.mergeMap)(() => {
            return (0, rxjs_1.of)(undefined);
        })),
        observeActiveAccount,
        observeAccounts: () => signingKeychain.observeSigningKeys().pipe((0, operators_1.map)(sksToAccounts)),
        addAccountFromPrivateKey: (input) => (0, rxjs_1.of)(skToAccount(signingKeychain.addSigningKeyFromPrivateKey(input))),
        restoreLocalHDAccountsToIndex: (index) => signingKeychain
            .restoreLocalHDSigningKeysUpToIndex(index)
            .pipe((0, operators_1.map)(sksToAccounts)),
        switchAccount: (input) => {
            const isSwitchToAccount = (something) => {
                const inspection = input;
                return (inspection.toAccount !== undefined &&
                    (0, account_2.isAccount)(inspection.toAccount));
            };
            if (isSwitchToAccount(input)) {
                return skToAccount(signingKeychain.switchSigningKey({
                    toSigningKey: input.toAccount.signingKey,
                }));
            }
            else {
                return skToAccount(signingKeychain.switchSigningKey(input));
            }
        },
    };
};
exports.Wallet = {
    create,
};
//# sourceMappingURL=wallet.js.map