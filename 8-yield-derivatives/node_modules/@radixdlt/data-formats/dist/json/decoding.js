"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONDecoding = exports.decoder = void 0;
const neverthrow_1 = require("neverthrow");
const ramda_1 = require("ramda");
const util_1 = require("@radixdlt/util");
/**
 * Creates a new decoder. A decoder defines a way to transform a key-value pair through a
 * supplied algorithm.
 */
const decoder = (algorithm) => (value, key) => algorithm(value, key);
exports.decoder = decoder;
const applyDecoders = (decoders, value, key) => {
    let unwrappedValue;
    if (util_1.isResult(value)) {
        if (value.isOk()) {
            unwrappedValue = value.value;
        }
        else {
            return value;
        }
    }
    else {
        unwrappedValue = value;
    }
    const results = decoders
        .map(decoder => decoder(unwrappedValue, key))
        .filter(result => result !== undefined);
    return results.length > 1
        ? neverthrow_1.err(Error(`JSON decoding failed. Several decoders were valid for key/value pair. 
                    This can lead to unexpected behavior.`))
        : results[0]
            ? results[0]
            : neverthrow_1.ok(unwrappedValue);
};
const JSONDecode = (...decoders) => (json) => {
    const decode = JSONDecodeUnflattened(...decoders);
    return ramda_1.pipe(
    //applyDecoders.bind(null, decoders),
    util_1.flattenResultsObject)(decode(json));
};
/**
 * Main decoding logic. Uses the registered decoders and applies matching decoders to
 * all key-value pairs in the supplied JSON.
 */
const JSONDecodeUnflattened = (...decoders) => (json) => util_1.isObject(json)
    ? util_1.flattenResultsObject(neverthrow_1.ok(ramda_1.mapObjIndexed((value, key) => applyDecoders(decoders, JSONDecodeUnflattened(...decoders)(value), key), json)))
    : util_1.isString(json) || util_1.isBoolean(json) || util_1.isNumber(json)
        ? applyDecoders(decoders, json).mapErr(err => [err])
        : util_1.isArray(json)
            ? neverthrow_1.combine(json.map(item => JSONDecodeUnflattened(...decoders)(item))).mapErr(err => err)
            : neverthrow_1.err([Error('JSON decoding failed. Unknown data type.')]);
const withDecoders = (...decoders) => ({
    create: () => JSONDecode(...decoders),
});
exports.JSONDecoding = {
    withDecoders,
    create: () => JSONDecode(...[]),
};
//# sourceMappingURL=decoding.js.map