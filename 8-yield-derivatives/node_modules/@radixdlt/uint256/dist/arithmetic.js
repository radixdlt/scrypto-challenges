"use strict";
exports.__esModule = true;
exports.ALPHABET = '0123456789abcdef';
exports.BYTES = 32;
exports.BYTE_MASK = 0xff;
exports.WORDS = exports.BYTES / 2;
exports.WORD_LENGTH = 16;
exports.WORD_MASK = 0xffff;
exports.DWORDS = exports.BYTES / 4;
exports.DWORD_LENGTH = 32;
exports.DWORD_MASK = 0xffffffff;
exports.JSNUMBER_MAX_INTEGER = 9007199254740991;
exports.RADIX_MIN = 2;
exports.RADIX_MAX = 16;
function fromHex(buffer, str, prefixed) {
    if (str.length < ((prefixed && 3) || 1)) {
        return 1;
    }
    var min = (prefixed && 2) || 0;
    var pd = new Uint8Array(buffer);
    var i = 0;
    var p = str.length - 1;
    while (p >= min && i < exports.BYTES) {
        // tslint:disable-next-line:no-increment-decrement
        var val = parseInt(str.substr(p--, 1), 16);
        if (isNaN(val)) {
            return 1;
        }
        pd[i] = val;
        if (p >= min) {
            // tslint:disable-next-line:no-increment-decrement
            val = parseInt(str.substr(p--, 1), 16);
            if (isNaN(val)) {
                return 1;
            }
            pd[i] |= val << 4;
            i += 1;
        }
    }
    return 0;
}
exports.fromHex = fromHex;
function toHex(buffer) {
    var ret = [];
    var hasVal = false;
    var pd = new Uint8Array(buffer);
    for (var i = pd.length; i; i -= 1) {
        if (!hasVal && !pd[i - 1]) {
            continue;
        }
        ret.push(exports.ALPHABET[pd[i - 1] >>> 4]);
        ret.push(exports.ALPHABET[pd[i - 1] & 0x0f]);
        hasVal = true;
    }
    while (ret.length && ret[0] === '0') {
        ret.shift();
    }
    return ret.join('') || '0';
}
exports.toHex = toHex;
function toNumber(buffer) {
    var ret = 0;
    var pd = new Uint32Array(buffer);
    for (var i = 0; i < pd.length; i += 1) {
        if (pd[i]) {
            ret += pd[i] * Math.pow(0x100000000, i);
        }
    }
    return ret;
}
exports.toNumber = toNumber;
function numberToBuffer(num) {
    var buffer = new ArrayBuffer(exports.BYTES);
    var buffer32 = new Uint32Array(buffer);
    buffer32[0] = num;
    buffer32[1] = num / (exports.DWORD_MASK + 1);
    return buffer;
}
exports.numberToBuffer = numberToBuffer;
function add(lval, rval) {
    if (typeof rval === 'number') {
        rval = numberToBuffer(rval);
    }
    var mem = new Uint32Array(2);
    var lv = new Uint16Array(lval);
    var rv = new Uint16Array(rval);
    for (var i = 0; i < exports.WORDS; i += 1) {
        mem[0] = mem[1] + lv[i] + rv[i];
        lv[i] = mem[0] & exports.WORD_MASK;
        mem[1] = mem[0] >>> exports.WORD_LENGTH;
    }
}
exports.add = add;
function not(lval) {
    var lv = new Uint32Array(lval);
    for (var i = 0; i < lv.length; i += 1) {
        lv[i] = ~lv[i];
    }
}
exports.not = not;
function and(lval, rval) {
    if (typeof rval === 'number') {
        rval = numberToBuffer(rval);
    }
    var lv = new Uint32Array(lval);
    var rv = new Uint32Array(rval);
    for (var i = 0; i < lv.length; i += 1) {
        lv[i] &= rv[i];
    }
}
exports.and = and;
function andNot(lval, rval) {
    if (typeof rval === 'number') {
        rval = numberToBuffer(rval);
    }
    var lv = new Uint32Array(lval);
    var rv = new Uint32Array(rval);
    for (var i = 0; i < lv.length; i += 1) {
        lv[i] &= ~rv[i];
    }
}
exports.andNot = andNot;
function or(lval, rval) {
    if (typeof rval === 'number') {
        rval = numberToBuffer(rval);
    }
    var lv = new Uint32Array(lval);
    var rv = new Uint32Array(rval);
    for (var i = 0; i < lv.length; i += 1) {
        lv[i] |= rv[i];
    }
}
exports.or = or;
function xor(lval, rval) {
    if (typeof rval === 'number') {
        rval = numberToBuffer(rval);
    }
    var lv = new Uint32Array(lval);
    var rv = new Uint32Array(rval);
    for (var i = 0; i < lv.length; i += 1) {
        lv[i] ^= rv[i];
    }
}
exports.xor = xor;
function comp(lval) {
    not(lval);
    add(lval, 1);
}
exports.comp = comp;
function sub(lval, rval) {
    if (typeof rval === 'number') {
        rval = numberToBuffer(rval);
    }
    else {
        rval = rval.slice(0);
    }
    comp(rval);
    add(lval, rval);
}
exports.sub = sub;
function eq(lval, rval) {
    var lv = new Uint32Array(lval);
    if (typeof rval === 'number') {
        for (var i = exports.DWORDS - 1; i >= 2; i -= 1) {
            if (lv[i]) {
                return false;
            }
        }
        if (lv[1] !== ~~(rval / (exports.DWORD_MASK + 1))) {
            return false;
        }
        var mem = new Uint32Array(1);
        mem[0] = rval & exports.DWORD_MASK;
        if (lv[0] !== mem[0]) {
            return false;
        }
        return true;
    }
    var rv = new Uint32Array(rval);
    for (var i = 0; i < lv.length; i += 1) {
        if (lv[i] !== rv[i]) {
            return false;
        }
    }
    return true;
}
exports.eq = eq;
function cmp(lval, rval) {
    if (typeof rval === 'number') {
        rval = numberToBuffer(rval);
    }
    var lv = new Uint32Array(lval);
    var rv = new Uint32Array(rval);
    for (var i = exports.DWORDS - 1; i >= 0; i -= 1) {
        if (lv[i] < rv[i]) {
            return -1;
        }
        if (lv[i] > rv[i]) {
            return 1;
        }
    }
    return 0;
}
exports.cmp = cmp;
function shl(lval, shift) {
    var copy = new Uint32Array(lval.slice(0));
    var lv = new Uint32Array(lval);
    lv.fill(0);
    var mem = new Uint32Array(2);
    mem[0] = shift % exports.DWORD_LENGTH; // shift
    mem[1] = shift / exports.DWORD_LENGTH; // offset
    for (var i = 0; i < exports.DWORDS; i += 1) {
        if (i + mem[1] + 1 < exports.DWORDS && mem[0] !== -0) {
            lv[i + mem[1] + 1] |= copy[i] >>> (exports.DWORD_LENGTH - mem[0]);
        }
        if (i + mem[1] < exports.DWORDS) {
            lv[i + mem[1]] |= copy[i] << mem[0];
        }
    }
}
exports.shl = shl;
function shr(lval, shift) {
    var copy = new Uint32Array(lval.slice(0));
    var lv = new Uint32Array(lval);
    lv.fill(0);
    var mem = new Uint32Array(2);
    mem[0] = shift % exports.DWORD_LENGTH; // shift
    mem[1] = shift / exports.DWORD_LENGTH; // offset
    for (var i = 0; i < exports.DWORDS; i += 1) {
        if (i - mem[1] - 1 >= 0 && mem[0] !== 0) {
            lv[i - mem[1] - 1] |= copy[i] << (exports.DWORD_LENGTH - mem[0]);
        }
        if (i - mem[1] >= 0) {
            lv[i - mem[1]] |= copy[i] >>> mem[0];
        }
    }
}
exports.shr = shr;
function mul(lval, rval) {
    if (typeof rval === 'number') {
        rval = numberToBuffer(rval);
    }
    var lv = new Uint16Array(lval);
    var rv = new Uint16Array(rval);
    var ret = new Uint16Array(new ArrayBuffer(exports.BYTES));
    var mem = new Uint32Array(3);
    for (var j = 0; j < exports.WORDS; j += 1) {
        mem[0] = 0;
        for (var i = 0; i + j < exports.WORDS; i += 1) {
            mem[2] = lv[j] * rv[i];
            mem[1] = mem[0] + ret[i + j] + mem[2];
            ret[i + j] = mem[1] & exports.WORD_MASK;
            mem[0] = mem[1] >>> exports.WORD_LENGTH;
        }
    }
    lv.set(ret);
}
exports.mul = mul;
function bits(lval) {
    var lv = new Uint32Array(lval);
    for (var pos = exports.DWORDS - 1; pos >= 0; pos -= 1) {
        if (lv[pos]) {
            for (var nbits = exports.DWORD_LENGTH - 1; nbits > 0; nbits -= 1) {
                if (lv[pos] & (1 << nbits)) {
                    return exports.DWORD_LENGTH * pos + nbits + 1;
                }
            }
            return exports.DWORD_LENGTH * pos + 1;
        }
    }
    return 0;
}
exports.bits = bits;
// lval = mod, rval = div
function divmod(lval, rval) {
    if (!rval) {
        return 1;
    }
    var num = new Uint32Array(lval.slice(0));
    var lv = new Uint32Array(lval);
    var rv = new Uint32Array(rval);
    lv.fill(0);
    var lvBits = bits(num.buffer);
    var rvBits = bits(rv.buffer);
    if (rvBits === 0) {
        return 1;
    }
    if (rvBits > lvBits) {
        lv.set(num);
        rv.fill(0);
        return 0;
    }
    var shift = lvBits - rvBits;
    shl(rv.buffer, shift);
    while (shift >= 0) {
        if (cmp(num.buffer, rv.buffer) >= 0) {
            sub(num.buffer, rv.buffer);
            lv[~~(shift / exports.DWORD_LENGTH)] |= 1 << (shift - exports.DWORD_LENGTH);
        }
        shr(rv.buffer, 1);
        shift -= 1;
    }
    rv.set(lv);
    lv.set(num);
    return 0;
}
exports.divmod = divmod;
function pop(lval) {
    function pop32(x) {
        x = x - ((x >>> 1) & 0x55555555);
        x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
        x = (x + (x >>> 4)) & 0x0f0f0f0f;
        x = x + (x >>> 8);
        x = x + (x >>> 16);
        return x & 0x0000003f;
    }
    var lv = new Uint32Array(lval);
    var sum = 0;
    for (var i = 0; i < exports.DWORDS; i += 1) {
        sum += pop32(lv[i]);
    }
    return sum;
}
exports.pop = pop;
