import { EntityMetadataItem, FungibleResourcesCollection, FungibleResourcesCollectionItemVaultAggregated, LedgerStateSelector, NonFungibleIdsCollection, NonFungibleResourcesCollection, NonFungibleResourcesCollectionItemVaultAggregated, StateApi, StateEntityDetailsResponseItem, StateEntityMetadataPageResponse, StateNonFungibleDetailsResponseItem, StateNonFungibleLocationResponseItem, ValidatorCollection, ValidatorCollectionItem } from '../generated';
import { RuntimeConfiguration } from '../runtime';
export type ReplaceProperty<ObjectType, Property extends string | number | symbol, NewPropertyType> = Omit<ObjectType, Property> & {
    [key in Property]: NewPropertyType;
};
export type FungibleResourcesVaultCollection = ReplaceProperty<FungibleResourcesCollection, 'items', FungibleResourcesCollectionItemVaultAggregated[]>;
export type NonFungibleResourcesVaultCollection = ReplaceProperty<NonFungibleResourcesCollection, 'items', NonFungibleResourcesCollectionItemVaultAggregated[]>;
export type StateEntityDetailsOptions = {
    explicitMetadata?: string[];
    ancestorIdentities?: true;
    nonFungibleIncludeNfids?: false;
    packageRoyaltyVaultBalance?: true;
    componentRoyaltyVaultBalance?: true;
};
export type StateEntityDetailsVaultResponseItem = Omit<StateEntityDetailsResponseItem, 'fungible_resources' | 'non_fungible_resources'> & {
    fungible_resources: FungibleResourcesVaultCollection;
    non_fungible_resources: NonFungibleResourcesVaultCollection;
};
export declare class State {
    innerClient: StateApi;
    configuration: RuntimeConfiguration;
    constructor(innerClient: StateApi, configuration: RuntimeConfiguration);
    /**
     * Get detailed information about entities together with vault aggregated fungible and non-fungible resources.
     * Returns an array or single item depending on input value. If array is passed, it will be split into chunks of 20 addresses
     * which will be requested separately and returned only if all requests are successful.
     *
     * Calling this function will exhaust list of all resources for each entity.
     * If any of the requests fail, the whole operation will fail.
     *
     * When requesting details for `internal_vault` entity, `non_fungible_resources` and `fungible_resources` will be defaulted to objects with empty arrays
     * in order to keep backward compatibility. You should look up balances inside `details` object.
     *
     * You can change limit by passing `maxAddressesCount` during gateway instantiation.
     *
     * @example
     * const entityDetails = await gatewayApi.state.getEntityDetailsVaultAggregated('account_tdx_21_1p823h2sq7nsefkdharvvh5')
     * console.log(entityDetails.fungible_resources.items, entityDetails.non_fungible_resources.items)
     *
     * @example
     * const entities = await gatewayApi.state.getEntityDetailsVaultAggregated(['account_tdx_21_1p823h2sq7nsefkdharvvh5'])
     * console.log(entities[0].fungible_resources.items, entities[0].non_fungible_resources.items)
     */
    getEntityDetailsVaultAggregated(addresses: string, options?: StateEntityDetailsOptions, ledgerState?: LedgerStateSelector): Promise<StateEntityDetailsVaultResponseItem>;
    getEntityDetailsVaultAggregated(addresses: string[], options?: StateEntityDetailsOptions, ledgerState?: LedgerStateSelector): Promise<StateEntityDetailsVaultResponseItem[]>;
    /**
     * Get paged list of entity metadata
     * @param address
     * @param cursor
     */
    getEntityMetadata(address: string, cursor?: string): Promise<StateEntityMetadataPageResponse>;
    /**
     * Get list of fungibles location for given resource and ids. If ids array is larger than configured limit, it will be split into chunks and multiple requests will be made.
     * You can change limit by passing `maxNftIdsCount` during gateway instantiation.
     * @param resource - non fungible resource address
     * @param ids - non fungible resource ids to get location for
     * @returns list of non fungible location response items
     */
    getNonFungibleLocation(resource: string, ids: string[]): Promise<StateNonFungibleLocationResponseItem[]>;
    /**
     * Get list of all metadata items for given entity. This will iterate over returned cursors and aggregate all responses,
     * which is why multiple API requests can be made.
     *
     * @param address - entity address
     * @param startCursor - optional cursor to start iteration from
     */
    getAllEntityMetadata(address: string, startCursor?: string): Promise<EntityMetadataItem[]>;
    /**
     * Get paged list of validators
     * @param cursor
     */
    getValidators(cursor?: string): Promise<ValidatorCollection>;
    /**
     * Get list of all validators. This will iterate over returned cursors and aggregate all responses.
     */
    getAllValidators(start?: string): Promise<ValidatorCollectionItem[]>;
    /**
     * Get paged list of validators with ledger state
     * @param cursor
     */
    getValidatorsWithLedgerState(cursor?: string): Promise<import("../generated").StateValidatorsListResponse>;
    /**
     * Get list of all validators. This will iterate over returned cursors and aggregate all responses.
     */
    getAllValidatorsWithLedgerState(start?: string): Promise<{
        aggregatedEntities: ValidatorCollectionItem[];
        ledger_state: import("../generated").LedgerState;
    }>;
    /**
     *  Get paged list of non fungible ids for given non fungible resource address
     * @params address - non fungible resource address
     * @params cursor - optional cursor used for pagination
     */
    getNonFungibleIds(address: string, ledgerState?: LedgerStateSelector, cursor?: string): Promise<NonFungibleIdsCollection>;
    /**
     * Get list of non fungible ids for given non fungible resource address. This will iterate over returned cursors and aggregate all responses.
     *
     * @params address - non fungible resource address
     * @params startCursor - optional cursor to start paging from
     */
    getAllNonFungibleIds(address: string, startCursor?: string, ledgerState?: LedgerStateSelector): Promise<string[]>;
    getNonFungibleData(address: string, ids: string, ledgerState?: LedgerStateSelector): Promise<StateNonFungibleDetailsResponseItem>;
    getNonFungibleData(address: string, ids: string[], ledgerState?: LedgerStateSelector): Promise<StateNonFungibleDetailsResponseItem[]>;
    private getEntityFungiblesPageVaultAggregated;
    private getEntityNonFungiblesPageVaultAggregated;
    private ensureResourcesProperties;
    private queryAllFungibles;
    private queryAllNonFungibles;
    private queryAllResources;
}
