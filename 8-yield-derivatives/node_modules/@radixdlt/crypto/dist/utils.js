"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toPrivateKeyHex = exports.validateLength = exports.validateMinLength = exports.validateMaxLength = void 0;
const neverthrow_1 = require("neverthrow");
const util_1 = require("@radixdlt/util");
const ensureNum = (num) => {
    if (!num || Number.isNaN(num)) {
        util_1.log.error(`Expected number but got none or got NaN: ${num}`);
        throw new Error('Incorrect implementation, must get a number');
    }
};
const validateMaxLength = (expectedMaxLength, name, buffer) => {
    ensureNum(expectedMaxLength);
    return buffer.length > expectedMaxLength
        ? (0, neverthrow_1.err)(new Error(`Incorrect length of ${name}, expected max: #${expectedMaxLength} bytes, but got: #${buffer.length}.`))
        : (0, neverthrow_1.ok)(buffer);
};
exports.validateMaxLength = validateMaxLength;
const validateMinLength = (expectedMinLength, name, buffer) => {
    ensureNum(expectedMinLength);
    return buffer.length < expectedMinLength
        ? (0, neverthrow_1.err)(new Error(`Incorrect length of ${name}, expected min: #${expectedMinLength} bytes, but got: #${buffer.length}.`))
        : (0, neverthrow_1.ok)(buffer);
};
exports.validateMinLength = validateMinLength;
const validateLength = (expectedLength, name, buffer) => {
    ensureNum(expectedLength);
    return buffer.length !== expectedLength
        ? (0, neverthrow_1.err)(new Error(`Incorrect length of ${name}, expected: #${expectedLength} bytes, but got: #${buffer.length}.`))
        : (0, neverthrow_1.ok)(buffer);
};
exports.validateLength = validateLength;
const toPrivateKeyHex = function (scalar) {
    return [...new Uint8Array(scalar.buffer)]
        .reverse()
        .map(x => x.toString(16).padStart(2, '0'))
        .join('');
};
exports.toPrivateKeyHex = toPrivateKeyHex;
//# sourceMappingURL=utils.js.map