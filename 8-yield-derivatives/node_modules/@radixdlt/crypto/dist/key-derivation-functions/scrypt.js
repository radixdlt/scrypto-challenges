"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScryptParams = exports.Scrypt = void 0;
const scrypt_js_1 = require("scrypt-js");
const neverthrow_1 = require("neverthrow");
const util_1 = require("@radixdlt/util");
const deriveKey = (input) => {
    if (input.kdf !== 'scrypt')
        return (0, neverthrow_1.errAsync)(new Error('Wrong KDF, expected scrypt'));
    const { params, password: key } = input;
    const { lengthOfDerivedKey: dklen, costParameterN: n, blockSize: r, parallelizationParameter: p, } = params;
    const salt = Buffer.from(params.salt, 'hex');
    return neverthrow_1.ResultAsync.fromPromise((0, scrypt_js_1.scrypt)(key, salt, n, r, p, dklen).then(uint8array => Buffer.from(uint8array)), (e) => {
        const underlyingErrorMessage = (0, util_1.msgFromError)(e);
        return new Error(`Failed to derive data using scrypt, underlying error: '${underlyingErrorMessage}'`);
    });
};
exports.Scrypt = {
    deriveKey,
};
const create = (input) => {
    var _a, _b, _c;
    const secureRandom = (_a = input.secureRandom) !== null && _a !== void 0 ? _a : util_1.secureRandomGenerator;
    if (input.salt && input.salt.length !== 32)
        throw new Error('Incorrect implementatin expected 32 bytes salt');
    const salt = (_c = (_b = input.salt) === null || _b === void 0 ? void 0 : _b.toString('hex')) !== null && _c !== void 0 ? _c : secureRandom.randomSecureBytes(32);
    return {
        costParameterN: 8192,
        costParameterC: 262144,
        blockSize: 8,
        parallelizationParameter: 1,
        lengthOfDerivedKey: 32,
        salt: salt,
    };
};
exports.ScryptParams = {
    create,
};
//# sourceMappingURL=scrypt.js.map