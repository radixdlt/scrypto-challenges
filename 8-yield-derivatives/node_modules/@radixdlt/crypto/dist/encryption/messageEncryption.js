"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageEncryption = void 0;
const util_1 = require("@radixdlt/util");
const neverthrow_1 = require("neverthrow");
const _types_1 = require("./_types");
const key_derivation_functions_1 = require("../key-derivation-functions");
const symmetric_encryption_1 = require("../symmetric-encryption");
const hash_1 = require("../hash");
const message_1 = require("./message");
const elliptic_curve_1 = require("../elliptic-curve");
const sealedMessage_1 = require("./sealedMessage");
const calculateSharedSecret = (input) => {
    const { diffieHellmanPoint } = input;
    return diffieHellmanPoint().map((dhKey) => {
        const ephemeralPoint = input.ephemeralPublicKey.decodeToPointOnCurve();
        const sharedSecretPoint = dhKey.add(ephemeralPoint);
        const data = sharedSecretPoint.x.toString(16);
        const buf = Buffer.alloc(32);
        buf.write(data.padStart(64, '0'), 'hex');
        return buf;
    });
};
const kdf = (secret, nonce) => {
    const salt = (0, hash_1.sha256)(nonce);
    return key_derivation_functions_1.Scrypt.deriveKey({
        password: secret,
        kdf: 'scrypt',
        params: key_derivation_functions_1.ScryptParams.create({ salt }),
    });
};
const decryptAESSealedBox = (input) => {
    const nonce = input.aesSealedBox.nonce;
    const { additionalAuthenticationData } = input;
    return kdf(input.sharedSecret, nonce)
        .map(symmetricKey => (Object.assign(Object.assign({}, input.aesSealedBox), { symmetricKey,
        additionalAuthenticationData })))
        .andThen(symmetric_encryption_1.AES_GCM.open);
};
const aesSealedBoxFromSealedMessage = (sealedMessage) => symmetric_encryption_1.AES_GCM_SealedBox.create({
    authTag: sealedMessage.authTag,
    ciphertext: sealedMessage.ciphertext,
    nonce: sealedMessage.nonce,
});
const decryptMessage = (input) => {
    const ephemeralPublicKey = input.sealedMessage.ephemeralPublicKey;
    const additionalAuthenticationData = ephemeralPublicKey.asData({
        compressed: true,
    });
    return (0, neverthrow_1.combine)([
        aesSealedBoxFromSealedMessage(input.sealedMessage).asyncAndThen(neverthrow_1.okAsync),
        calculateSharedSecret(Object.assign(Object.assign({}, input), { ephemeralPublicKey })),
    ])
        .map(resultList => {
        const aesSealedBox = resultList[0];
        const sharedSecret = resultList[1];
        return {
            aesSealedBox,
            sharedSecret,
            additionalAuthenticationData,
        };
    })
        .andThen(decryptAESSealedBox);
};
const decryptEncryptedMessageBuffer = (input) => message_1.Message.fromBuffer(input.messageBuffer)
    .andThen((message) => message.kind === 'ENCRYPTED'
    ? (0, neverthrow_1.ok)([
        {
            diffieHellmanPoint: input.diffieHellmanPoint,
            sealedMessage: message.sealedMessage,
        },
    ])
    : (0, neverthrow_1.err)(Error(`Expected an encrypted message, but got a plaintext message.`)))
    .asyncAndThen(a => decryptMessage(...a));
const decrypt = (input) => Buffer.isBuffer(input.encryptedMessage)
    ? decryptEncryptedMessageBuffer(Object.assign(Object.assign({}, input), { messageBuffer: input.encryptedMessage }))
    : decryptMessage(Object.assign(Object.assign({}, input), { sealedMessage: input.encryptedMessage.sealedMessage }));
const encodePlaintext = (plaintext) => typeof plaintext === 'string' ? Buffer.from(plaintext, 'utf-8') : plaintext;
const __encryptDeterministic = (input) => {
    const { nonce, ephemeralPublicKey } = input;
    const additionalAuthenticationData = ephemeralPublicKey.asData({
        compressed: true,
    });
    const plaintext = encodePlaintext(input.plaintext);
    if (plaintext.length > message_1.Message.maxLengthOfCipherTextOfSealedMsg) {
        const errMsg = `Plaintext is too long, expected max #${message_1.Message.maxLengthOfCipherTextOfSealedMsg}, but got: #${plaintext.length}`;
        return (0, neverthrow_1.errAsync)(new Error(errMsg));
    }
    return calculateSharedSecret(Object.assign({}, input)).andThen(sharedSecret => kdf(sharedSecret, nonce)
        .andThen(symmetricKey => (0, symmetric_encryption_1.aesGCMSealDeterministic)({
        nonce,
        plaintext,
        additionalAuthenticationData,
        symmetricKey,
    }))
        .andThen(s => sealedMessage_1.SealedMessage.fromAESSealedBox(s, ephemeralPublicKey))
        .andThen((sealedMessage) => message_1.Message.createEncrypted(_types_1.EncryptionScheme.DH_ADD_EPH_AESGCM256_SCRYPT_000, sealedMessage)));
};
const encrypt = (input) => {
    var _a;
    const secureRandom = (_a = input.secureRandom) !== null && _a !== void 0 ? _a : util_1.secureRandomGenerator;
    const nonce = Buffer.from(secureRandom.randomSecureBytes(symmetric_encryption_1.AES_GCM.nonceLength), 'hex');
    const ephemeralKeyPair = elliptic_curve_1.KeyPair.generateNew(secureRandom);
    const ephemeralPublicKey = ephemeralKeyPair.publicKey;
    return __encryptDeterministic(Object.assign(Object.assign({}, input), { nonce,
        ephemeralPublicKey }));
};
exports.MessageEncryption = {
    __encryptDeterministic,
    encodePlaintext,
    encrypt,
    decrypt,
};
//# sourceMappingURL=messageEncryption.js.map