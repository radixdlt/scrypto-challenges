"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SealedMessage = exports.__validateNonce = exports.__validateTag = void 0;
const neverthrow_1 = require("neverthrow");
const util_1 = require("@radixdlt/util");
const symmetric_encryption_1 = require("../symmetric-encryption");
const utils_1 = require("../utils");
const elliptic_curve_1 = require("../elliptic-curve");
const create = (input) => (0, neverthrow_1.combine)([(0, exports.__validateNonce)(input.nonce), (0, exports.__validateTag)(input.authTag)]).map(_ => (Object.assign(Object.assign({}, input), { combined: () => Buffer.concat([
        input.ephemeralPublicKey.asData({ compressed: true }),
        input.nonce,
        input.authTag,
        input.ciphertext,
    ]) })));
const sealedMessageNonceLength = symmetric_encryption_1.AES_GCM.nonceLength;
const sealedMessageAuthTagLength = symmetric_encryption_1.AES_GCM.tagLength;
exports.__validateTag = utils_1.validateLength.bind(null, sealedMessageAuthTagLength, 'auth tag');
exports.__validateNonce = utils_1.validateLength.bind(null, sealedMessageNonceLength, 'nonce');
const sealedMessageFromBuffer = (buffer) => {
    const sealedMessageLength = buffer.length;
    const lengthOfCiphertext = sealedMessageLength -
        elliptic_curve_1.PublicKey.compressedByteCount -
        sealedMessageNonceLength -
        sealedMessageAuthTagLength;
    if (lengthOfCiphertext <= 0)
        return (0, neverthrow_1.err)(new Error('Ciphertext cannot be empty'));
    const readNextBuffer = util_1.readBuffer.bind(null, buffer)();
    return (0, neverthrow_1.combine)([
        readNextBuffer(elliptic_curve_1.PublicKey.compressedByteCount).andThen(elliptic_curve_1.PublicKey.fromBuffer),
        readNextBuffer(sealedMessageNonceLength),
        readNextBuffer(sealedMessageAuthTagLength),
        readNextBuffer(lengthOfCiphertext),
    ]).andThen(resultList => {
        const ephemeralPublicKey = resultList[0];
        const nonce = resultList[1];
        const authTag = resultList[2];
        const ciphertext = resultList[3];
        return create({
            ephemeralPublicKey,
            nonce,
            authTag,
            ciphertext,
        });
    });
};
const sealedMsgFromAESSealedBox = (aesSealedBox, ephemeralPublicKey) => create(Object.assign(Object.assign({}, aesSealedBox), { ephemeralPublicKey }));
exports.SealedMessage = {
    nonceByteCount: sealedMessageNonceLength,
    authTagByteCount: sealedMessageAuthTagLength,
    create,
    fromAESSealedBox: sealedMsgFromAESSealedBox,
    fromBuffer: sealedMessageFromBuffer,
};
//# sourceMappingURL=sealedMessage.js.map