"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = exports.__validateEncryptedMessageLength = void 0;
const _types_1 = require("./_types");
const neverthrow_1 = require("neverthrow");
const util_1 = require("@radixdlt/util");
const sealedMessage_1 = require("./sealedMessage");
const utils_1 = require("../utils");
const elliptic_curve_1 = require("../elliptic-curve");
const messageEncryption_1 = require("./messageEncryption");
const maxLengthEncryptedMessage = 255;
const minLengthEncryptedMessage = sealedMessage_1.SealedMessage.authTagByteCount +
    sealedMessage_1.SealedMessage.nonceByteCount +
    elliptic_curve_1.PublicKey.compressedByteCount +
    _types_1.ENCRYPTION_SCHEME_BYTES +
    _types_1.MESSAGE_TYPE_BYTES;
const maxLengthOfCipherTextOfSealedMsg = maxLengthEncryptedMessage - minLengthEncryptedMessage;
const isPlaintext = (rawHex) => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.PLAINTEXT;
const isEncrypted = (rawHex) => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.ENCRYPTED;
const isHexEncoded = (rawHex) => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.HEX;
const __validateEncryptedMessageMaxLength = utils_1.validateMaxLength.bind(null, maxLengthEncryptedMessage, 'encryptedMessage');
const __validateEncryptedMessageMinLength = utils_1.validateMinLength.bind(null, minLengthEncryptedMessage, 'encryptedMessage');
const __validateEncryptedMessageLength = (buffer) => (0, neverthrow_1.combine)([
    __validateEncryptedMessageMaxLength(buffer),
    __validateEncryptedMessageMinLength(buffer),
]).map(_ => buffer);
exports.__validateEncryptedMessageLength = __validateEncryptedMessageLength;
const createEncrypted = (encryptionScheme, sealedMessage) => (0, exports.__validateEncryptedMessageLength)(Buffer.concat([
    Buffer.from([_types_1.MessageType.ENCRYPTED]),
    Buffer.from([encryptionScheme]),
    sealedMessage.combined(),
])).map(combinedBuffer => ({
    kind: 'ENCRYPTED',
    messageType: _types_1.MessageType.ENCRYPTED,
    encryptionScheme,
    sealedMessage,
    combined: () => combinedBuffer,
}));
const createPlaintext = (message) => ({
    kind: 'PLAINTEXT',
    plaintext: (0, util_1.isString)(message) ? message : message.toString('utf8'),
    bytes: Buffer.concat([
        Buffer.from([_types_1.MessageType.PLAINTEXT]),
        Buffer.from([_types_1.EncryptionScheme.NONE]),
        messageEncryption_1.MessageEncryption.encodePlaintext(message),
    ]),
});
const plaintextToString = (plaintext, startAt = 2) => Buffer.from(plaintext.slice(startAt).toString('hex'), 'hex').toString('utf-8');
const fromBuffer = (buf) => (0, exports.__validateEncryptedMessageLength)(buf).andThen((buffer) => {
    const readNextBuffer = (0, util_1.readBuffer)(buf);
    const messageTypeResult = readNextBuffer(_types_1.MESSAGE_TYPE_BYTES);
    if (messageTypeResult.isErr())
        return (0, neverthrow_1.err)(messageTypeResult.error);
    const messageType = messageTypeResult.value.readUIntBE(0, 1);
    if (!(messageType in _types_1.MessageType))
        return (0, neverthrow_1.err)(Error(`Unknown message type: ${messageType}`));
    const schemeResult = readNextBuffer(_types_1.ENCRYPTION_SCHEME_BYTES);
    if (schemeResult.isErr())
        return (0, neverthrow_1.err)(schemeResult.error);
    const scheme = schemeResult.value.readUIntBE(0, 1);
    if (!(scheme in _types_1.EncryptionScheme))
        return (0, neverthrow_1.err)(Error(`Unknown encryption scheme: ${scheme}`));
    const payloadResult = readNextBuffer(buffer.length - _types_1.ENCRYPTION_SCHEME_BYTES - _types_1.MESSAGE_TYPE_BYTES);
    if (payloadResult.isErr())
        return (0, neverthrow_1.err)(payloadResult.error);
    const payload = payloadResult.value;
    if (messageType === _types_1.MessageType.ENCRYPTED &&
        scheme !== _types_1.EncryptionScheme.NONE) {
        const sealedMessageResult = sealedMessage_1.SealedMessage.fromBuffer(payload);
        if (sealedMessageResult.isErr())
            return (0, neverthrow_1.err)(sealedMessageResult.error);
        return createEncrypted(scheme, sealedMessageResult.value);
    }
    if (messageType === _types_1.MessageType.PLAINTEXT &&
        scheme === _types_1.EncryptionScheme.NONE) {
        return (0, neverthrow_1.ok)(createPlaintext(payload));
    }
    return (0, neverthrow_1.err)(Error(`Invalid combination of message type ${messageType} and encryption scheme ${scheme}.`));
});
exports.Message = {
    maxLength: maxLengthEncryptedMessage,
    maxLengthOfCipherTextOfSealedMsg,
    minLengthEncryptedMessage,
    createEncrypted,
    createPlaintext,
    fromBuffer,
    plaintextToString,
    isPlaintext,
    isEncrypted,
    isHexEncoded,
};
//# sourceMappingURL=message.js.map