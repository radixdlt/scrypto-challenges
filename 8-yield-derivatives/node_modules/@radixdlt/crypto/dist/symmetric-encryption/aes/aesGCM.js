"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AES_GCM = exports.aesGCMSealDeterministic = void 0;
const node_forge_1 = require("node-forge");
const neverthrow_1 = require("neverthrow");
const util_1 = require("@radixdlt/util");
const aesGCMSealedBox_1 = require("./aesGCMSealedBox");
const AES_GCM_256_ALGORITHM = 'AES-GCM';
const aesGCMSealDeterministic = (input) => {
    const { nonce } = input;
    const aesCipher = node_forge_1.cipher.createCipher(AES_GCM_256_ALGORITHM, node_forge_1.util.createBuffer(input.symmetricKey));
    const iv = node_forge_1.util.createBuffer(nonce);
    const startOptions = { iv };
    if (input.additionalAuthenticationData) {
        aesCipher.start(Object.assign(Object.assign({}, startOptions), { additionalData: node_forge_1.util.hexToBytes(input.additionalAuthenticationData.toString('hex')) }));
    }
    else {
        aesCipher.start(startOptions);
    }
    aesCipher.update(node_forge_1.util.createBuffer(input.plaintext));
    if (!aesCipher.finish()) {
        throw new Error(`AES encryption failed, error unknown...`);
    }
    const ciphertext = Buffer.from(aesCipher.output.toHex(), 'hex');
    const authTag = Buffer.from(aesCipher.mode.tag.toHex(), 'hex');
    return aesGCMSealedBox_1.AES_GCM_SealedBox.create({
        ciphertext,
        authTag,
        nonce,
    });
};
exports.aesGCMSealDeterministic = aesGCMSealDeterministic;
const seal = (input) => {
    var _a, _b;
    const secureRandom = (_a = input.secureRandom) !== null && _a !== void 0 ? _a : util_1.secureRandomGenerator;
    const nonce = (_b = input.nonce) !== null && _b !== void 0 ? _b : Buffer.from(secureRandom.randomSecureBytes(aesGCMSealedBox_1.AES_GCM_SealedBox.nonceLength), 'hex');
    return (0, exports.aesGCMSealDeterministic)(Object.assign(Object.assign({}, input), { nonce }));
};
const open = (input) => {
    const { ciphertext, additionalAuthenticationData, symmetricKey } = input;
    return aesGCMSealedBox_1.AES_GCM_SealedBox.create(input).andThen((box) => {
        const nonce = box.nonce;
        const authTag = box.authTag;
        const decipher = node_forge_1.cipher.createDecipher(AES_GCM_256_ALGORITHM, node_forge_1.util.createBuffer(symmetricKey));
        const iv = node_forge_1.util.createBuffer(nonce);
        const tag = node_forge_1.util.createBuffer(authTag);
        const startOptions = {
            iv,
            tag,
        };
        if (additionalAuthenticationData) {
            const additionalData = node_forge_1.util.hexToBytes(additionalAuthenticationData.toString('hex'));
            decipher.start(Object.assign(Object.assign({}, startOptions), { additionalData }));
        }
        else {
            decipher.start(startOptions);
        }
        decipher.update(node_forge_1.util.createBuffer(ciphertext));
        if (!decipher.finish()) {
            return (0, neverthrow_1.err)(new Error(`AES decryption failed.`));
        }
        return (0, neverthrow_1.ok)(Buffer.from(decipher.output.toHex(), 'hex'));
    });
};
exports.AES_GCM = {
    seal,
    open,
    tagLength: aesGCMSealedBox_1.AES_GCM_SealedBox.tagLength,
    nonceLength: aesGCMSealedBox_1.AES_GCM_SealedBox.nonceLength,
    algorithm: AES_GCM_256_ALGORITHM,
};
//# sourceMappingURL=aesGCM.js.map