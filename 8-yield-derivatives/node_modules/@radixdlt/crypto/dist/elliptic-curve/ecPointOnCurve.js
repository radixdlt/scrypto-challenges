"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ECPointOnCurve = exports.__pointOnCurveFromEllipticShortPoint = void 0;
const uint256_1 = require("@radixdlt/uint256");
const neverthrow_1 = require("neverthrow");
const elliptic_1 = require("elliptic");
const primitives_1 = require("@radixdlt/primitives");
const util_1 = require("@radixdlt/util");
const thirdPartyLibEllipticSecp256k1 = new elliptic_1.ec('secp256k1');
const pointFromCoordinates = (input) => {
    const otherX = (0, primitives_1.bnFromUInt256)(input.x);
    const otherY = (0, primitives_1.bnFromUInt256)(input.y);
    const shortWeirestrassCurve = thirdPartyLibEllipticSecp256k1.curve;
    return shortWeirestrassCurve.point(otherX, otherY);
};
const pointFromOther = (other) => pointFromCoordinates({ x: other.x, y: other.y });
const incorrectImplementationECPointInvalid = new Error('Incorrect implementation, EC point is invalid');
const ecPointOnCurveFromCoordinates = (input) => {
    var _a;
    const { x, y } = input;
    const shortPoint = (_a = input.shortPoint) !== null && _a !== void 0 ? _a : pointFromCoordinates(input);
    const multiplyByScalar = (by) => {
        const factorShortPoint = shortPoint.mul((0, primitives_1.bnFromUInt256)(by));
        // using recursion here!
        const factorPoint = (0, exports.__pointOnCurveFromEllipticShortPoint)(factorShortPoint);
        // This should not happen, the internals of the EC lib `Elliptic` should always be
        // able to perform multiplication between point and a scalar.
        if (!factorPoint.isOk())
            throw incorrectImplementationECPointInvalid;
        return factorPoint.value;
    };
    const u256ToBuf = (n) => Buffer.from(n.toString(16), 'hex');
    const toBuffer = (includePrefixByte) => Buffer.concat([
        includePrefixByte ? Buffer.from([0x04]) : Buffer.alloc(0),
        u256ToBuf(x),
        u256ToBuf(y),
    ]);
    const toString = (includePrefixByte) => toBuffer(includePrefixByte).toString('hex');
    return {
        x,
        y,
        toBuffer,
        toString,
        equals: (other) => other.x.eq(x) && other.y.eq(y),
        add: (other) => {
            const sumShortPoint = shortPoint.add(pointFromOther(other));
            // using recursion here!
            const sumPoint = (0, exports.__pointOnCurveFromEllipticShortPoint)(sumShortPoint);
            // This should not happen, the internals of the EC lib `Elliptic` should always be
            // able to perform EC point addition.
            if (!sumPoint.isOk())
                throw incorrectImplementationECPointInvalid;
            return sumPoint.value;
        },
        multiply: multiplyByScalar,
        multiplyWithPrivateKey: (privateKey) => multiplyByScalar(privateKey.scalar),
    };
};
const __pointOnCurveFromEllipticShortPoint = (shortPoint) => {
    const validateOnCurve = (somePoint) => {
        if (!somePoint.validate())
            return (0, neverthrow_1.err)(new Error('Not point on curve!'));
        return (0, neverthrow_1.ok)({ witness: 'Point is on curve.' });
    };
    return validateOnCurve(shortPoint).andThen(_ => (0, neverthrow_1.combine)([
        (0, primitives_1.uint256FromBN)(shortPoint.getX()),
        (0, primitives_1.uint256FromBN)(shortPoint.getY()),
    ]).map(xNy => {
        const x = xNy[0];
        const y = xNy[1];
        return ecPointOnCurveFromCoordinates({ x, y, shortPoint });
    }));
};
exports.__pointOnCurveFromEllipticShortPoint = __pointOnCurveFromEllipticShortPoint;
const fromXY = (input) => (0, exports.__pointOnCurveFromEllipticShortPoint)(pointFromCoordinates(input));
const fromBuffer = (buffer) => {
    let bytes = buffer;
    if (bytes.length === 65) {
        const firstByte = parseInt(bytes.slice(0, 1).toString('hex'), 16);
        if (firstByte !== 0x04) {
            const errMsg = `For buffers with length 65 bytes we expect the first byte to be 0x04, but got: ${firstByte.toString(16)}`;
            util_1.log.error(errMsg);
            return (0, neverthrow_1.err)(new Error(errMsg));
        }
        bytes = bytes.slice(1);
    }
    const expectedByteCount = 64;
    if (bytes.length !== expectedByteCount) {
        const errMsg = `Expected #${expectedByteCount} bytes, but got: ${bytes.length}`;
        util_1.log.error(errMsg);
        return (0, neverthrow_1.err)(new Error(errMsg));
    }
    const xBuf = bytes.slice(0, expectedByteCount / 2);
    const yBuf = bytes.slice(expectedByteCount / 2);
    const x = new uint256_1.UInt256(xBuf.toString('hex'), 16);
    const y = new uint256_1.UInt256(yBuf.toString('hex'), 16);
    return fromXY({ x, y });
};
exports.ECPointOnCurve = {
    fromXY,
    fromBuffer,
};
//# sourceMappingURL=ecPointOnCurve.js.map