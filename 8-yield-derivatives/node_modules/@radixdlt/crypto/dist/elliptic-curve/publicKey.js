"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublicKey = exports.isPublicKey = void 0;
const tslib_1 = require("tslib");
const neverthrow_1 = require("neverthrow");
const elliptic_1 = require("elliptic");
const bn_js_1 = (0, tslib_1.__importDefault)(require("bn.js"));
const util_1 = require("@radixdlt/util");
const primitives_1 = require("@radixdlt/primitives");
const ecPointOnCurve_1 = require("./ecPointOnCurve");
const thirdPartyLibEllipticSecp256k1 = new elliptic_1.ec('secp256k1');
const isPublicKey = (something) => {
    const inspection = something;
    return (inspection.asData !== undefined &&
        inspection.isValidSignature !== undefined &&
        inspection.decodeToPointOnCurve !== undefined &&
        inspection.equals !== undefined &&
        inspection.toString !== undefined);
};
exports.isPublicKey = isPublicKey;
// eslint-disable-next-line max-lines-per-function
const publicKeyFromEllipticKey = (ecKeyPair) => {
    const validation = ecKeyPair.validate();
    if (!validation.result) {
        return (0, neverthrow_1.err)(new Error(`Invalid privateKey: ${validation.reason}`));
    }
    const newKeyAsData = (input) => Buffer.from(ecKeyPair.getPublic(input.compressed, 'array'));
    const isValidSignature = (input) => {
        const message = input.hashedMessage;
        const signature = input.signature;
        const r = (0, primitives_1.bnFromUInt256)(signature.r);
        const s = (0, primitives_1.bnFromUInt256)(signature.s);
        return ecKeyPair.verify(new bn_js_1.default(message), { r, s });
    };
    const equals = (other) => {
        const comparePubKeyBytes = (compressed) => {
            const newKeyBytes = newKeyAsData({ compressed });
            const otherBytes = other.asData({ compressed });
            return (0, util_1.buffersEquals)(newKeyBytes, otherBytes);
        };
        return comparePubKeyBytes(true) && comparePubKeyBytes(false);
    };
    const toString = (compressed) => newKeyAsData({ compressed: compressed !== null && compressed !== void 0 ? compressed : true }).toString('hex');
    const publicKey = {
        __hex: toString(),
        asData: newKeyAsData,
        toString,
        isValidSignature: isValidSignature,
        equals: equals,
        decodeToPointOnCurve: () => {
            const shortPoint = ecKeyPair.getPublic();
            const pointOnCurveResult = (0, ecPointOnCurve_1.__pointOnCurveFromEllipticShortPoint)(shortPoint);
            if (pointOnCurveResult.isErr())
                throw new Error(`Incorrect implementation, should always be able to decode a valid public key
					 into a point on the curve, but got error ${pointOnCurveResult.error.message}`);
            return pointOnCurveResult.value;
        },
    };
    return (0, neverthrow_1.ok)(publicKey);
};
const fromPrivateKey = (input) => fromPrivateKeyScalar({ scalar: input.privateKey.scalar });
const fromPrivateKeyScalar = (input) => {
    const result = publicKeyFromEllipticKey(thirdPartyLibEllipticSecp256k1.keyFromPrivate(input.scalar.toString(16)));
    if (result.isErr()) {
        throw new Error(`Failed to derive public key from private key, this should never happend since you passed in an 'PrivateKeyT' type value, which should have been validated. You must somehow have bypassed validation, or our implementation is incorrect, which is a fatal error.`);
    }
    return result.value;
};
const fromBuffer = (publicKeyBytes) => {
    try {
        const ecKeyPairElliptic = thirdPartyLibEllipticSecp256k1.keyFromPublic(publicKeyBytes);
        return publicKeyFromEllipticKey(ecKeyPairElliptic);
    }
    catch (e) {
        const underlyingError = (0, util_1.msgFromError)(e);
        const errMsg = `Failed to decode bytes into public key, underlying error: ${underlyingError}. bytes: '${publicKeyBytes.toString('hex')}'`;
        console.error(errMsg);
        return (0, neverthrow_1.err)(new Error(errMsg));
    }
};
const compressedByteCount = 33;
exports.PublicKey = {
    compressedByteCount,
    fromBuffer,
    fromPrivateKey,
    fromPrivateKeyScalar,
};
//# sourceMappingURL=publicKey.js.map