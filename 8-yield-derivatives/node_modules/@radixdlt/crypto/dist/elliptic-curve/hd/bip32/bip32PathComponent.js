"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BIP32PathComponent = exports.isBIP32PathSimpleT = exports.hardenedIncrement = void 0;
const neverthrow_1 = require("neverthrow");
const bip32_1 = require("./bip32");
exports.hardenedIncrement = 0x80000000;
const assertNotHardened = (simplePath) => {
    const { index, isHardened } = simplePath;
    if (index >= exports.hardenedIncrement) {
        return (0, neverthrow_1.err)(new Error(`Incorrect implementation, expected value of index to be less than 'hardenedIncrement' for path components which are hardended. This function will add 'hardenedIncrement' to the value of index passed in, if 'isHardened' flag is set to true. But got value of index: ${index}, 'isHardened': ${isHardened ? 'true' : 'false'}`));
    }
    return (0, neverthrow_1.ok)(index);
};
const create = (input) => {
    const { isHardened } = input;
    return assertNotHardened(Object.assign({}, input)).map(index => (Object.assign(Object.assign({}, input), { index: isHardened ? index + exports.hardenedIncrement : index, value: () => index, toString: () => `${index}` + (isHardened ? `'` : '') })));
};
const isBIP32PathSimpleT = (something) => {
    const inspection = something;
    return inspection.index !== undefined && inspection.isHardened !== undefined;
};
exports.isBIP32PathSimpleT = isBIP32PathSimpleT;
const fromString = (componentString, level) => {
    if (componentString.includes(bip32_1.BIP32.pathSeparator)) {
        return (0, neverthrow_1.err)(new Error('Path component contains separator'));
    }
    let component = componentString;
    let isHardened = false;
    if (component.endsWith(bip32_1.BIP32.hardener)) {
        isHardened = true;
        component = component.replace(bip32_1.BIP32.hardener, '');
    }
    let parsedInt = 0;
    try {
        parsedInt = parseInt(component, 10);
    }
    catch (e) {
        return (0, neverthrow_1.err)(new Error('Failed to parse integer'));
    }
    if (!Number.isInteger(parsedInt)) {
        return (0, neverthrow_1.err)(new Error('Found no integer'));
    }
    return exports.BIP32PathComponent.create({
        index: parsedInt,
        isHardened,
        level,
    });
};
exports.BIP32PathComponent = {
    create,
    fromString,
};
//# sourceMappingURL=bip32PathComponent.js.map