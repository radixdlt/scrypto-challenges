"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BIP32 = exports.unsafeCreate = void 0;
const neverthrow_1 = require("neverthrow");
const bip32PathComponent_1 = require("./bip32PathComponent");
const pathSeparator = '/';
const hardener = `'`;
const isBIP32 = (something) => {
    const inspection = something;
    return (inspection.pathComponents !== undefined &&
        inspection.toString !== undefined);
};
const unsafeCreate = (pathComponents) => {
    const toString = () => 'm' +
        pathSeparator +
        pathComponents.map(pc => pc.toString()).join(pathSeparator);
    return {
        pathComponents,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        equals: (other) => {
            if (!isBIP32(other))
                return false;
            return other.toString() === toString();
        },
        toString,
    };
};
exports.unsafeCreate = unsafeCreate;
const validateLevels = (pathComponents) => (0, neverthrow_1.combine)(pathComponents.map((component, i, components) => component.level !== (i > 0 ? components[i - 1].level + 1 : 1)
    ? (0, neverthrow_1.err)(new Error(`Expected components with strictly increasing level with an increment of one.`))
    : (0, neverthrow_1.ok)({ witness: 'component valid' }))).andThen(_a => (0, neverthrow_1.ok)({ witness: 'all components valid' }));
const create = (pathComponents) => validateLevels(pathComponents).map(() => (0, exports.unsafeCreate)(pathComponents));
const fromString = (path) => {
    let bip32Path = path.trim();
    if (bip32Path === '' || bip32Path === 'm' || bip32Path === pathSeparator) {
        return (0, neverthrow_1.ok)({
            pathComponents: [],
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            equals: (other) => {
                if (!isBIP32(other))
                    return false;
                return other.toString() === 'm';
            },
            toString: () => 'm',
        });
    }
    if (bip32Path.startsWith('M/') || bip32Path.startsWith('m/')) {
        bip32Path = bip32Path.slice(2);
        if (bip32Path.length === 0) {
            return (0, neverthrow_1.err)(new Error(`Must start with just 'm/' or 'M/'`));
        }
    }
    if (bip32Path.length === 0) {
        return (0, neverthrow_1.err)(new Error('Must not be empty'));
    }
    if (bip32Path.includes('//')) {
        return (0, neverthrow_1.err)(new Error(`Must not contain '//'`));
    }
    const components = bip32Path.split(pathSeparator);
    const pathComponents = [];
    for (const { index, value } of components.map((value, index) => ({
        index,
        value,
    }))) {
        const pathComponentResult = bip32PathComponent_1.BIP32PathComponent.fromString(value, index + 1);
        if (pathComponentResult.isErr())
            return (0, neverthrow_1.err)(pathComponentResult.error);
        pathComponents.push(pathComponentResult.value);
    }
    return create(pathComponents);
};
const unsafeFromSimpleComponents = (pathComponents) => (0, neverthrow_1.combine)(pathComponents.map((e, i) => bip32PathComponent_1.BIP32PathComponent.create(Object.assign(Object.assign({}, e), { level: i })))).map(exports.unsafeCreate);
exports.BIP32 = {
    create,
    unsafeCreate: exports.unsafeCreate,
    fromString,
    unsafeFromSimpleComponents,
    hardener,
    pathSeparator,
};
//# sourceMappingURL=bip32.js.map