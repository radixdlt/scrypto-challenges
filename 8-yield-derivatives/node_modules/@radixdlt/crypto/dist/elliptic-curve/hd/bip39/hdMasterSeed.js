"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDNode = exports.HDMasterSeed = void 0;
const tslib_1 = require("tslib");
const bip39_1 = require("bip39");
const hdkey_1 = (0, tslib_1.__importDefault)(require("hdkey"));
const neverthrow_1 = require("neverthrow");
const privateKey_1 = require("../../privateKey");
const hdNodeFromHDNodeThirdParty = (hdNodeThirdParty) => {
    const privateKeyResult = privateKey_1.PrivateKey.fromBuffer(hdNodeThirdParty.privateKey);
    if (privateKeyResult.isErr())
        throw new Error(`Incorrect implementation, failed to get private key from HDNode, third party lib 'hdkey' might be buggy?`);
    const privateKey = privateKeyResult.value;
    return {
        privateKey,
        publicKey: privateKey.publicKey(),
        chainCode: hdNodeThirdParty.chainCode,
        derive: (path) => hdNodeFromHDNodeThirdParty(hdNodeThirdParty.derive(path.toString())),
        toJSON: () => hdNodeThirdParty.toJSON(),
    };
};
const fromMnemonic = (input) => {
    const seed = (0, bip39_1.mnemonicToSeedSync)(input.mnemonic.phrase, input.passphrase);
    return fromSeed(seed);
};
const fromSeed = (seed) => {
    const hdNodeMaster = hdkey_1.default.fromMasterSeed(seed);
    return {
        seed,
        masterNode: () => hdNodeFromHDNodeThirdParty(hdNodeMaster),
    };
};
exports.HDMasterSeed = {
    fromMnemonic,
    fromSeed,
};
const fromExtendedPrivateKey = (xpriv) => {
    try {
        const hdKey = hdkey_1.default.fromJSON({ xpriv, xpub: 'not used' });
        return (0, neverthrow_1.ok)(hdNodeFromHDNodeThirdParty(hdKey));
    }
    catch (_a) {
        return (0, neverthrow_1.err)(new Error('Failed to create HDNode from extended private key'));
    }
};
exports.HDNode = {
    fromExtendedPrivateKey,
};
//# sourceMappingURL=hdMasterSeed.js.map