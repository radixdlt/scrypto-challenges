/// <reference types="node" />
import { Result } from 'neverthrow';
import { UInt256 } from '@radixdlt/uint256';
import { PrivateKeyT, PublicKeyT } from './_types';
export declare const isPublicKey: (something: unknown) => something is Readonly<{
    __hex: string;
    asData: (input: {
        readonly compressed: boolean;
    }) => Buffer;
    toString: (compressed?: boolean | undefined) => string;
    isValidSignature: (input: Readonly<{
        signature: Readonly<{
            r: UInt256;
            s: UInt256;
            toDER: () => string;
            equals: (other: Readonly<any>) => boolean;
        }>;
        hashedMessage: Buffer;
    }>) => boolean;
    decodeToPointOnCurve: () => Readonly<{
        x: UInt256;
        y: UInt256;
        toBuffer: (includePrefixByte?: boolean | undefined) => Buffer;
        toString: (includePrefixByte?: boolean | undefined) => string;
        equals: (other: Readonly<any>) => boolean;
        add: (other: Readonly<any>) => Readonly<any>;
        multiply: (by: UInt256) => Readonly<any>;
        multiplyWithPrivateKey: (privateKey: PrivateKeyT) => Readonly<any>;
    }>;
    equals: (other: Readonly<any>) => boolean;
}>;
export declare const PublicKey: {
    compressedByteCount: number;
    fromBuffer: (publicKeyBytes: Buffer) => Result<PublicKeyT, Error>;
    fromPrivateKey: (input: Readonly<{
        privateKey: PrivateKeyT;
    }>) => PublicKeyT;
    fromPrivateKeyScalar: (input: Readonly<{
        scalar: UInt256;
    }>) => PublicKeyT;
};
//# sourceMappingURL=publicKey.d.ts.map