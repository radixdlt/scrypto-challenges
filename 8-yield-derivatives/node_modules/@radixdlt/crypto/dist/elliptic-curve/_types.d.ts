/// <reference types="node" />
import { ResultAsync } from 'neverthrow';
import { UInt256 } from '@radixdlt/uint256';
import { Hasher } from '../_types';
export declare type DiffieHellman = (publicKeyOfOtherParty: PublicKeyT) => ResultAsync<ECPointOnCurveT, Error>;
export declare type Signer = Readonly<{
    sign: (hashedMessage: Buffer) => ResultAsync<SignatureT, Error>;
    signUnhashed: (input: Readonly<{
        msgToHash: Buffer | string;
        hasher?: Hasher;
    }>) => ResultAsync<SignatureT, Error>;
}>;
export declare type SignatureT = Readonly<{
    r: UInt256;
    s: UInt256;
    toDER: () => string;
    equals: (other: SignatureT) => boolean;
}>;
export declare type ECPointOnCurveT = Readonly<{
    x: UInt256;
    y: UInt256;
    toBuffer: (includePrefixByte?: boolean) => Buffer;
    toString: (includePrefixByte?: boolean) => string;
    equals: (other: ECPointOnCurveT) => boolean;
    add: (other: ECPointOnCurveT) => ECPointOnCurveT;
    multiply: (by: UInt256) => ECPointOnCurveT;
    multiplyWithPrivateKey: (privateKey: PrivateKeyT) => ECPointOnCurveT;
}>;
export declare type PublicKeyT = Readonly<{
    __hex: string;
    asData: (input: {
        readonly compressed: boolean;
    }) => Buffer;
    toString: (compressed?: boolean) => string;
    isValidSignature: (input: Readonly<{
        signature: SignatureT;
        hashedMessage: Buffer;
    }>) => boolean;
    decodeToPointOnCurve: () => ECPointOnCurveT;
    equals: (other: PublicKeyT) => boolean;
}>;
export declare type PrivateKeyT = Signer & Readonly<{
    diffieHellman: DiffieHellman;
    scalar: UInt256;
    publicKey: () => PublicKeyT;
    toString: () => string;
}>;
export declare type KeyPairT = Readonly<{
    publicKey: PublicKeyT;
    privateKey: PrivateKeyT;
}>;
//# sourceMappingURL=_types.d.ts.map