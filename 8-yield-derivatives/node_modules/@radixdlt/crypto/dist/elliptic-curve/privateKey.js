"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivateKey = exports.fromHex = exports.fromBuffer = void 0;
const primitives_1 = require("@radixdlt/primitives");
const uint256_1 = require("@radixdlt/uint256");
const neverthrow_1 = require("neverthrow");
const util_1 = require("@radixdlt/util");
const secp256k1_1 = require("./secp256k1");
const hash_1 = require("../hash");
const elliptic_1 = require("elliptic");
const publicKey_1 = require("./publicKey");
const signature_1 = require("./signature");
const utils_1 = require("../utils");
const __signDataWithPrivateKey = (input) => {
    // log.info(`Signing ${input.data.toString()} with private key.`)
    const thirdPartyLibEllipticSecp256k1 = new elliptic_1.ec('secp256k1');
    const privateKey = thirdPartyLibEllipticSecp256k1.keyFromPrivate(input.privateKey.toString(16));
    const ellipticSignature = privateKey.sign(input.data, {
        canonical: true,
    });
    return signature_1.Signature.fromIndutnyElliptic(ellipticSignature);
};
const __privateKeyFromValidatedScalar = (scalar) => {
    const sign = (hashedMessage) => {
        if (hashedMessage.length !== 32) {
            return (0, neverthrow_1.errAsync)(new Error('Incorrect length of message to sign, expected 32 bytes.'));
        }
        return (0, primitives_1.resultToAsync)(__signDataWithPrivateKey({
            privateKey: scalar,
            data: hashedMessage,
        }));
    };
    const diffieHellman = (publicKeyOfOtherParty) => (0, neverthrow_1.okAsync)(publicKeyOfOtherParty
        .decodeToPointOnCurve()
        .multiplyWithPrivateKey(privateKey));
    const privateKey = {
        sign,
        diffieHellman: diffieHellman,
        signUnhashed: (input) => {
            var _a;
            const hasher = (_a = input.hasher) !== null && _a !== void 0 ? _a : hash_1.sha256Twice;
            const hashedMessage = hasher(input.msgToHash);
            return sign(hashedMessage);
        },
        publicKey: () => {
            throw new Error('Overridden below.');
        },
        toString: () => (0, utils_1.toPrivateKeyHex)(scalar),
        scalar: scalar,
    };
    return Object.assign(Object.assign({}, privateKey), { publicKey: () => publicKey_1.PublicKey.fromPrivateKey({ privateKey }) });
};
const fromBuffer = (buffer) => (0, exports.fromHex)(buffer.toString('hex'));
exports.fromBuffer = fromBuffer;
const fromHex = (privateKeyHexString) => fromScalar(new uint256_1.UInt256(privateKeyHexString, 16));
exports.fromHex = fromHex;
const fromScalar = (scalar) => {
    if (!validateSecp256k1PrivateKey(scalar))
        return (0, neverthrow_1.err)(new Error('Invalid private key scalar.'));
    return (0, neverthrow_1.ok)(__privateKeyFromValidatedScalar(scalar));
};
const validateSecp256k1PrivateKey = (scalar) => scalar.gte(uint256_1.UInt256.valueOf(1)) && scalar.lte(secp256k1_1.Secp256k1.order);
const generateNew = (secureRandom = util_1.secureRandomGenerator) => {
    // eslint-disable-next-line functional/no-let
    let scalar = primitives_1.uint256Max;
    // eslint-disable-next-line functional/no-loop-statement
    while (!validateSecp256k1PrivateKey(scalar)) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call
        scalar = (0, primitives_1.secureRandomUInt256)(secureRandom);
    }
    return __privateKeyFromValidatedScalar(scalar);
};
exports.PrivateKey = {
    generateNew,
    fromScalar,
    fromHex: exports.fromHex,
    fromBuffer: exports.fromBuffer,
};
//# sourceMappingURL=privateKey.js.map