"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Signature = void 0;
const tslib_1 = require("tslib");
const neverthrow_1 = require("neverthrow");
const uint256_1 = require("@radixdlt/uint256");
const primitives_1 = require("@radixdlt/primitives");
const bn_js_1 = (0, tslib_1.__importDefault)(require("bn.js"));
// @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-var-requires
const __js_DER = require('./indutnyEllipticImportDER');
const __fromRSAndDER = (input) => {
    const { r, s, der } = input;
    return {
        r,
        s,
        toDER: () => der,
        equals: (other) => other.toDER() === der,
    };
};
const fromIndutnyElliptic = (ellipticSignature) => {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const derUnknown = ellipticSignature.toDER('hex');
    if (!derUnknown || typeof derUnknown !== 'string') {
        throw new Error('Incorrect implementation, should always be able to format DER from signature.');
    }
    const der = derUnknown;
    return (0, neverthrow_1.combine)([
        (0, primitives_1.uint256FromBN)(ellipticSignature.r),
        (0, primitives_1.uint256FromBN)(ellipticSignature.s),
    ]).map(resultList => {
        const r = resultList[0];
        const s = resultList[1];
        return __fromRSAndDER({ r, s, der });
    });
};
const fromRSBuffer = (buffer) => {
    const expectedLength = 64;
    if (buffer.length !== expectedLength) {
        return (0, neverthrow_1.err)(new Error(`Incorrect length of signature buffer (R||S), expected #${expectedLength} bytes, but got #${buffer.length}.`));
    }
    const rHex = buffer.slice(0, 32).toString('hex');
    const r = new uint256_1.UInt256(rHex, 16);
    const sHex = buffer.slice(32, 64).toString('hex');
    const s = new uint256_1.UInt256(sHex, 16);
    /* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access */
    const der = __js_DER.__js_toDER(new bn_js_1.default(rHex, 16), new bn_js_1.default(sHex, 16), 'hex');
    return (0, neverthrow_1.ok)(__fromRSAndDER({
        r,
        s,
        der,
    }));
    /* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access */
};
const fromDER = (buffer) => {
    const dataHex = typeof buffer === 'string' ? buffer : buffer.toString('hex');
    /* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access */
    const importedDER = __js_DER.__js_importDER(dataHex, 'hex');
    if (!importedDER) {
        return (0, neverthrow_1.err)(new Error('Failed to import DER'));
    }
    return (0, neverthrow_1.ok)(__fromRSAndDER({
        r: importedDER.r,
        s: importedDER.s,
        der: buffer.toString('hex'),
    }));
    /* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access */
};
exports.Signature = {
    fromDER,
    fromRSBuffer,
    fromIndutnyElliptic,
};
//# sourceMappingURL=signature.js.map