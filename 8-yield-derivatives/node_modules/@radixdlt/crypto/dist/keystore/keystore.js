"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Keystore = void 0;
const neverthrow_1 = require("neverthrow");
const symmetric_encryption_1 = require("../symmetric-encryption");
const util_1 = require("@radixdlt/util");
const key_derivation_functions_1 = require("../key-derivation-functions");
const hash_1 = require("../hash");
const validatePassword = (password) => (0, neverthrow_1.ok)(password); // no validation for now...
const encryptSecret = (input) => {
    var _a, _b, _c, _d;
    const secureRandom = (_a = input.secureRandom) !== null && _a !== void 0 ? _a : util_1.secureRandomGenerator;
    const kdf = (_b = input.kdf) !== null && _b !== void 0 ? _b : 'scrypt';
    const params = (_c = input.kdfParams) !== null && _c !== void 0 ? _c : key_derivation_functions_1.ScryptParams.create({ secureRandom });
    const memo = (_d = input.memo) !== null && _d !== void 0 ? _d : Date.now().toLocaleString();
    return validatePassword(input.password)
        .map(p => ({ kdf, params, password: Buffer.from(p) }))
        .asyncAndThen(inp => key_derivation_functions_1.Scrypt.deriveKey(inp))
        .map(derivedKey => ({
        plaintext: input.secret,
        symmetricKey: derivedKey,
    }))
        .andThen(inp => symmetric_encryption_1.AES_GCM.seal(inp))
        .map(sealedBox => {
        const cipherText = sealedBox.ciphertext;
        const mac = sealedBox.authTag;
        const id = (0, hash_1.sha256)(cipherText).toString('hex').slice(-16);
        util_1.log.debug(`Created Keystore with id='${id}' and memo='${memo}' (non of these are sensisitve).`);
        return {
            memo,
            crypto: {
                cipher: symmetric_encryption_1.AES_GCM.algorithm,
                cipherparams: {
                    nonce: sealedBox.nonce.toString('hex'),
                },
                ciphertext: cipherText.toString('hex'),
                kdf,
                kdfparams: params,
                mac: mac.toString('hex'),
            },
            id,
            version: 1,
        };
    });
};
const decrypt = (input) => {
    const { keystore, password } = input;
    const kdf = keystore.crypto.kdf;
    const encryptedPrivateKey = Buffer.from(keystore.crypto.ciphertext, 'hex');
    const params = keystore.crypto.kdfparams;
    return symmetric_encryption_1.AES_GCM_SealedBox.create({
        nonce: Buffer.from(keystore.crypto.cipherparams.nonce, 'hex'),
        authTag: Buffer.from(keystore.crypto.mac, 'hex'),
        ciphertext: encryptedPrivateKey,
    }).asyncAndThen((aesSealBox) => {
        const aesOpenInput = Object.assign({}, aesSealBox);
        return validatePassword(password)
            .map((p) => ({ kdf, params, password: Buffer.from(p) }))
            .asyncAndThen(inp => key_derivation_functions_1.Scrypt.deriveKey(inp))
            .map((derivedKey) => {
            util_1.log.info(`[Decrypting Keystore] successfully derived key using KDF ('${keystore.crypto.kdf}')`);
            return Object.assign(Object.assign({}, aesOpenInput), { symmetricKey: derivedKey });
        })
            .andThen((inp) => symmetric_encryption_1.AES_GCM.open(inp).mapErr(e => {
            const underlyingError = (0, util_1.msgFromError)(e);
            const errMsg = `Failed to decrypt keystore, wrong password? Underlying error: '${underlyingError}'.`;
            console.error(errMsg);
            return new Error(errMsg);
        }))
            .map(decrypted => {
            util_1.log.debug(`Successfully decrypted Keystore with id='${keystore.id}'`);
            return decrypted;
        });
    });
};
const fromBuffer = (keystoreBuffer) => {
    try {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call
        const keystore = JSON.parse(keystoreBuffer.toString());
        if (isKeystore(keystore))
            return (0, neverthrow_1.ok)(keystore);
        const errMsg = 'Parse object, but is not a keystore';
        util_1.log.error(errMsg);
        return (0, neverthrow_1.err)(new Error(errMsg));
    }
    catch (e) {
        const underlying = (0, util_1.msgFromError)(e);
        const errMsg = `Failed to parse keystore from JSON data, underlying error: ${underlying}`;
        util_1.log.error(errMsg);
        return (0, neverthrow_1.err)(new Error(errMsg));
    }
};
const isScryptParams = (something) => {
    const inspection = something;
    return (inspection.blockSize !== undefined &&
        inspection.costParameterC !== undefined &&
        inspection.costParameterN !== undefined &&
        inspection.lengthOfDerivedKey !== undefined &&
        inspection.parallelizationParameter !== undefined &&
        inspection.salt !== undefined);
};
const isKeystoreCrypto = (something) => {
    const inspection = something;
    return (inspection.cipher !== undefined &&
        inspection.cipherparams !== undefined &&
        inspection.ciphertext !== undefined &&
        inspection.kdf !== undefined &&
        inspection.kdfparams !== undefined &&
        isScryptParams(inspection.kdfparams));
};
const isKeystore = (something) => {
    const inspection = something;
    return (inspection.crypto !== undefined &&
        isKeystoreCrypto(inspection.crypto) &&
        inspection.id !== undefined &&
        inspection.version !== undefined);
};
exports.Keystore = {
    fromBuffer,
    decrypt,
    validatePassword,
    encryptSecret,
};
//# sourceMappingURL=keystore.js.map