interface ErrorConfig {
    withStackTrace: boolean;
}

declare namespace Result {
    /**
     * Wraps a function with a try catch, creating a new function with the same
     * arguments but returning `Ok` if successful, `Err` if the function throws
     *
     * @param fn function to wrap with ok on success or err on failure
     * @param errorFn when an error is thrown, this will wrap the error result if provided
     */
    function fromThrowable<Fn extends (...args: readonly unknown[]) => any, E>(fn: Fn, errorFn?: (e: unknown) => E): (...args: Parameters<Fn>) => Result<ReturnType<Fn>, E>;
}
declare type Result<T, E> = Ok<T, E> | Err<T, E>;
declare const ok: <T, E>(value: T) => Ok<T, E>;
declare const err: <T, E>(err: E) => Err<T, E>;
declare class Ok<T, E> {
    readonly value: T;
    constructor(value: T);
    isOk(): this is Ok<T, E>;
    isErr(): this is Err<T, E>;
    map<A>(f: (t: T) => A): Result<A, E>;
    mapErr<U>(_f: (e: E) => U): Result<T, U>;
    andThen<U>(f: (t: T) => Result<U, E>): Result<U, E>;
    /**
     * Applies a function to an `Err` value, leaving `Ok` values untouched. Useful for error recovery.
     */
    orElse<A>(_f: (e: E) => Result<T, A>): Result<T, A>;
    asyncAndThen<U>(f: (t: T) => ResultAsync<U, E>): ResultAsync<U, E>;
    asyncMap<U>(f: (t: T) => Promise<U>): ResultAsync<U, E>;
    unwrapOr(_v: T): T;
    match<A>(ok: (t: T) => A, _err: (e: E) => A): A;
    _unsafeUnwrap(_?: ErrorConfig): T;
    _unsafeUnwrapErr(config?: ErrorConfig): E;
}
declare class Err<T, E> {
    readonly error: E;
    constructor(error: E);
    isOk(): this is Ok<T, E>;
    isErr(): this is Err<T, E>;
    map<A>(_f: (t: T) => A): Result<A, E>;
    mapErr<U>(f: (e: E) => U): Result<T, U>;
    andThen<U>(_f: (t: T) => Result<U, E>): Result<U, E>;
    /**
     * Applies a function to an `Err` value, leaving `Ok` values untouched. Useful for error recovery.
     */
    orElse<A>(f: (e: E) => Result<T, A>): Result<T, A>;
    asyncAndThen<U>(_f: (t: T) => ResultAsync<U, E>): ResultAsync<U, E>;
    asyncMap<U>(_f: (t: T) => Promise<U>): ResultAsync<U, E>;
    unwrapOr(v: T): T;
    match<A>(_ok: (t: T) => A, err: (e: E) => A): A;
    _unsafeUnwrap(config?: ErrorConfig): T;
    _unsafeUnwrapErr(_?: ErrorConfig): E;
}

declare class ResultAsync<T, E> implements PromiseLike<Result<T, E>> {
    private _promise;
    constructor(res: Promise<Result<T, E>>);
    static fromSafePromise<T, E>(promise: Promise<T>): ResultAsync<T, E>;
    static fromPromise<T, E>(promise: Promise<T>, errorFn: (e: unknown) => E): ResultAsync<T, E>;
    map<A>(f: (t: T) => A | Promise<A>): ResultAsync<A, E>;
    mapErr<U>(f: (e: E) => U | Promise<U>): ResultAsync<T, U>;
    andThen<U>(f: (t: T) => Result<U, E> | ResultAsync<U, E>): ResultAsync<U, E>;
    orElse<A>(f: (e: E) => Result<T, A> | ResultAsync<T, A>): ResultAsync<T, A>;
    match<A>(ok: (t: T) => A, _err: (e: E) => A): Promise<A>;
    unwrapOr(t: T): Promise<T>;
    then<A, B>(successCallback?: (res: Result<T, E>) => A | PromiseLike<A>, failureCallback?: (reason: unknown) => B | PromiseLike<B>): PromiseLike<A | B>;
}
declare const okAsync: <T, E>(value: T) => ResultAsync<T, E>;
declare const errAsync: <T, E>(err: E) => ResultAsync<T, E>;

declare type ExtractOkTypes<T extends readonly Result<unknown, unknown>[]> = {
    [idx in keyof T]: T[idx] extends Result<infer U, unknown> ? U : never;
};
declare type ExtractOkAsyncTypes<T extends readonly ResultAsync<unknown, unknown>[]> = {
    [idx in keyof T]: T[idx] extends ResultAsync<infer U, unknown> ? U : never;
};
declare type ExtractErrTypes<T extends readonly Result<unknown, unknown>[]> = {
    [idx in keyof T]: T[idx] extends Result<unknown, infer E> ? E : never;
};
declare type ExtractErrAsyncTypes<T extends readonly ResultAsync<unknown, unknown>[]> = {
    [idx in keyof T]: T[idx] extends ResultAsync<unknown, infer E> ? E : never;
};
declare function combine<T extends readonly Result<unknown, unknown>[]>(resultList: T): Result<ExtractOkTypes<T>, ExtractErrTypes<T>[number]>;
declare function combine<T extends readonly ResultAsync<unknown, unknown>[]>(asyncResultList: T): ResultAsync<ExtractOkAsyncTypes<T>, ExtractErrAsyncTypes<T>[number]>;

export { Err, Ok, Result, ResultAsync, combine, err, errAsync, ok, okAsync };
