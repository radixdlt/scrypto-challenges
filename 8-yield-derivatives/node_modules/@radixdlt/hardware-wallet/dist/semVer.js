"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SemVer = void 0;
const neverthrow_1 = require("neverthrow");
const separator = '.';
const create = (input) => {
    const { major, minor, patch } = input;
    const toString = () => [major, minor, patch]
        .map((n) => n.toString())
        .join(separator);
    const equals = (other) => other.major === major && other.minor === minor && other.patch === patch;
    return {
        major,
        minor,
        patch,
        equals,
        toString,
    };
};
const fromBuffer = (buf) => {
    const expectedByteCount = 3;
    if (buf.length !== expectedByteCount) {
        return (0, neverthrow_1.err)(new Error(`Incorrect length of buffer, expected #${expectedByteCount} bytes, but got: #${buf.length}`));
    }
    const major = buf.readUInt8(0);
    const minor = buf.readUInt8(1);
    const patch = buf.readUInt8(2);
    return (0, neverthrow_1.ok)(create({ major, minor, patch }));
};
const fromString = (versionString) => {
    const components = versionString.split(separator);
    const expectedComponentCount = 3;
    if (components.length !== expectedComponentCount) {
        return (0, neverthrow_1.err)(new Error(`Expected semantic version to contain ${expectedComponentCount} components.`));
    }
    const numAtIndex = (index) => {
        let parsedInt = undefined;
        try {
            parsedInt = parseInt(components[index], 10);
        }
        catch (e) {
            return (0, neverthrow_1.err)(new Error('Failed to parse integer'));
        }
        if (!Number.isInteger(parsedInt)) {
            return (0, neverthrow_1.err)(new Error('Found no integer'));
        }
        return (0, neverthrow_1.ok)(parsedInt);
    };
    return (0, neverthrow_1.combine)([numAtIndex(0), numAtIndex(1), numAtIndex(2)]).map(resultList => {
        const major = resultList[0];
        const minor = resultList[1];
        const patch = resultList[2];
        return create({
            major,
            minor,
            patch,
        });
    });
};
exports.SemVer = {
    fromBuffer,
    fromString,
    create,
};
//# sourceMappingURL=semVer.js.map