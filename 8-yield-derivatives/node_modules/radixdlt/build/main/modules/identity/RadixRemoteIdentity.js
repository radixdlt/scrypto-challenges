"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var RadixIdentity_1 = tslib_1.__importDefault(require("./RadixIdentity"));
var atommodel_1 = require("../atommodel");
var RadixLogger_1 = require("../common/RadixLogger");
var rpc_websockets_1 = require("rpc-websockets");
var RadixRemoteIdentity = /** @class */ (function (_super) {
    tslib_1.__extends(RadixRemoteIdentity, _super);
    function RadixRemoteIdentity(address, token, remoteUrl) {
        var _this = _super.call(this, address) || this;
        _this.address = address;
        _this.token = token;
        _this.remoteUrl = remoteUrl;
        return _this;
    }
    /**
     * Checks if a given web socket connection is still alive, otherwise creates a new one
     *
     * @returns A WebSocket connection
     */
    RadixRemoteIdentity.prototype.getSocketConnection = function () {
        this.socket = new rpc_websockets_1.Client(this.remoteUrl);
        this.socket.on('error', function (error) { return RadixLogger_1.logger.error(error); });
        this.socket.on('close', function () { return RadixLogger_1.logger.info('Socket closed'); });
        return this.socket;
    };
    /**
     * Signs an atom with the wallet using the remote identity
     *
     * @param atom - The atom to be signed
     * @returns A promise with the signed atom
     */
    RadixRemoteIdentity.prototype.signAtom = function (atom) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var socket = _this.getSocketConnection();
            socket.on('open', function () {
                socket.call('sign_atom', {
                    token: _this.token,
                    atom: atommodel_1.RadixSerializer.toJSON(atom),
                }).then(function (response) {
                    atom.signatures = atommodel_1.RadixSerializer.fromJSON(response);
                    resolve(atom);
                }).catch(function (error) {
                    reject(error);
                }).finally(function () {
                    socket.close();
                });
            });
        });
    };
    /**
     * Decrypt the payload of an atom
     *
     * @param payload - The payload of the atom to be decrypted
     * @returns A promise with the decrypted payload
     */
    RadixRemoteIdentity.prototype.decryptECIESPayload = function (payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var socket = _this.getSocketConnection();
                        socket.on('open', function () {
                            socket.call('decrypt_ecies_payload', {
                                token: _this.token,
                                payload: payload,
                            })
                                .then(function (response) {
                                resolve(Buffer.from(response.data));
                            })
                                .catch(function (error) {
                                reject(error);
                            }).finally(function () {
                                socket.close();
                            });
                        });
                    })];
            });
        });
    };
    RadixRemoteIdentity.prototype.decryptECIESPayloadWithProtectors = function (protectors, payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var socket = _this.getSocketConnection();
                        socket.on('open', function () {
                            socket.call('decrypt_ecies_payload_with_protectors', {
                                token: _this.token,
                                protectors: protectors,
                                payload: payload,
                            })
                                .then(function (response) {
                                resolve(Buffer.from(response.data));
                            })
                                .catch(function (error) {
                                reject(error);
                            }).finally(function () {
                                socket.close();
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Returns the public key of this identity synchronously
     *
     * @returns The public key of the identity
     */
    RadixRemoteIdentity.prototype.getPublicKey = function () {
        return this.address.getPublic();
    };
    /**
     * Creates a new instance of a RadixRemoteIdentity
     *
     * @param name - The name of the application that wants to use the remote identity
     * @param description - The description of the application that wants to use the remote identity
     * @param [host] - The host of the wallet
     * @param [port] - The port in which the wallet server is being exposed
     * @returns A promise with an instance of a RadixRemoteIdentity
     */
    RadixRemoteIdentity.createNew = function (name, description, permissions, host, port) {
        if (permissions === void 0) { permissions = ['sign_atom', 'decrypt_ecies_payload', 'get_public_key']; }
        if (host === void 0) { host = 'localhost'; }
        if (port === void 0) { port = '54345'; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var token, publicKey, error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, RadixRemoteIdentity.register(name, description, permissions, host, port)];
                    case 1:
                        token = _a.sent();
                        return [4 /*yield*/, RadixRemoteIdentity.getRemotePublicKey(token, host, port)];
                    case 2:
                        publicKey = _a.sent();
                        return [2 /*return*/, new RadixRemoteIdentity(atommodel_1.RadixAddress.fromPublic(publicKey), token, "ws://" + host + ":" + port)];
                    case 3:
                        error_1 = _a.sent();
                        throw error_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Registers a RadixRemoteIdentity to the wallet
     *
     * @param name - The name of the application that wants to use the remote identity
     * @param description - The description of the application that wants to use the remote identity
     * @param [host] - The host of the wallet
     * @param [port] - The port in which the wallet server is being exposed
     * @returns A promise with a valid token to interact with the wallet
     */
    RadixRemoteIdentity.register = function (name, description, permissions, host, port) {
        if (host === void 0) { host = 'localhost'; }
        if (port === void 0) { port = '54345'; }
        return new Promise(function (resolve, reject) {
            // This is an independant websocket because 'register' is a static method
            var socket = new rpc_websockets_1.Client("ws://" + host + ":" + port);
            socket.on('open', function () {
                socket.call('register', {
                    name: name,
                    description: description,
                    permissions: permissions,
                }).then(function (response) {
                    resolve(response.token);
                }).catch(function (error) {
                    reject(error);
                });
            });
        });
    };
    /**
     * Returns the public key of this identity asynchronously
     *
     * @param [host] - The host of the wallet
     * @param [port] - The port in which the wallet server is being exposed
     * @returns A promise with the public key of the identity
     */
    RadixRemoteIdentity.getRemotePublicKey = function (token, host, port) {
        if (host === void 0) { host = 'localhost'; }
        if (port === void 0) { port = '54345'; }
        return new Promise(function (resolve, reject) {
            // This is an independant websocket because 'getRemotePublicKey' is a static method
            var socket = new rpc_websockets_1.Client("ws://" + host + ":" + port);
            socket.on('open', function () {
                socket.call('get_public_key', {
                    token: token,
                }).then(function (response) {
                    resolve(response.data);
                }).catch(function (error) {
                    reject(error);
                }).finally(function () {
                    socket.close();
                });
            });
        });
    };
    /**
     * Determines whether the server is up or down
     *
     * @param [host] - The host of the wallet
     * @param [port] - The port in which the wallet server is being exposed
     * @returns A promise with true or false whether the server is up or down
     */
    RadixRemoteIdentity.isServerUp = function (host, port) {
        if (host === void 0) { host = 'localhost'; }
        if (port === void 0) { port = '54345'; }
        return new Promise(function (resolve, reject) {
            var socket = new rpc_websockets_1.Client("ws://" + host + ":" + port);
            socket.on('open', function () { return resolve(true); });
            setTimeout(function () {
                if (socket && socket.ready) {
                    socket.close();
                    resolve(true);
                }
                else {
                    socket.close();
                    resolve(false);
                }
            }, 2000);
        });
    };
    return RadixRemoteIdentity;
}(RadixIdentity_1.default));
exports.default = RadixRemoteIdentity;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFkaXhSZW1vdGVJZGVudGl0eS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVzL2lkZW50aXR5L1JhZGl4UmVtb3RlSWRlbnRpdHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsMEVBQTJDO0FBRzNDLDBDQUF1RTtBQUV2RSxxREFBOEM7QUFFOUMsaURBQXVDO0FBRXZDO0lBQWlELCtDQUFhO0lBSzFELDZCQUE2QixPQUFxQixFQUFFLEtBQWEsRUFBRSxTQUFpQjtRQUFwRixZQUNJLGtCQUFNLE9BQU8sQ0FBQyxTQUlqQjtRQUw0QixhQUFPLEdBQVAsT0FBTyxDQUFjO1FBRzlDLEtBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFBO1FBQ2xCLEtBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFBOztJQUM5QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLGlEQUFtQixHQUEzQjtRQUNJLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSx1QkFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQTtRQUV4QyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsVUFBQyxLQUFLLElBQUssT0FBQSxvQkFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBbkIsQ0FBbUIsQ0FBQyxDQUFBO1FBQ3ZELElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxjQUFNLE9BQUEsb0JBQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQTVCLENBQTRCLENBQUMsQ0FBQTtRQUUzRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUE7SUFDdEIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksc0NBQVEsR0FBZixVQUFnQixJQUFlO1FBQS9CLGlCQWtCQztRQWpCRyxPQUFPLElBQUksT0FBTyxDQUFZLFVBQUMsT0FBTyxFQUFFLE1BQU07WUFDMUMsSUFBTSxNQUFNLEdBQUcsS0FB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