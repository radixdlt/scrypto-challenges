"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var RadixLogger_1 = require("../common/RadixLogger");
var promise_retry_1 = tslib_1.__importDefault(require("promise-retry"));
var __1 = require("../..");
var atommodel_1 = require("../atommodel");
var ipaddr_js_1 = tslib_1.__importDefault(require("ipaddr.js"));
var RadixUniverse = /** @class */ (function () {
    function RadixUniverse() {
        var _this = this;
        this.initialized = false;
        this.liveNodes = [];
        this.connectedNodes = [];
        this.lastNetworkUpdate = 0;
        this.networkUpdateInterval = 1000 * 60 * 10;
        /**
         * Close all open connections
         * Recommended to call this before quitting the application, so that nodes can close the corresponding open connections as well
         */
        this.closeAllConnections = function () {
            var e_1, _a;
            try {
                for (var _b = tslib_1.__values(_this.connectedNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var connection = _c.value;
                    connection.close();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
    }
    /**
     * Bootstraps the universe with a specific configuration
     * Must be called before performing any operations
     * Use one of the predefined static configurations in this class
     * @param config
     */
    RadixUniverse.prototype.bootstrap = function (config) {
        var e_2, _a;
        this.universeConfig = config.universeConfig;
        this.nodeDiscovery = config.nodeDiscovery;
        // Deserialize config
        this.universeConfig.initialize();
        try {
            // Find native token
            for (var _b = tslib_1.__values(this.universeConfig.genesis), _c = _b.next(); !_c.done; _c = _b.next()) {
                var atom = _c.value;
                var tokenClasses = atom.getParticlesOfType(atommodel_1.RadixTokenDefinitionParticle);
                if (tokenClasses.length === 0) {
                    throw new Error("Couldn't find native token in genesis");
                }
                else {
                    if (tokenClasses.length > 1) {
                        RadixLogger_1.logger.warn('More than 1 tokens defined in genesis, using the first');
                    }
                    this.nativeToken = tokenClasses[0].getRRI();
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        __1.radixTokenManager.initialize(this.universeConfig.genesis, this.nativeToken);
        this.initialized = true;
    };
    /**
     * Gets the universe magic byte, used mainly for generating an address from a public key
     * @returns
     */
    RadixUniverse.prototype.getMagicByte = function () {
        this.isInitialized();
        return this.universeConfig.getMagicByte();
    };
    RadixUniverse.prototype.loadPeersFromBootstrap = function () {
        var _this = this;
        // const bootstrapNodesLenght = (this.nodeDiscovery as RadixNodeDiscoveryHardcoded).bootstrapNodes.length;
        // if(bootstrapNodesLenght > 1)
        //     throw new Error('not cool ' + bootstrapNodesLenght)
        return promise_retry_1.default(function (retry, attempt) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a, error_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        _a = this;
                        return [4 /*yield*/, this.nodeDiscovery.loadNodes()];
                    case 1:
                        _a.liveNodes = _b.sent();
                        this.lastNetworkUpdate = Date.now();
                        return [2 /*return*/, this.liveNodes];
                    case 2:
                        error_1 = _b.sent();
                        RadixLogger_1.logger.error(error_1);
                        retry();
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); }, {
            retries: 1000,
            maxtimeout: 60000,
        });
    };
    /**
     * Gets a RadixNodeConnection for a specified shard
     * Updates the node list if neccessary
     * @param shard
     * @returns node connection
     */
    RadixUniverse.prototype.getNodeConnection = function (shard) {
        var _this = this;
        this.isInitialized();
        return new Promise(function (resolve, reject) {
            var e_3, _a, e_4, _b;
            try {
                // Find active connection, return
                for (var _c = tslib_1.__values(_this.connectedNodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var node = _d.value;
                    if (node.isReady() && node.node.canServiceShard(shard)) {
                        RadixLogger_1.logger.info('Got an active connection');
                        return resolve(node);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_3) throw e_3.error; }
            }
            var _loop_1 = function (nodeConnection) {
                if (nodeConnection.node.canServiceShard(shard)) {
                    RadixLogger_1.logger.info('Got a pending connection');
                    // Wait for ready or error
                    nodeConnection.on('open', function () {
                        resolve(nodeConnection);
                    });
                    nodeConnection.on('closed', function () {
                        resolve(_this.getNodeConnection(shard));
                    });
                    return { value: void 0 };
                }
            };
            try {
                // Failing that, find a pending node connection
                for (var _e = tslib_1.__values(_this.connectedNodes), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var nodeConnection = _f.value;
                    var state_1 = _loop_1(nodeConnection);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_4) throw e_4.error; }
            }
            // Open a new connection, return when ready
            RadixLogger_1.logger.info('Opening a new connection');
            _this.openNodeConnection(shard).then(function (connection) {
                if (connection) {
                    resolve(connection);
                }
                else {
                    reject("Coudln't find a node to connect to");
                }
            });
        });
    };
    RadixUniverse.prototype.openNodeConnection = function (shard) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _loop_2, this_1, _a, _b, node, state_2, e_5_1;
            var e_5, _c;
            var _this = this;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!(Date.now() - this.lastNetworkUpdate > this.networkUpdateInterval)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.loadPeersFromBootstrap()];
                    case 1:
                        _d.sent();
                        _d.label = 2;
                    case 2:
                        // Randomize node order every time
                        this.liveNodes = __1.shuffleArray(this.liveNodes);
                        _loop_2 = function (node) {
                            var connection_1, error_2;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!node.canServiceShard(shard)) return [3 /*break*/, 5];
                                        connection_1 = new __1.RadixNodeConnection(node);
                                        this_1.connectedNodes.push(connection_1);
                                        connection_1.on('closed', function () {
                                            // Remove connection from connected nodes 
                                            var nodeIndex = _this.connectedNodes.indexOf(connection_1);
                                            if (nodeIndex > -1) {
                                                _this.connectedNodes.splice(nodeIndex, 1);
                                            }
                                        });
                                        _a.label = 1;
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, connection_1.openConnection()];
                                    case 2:
                                        _a.sent();
                                        return [3 /*break*/, 4];
                                    case 3:
                                        error_2 = _a.sent();
                                        RadixLogger_1.logger.error(error_2);
                                        return [2 /*return*/, { value: null }];
                                    case 4: return [2 /*return*/, { value: connection_1 }];
                                    case 5: return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _d.label = 3;
                    case 3:
                        _d.trys.push([3, 8, 9, 10]);
                        _a = tslib_1.__values(this.liveNodes), _b = _a.next();
                        _d.label = 4;
                    case 4:
                        if (!!_b.done) return [3 /*break*/, 7];
                        node = _b.value;
                        return [5 /*yield**/, _loop_2(node)];
                    case 5:
                        state_2 = _d.sent();
                        if (typeof state_2 === "object")
                            return [2 /*return*/, state_2.value];
                        _d.label = 6;
                    case 6:
                        _b = _a.next();
                        return [3 /*break*/, 4];
                    case 7: return [3 /*break*/, 10];
                    case 8:
                        e_5_1 = _d.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 10];
                    case 9:
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_5) throw e_5.error; }
                        return [7 /*endfinally*/];
                    case 10: return [2 /*return*/, null];
                }
            });
        });
    };
    RadixUniverse.prototype.getLiveNodes = function () {
        return this.liveNodes;
    };
    RadixUniverse.prototype.isInitialized = function () {
        if (!this.initialized) {
            throw new Error('Universe needs to be initialized before using the library, please call "radixUniverse.bootstrap" with a universe configuration');
        }
    };
    /**
     * Given an IP address this function resolves a deterministic
     * DNS record in the radixnode.net domain.
     *
     * @param address IP address or hostname
     */
    RadixUniverse.resolveNodeName = function (address) {
        try {
            var ipbytes = ipaddr_js_1.default.parse(address).toByteArray();
            if (ipbytes.length == 4) { // IPv4
                // trivial but safe left-shift function that does not overflow
                var shl = function (base, exp) { return base * Math.pow(2, exp); };
                // use + instead of | (bitwise or) because it overflows
                var ip = ipbytes[3] + shl(ipbytes[2], 8) + shl(ipbytes[1], 16) + shl(ipbytes[0], 24);
                return "a" + ip.toString(36) + ".radixnode.net";
            }
            RadixLogger_1.logger.warn('No base36 encoder for IPv6 yet');
            return "[" + address + "]";
        }
        catch (err) {
            // the address has neither IPv6 nor IPv4 format => hostname
        }
        return address;
    };
    RadixUniverse.BETANET = {
        universeConfig: __1.RadixUniverseConfig.BETANET,
        nodeDiscovery: new __1.RadixNodeDiscoveryFromNodeFinder('https://betanet-staging.radixdlt.com/node-finder', function (ip, port) { return "wss://" + RadixUniverse.resolveNodeName(ip) + "/rpc"; }, function (ip, port) { return "https://" + RadixUniverse.resolveNodeName(ip) + "/rpc"; }),
    };
    RadixUniverse.SUNSTONE = {
        universeConfig: __1.RadixUniverseConfig.SUNSTONE,
        nodeDiscovery: new __1.RadixNodeDiscoveryFromNodeFinder('https://sunstone.radixdlt.com/node-finder', function (ip, port) { return "wss://" + RadixUniverse.resolveNodeName(ip) + "/rpc"; }, function (ip, port) { return "https://" + RadixUniverse.resolveNodeName(ip) + "/rpc"; }),
    };
    RadixUniverse.LOCALHOST = {
        universeConfig: __1.RadixUniverseConfig.LOCAL,
        nodeDiscovery: new __1.RadixNodeDiscoveryHardcoded(['localhost:8080', 'localhost:8081']),
    };
    RadixUniverse.LOCALHOST_SINGLENODE = {
        universeConfig: __1.RadixUniverseConfig.LOCAL,
        nodeDiscovery: new __1.RadixNodeDiscoveryHardcoded(['localhost:8080']),
    };
    RadixUniverse.BETANET_EMULATOR = {
        universeConfig: __1.RadixUniverseConfig.BETANET,
        nodeDiscovery: new __1.RadixNodeDiscoveryHardcodedSecure(['sunstone-emu.radixdlt.com:443']),
    };
    return RadixUniverse;
}());
exports.default = RadixUniverse;
exports.radixUniverse = new RadixUniverse();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFkaXhVbml2ZXJzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVzL3VuaXZlcnNlL1JhZGl4VW5pdmVyc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEscURBQThDO0FBRzlDLHdFQUF3QztBQUN4QywyQkFTc0M7QUFDdEMsMENBQWlFO0FBQ2pFLGdFQUErQjtBQUUvQjtJQUFBO1FBQUEsaUJBa1BDO1FBaE5VLGdCQUFXLEdBQUcsS0FBSyxDQUFBO1FBTWxCLGNBQVMsR0FBZ0IsRUFBRSxDQUFBO1FBQzNCLG1CQUFjLEdBQTBCLEVBQUUsQ0FBQTtRQUMxQyxzQkFBaUIsR0FBRyxDQUFDLENBQUE7UUFDckIsMEJBQXFCLEdBQUcsSUFBSSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUE7UUEwSjlDOzs7V0FHRztRQUNJLHdCQUFtQixHQUFHOzs7Z0JBQ3pCLEtBQXlCLElBQUEsS0FBQSxpQkFBQSxLQUFJLENBQUMsY0FBYyxDQUFBLGdCQUFBLDRCQUFFO29CQUF6QyxJQUFNLFVBQVUsV0FBQTtvQkFDakIsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFBO2lCQUNyQjs7Ozs7Ozs7O1FBQ0wsQ0FBQyxDQUFBO0lBcUNMLENBQUM7SUFyTUc7Ozs7O09BS0c7SUFDSSxpQ0FBUyxHQUFoQixVQUFpQixNQUdoQjs7UUFDRyxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUE7UUFDM0MsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFBO1FBRXpDLHFCQUFxQjtRQUNyQixJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxDQUFBOztZQUVoQyxvQkFBb0I7WUFDcEIsS0FBbUIsSUFBQSxLQUFBLGlCQUFBLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFBLGdCQUFBLDRCQUFFO2dCQUEzQyxJQUFNLElBQUksV0FBQTtnQkFDWCxJQUFNLFlBQVksR0FBRyxJQUFJ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