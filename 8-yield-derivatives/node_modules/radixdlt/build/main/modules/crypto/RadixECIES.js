"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var buffer_reader_1 = tslib_1.__importDefault(require("buffer-reader"));
var elliptic_1 = tslib_1.__importDefault(require("elliptic"));
var crypto_1 = tslib_1.__importDefault(require("crypto"));
var ec = new elliptic_1.default.ec('secp256k1');
var RadixECIES = /** @class */ (function () {
    function RadixECIES() {
    }
    RadixECIES.decrypt = function (privKey, encrypted) {
        var reader = new buffer_reader_1.default(encrypted);
        var iv = reader.nextBuffer(16);
        var ephemPubKeyEncoded = reader.nextBuffer(reader.nextUInt8());
        var ciphertext = reader.nextBuffer(reader.nextUInt32BE());
        var MAC = reader.nextBuffer(32);
        var ephemPubKey = ec.keyFromPublic(ephemPubKeyEncoded).getPublic();
        var px = ec.keyFromPrivate(privKey).derive(ephemPubKey);
        // Double hash to prevent length extension attacks
        var hash = crypto_1.default
            .createHash('sha512')
            .update(crypto_1.default
            .createHash('sha512')
            .update(px.toArrayLike(Buffer))
            .digest())
            .digest();
        var encryptionKey = hash.slice(0, 32);
        var MACKey = hash.slice(32);
        var computedMAC = this.calculateMAC(MACKey, iv, ephemPubKeyEncoded, ciphertext);
        // Verify MAC
        if (!computedMAC.equals(MAC)) {
            throw new Error('MAC mismatch');
        }
        var plaintext = this.AES256CbcDecrypt(iv, encryptionKey, ciphertext);
        return plaintext;
    };
    RadixECIES.encrypt = function (pubKeyTo, plaintext) {
        var ephemPrivKey = ec.keyFromPrivate(crypto_1.default.randomBytes(32));
        var ephemPubKey = ephemPrivKey.getPublic();
        var ephemPubKeyEncoded = Buffer.from(ephemPubKey.encode('array', true));
        // Every EC public key begins with the 0x04 prefix before giving the location of the two point on the curve
        // const px = ephemPrivKey.derive(ec.keyFromPublic(Buffer.concat([Buffer.from([0x04]), pubKeyTo])).getPublic())
        var px = ephemPrivKey.derive(ec.keyFromPublic(pubKeyTo).getPublic());
        // Double hash to preven lenght extension attacks
        var hash = crypto_1.default
            .createHash('sha512')
            .update(crypto_1.default
            .createHash('sha512')
            .update(px.toArrayLike(Buffer))
            .digest())
            .digest();
        var iv = crypto_1.default.randomBytes(16);
        var encryptionKey = hash.slice(0, 32);
        var MACKey = hash.slice(32);
        var ciphertext = this.AES256CbcEncrypt(iv, encryptionKey, plaintext);
        var MAC = this.calculateMAC(MACKey, iv, ephemPubKeyEncoded, ciphertext);
        var offset = 0;
        var serializedCiphertext = Buffer.alloc(iv.length +
            1 +
            ephemPubKeyEncoded.length +
            4 +
            ciphertext.length +
            MAC.length);
        // IV
        iv.copy(serializedCiphertext, 0);
        offset += iv.length;
        // Ephemeral key
        serializedCiphertext.writeUInt8(ephemPubKeyEncoded.length, offset);
        offset++;
        ephemPubKeyEncoded.copy(serializedCiphertext, offset);
        offset += ephemPubKeyEncoded.length;
        // Ciphertext
        serializedCiphertext.writeUInt32BE(ciphertext.length, offset);
        offset += 4;
        ciphertext.copy(serializedCiphertext, offset);
        offset += ciphertext.length;
        // MAC
        MAC.copy(serializedCiphertext, offset);
        return serializedCiphertext;
    };
    RadixECIES.calculateMAC = function (MACKey, iv, ephemPubKeyEncoded, ciphertext) {
        var dataToMAC = Buffer.concat([iv, ephemPubKeyEncoded, ciphertext]);
        return crypto_1.default
            .createHmac('sha256', MACKey)
            .update(dataToMAC)
            .digest();
    };
    RadixECIES.encryptForMultiple = function (recipientsPublicKeys, plaintext) {
        var _this = this;
        // Generate key pair        
        var ephemeral = ec.genKeyPair();
        var ephemeralPriv = Buffer.from(ephemeral.getPrivate('hex'), 'hex');
        // Encrypt protectors
        var protectors = recipientsPublicKeys.map(function (recipient) {
            return _this.encrypt(recipient, ephemeralPriv);
        });
        // Encrypt message
        var ciphertext = RadixECIES.encrypt(Buffer.from(ephemeral.getPublic(true, 'array')), plaintext);
        return {
            protectors: protectors,
            ciphertext: ciphertext,
        };
    };
    RadixECIES.decryptWithProtectors = function (privKey, protectors, ciphertext) {
        var e_1, _a;
        try {
            for (var protectors_1 = tslib_1.__values(protectors), protectors_1_1 = protectors_1.next(); !protectors_1_1.done; protectors_1_1 = protectors_1.next()) {
                var protector = protectors_1_1.value;
                try {
                    var ephemPrivKey = this.decrypt(privKey, protector);
                    try {
                        return this.decrypt(ephemPrivKey, ciphertext);
                    }
                    catch (error) {
                        throw new Error('Decrypted a protector, but unable to decrypt ciphertext with acquired private key');
                    }
                }
                catch (error) {
                    // Do nothing, another protector might work
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (protectors_1_1 && !protectors_1_1.done && (_a = protectors_1.return)) _a.call(protectors_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        throw new Error('Unable to decrypt any protectors');
    };
    /**
     * AES-256 CBC encrypt
     * @param {Buffer} iv
     * @param {Buffer} key
     * @param {Buffer} plaintext
     * @returns {Buffer} ciphertext
     */
    RadixECIES.AES256CbcEncrypt = function (iv, key, plaintext) {
        var cipher = crypto_1.default.createCipheriv('aes-256-cbc', key, iv);
        var firstChunk = cipher.update(plaintext);
        var secondChunk = cipher.final();
        return Buffer.concat([firstChunk, secondChunk]);
    };
    /**
     * AES-256 CBC decrypt
     * @param {Buffer} iv
     * @param {Buffer} key
     * @param {Buffer} ciphertext
     * @returns {Buffer} plaintext
     */
    RadixECIES.AES256CbcDecrypt = function (iv, key, ciphertext) {
        var cipher = crypto_1.default.createDecipheriv('aes-256-cbc', key, iv);
        var firstChunk = cipher.update(ciphertext);
        var secondChunk = cipher.final();
        return Buffer.concat([firstChunk, secondChunk]);
    };
    return RadixECIES;
}());
exports.default = RadixECIES;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFkaXhFQ0lFUy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVzL2NyeXB0by9SYWRpeEVDSUVTLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHdFQUF3QztBQUN4Qyw4REFBeUI7QUFDekIsMERBQTJCO0FBRzNCLElBQU0sRUFBRSxHQUFHLElBQUksa0JBQUUsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUE7QUFFakM7SUFBQTtJQTBMQSxDQUFDO0lBekxpQixrQkFBTyxHQUFyQixVQUFzQixPQUFlLEVBQUUsU0FBaUI7UUFDcEQsSUFBSSxNQUFNLEdBQUcsSUFBSSx1QkFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFBO1FBRXhDLElBQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUE7UUFDaEMsSUFBTSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFBO1FBQ2hFLElBQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUE7UUFDM0QsSUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQTtRQUVqQyxJQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDLGtCQUFrQixDQUFDLENBQUMsU0FBUyxFQUFFLENBQUE7UUFFcEUsSUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUE7UUFDekQsa0RBQWtEO1FBQ2xELElBQU0sSUFBSSxHQUFHLGdCQUFNO2FBQ2QsVUFBVSxDQUFDLFFBQVEsQ0FBQzthQUNwQixNQUFNLENBQ0gsZ0JBQU07YUFDRCxVQUFVLENBQUMsUUFBUSxDQUFDO2FBQ3BCLE1BQU0sQ0FBQyxFQUFFLENBQUMs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