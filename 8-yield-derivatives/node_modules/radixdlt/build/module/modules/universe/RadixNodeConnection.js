import { BehaviorSubject, Subject } from 'rxjs/Rx';
import { Client } from 'rpc-websockets';
import { RadixSerializer } from '../atommodel';
import { logger } from '../common/RadixLogger';
import events from 'events';
export class RadixNodeConnection extends events.EventEmitter {
    constructor(node) {
        super();
        this.node = node;
        this._subscriptions = {};
        this._atomUpdateSubjects = {};
        this._addressSubscriptions = {};
        this.lastSubscriberId = 1;
        this.ping = () => {
            if (this.isReady()) {
                this._socket
                    .call('Ping', { id: 0 }).then((response) => {
                    logger.debug(`Ping`, response);
                }).catch((error) => {
                    logger.warn(`Error sending ping`, error);
                });
            }
        };
        this.close = () => {
            this._socket.close();
            clearInterval(this.pingInterval);
        };
        this._onClosed = () => {
            logger.info('Socket closed');
            clearInterval(this.pingInterval);
            // Close subject
            for (const subscriberId in this._subscriptions) {
                const subscription = this._subscriptions[subscriberId];
                if (!subscription.closed) {
                    subscription.error('Socket closed');
                }
            }
            for (const subscriberId in this._atomUpdateSubjects) {
                const subject = this._atomUpdateSubjects[subscriberId];
                if (!subject.closed) {
                    subject.error('Socket closed');
                }
            }
            this.emit('closed');
        };
        this._onAtomStatusNotification = (notification) => {
            logger.info('Atom Status notification', notification);
            // Handle atom state update
            const subscriberId = notification.subscriberId;
            const value = notification.status;
            const message = JSON.stringify(notification.data);
            const subject = this._atomUpdateSubjects[subscriberId];
            switch (value) {
                case 'STORED':
                    subject.next(value);
                    subject.complete();
                    break;
                case 'EVICTED_CONFLICT_LOSER':
                case 'EVICTED_FAILED_CM_VERIFICATION':
                case 'MISSING_DEPEPENDENCY':
                case 'CONFLICT_LOSER':
                    subject.error(value + ': ' + message);
                    break;
            }
        };
        this._onAtomSubmissionStateUpdate = (notification) => {
            logger.info('Atom Submission state update', notification);
            // Handle atom state update
            const subscriberId = notification.subscriberId;
            const value = notification.value;
            const message = JSON.stringify(notification.data);
            const subject = this._atomUpdateSubjects[subscriberId];
            switch (value) {
                case 'SUBMITTING':
                case 'SUBMITTED':
                    subject.next(value);
                    break;
                case 'STORED':
                    subject.next(value);
                    subject.complete();
                    break;
                case 'COLLISION':
                case 'ILLEGAL_STATE':
                case 'UNSUITABLE_PEER':
                case 'VALIDATION_ERROR':
                    subject.error(value + ': ' + message);
                    break;
            }
        };
        this._onAtomReceivedNotification = (notification) => {
            logger.debug('Atoms notification', notification);
            // Store atom for testing
            // const jsonPath = `./atomNotification-${Math.random().toString(36).substring(6)}.json`
            // // let jsonPath = path.join(__dirname, '..', '..', '..', '..', 'atomNotification.json')
            // logger.info(jsonPath)
            // fs.writeFile(jsonPath, JSON.stringify(notification), (error) => {
            //    // Throws an error, you could also catch it here
            //    if (error) { throw error }
            //    // Success case, the file was saved
            //    logger.info('Atoms saved!')
            // })
            const deserializedAtomEvents = RadixSerializer.fromJSON(notification.atomEvents);
            logger.debug('Recieved atom AIDs, subscriberId: ' + notification.subscriberId, deserializedAtomEvents.map(event => {
                return { aid: event.atom.getAidString(), type: event.type };
            }));
            // logger.debug('AtomEvents', deserializedAtomEvents)
            // Forward atoms to correct wallets
            const subscription = this._subscriptions[notification.subscriberId];
            for (const event of deserializedAtomEvents) {
                subscription.next({
                    action: event.type.toUpperCase(),
                    atom: event.atom,
                    processedData: {},
                    // Only set to head if it is the last atom of an update
                    isHead: event === deserializedAtomEvents[deserializedAtomEvents.length - 1],
                });
            }
        };
        this.node = node;
    }
    getSubscriberId() {
        this.lastSubscriberId++;
        return this.lastSubscriberId + '';
    }
    /**
     * Check whether the node connection is ready for requests
     * @returns true if ready
     */
    isReady() {
        return this._socket && this._socket.ready;
    }
    /**
     * Opens connection
     * @returns a promise that resolves once the connection is ready, or rejects on error or timeout
     */
    async openConnection() {
        return new Promise((resolve, reject) => {
            this.address = this.node.wsAddress;
            // For testing atom queueing during connection issues
            // if (Math.random() > 0.1) {
            //    this.address += 'garbage'
            // }
            logger.info(`Connecting to ${this.address}`);
            this._socket = new Client(this.address, { reconnect: false });
            this._socket.on('close', this._onClosed);
            this._socket.on('error', error => {
                logger.error(error);
                reject(error);
            });
            setTimeout(() => {
                if (!this._socket.ready) {
                    logger.debug('Socket timeout');
                    this._socket.close();
                    this.emit('closed');
                    reject('Timeout');
                }
            }, 5000);
            this._socket.on('open', () => {
                logger.info(`Connected to ${this.address}`);
                this.pingInterval = setInterval(this.ping, 10000);
                this.emit('open');
                this._socket.on('Atoms.subscribeUpdate', this._onAtomReceivedNotification);
                this._socket.on('AtomSubmissionState.onNext', this._onAtomSubmissionStateUpdate);
                this._socket.on('Atoms.nextStatusEvent', this._onAtomStatusNotification);
                resolve();
            });
        });
    }
    /**
     * Subscribe for all existing and future atoms for a given address
     *
     * @param address Base58 formatted address
     * @returns A stream of atoms
     */
    subscribe(address) {
        const subscriberId = this.getSubscriberId();
        this._addressSubscriptions[address] = subscriberId;
        this._subscriptions[subscriberId] = new Subject();
        this._socket
            .call('Atoms.subscribe', {
            subscriberId,
            query: {
                address,
            },
            debug: true,
        })
            .then((response) => {
            logger.info(`Subscribed for address ${address}`, response);
        })
            .catch((error) => {
            logger.error(`Error subscribing for address ${address}`, error);
            this._subscriptions[subscriberId].error(error);
        });
        return this._subscriptions[subscriberId];
    }
    /**
     * Unsubscribe for all existing and future atoms for a given address
     *
     * @param address - Base58 formatted address
     * @returns A promise with the result of the unsubscription call
     */
    unsubscribe(address) {
        const subscriberId = this._addressSubscriptions[address];
        return new Promise((resolve, reject) => {
            this._socket
                .call('Atoms.cancel', {
                subscriberId,
            })
                .then((response) => {
                logger.info(`Unsubscribed for address ${address}`);
                this._subscriptions[this._addressSubscriptions[address]].complete();
                delete this._addressSubscriptions[address];
                resolve(response);
            })
                .catch((error) => {
                reject(error);
            });
        });
    }
    /**
     * Unsubscribes to all the addresses this node is subscribed to
     *
     * @returns An array with the result of each unsubscription
     */
    unsubscribeAll() {
        return new Promise((resolve, reject) => {
            const unsubscriptions = new Array();
            for (const address in this._addressSubscriptions) {
                unsubscriptions.push(this.unsubscribe(address));
            }
            Promise.all(unsubscriptions)
                .then((values) => {
                resolve(values);
            })
                .catch((error) => {
                reject(error);
            });
        });
    }
    /**
     * Submit an atom to the ledger
     *
     * @param atom - The atom to be submitted
     * @returns A stream of the status of the atom submission
     */
    submitAtom(atom) {
        // // Store atom for testing
        // let jsonPath = path.join('./submitAtom.json')
        // logger.info(jsonPath)
        // fs.writeFile(jsonPath, JSON.stringify(atom.toJSON()), (error) => {
        //    // Throws an error, you could also catch it here
        //    if (error) { throw error }
        //    // Success case, the file was saved
        //    logger.info('Atom saved!')
        // })
        const subscriberId = this.getSubscriberId();
        const atomStateSubject = new BehaviorSubject('CREATED');
        this._atomUpdateSubjects[subscriberId] = atomStateSubject;
        const timeout = setTimeout(() => {
            this._socket.close();
            atomStateSubject.error('Socket timeout');
        }, 5000);
        this._socket
            .call('Atoms.getAtomStatusNotifications', {
            subscriberId,
            aid: atom.getAidString(),
        })
            .then((response) => {
            let atomJSON = RadixSerializer.toJSON(atom);
            return this._socket.call('Atoms.submitAtom', atomJSON);
        })
            .then((response) => {
            if (response.aid !== atom.getAidString()) {
                throw new Error(`Local AID "${atom.getAidString()}" does not match that computed on the node "${response.aid}".
This is a radixdlt-js issue, please report this at https://github.com/radixdlt/radixdlt-js/issues . 
The atom may or may not have been accepted by the node.
                    `);
            }
            clearTimeout(timeout);
            atomStateSubject.next('SUBMITTED');
        })
            .catch((error) => {
            clearTimeout(timeout);
            atomStateSubject.error(error);
        });
        return atomStateSubject;
    }
    /**
     * NOT IMPLEMENTED
     * Query the ledger for an atom by its id
     * @param id
     * @returns The atom
     */
    async getAtomById(id) {
        // TODO: everything
        return this._socket
            .call('Atoms.getAtomInfo', { id: id.toJSON() })
            .then((response) => {
            return RadixSerializer.fromJSON(response.result);
        });
    }
}
export default RadixNodeConnection;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFkaXhOb2RlQ29ubmVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVzL3VuaXZlcnNlL1JhZGl4Tm9kZUNvbm5lY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsTUFBTSxTQUFTLENBQUE7QUFDbEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFBO0FBR3ZDLE9BQU8sRUFBd0IsZUFBZSxFQUFtQyxNQUFNLGNBQWMsQ0FBQTtBQUNyRyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUE7QUFFOUMsT0FBTyxNQUFNLE1BQU0sUUFBUSxDQUFBO0FBa0MzQixNQUFNLE9BQU8sbUJBQW9CLFNBQVEsTUFBTSxDQUFDLFlBQVk7SUFheEQsWUFBcUIsSUFBZTtRQUNoQyxLQUFLLEVBQUUsQ0FBQTtRQURVLFNBQUksR0FBSixJQUFJLENBQVc7UUFUNUIsbUJBQWMsR0FBeUQsRUFBRSxDQUFBO1FBQ3pFLHdCQUFtQixHQUFxRCxFQUFFLENBQUE7UUFFMUUsMEJBQXFCLEdBQWtDLEVBQUUsQ0FBQTtRQUV6RCxxQkFBZ0IsR0FBRyxDQUFDLENBQUE7UUFzQnBCLFNBQUksR0FBRyxHQUFHLEVBQUU7WUFDaEIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQyxPQUFPO3FCQUNQLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFhLEVBQUUsRUFBRTtvQkFDNUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUE7Z0JBQ2xDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQVUsRUFBRSxFQUFFO29CQUNwQixNQUFNLENBQUMsSUFBSSxDQUFDLG9CQUFvQixF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