/// <reference types="node" />
import { BehaviorSubject } from 'rxjs';
import Decimal from 'decimal.js';
import { RadixSignatureProvider, RadixAccount, RadixNodeConnection } from '../..';
import { RadixAtom, RadixTokenPermissions, RRI } from '../atommodel';
export default class RadixTransactionBuilder {
    private BNZERO;
    private DCZERO;
    private participants;
    private particleGroups;
    private getSubUnitsQuantity;
    /**
     * Creates transfer atom
     * @param from Sender account, needs to have RadixAccountTransferSystem
     * @param to Receiver account
     * @param tokenReference TokenClassReference string
     * @param decimalQuantity
     * @param [message] Optional reference message
     */
    static createTransferAtom(from: RadixAccount, to: RadixAccount, tokenReference: string | RRI, decimalQuantity: number | string | Decimal, message?: string): RadixTransactionBuilder;
    /**
     * Creates transfer atom
     * @param from Sender account, needs to have RadixAccountTransferSystem
     * @param to Receiver account
     * @param tokenReferenceURI TokenClassReference string
     * @param decimalQuantity
     * @param [message] Optional reference message
     */
    addTransfer(from: RadixAccount, to: RadixAccount, tokenReference: string | RRI, decimalQuantity: number | string | Decimal, message?: string): this;
    /**
     * Create an atom to burn a specified amount of tokens
     * ownerAccount must be the owner and the holder of the tokens to be burned
     *
     * @param  {RadixAccount} ownerAccount
     * @param  {string|RRI} tokenReference
     * @param  {string|number|Decimal} decimalQuantity
     */
    static createBurnAtom(ownerAccount: RadixAccount, tokenReference: string | RRI, decimalQuantity: string | number | Decimal): RadixTransactionBuilder;
    /**
     * Create an atom to burn a specified amount of tokens
     * The token must be multi-issuance
     *
     * @param  {RadixAccount} ownerAccount must be the owner and the holder of the tokens to be burned
     * @param  {string|RRI} tokenReference
     * @param  {string|number|Decimal} decimalQuantity
     */
    burnTokens(ownerAccount: RadixAccount, tokenReference: string | RRI, decimalQuantity: string | number | Decimal): this;
    /**
     * Create an atom to mint a specified amount of tokens
     * The token must be multi-issuance
     *
     * @param  {RadixAccount} ownerAccount must be the owner of the token
     * @param  {string|RRI} tokenReference
     * @param  {string|number|Decimal} decimalQuantity
     */
    static createMintAtom(ownerAccount: RadixAccount, tokenReference: string | RRI, decimalQuantity: string | number | Decimal): RadixTransactionBuilder;
    /**
     * Create an atom to mint a specified amount of tokens
     * The token must be multi-issuance
     *
     * @param  {RadixAccount} ownerAccount must be the owner of the token
     * @param  {string|RRI} tokenReference
     * @param  {string|number|Decimal} decimalQuantity
     */
    mintTokens(ownerAccount: RadixAccount, tokenReference: string | RRI, decimalQuantity: string | number | Decimal): this;
    createToken(owner: RadixAccount, name: string, symbol: string, description: string, granularity: number | string | Decimal, decimalQuantity: number | string | Decimal, iconUrl: string, permissions: RadixTokenPermissions): this;
    createTokenSingleIssuance(owner: RadixAccount, name: string, symbol: string, description: string, granularity: string | number | Decimal, amount: string | number | Decimal, iconUrl: string): this;
    createTokenMultiIssuance(owner: RadixAccount, name: string, symbol: string, description: string, granularity: string | number | Decimal, amount: string | number | Decimal, iconUrl: string): this;
    /**
     * Creates payload atom
     * @param from
     * @param recipients Everyone who will receive and be able to decrypt the message
     * @param applicationId
     * @param payload
     * @param [encrypted] Sets if the message should be encrypted using ECIES
     */
    static createPayloadAtom(from: RadixAccount, recipients: RadixAccount[], applicationId: string, payload: string, encrypted?: boolean): RadixTransactionBuilder;
    /**
     * Creates radix messaging application payload atom
     * @param from
     * @param to
     * @param message
     */
    static createRadixMessageAtom(from: RadixAccount, to: RadixAccount, message: string): RadixTransactionBuilder;
    addEncryptedMessage(from: RadixAccount, applicationId: string, message: string, recipients: RadixAccount[]): this;
    addUnencryptedMessage(from: RadixAccount, applicationId: string, message: string, recipients: RadixAccount[]): this;
    addMessageParticle(from: RadixAccount, data: string | Buffer, metadata: {}, recipients: RadixAccount[]): this;
    /**
     * Add a particle which enforces that only one such particle can exists per account,
     * enforced on the ledger level
     *
     * @param  {RadixAccount} account Scope of the uniqueness constraint
     * @param  {string} unique The unique id
     */
    addUniqueParticle(account: RadixAccount, unique: string): this;
    /**
     * Builds the atom, finds a node to submit to, adds network fee, signs the atom and submits
     * @param signer
     * @returns a BehaviourSubject that streams the atom status updates
     */
    signAndSubmit(signer: RadixSignatureProvider): BehaviorSubject<string>;
    buildAtom(): RadixAtom;
    static signAndSubmitAtom(atom: RadixAtom, connection: RadixNodeConnection, signer: RadixSignatureProvider, participants: RadixAccount[]): BehaviorSubject<string>;
}
