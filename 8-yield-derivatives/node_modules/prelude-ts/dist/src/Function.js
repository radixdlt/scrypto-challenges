"use strict";
/**
 * Rich functions with helpers such as [[Function1.andThen]],
 * [[Function2.apply1]] and so on.
 *
 * We support functions of arities up to 5. For each arity, we have
 * the interface ([[Function1]], [[Function2]], ...), builders are on functions
 * on [[Function1Static]], [[Function2Static]]... accessible on constants
 * named Function1, Function2,...
 *
 * Examples:
 *
 *     const combined = Function1.of((x:number)=>x+2).andThen(x=>x*3);
 *     combined(6);
 *     => 24
 *
 *     const plus5 = Function2.of((x:number,y:number)=>x+y).apply1(5);
 *     plus5(1);
 *     => 6
 */
exports.__esModule = true;
/**
 * This is the type of the Function0 constant, which
 * offers some helper functions to deal
 * with [[Function0]] including
 * the ability to build [[Function0]]
 * from functions using [[Function0Static.of]].
 * It also offers some builtin functions like [[Function0Static.constant]].
 */
var Function0Static = /** @class */ (function () {
    function Function0Static() {
    }
    /**
     * The constant function of one parameter:
     * will always return the value you give, no
     * matter the parameter it's given.
     */
    Function0Static.prototype.constant = function (val) {
        return exports.Function0.of(function () { return val; });
    };
    /**
     * Take a one-parameter function and lift it to become a [[Function1Static]],
     * enabling you to call [[Function1.andThen]] and other such methods on it.
     */
    Function0Static.prototype.of = function (fn) {
        var r = (function () { return fn(); });
        r.andThen = function (fn2) { return exports.Function0.of(function () { return fn2(r()); }); };
        return r;
    };
    return Function0Static;
}());
exports.Function0Static = Function0Static;
/**
 * The Function1 constant allows to call the [[Function0]] "static" methods.
 */
exports.Function0 = new Function0Static();
/**
 * This is the type of the Function1 constant, which
 * offers some helper functions to deal
 * with [[Function1]] including
 * the ability to build [[Function1]]
 * from functions using [[Function1Static.of]].
 * It also offers some builtin functions like [[Function1Static.constant]].
 */
var Function1Static = /** @class */ (function () {
    function Function1Static() {
    }
    /**
     * The identity function.
     */
    Function1Static.prototype.id = function () {
        return exports.Function1.of(function (x) { return x; });
    };
    /**
     * The constant function of one parameter:
     * will always return the value you give, no
     * matter the parameter it's given.
     */
    Function1Static.prototype.constant = function (val) {
        return exports.Function1.of(function (x) { return val; });
    };
    /**
     * Take a one-parameter function and lift it to become a [[Function1Static]],
     * enabling you to call [[Function1.andThen]] and other such methods on it.
     */
    Function1Static.prototype.of = function (fn) {
        var r = (function (x) { return fn(x); });
        r.andThen = function (fn2) { return exports.Function1.of(function (x) { return fn2(r(x)); }); };
        r.compose = function (fn2) { return exports.Function1.of(function (x) { return r(fn2(x)); }); };
        return r;
    };
    return Function1Static;
}());
exports.Function1Static = Function1Static;
/**
 * The Function1 constant allows to call the [[Function1]] "static" methods.
 */
exports.Function1 = new Function1Static();
/**
 * This is the type of the Function2 constant, which
 * offers some helper functions to deal
 * with [[Function2]] including
 * the ability to build [[Function2]]
 * from functions using [[Function2Static.of]].
 * It also offers some builtin functions like [[Function2Static.constant]].
 */
var Function2Static = /** @class */ (function () {
    function Function2Static() {
    }
    /**
     * The constant function of two parameters:
     * will always return the value you give, no
     * matter the parameters it's given.
     */
    Function2Static.prototype.constant = function (val) {
        return exports.Function2.of(function (x, y) { return val; });
    };
    /**
     * Take a two-parameter function and lift it to become a [[Function2]],
     * enabling you to call [[Function2.andThen]] and other such methods on it.
     */
    Function2Static.prototype.of = function (fn) {
        var r = (function (x, y) { return fn(x, y); });
        r.andThen = function (fn2) { return exports.Function2.of(function (x, y) { return fn2(r(x, y)); }); };
        r.curried = function () { return exports.Function1.of(function (x) { return exports.Function1.of(function (y) { return r(x, y); }); }); };
        r.tupled = function () { return exports.Function1.of(function (pair) { return r(pair[0], pair[1]); }); };
        r.flipped = function () { return exports.Function2.of(function (x, y) { return r(y, x); }); };
        r.apply1 = function (x) { return exports.Function1.of(function (y) { return r(x, y); }); };
        return r;
    };
    return Function2Static;
}());
exports.Function2Static = Function2Static;
/**
 * The Function2 constant allows to call the [[Function2]] "static" methods.
 */
exports.Function2 = new Function2Static();
/**
 * This is the type of the Function3 constant, which
 * offers some helper functions to deal
 * with [[Function3]] including
 * the ability to build [[Function3]]
 * from functions using [[Function3Static.of]].
 * It also offers some builtin functions like [[Function3Static.constant]].
 */
var Function3Static = /** @class */ (function () {
    function Function3Static() {
    }
    /**
     * The constant function of three parameters:
     * will always return the value you give, no
     * matter the parameters it's given.
     */
    Function3Static.prototype.constant = function (val) {
        return exports.Function3.of(function (x, y, z) { return val; });
    };
    /**
     * Take a three-parameter function and lift it to become a [[Function3]],
     * enabling you to call [[Function3.andThen]] and other such methods on it.
     */
    Function3Static.prototype.of = function (fn) {
        var r = (function (x, y, z) { return fn(x, y, z); });
        r.andThen = function (fn2) { return exports.Function3.of(function (x, y, z) { return fn2(r(x, y, z)); }); };
        r.curried = function () { return exports.Function1.of(function (x) { return exports.Function1.of(function (y) { return exports.Function1.of(function (z) { return r(x, y, z); }); }); }); };
        r.tupled = function () { return exports.Function1.of(function (tuple) { return r(tuple[0], tuple[1], tuple[2]); }); };
        r.flipped = function () { return exports.Function3.of(function (x, y, z) { return r(z, y, x); }); };
        r.apply1 = function (x) { return exports.Function2.of(function (y, z) { return r(x, y, z); }); };
        r.apply2 = function (x, y) { return exports.Function1.of(function (z) { return r(x, y, z); }); };
        return r;
    };
    return Function3Static;
}());
exports.Function3Static = Function3Static;
/**
 * The Function3 constant allows to call the [[Function3]] "static" methods.
 */
exports.Function3 = new Function3Static();
/**
 * This is the type of the Function4 constant, which
 * offers some helper functions to deal
 * with [[Function4]] including
 * the ability to build [[Function4]]
 * from functions using [[Function4Static.of]].
 * It also offers some builtin functions like [[Function4Static.constant]].
 */
var Function4Static = /** @class */ (function () {
    function Function4Static() {
    }
    /**
     * The constant function of four parameters:
     * will always return the value you give, no
     * matter the parameters it's given.
     */
    Function4Static.prototype.constant = function (val) {
        return exports.Function4.of(function (x, y, z, a) { return val; });
    };
    /**
     * Take a four-parameter function and lift it to become a [[Function4]],
     * enabling you to call [[Function4.andThen]] and other such methods on it.
     */
    Function4Static.prototype.of = function (fn) {
        var r = (function (x, y, z, a) { return fn(x, y, z, a); });
        r.andThen = function (fn2) { return exports.Function4.of(function (x, y, z, a) { return fn2(r(x, y, z, a)); }); };
        r.curried = function () { return exports.Function1.of(function (x) { return exports.Function1.of(function (y) { return exports.Function1.of(function (z) { return exports.Function1.of(function (a) { return r(x, y, z, a); }); }); }); }); };
        r.tupled = function () { return exports.Function1.of(function (tuple) { return r(tuple[0], tuple[1], tuple[2], tuple[3]); }); };
        r.flipped = function () { return exports.Function4.of(function (x, y, z, a) { return r(a, z, y, x); }); };
        r.apply1 = function (x) { return exports.Function3.of(function (y, z, a) { return r(x, y, z, a); }); };
        r.apply2 = function (x, y) { return exports.Function2.of(function (z, a) { return r(x, y, z, a); }); };
        r.apply3 = function (x, y, z) { return exports.Function1.of(function (a) { return r(x, y, z, a); }); };
        return r;
    };
    return Function4Static;
}());
exports.Function4Static = Function4Static;
;
/**
 * The Function4 constant allows to call the [[Function4]] "static" methods.
 */
exports.Function4 = new Function4Static();
/**
 * This is the type of the Function5 constant, which
 * offers some helper functions to deal
 * with [[Function5]] including
 * the ability to build [[Function5]]
 * from functions using [[Function5Static.of]].
 * It also offers some builtin functions like [[Function5Static.constant]].
 */
var Function5Static = /** @class */ (function () {
    function Function5Static() {
    }
    /**
     * The constant function of five parameters:
     * will always return the value you give, no
     * matter the parameters it's given.
     */
    Function5Static.prototype.constant = function (val) {
        return exports.Function5.of(function (x, y, z, a, b) { return val; });
    };
    /**
     * Take a five-parameter function and lift it to become a [[Function5]],
     * enabling you to call [[Function5.andThen]] and other such methods on it.
     */
    Function5Static.prototype.of = function (fn) {
        var r = (function (x, y, z, a, b) { return fn(x, y, z, a, b); });
        r.andThen = function (fn2) { return exports.Function5.of(function (x, y, z, a, b) { return fn2(r(x, y, z, a, b)); }); };
        r.curried = function () { return exports.Function1.of(function (x) { return exports.Function1.of(function (y) { return exports.Function1.of(function (z) { return exports.Function1.of(function (a) { return exports.Function1.of(function (b) { return r(x, y, z, a, b); }); }); }); }); }); };
        r.tupled = function () { return exports.Function1.of(function (tuple) { return r(tuple[0], tuple[1], tuple[2], tuple[3], tuple[4]); }); };
        r.flipped = function () { return exports.Function5.of(function (x, y, z, a, b) { return r(b, a, z, y, x); }); };
        r.apply1 = function (x) { return exports.Function4.of(function (y, z, a, b) { return r(x, y, z, a, b); }); };
        r.apply2 = function (x, y) { return exports.Function3.of(function (z, a, b) { return r(x, y, z, a, b); }); };
        r.apply3 = function (x, y, z) { return exports.Function2.of(function (a, b) { return r(x, y, z, a, b); }); };
        r.apply4 = function (x, y, z, a) { return exports.Function1.of(function (b) { return r(x, y, z, a, b); }); };
        return r;
    };
    return Function5Static;
}());
exports.Function5Static = Function5Static;
/**
 * The Function5 constant allows to call the [[Function5]] "static" methods.
 */
exports.Function5 = new Function5Static();
//# sourceMappingURL=Function.js.map