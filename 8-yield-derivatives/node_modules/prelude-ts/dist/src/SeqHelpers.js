"use strict";
exports.__esModule = true;
var Option_1 = require("./Option");
var Stream_1 = require("./Stream");
var Lazy_1 = require("./Lazy");
var HashSet_1 = require("./HashSet");
/**
 * @hidden
 */
function shuffle(array) {
    // https://stackoverflow.com/a/2450976/516188
    var currentIndex = array.length, temporaryValue, randomIndex;
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
    return array;
}
exports.shuffle = shuffle;
/**
 * @hidden
 */
function arrangeBy(collection, getKey) {
    return Option_1.Option.of(collection.groupBy(getKey).mapValues(function (v) { return v.single(); }))
        .filter(function (map) { return !map.anyMatch(function (k, v) { return v.isNone(); }); })
        .map(function (map) { return map.mapValues(function (v) { return v.getOrThrow(); }); });
}
exports.arrangeBy = arrangeBy;
/**
 * @hidden
 */
function seqHasTrueEquality(seq) {
    return seq.find(function (x) { return x != null; }).hasTrueEquality();
}
exports.seqHasTrueEquality = seqHasTrueEquality;
/**
 * @hidden
 */
function zipWithIndex(seq) {
    return seq.zip(Stream_1.Stream.iterate(0, function (i) { return i + 1; }));
}
exports.zipWithIndex = zipWithIndex;
/**
 * @hidden
 */
function sortOn(seq, getKeys) {
    return seq.sortBy(function (x, y) {
        for (var _i = 0, getKeys_1 = getKeys; _i < getKeys_1.length; _i++) {
            var getKey = getKeys_1[_i];
            if (getKey.desc) {
                var a = getKey.desc(x);
                var b = getKey.desc(y);
                if (a === b) {
                    continue;
                }
                return a < b ? 1 /* GT */ : -1 /* LT */;
            }
            else {
                var a = getKey(x);
                var b = getKey(y);
                if (a === b) {
                    continue;
                }
                return a > b ? 1 /* GT */ : -1 /* LT */;
            }
        }
        return 0 /* EQ */;
    });
}
exports.sortOn = sortOn;
/**
 * @hidden
 */
function distinctBy(seq, keyExtractor) {
    var knownKeys = HashSet_1.HashSet.empty();
    return seq.filter(function (x) {
        var key = keyExtractor(x);
        var r = knownKeys.contains(key);
        if (!r) {
            knownKeys = knownKeys.add(key);
        }
        return !r;
    });
}
exports.distinctBy = distinctBy;
/**
 * Utility function to help converting a value to string
 * util.inspect seems to depend on node.
 * @hidden
 */
function toStringHelper(obj, options) {
    if (options === void 0) { options = { quoteStrings: true }; }
    if (Array.isArray(obj)) {
        return "[" + obj.map(function (o) { return toStringHelper(o, options); }) + "]";
    }
    if (typeof obj === "string") {
        return options.quoteStrings ? "'" + obj + "'" : obj;
    }
    if (obj && (obj.toString !== Object.prototype.toString)) {
        return obj.toString();
    }
    // We used to use JSON.stringify here, but that will
    // throw an exception if there are cycles, which we
    // absolutely don't want!
    // https://stackoverflow.com/a/48254637/516188
    var customStringify = function (v) {
        var cache = new Set();
        return JSON.stringify(v, function (key, value) {
            if (typeof value === 'object' && value !== null) {
                if (cache.has(value)) {
                    // Circular reference found, discard key
                    return;
                }
                // Store value in our set
                cache.add(value);
            }
            return value;
        });
    };
    return customStringify(obj);
}
exports.toStringHelper = toStringHelper;
/**
 * @hidden
 */
function minBy(coll, compare) {
    return coll.reduce(function (v1, v2) { return compare(v1, v2) < 0 ? v2 : v1; });
}
exports.minBy = minBy;
/**
 * @hidden
 */
function minOn(coll, getSortable) {
    if (coll.isEmpty()) {
        return Option_1.Option.none();
    }
    var iter = coll[Symbol.iterator]();
    var step = iter.next();
    var val = getSortable(step.value);
    var result = step.value;
    while (!(step = iter.next()).done) {
        var curVal = getSortable(step.value);
        if (curVal < val) {
            val = curVal;
            result = step.value;
        }
    }
    return Option_1.Option.of(result);
}
exports.minOn = minOn;
/**
 * @hidden
 */
function maxBy(coll, compare) {
    return coll.reduce(function (v1, v2) { return compare(v1, v2) > 0 ? v2 : v1; });
}
exports.maxBy = maxBy;
/**
 * @hidden
 */
function maxOn(coll, getSortable) {
    if (coll.isEmpty()) {
        return Option_1.Option.none();
    }
    var iter = coll[Symbol.iterator]();
    var step = iter.next();
    var val = getSortable(step.value);
    var result = step.value;
    while (!(step = iter.next()).done) {
        var curVal = getSortable(step.value);
        if (curVal > val) {
            val = curVal;
            result = step.value;
        }
    }
    return Option_1.Option.of(result);
}
exports.maxOn = maxOn;
/**
 * @hidden
 */
function sumOn(coll, getNumber) {
    return coll.foldLeft(0, function (soFar, cur) { return soFar + getNumber(cur); });
}
exports.sumOn = sumOn;
/**
 * @hidden
 */
function reduce(coll, combine) {
    if (coll.isEmpty()) {
        return Option_1.Option.none();
    }
    var iter = coll[Symbol.iterator]();
    var step = iter.next();
    var result = step.value;
    while (!(step = iter.next()).done) {
        result = combine(result, step.value);
    }
    return Option_1.Option.of(result);
}
exports.reduce = reduce;
/**
 * @hidden
 */
function sliding(seq, count) {
    // in a way should get better performance with Seq.splitAt instead
    // of Seq.take+Seq.drop, but we should be lazy and not hold another
    // version of the sequence in memory (though for linked list it's free,
    // it's not the case for Vector)
    return seq.isEmpty() ?
        Stream_1.Stream.empty() :
        new Stream_1.ConsStream(seq.take(count), Lazy_1.Lazy.of(function () { return sliding(seq.drop(count), count); }));
}
exports.sliding = sliding;
/**
 * @hidden
 */
function removeAll(seq, elts) {
    var toRemove = HashSet_1.HashSet.ofIterable(elts);
    // I know T must have equality since the parameter has it and is the same type.
    return seq.filter(function (x) { return !toRemove.contains(x); });
}
exports.removeAll = removeAll;
//# sourceMappingURL=SeqHelpers.js.map