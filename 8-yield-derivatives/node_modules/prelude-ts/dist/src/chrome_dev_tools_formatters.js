(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.prelude_ts_object_formatters = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
//  http://bit.ly/object-formatters
var olStyle = "list-style-type:none; padding-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-left: 12px";
function getWithToArrayBody(elt) {
    return ["ol",
        { "style": olStyle }].concat(elt.toArray().map(function (x, idx) { return ["li", {},
        ["span", { "style": "color: rgb(136, 19, 145);" }, idx + ": "],
        ["object", { "object": x }]]; }));
}
var VectorHandler = /** @class */ (function () {
    function VectorHandler() {
        this.getBody = getWithToArrayBody;
    }
    VectorHandler.prototype.isElement = function (object) {
        return object.hashCode && object.equals &&
            object.replace && object.sortOn && object._list;
    };
    VectorHandler.prototype.getHeader = function (object) {
        return ["span", {}, "Vector(" + object.length() + ")"];
    };
    VectorHandler.prototype.hasBody = function (elt) {
        return !elt.isEmpty();
    };
    return VectorHandler;
}());
// not going to behave well with infinite streams...
var StreamHandler = /** @class */ (function () {
    function StreamHandler() {
        this.getBody = getWithToArrayBody;
    }
    StreamHandler.prototype.isElement = function (object) {
        return object.hashCode && object.equals && object.sortBy && object.cycle && object.toVector;
    };
    StreamHandler.prototype.getHeader = function (object) {
        // not displaying the length for streams in case
        // of infinite streams. the user can expand if needed.
        return ["span", {}, "Stream(?)"];
    };
    StreamHandler.prototype.hasBody = function (elt) {
        return !elt.isEmpty();
    };
    return StreamHandler;
}());
var ListHandler = /** @class */ (function () {
    function ListHandler() {
        this.getBody = getWithToArrayBody;
    }
    ListHandler.prototype.isElement = function (object) {
        return object.hashCode && object.equals && object.sortBy && object.toVector;
    };
    ListHandler.prototype.getHeader = function (object) {
        // not displaying the length for streams in case
        // of infinite streams. the user can expand if needed.
        return ["span", {}, "List(" + object.length() + ")"];
    };
    ListHandler.prototype.hasBody = function (elt) {
        return !elt.isEmpty();
    };
    return ListHandler;
}());
var HashSetHandler = /** @class */ (function () {
    function HashSetHandler() {
        this.getBody = getWithToArrayBody;
    }
    HashSetHandler.prototype.isElement = function (object) {
        return object.hashCode && object.equals && object.hamt && object.intersect;
    };
    HashSetHandler.prototype.getHeader = function (object) {
        return ["span", {}, "HashSet(" + object.length() + ")"];
    };
    HashSetHandler.prototype.hasBody = function (elt) {
        return !elt.isEmpty();
    };
    return HashSetHandler;
}());
var HashMapHandler = /** @class */ (function () {
    function HashMapHandler() {
    }
    HashMapHandler.prototype.isElement = function (object) {
        return object.hashCode && object.equals && object.hamt && object.valueIterable;
    };
    HashMapHandler.prototype.getHeader = function (object) {
        return ["span", {}, "HashMap(" + object.length() + ")"];
    };
    HashMapHandler.prototype.hasBody = function (elt) {
        return !elt.isEmpty();
    };
    HashMapHandler.prototype.getBody = function (elt) {
        return ["ol",
            { "style": olStyle }].concat(elt.toArray().map(function (kv, idx) {
            // using object.create to avoid the __proto__ in the GUI
            var obj = Object.create(null);
            obj.key = kv[0];
            obj.value = kv[1];
            return ["li", {},
                ["span", { "style": "color: rgb(136, 19, 145);" }, idx + ": "],
                ["object", { "object": obj }]];
        }));
    };
    return HashMapHandler;
}());
var handlers = [new VectorHandler(),
    new StreamHandler(),
    new ListHandler(),
    new HashSetHandler(),
    new HashMapHandler()];
function getHandler(object) {
    return handlers.find(function (h) { return h.isElement(object); });
}
var formatter = {
    header: function (object, config) {
        var handler = getHandler(object);
        return handler ? handler.getHeader(object) : null;
    },
    hasBody: function (object, config) {
        var handler = getHandler(object);
        return handler ? handler.hasBody(object) : false;
    },
    body: function (object, config) {
        var handler = getHandler(object);
        return handler ? handler.getBody(object) : null;
    }
};
if (!window.devtoolsFormatters) {
    window.devtoolsFormatters = [];
}
window.devtoolsFormatters.push(formatter);

},{}]},{},[1])(1)
});
