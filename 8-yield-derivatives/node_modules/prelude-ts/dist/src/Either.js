"use strict";
/**
 * The [[Either]] type represents an alternative between two value types.
 * A "left" value which is also conceptually tied to a failure,
 * or a "right" value which is conceptually tied to success.
 *
 * The code is organized through the class [[Left]], the class [[Right]],
 * and the type alias [[Either]] (Left or Right).
 *
 * Finally, "static" functions on Option are arranged in the class
 * [[EitherStatic]] and are accessed through the global constant Either.
 *
 * Examples:
 *
 *     Either.right<number,number>(5);
 *     Either.left<number,number>(2);
 *     Either.right<number,number>(5).map(x => x*2);
 *
 * Left has the extra [[Left.getLeft]] method that [[Right]] doesn't have.
 * Right has the extra [[Right.get]] method that [[Left]] doesn't have.
 */
exports.__esModule = true;
var Value_1 = require("./Value");
var Option_1 = require("./Option");
var LinkedList_1 = require("./LinkedList");
var Vector_1 = require("./Vector");
var Comparison_1 = require("./Comparison");
var Contract_1 = require("./Contract");
/**
 * Holds the "static methods" for [[Either]]
 */
var EitherStatic = /** @class */ (function () {
    function EitherStatic() {
    }
    /**
     * Constructs an Either containing a left value which you give.
     */
    EitherStatic.prototype.left = function (val) {
        return new Left(val);
    };
    /**
     * Constructs an Either containing a right value which you give.
     */
    EitherStatic.prototype.right = function (val) {
        return new Right(val);
    };
    /**
     * Curried type guard for Either
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))
     *         .filter(Either.isLeft)
     *         .map(o => o.getLeft())
     *     => Vector.of(1)
     */
    EitherStatic.prototype.isLeft = function (e) {
        return e.isLeft();
    };
    /**
     * Curried type guard for Either
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))
     *         .filter(Either.isRight)
     *         .map(o => o.get())
     *     => Vector.of(2)
     */
    EitherStatic.prototype.isRight = function (e) {
        return e.isRight();
    };
    /**
     * Turns a list of eithers in an either containing a list of items.
     * Useful in many contexts.
     *
     *     Either.sequence(Vector.of(
     *         Either.right<number,number>(1),
     *         Either.right<number,number>(2)));
     *     => Either.right(Vector.of(1,2))
     *
     * But if a single element is Left, everything is discarded:
     *
     *     Either.sequence(Vector.of(
     *           Either.right<number,number>(1),
     *           Either.left<number,number>(2),
     *           Either.left<number,number>(3)));
     *     => Either.left(2)
     *
     * Also see [[EitherStatic.traverse]]
     */
    EitherStatic.prototype.sequence = function (elts) {
        return exports.Either.traverse(elts, function (x) { return x; });
    };
    /**
     * Takes a list, a function that can transform list elements
     * to eithers, then return an either containing a list of
     * the transformed elements.
     *
     *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?
     *         Either.right("user" + x.toString()) : Either.left("invalid id!");
     *     Either.traverse([4, 3, 2], getUserById);
     *     => Either.right(Vector.of("user4", "user3", "user2"))
     *
     * But if a single element results in Left, everything is discarded:
     *
     *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?
     *         Either.right("user" + x.toString()) : Either.left("invalid id!");
     *     Either.traverse([4, -3, 2], getUserById);
     *     => Either.left("invalid id!")
     *
     * Also see [[EitherStatic.sequence]]
     */
    EitherStatic.prototype.traverse = function (elts, fn) {
        var r = Vector_1.Vector.empty();
        var iterator = elts[Symbol.iterator]();
        var curItem = iterator.next();
        while (!curItem.done) {
            var v = fn(curItem.value);
            if (v.isLeft()) {
                return v;
            }
            r = r.append(v.get());
            curItem = iterator.next();
        }
        return exports.Either.right(r);
    };
    /**
     * Turns a list of eithers in an either containing a list of items.
     * Compared to [[EitherStatic.sequence]], sequenceAcc 'accumulates'
     * the errors, instead of short-circuiting on the first error.
     *
     *     Either.sequenceAcc(Vector.of(
     *         Either.right<number,number>(1),
     *         Either.right<number,number>(2)));
     *     => Either.right(Vector.of(1,2))
     *
     * But if a single element is Left, you get all the lefts:
     *
     *     Either.sequenceAcc(Vector.of(
     *           Either.right<number,number>(1),
     *           Either.left<number,number>(2),
     *           Either.left<number,number>(3)));
     *     => Either.left(Vector.of(2,3))
     */
    EitherStatic.prototype.sequenceAcc = function (elts) {
        var _a = Vector_1.Vector.ofIterable(elts).partition(exports.Either.isLeft), lefts = _a[0], rights = _a[1];
        if (lefts.isEmpty()) {
            return exports.Either.right(rights.map(function (r) { return r.getOrThrow(); }));
        }
        return exports.Either.left(lefts.map(function (l) { return l.getLeft(); }));
    };
    /**
     * Applicative lifting for Either.
     * Takes a function which operates on basic values, and turns it
     * in a function that operates on eithers of these values ('lifts'
     * the function). The 2 is because it works on functions taking two
     * parameters.
     *
     *     const lifted = Either.liftA2(
     *         (x:number,y:number) => x+y, {} as string);
     *     lifted(
     *         Either.right<string,number>(5),
     *         Either.right<string,number>(6));
     *     => Either.right(11)
     *
     *     const lifted = Either.liftA2(
     *         (x:number,y:number) => x+y, {} as string);
     *     lifted(
     *         Either.right<string,number>(5),
     *         Either.left<string,number>("bad"));
     *     => Either.left("bad")
     *
     * @param R1 the first right type
     * @param R2 the second right type
     * @param L the left type
     * @param V the new right type as returned by the combining function.
     */
    EitherStatic.prototype.liftA2 = function (fn, leftWitness) {
        return function (p1, p2) { return p1.flatMap(function (a1) { return p2.map(function (a2) { return fn(a1, a2); }); }); };
    };
    /**
     * Applicative lifting for Either. 'p' stands for 'properties'.
     *
     * Takes a function which operates on a simple JS object, and turns it
     * in a function that operates on the same JS object type except which each field
     * wrapped in an Either ('lifts' the function).
     * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters
     * is not two.
     *
     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;
     *     const lifted = Either.liftAp(fn, {} as number);
     *     lifted({
     *         a: Either.right<number,number>(5),
     *         b: Either.right<number,number>(6),
     *         c: Either.right<number,number>(3)});
     *     => Either.right(14)
     *
     *     const lifted = Either.liftAp<number,{a:number,b:number},number>(
     *         x => x.a+x.b);
     *     lifted({
     *         a: Either.right<number,number>(5),
     *         b: Either.left<number,number>(2)});
     *     => Either.left(2)
     *
     * @param L the left type
     * @param A the object property type specifying the parameters for your function
     * @param B the type returned by your function, returned wrapped in an either by liftAp.
     */
    EitherStatic.prototype.liftAp = function (fn, leftWitness) {
        return function (x) {
            var copy = {};
            for (var p in x) {
                if (x[p].isLeft()) {
                    return x[p];
                }
                copy[p] = x[p].getOrThrow();
            }
            return exports.Either.right(fn(copy));
        };
    };
    /**
     * Applicative lifting for Either. 'p' stands for 'properties'.
     * Compared to [[EitherStatic.liftAp]], liftApAcc 'accumulates'
     * the errors, instead of short-circuiting on the first error.
     *
     * Takes a function which operates on a simple JS object, and turns it
     * in a function that operates on the same JS object type except which each field
     * wrapped in an Either ('lifts' the function).
     * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters
     * is not two.
     *
     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;
     *     const lifted = Either.liftApAcc(fn, {} as number);
     *     lifted({
     *         a: Either.right<number,number>(5),
     *         b: Either.right<number,number>(6),
     *         c:Either.right<number,number>(3)});
     *     => Either.right(14)
     *
     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;
     *     const lifted = Either.liftApAcc(fn, {} as number);
     *     lifted({
     *         a: Either.right<number,number>(5),
     *         b: Either.left<number,number>(2),
     *         c: Either.left<number,number>(6)});
     *     => Either.left(Vector.of(2, 6))
     *
     * @param L the left type
     * @param A the object property type specifying the parameters for your function
     * @param B the type returned by your function, returned wrapped in an either by liftAp.
     */
    EitherStatic.prototype.liftApAcc = function (fn, leftWitness) {
        var leftErrs = [];
        return function (x) {
            var copy = {};
            for (var p in x) {
                var field = x[p];
                if (field.isLeft()) {
                    leftErrs.push(field.getLeft());
                }
                else {
                    copy[p] = x[p].getOrThrow();
                }
            }
            if (leftErrs.length === 0) {
                return exports.Either.right(fn(copy));
            }
            else {
                return exports.Either.left(Vector_1.Vector.ofIterable(leftErrs));
            }
        };
    };
    /**
     * Take a partial function (may return undefined or throw),
     * and lift it to return an [[Either]] instead.
     *
     * Note that unlike the [[OptionStatic.lift]] version, if
     * the function returns undefined, the Either.lift version will throw
     * (the Option.lift version returns None()): if you want to do
     * pure side-effects which may throw, you're better off just using
     * javascript try blocks.
     *
     * When using typescript, to help the compiler infer the left type,
     * you can either pass a second parameter like `{} as <type>`, or
     * call with `lift<L,R>(...)`.
     *
     *     const add = Either.lift((x:number,y:number) => x+y, {} as string);
     *     add(1,2);
     *     => Either.right(3)
     *
     *     const undef = Either.lift((x:number,y:number,z:number) => undefined);
     *     undef(1,2,3);
     *     => throws
     *
     *     const throws = Either.lift(() => {throw "x"});
     *     throws();
     *     => Either.left("x")
     */
    EitherStatic.prototype.lift = function (fn, witness) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                var r = fn.apply(void 0, args);
                if (r !== undefined) {
                    return exports.Either.right(r);
                }
            }
            catch (err) {
                return exports.Either.left(err);
            }
            throw new Error("liftEither got undefined!");
        };
    };
    /**
     * Take a no-parameter partial function (may return undefined or throw),
     * call it, and return an [[Either]] instead.
     *
     * Note that unlike the [[OptionStatic.try_]] version, if
     * the function returns undefined, this function will throw
     * (the Option.try_ version returns None()): if you want to do
     * pure side-effects which may throw, you're better off just using
     * javascript try blocks.
     *
     * When using typescript, to help the compiler infer the left type,
     * you can either pass a second parameter like `{} as <type>`, or
     * call with `try_<L,R>(...)`.
     *
     *     Either.try_(Math.random, {} as string);
     *     => Either.right(0.49884723907769635)
     *
     *     Either.try_(() => undefined);
     *     => throws
     *
     *     Either.try_(() => {throw "x"});
     *     => Either.left("x")
     *
     * Also see [[EitherStatic.lift]], [[OptionStatic.try_]],
     * [[OptionStatic.tryNullable]]
     */
    EitherStatic.prototype.try_ = function (fn, witness) {
        return exports.Either.lift(fn)();
    };
    return EitherStatic;
}());
exports.EitherStatic = EitherStatic;
/**
 * The Either constant allows to call the either "static" methods
 */
exports.Either = new EitherStatic();
/**
 * Represents an [[Either]] containing a left value,
 * conceptually tied to a failure.
 * "static methods" available through [[EitherStatic]]
 * @param L the "left" item type 'failure'
 * @param R the "right" item type 'success'
 */
var Left = /** @class */ (function () {
    function Left(value) {
        this.value = value;
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * Returns true since this is a Left
     */
    Left.prototype.isLeft = function () {
        return true;
    };
    /**
     * Returns false since this is a Left
     */
    Left.prototype.isRight = function () {
        return false;
    };
    /**
     * Returns true if this is either is a right and contains the value you give.
     */
    Left.prototype.contains = function (val) {
        return false;
    };
    /**
     * If this either is a right, applies the function you give
     * to its contents and build a new right either, otherwise return this.
     */
    Left.prototype.map = function (fn) {
        return this;
    };
    /**
     * If this either is a right, call the function you give with
     * the contents, and return what the function returns, else
     * returns this.
     * This is the monadic bind.
     */
    Left.prototype.flatMap = function (fn) {
        return this;
    };
    /**
     * If this either is a left, call the function you give with
     * the left value and return a new either left with the result
     * of the function, else return this.
     */
    Left.prototype.mapLeft = function (fn) {
        return new Left(fn(this.value));
    };
    /**
     * Map the either: you give a function to apply to the value,
     * a function in case it's a left, a function in case it's a right.
     */
    Left.prototype.bimap = function (fnL, fnR) {
        return new Left(fnL(this.value));
    };
    /**
     * "filter" the either. If it was a Left, it stays a Left.
     * If it was a Right and the predicate you pass returns
     * true for its value, return the either unchanged.
     * But if it was a left and the predicate returns false,
     * return a Left with the value returned by the function
     * passed as second parameter.
     *
     *     Either.right<string,number>(-3)
     *         .filter(x => x >= 0, v => "got negative value: " + v);
     *     => Either.left<string,number>("got negative value: -3")
     */
    Left.prototype.filter = function (p, filterVal) {
        return this;
    };
    /**
     * Combines two eithers. If this either is a right, returns it.
     * If it's a left, returns the other one.
     */
    Left.prototype.orElse = function (other) {
        return other;
    };
    /**
     * Has no effect if this Either is a right. If it's a left however,
     * the function you give will be called, receiving as parameter
     * the left contents, and an Either equivalent to the one your
     * function returns will be returned.
     */
    Left.prototype.recoverWith = function (recoveryFn) {
        return recoveryFn(this.value);
    };
    /**
     * Execute a side-effecting function if the either
     * is a right; returns the either.
     */
    Left.prototype.ifRight = function (fn) {
        return this;
    };
    /**
     * Execute a side-effecting function if the either
     * is a left; returns the either.
     */
    Left.prototype.ifLeft = function (fn) {
        fn(this.value);
        return this;
    };
    /**
     * Handle both branches of the either and return a value
     * (can also be used for side-effects).
     * This is the catamorphism for either.
     *
     *     Either.right<string,number>(5).match({
     *         Left:  x => "left " + x,
     *         Right: x => "right " + x
     *     });
     *     => "right 5"
     */
    Left.prototype.match = function (cases) {
        return cases.Left(this.value);
    };
    /**
     * If this either is a right, return its value, else throw
     * an exception.
     * You can optionally pass a message that'll be used as the
     * exception message, or an Error object.
     */
    Left.prototype.getOrThrow = function (errorInfo) {
        if (typeof errorInfo === 'string') {
            throw new Error(errorInfo || "Left.getOrThrow called!");
        }
        throw errorInfo || new Error("Left.getOrThrow called!");
    };
    /**
     * If this either is a right, return its value, else return
     * the value you give.
     */
    Left.prototype.getOrElse = function (other) {
        return other;
    };
    /**
     * Get the value contained in this left.
     * NOTE: we know it's there, since this method
     * belongs to Left, not Either.
     */
    Left.prototype.getLeft = function () {
        return this.value;
    };
    /**
     * If this either is a left, return its value, else throw
     * an exception.
     * You can optionally pass a message that'll be used as the
     * exception message.
     */
    Left.prototype.getLeftOrThrow = function (message) {
        return this.value;
    };
    /**
     * If this either is a left, return its value, else return
     * the value you give.
     */
    Left.prototype.getLeftOrElse = function (other) {
        return this.value;
    };
    /**
     * Convert this either to an option, conceptually dropping
     * the left (failing) value.
     */
    Left.prototype.toOption = function () {
        return Option_1.Option.none();
    };
    /**
     * Convert to a vector. If it's a left, it's the empty
     * vector, if it's a right, it's a one-element vector with
     * the contents of the either.
     */
    Left.prototype.toVector = function () {
        return Vector_1.Vector.empty();
    };
    /**
     * Convert to a list. If it's a left, it's the empty
     * list, if it's a right, it's a one-element list with
     * the contents of the either.
     */
    Left.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.empty();
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    Left.prototype.transform = function (converter) {
        return converter(this);
    };
    Left.prototype.hasTrueEquality = function () {
        return (this.value && this.value.hasTrueEquality) ?
            this.value.hasTrueEquality() :
            Comparison_1.hasTrueEquality(this.value);
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    Left.prototype.hashCode = function () {
        return Comparison_1.getHashCode(this.value);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    Left.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if ((!other) || (!other.isRight) || other.isRight()) {
            return false;
        }
        var leftOther = other;
        Contract_1.contractTrueEquality("Either.equals", this, leftOther);
        return Comparison_1.areEqual(this.value, leftOther.value);
    };
    /**
     * Get a human-friendly string representation of that value.
     */
    Left.prototype.toString = function () {
        return "Left(" + this.value + ")";
    };
    /**
     * Used by the node REPL to display values.
     */
    Left.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return Left;
}());
exports.Left = Left;
/**
 * Represents an [[Either]] containing a success value,
 * conceptually tied to a success.
 * "static methods" available through [[EitherStatic]]
 * @param L the "left" item type 'failure'
 * @param R the "right" item type 'success'
 */
var Right = /** @class */ (function () {
    function Right(value) {
        this.value = value;
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * Returns false since this is a Right
     */
    Right.prototype.isLeft = function () {
        return false;
    };
    /**
     * Returns true since this is a Right
     */
    Right.prototype.isRight = function () {
        return true;
    };
    /**
     * Returns true if this is either is a right and contains the value you give.
     */
    Right.prototype.contains = function (val) {
        return Comparison_1.areEqual(this.value, val);
    };
    /**
     * If this either is a right, applies the function you give
     * to its contents and build a new right either, otherwise return this.
     */
    Right.prototype.map = function (fn) {
        return new Right(fn(this.value));
    };
    /**
     * If this either is a right, call the function you give with
     * the contents, and return what the function returns, else
     * returns this.
     * This is the monadic bind.
     */
    Right.prototype.flatMap = function (fn) {
        return fn(this.value);
    };
    /**
     * If this either is a left, call the function you give with
     * the left value and return a new either left with the result
     * of the function, else return this.
     */
    Right.prototype.mapLeft = function (fn) {
        return this;
    };
    /**
     * Map the either: you give a function to apply to the value,
     * a function in case it's a left, a function in case it's a right.
     */
    Right.prototype.bimap = function (fnL, fnR) {
        return new Right(fnR(this.value));
    };
    /**
     * "filter" the either. If it was a Left, it stays a Left.
     * If it was a Right and the predicate you pass returns
     * true for its value, return the either unchanged.
     * But if it was a left and the predicate returns false,
     * return a Left with the value returned by the function
     * passed as second parameter.
     *
     *     Either.right<string,number>(-3)
     *         .filter(x => x >= 0, v => "got negative value: " + v);
     *     => Either.left<string,number>("got negative value: -3")
     */
    Right.prototype.filter = function (p, filterVal) {
        if (p(this.value)) {
            return this;
        }
        return new Left(filterVal(this.value));
    };
    /**
     * Combines two eithers. If this either is a right, returns it.
     * If it's a left, returns the other one.
     */
    Right.prototype.orElse = function (other) {
        return this;
    };
    /**
     * Has no effect if this Either is a right. If it's a left however,
     * the function you give will be called, receiving as parameter
     * the left contents, and an Either equivalent to the one your
     * function returns will be returned.
     */
    Right.prototype.recoverWith = function (recoveryFn) {
        return this;
    };
    /**
     * Execute a side-effecting function if the either
     * is a right; returns the either.
     */
    Right.prototype.ifRight = function (fn) {
        fn(this.value);
        return this;
    };
    /**
     * Execute a side-effecting function if the either
     * is a left; returns the either.
     */
    Right.prototype.ifLeft = function (fn) {
        return this;
    };
    /**
     * Handle both branches of the either and return a value
     * (can also be used for side-effects).
     * This is the catamorphism for either.
     *
     *     Either.right<string,number>(5).match({
     *         Left:  x => "left " + x,
     *         Right: x => "right " + x
     *     });
     *     => "right 5"
     */
    Right.prototype.match = function (cases) {
        return cases.Right(this.value);
    };
    /**
     * Get the value contained in this right.
     * NOTE: we know it's there, since this method
     * belongs to Right, not Either.
     */
    Right.prototype.get = function () {
        return this.value;
    };
    /**
     * If this either is a right, return its value, else throw
     * an exception.
     * You can optionally pass a message that'll be used as the
     * exception message, or an Error object.
     */
    Right.prototype.getOrThrow = function (errorInfo) {
        return this.value;
    };
    /**
     * If this either is a right, return its value, else return
     * the value you give.
     */
    Right.prototype.getOrElse = function (other) {
        return this.value;
    };
    /**
     * If this either is a left, return its value, else throw
     * an exception.
     * You can optionally pass a message that'll be used as the
     * exception message.
     */
    Right.prototype.getLeftOrThrow = function (message) {
        throw message || "Left.getOrThrow called!";
    };
    /**
     * If this either is a left, return its value, else return
     * the value you give.
     */
    Right.prototype.getLeftOrElse = function (other) {
        return other;
    };
    /**
     * Convert this either to an option, conceptually dropping
     * the left (failing) value.
     */
    Right.prototype.toOption = function () {
        return Option_1.Option.of(this.value);
    };
    /**
     * Convert to a vector. If it's a left, it's the empty
     * vector, if it's a right, it's a one-element vector with
     * the contents of the either.
     */
    Right.prototype.toVector = function () {
        return Vector_1.Vector.of(this.value);
    };
    /**
     * Convert to a list. If it's a left, it's the empty
     * list, if it's a right, it's a one-element list with
     * the contents of the either.
     */
    Right.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.of(this.value);
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    Right.prototype.transform = function (converter) {
        return converter(this);
    };
    Right.prototype.hasTrueEquality = function () {
        return (this.value && this.value.hasTrueEquality) ?
            this.value.hasTrueEquality() :
            Comparison_1.hasTrueEquality(this.value);
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    Right.prototype.hashCode = function () {
        return Comparison_1.getHashCode(this.value);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    Right.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if ((!other) || (!other.isRight) || (!other.isRight())) {
            return false;
        }
        var rightOther = other;
        Contract_1.contractTrueEquality("Either.equals", this, rightOther);
        return Comparison_1.areEqual(this.value, rightOther.value);
    };
    /**
     * Get a human-friendly string representation of that value.
     */
    Right.prototype.toString = function () {
        return "Right(" + this.value + ")";
    };
    /**
     * Used by the node REPL to display values.
     */
    Right.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return Right;
}());
exports.Right = Right;
//# sourceMappingURL=Either.js.map