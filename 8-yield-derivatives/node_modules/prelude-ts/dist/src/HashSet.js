"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var ISet_1 = require("./ISet");
var Vector_1 = require("./Vector");
var HashMap_1 = require("./HashMap");
var LinkedList_1 = require("./LinkedList");
var Option_1 = require("./Option");
var Comparison_1 = require("./Comparison");
var SeqHelpers = require("./SeqHelpers");
var Contract_1 = require("./Contract");
var Value_1 = require("./Value");
var hamt = require("hamt_plus");
/**
 * An unordered collection of values, where no two values
 * may be equal. A value can only be present once.
 * @param T the item type
 */
var HashSet = /** @class */ (function () {
    /**
     * @hidden
     */
    function HashSet(hamt) {
        this.hamt = hamt;
    }
    /**
     * The empty hashset.
     * @param T the item type
     */
    HashSet.empty = function () {
        return emptyHashSet;
    };
    /**
     * Build a hashset from any iterable, which means also
     * an array for instance.
     * @param T the item type
     */
    HashSet.ofIterable = function (elts) {
        return new EmptyHashSet().addAll(elts);
    };
    /**
     * Build a hashset from a series of items (any number, as parameters)
     * @param T the item type
     */
    HashSet.of = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        return HashSet.ofIterable(arr);
    };
    /**
     * Curried predicate to find out whether the HashSet is empty.
     *
     *     Vector.of(HashSet.of(1), HashSet.empty<number>())
     *         .filter(HashSet.isEmpty)
     *     => Vector.of(HashSet.empty<number>())
     */
    HashSet.isEmpty = function (v) {
        return v.isEmpty();
    };
    /**
     * Curried predicate to find out whether the HashSet is empty.
     *
     *     Vector.of(HashSet.of(1), HashSet.empty<number>())
     *         .filter(HashSet.isNotEmpty)
     *     => Vector.of(HashSet.of(1))
     */
    HashSet.isNotEmpty = function (v) {
        return !v.isEmpty();
    };
    /**
     * Implementation of the Iterator interface.
     */
    HashSet.prototype[Symbol.iterator] = function () {
        return this.hamt.keys();
    };
    /**
     * Add an element to this set.
     */
    HashSet.prototype.add = function (elt) {
        return new HashSet(this.hamt.set(elt, elt));
    };
    HashSet.prototype.addAllArray = function (elts) {
        return new HashSet(this.hamt.mutate(function (h) {
            if (elts.length > 0) {
                Contract_1.contractTrueEquality("Error building a HashSet", elts[0]);
            }
            for (var _i = 0, elts_1 = elts; _i < elts_1.length; _i++) {
                var val = elts_1[_i];
                h.set(val, val);
            }
        }));
    };
    /**
     * Add multiple elements to this set.
     */
    HashSet.prototype.addAll = function (elts) {
        if (Array.isArray(elts)) {
            return this.addAllArray(elts);
        }
        return new HashSet(this.hamt.mutate(function (h) {
            var checkedEq = false;
            var iterator = elts[Symbol.iterator]();
            var curItem = iterator.next();
            if (!curItem.done && curItem.value && !checkedEq) {
                Contract_1.contractTrueEquality("Error building a HashSet", curItem.value);
                checkedEq = true;
            }
            while (!curItem.done) {
                h.set(curItem.value, curItem.value);
                curItem = iterator.next();
            }
        }));
    };
    /**
     * Returns true if the element you give is present in
     * the set, false otherwise.
     */
    HashSet.prototype.contains = function (elt) {
        return this.hamt.has(elt);
    };
    /**
     * Return a new collection where each element was transformed
     * by the mapper function you give.
     * The resulting set may be smaller than the source.
     */
    HashSet.prototype.map = function (mapper) {
        return this.hamt.fold(function (acc, value, key) {
            return acc.add(mapper(value));
        }, HashSet.empty());
    };
    /**
     * Apply the mapper function on every element of this collection.
     * The mapper function returns an Option; if the Option is a Some,
     * the value it contains is added to the result Collection, if it's
     * a None, the value is discarded.
     *
     *     HashSet.of(1,2,6).mapOption(x => x%2===0 ?
     *         Option.of(x+1) : Option.none<number>())
     *     => HashSet.of(3, 7)
     */
    HashSet.prototype.mapOption = function (mapper) {
        return this.hamt.fold(function (acc, value, key) {
            var val = mapper(value);
            return val.isSome() ? acc.add(val.get()) : acc;
        }, HashSet.empty());
    };
    /**
     * Call a function for element in the collection.
     */
    HashSet.prototype.forEach = function (fun) {
        var iterator = this.hamt.values();
        var curItem = iterator.next();
        while (!curItem.done) {
            fun(curItem.value);
            curItem = iterator.next();
        }
        return this;
    };
    /**
     * Calls the function you give for each item in the set,
     * your function returns a set, all the sets are
     * merged.
     */
    HashSet.prototype.flatMap = function (mapper) {
        return this.foldLeft(HashSet.empty(), function (soFar, cur) { return soFar.addAll(mapper(cur)); });
    };
    HashSet.prototype.filter = function (predicate) {
        var _this = this;
        return new HashSet(hamt.make({ hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq }).mutate(function (h) {
            var iterator = _this.hamt.values();
            var curItem = iterator.next();
            while (!curItem.done) {
                if (predicate(curItem.value)) {
                    h.set(curItem.value, curItem.value);
                }
                curItem = iterator.next();
            }
        }));
    };
    /**
     * Search for an item matching the predicate you pass,
     * return Option.Some of that element if found,
     * Option.None otherwise.
     * We name the method findAny instead of find to emphasize
     * that there is not ordering in a hashset.
     *
     *     HashSet.of(1,2,3).findAny(x => x>=3)
     *     => Option.of(3)
     *
     *     HashSet.of(1,2,3).findAny(x => x>=4)
     *     => Option.none<number>()
     */
    HashSet.prototype.findAny = function (predicate) {
        var iterator = this.hamt.values();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (predicate(curItem.value)) {
                return Option_1.Option.of(curItem.value);
            }
            curItem = iterator.next();
        }
        return Option_1.Option.none();
    };
    /**
     * Reduces the collection to a single value using the
     * associative binary function you give. Since the function
     * is associative, order of application doesn't matter.
     *
     * Example:
     *
     *     HashSet.of(1,2,3).fold(0, (a,b) => a + b);
     *     => 6
     */
    HashSet.prototype.fold = function (zero, fn) {
        return this.foldLeft(zero, fn);
    };
    /**
     * Reduces the collection to a single value.
     * Left-associative.
     * No guarantees for the order of items in a hashset!
     *
     * Example:
     *
     *     HashSet.of("a", "bb", "ccc").foldLeft(0, (soFar,item) => soFar+item.length);
     *     => 6
     *
     * @param zero The initial value
     * @param fn A function taking the previous value and
     *           the current collection item, and returning
     *           an updated value.
     */
    HashSet.prototype.foldLeft = function (zero, fn) {
        return this.hamt.fold(function (acc, v, k) {
            return fn(acc, v);
        }, zero);
    };
    /**
     * Reduces the collection to a single value.
     * Right-associative.
     * No guarantees for the order of items in a hashset!
     *
     * Example:
     *
     *     HashSet.of("a", "bb", "ccc").foldRight(0, (item,soFar) => soFar+item.length);
     *     => 6
     *
     * @param zero The initial value
     * @param fn A function taking the current collection item and
     *           the previous value , and returning
     *           an updated value.
     */
    HashSet.prototype.foldRight = function (zero, fn) {
        return this.foldLeft(zero, function (cur, soFar) { return fn(soFar, cur); });
    };
    /**
     * Converts this set to an array. Since a Set is not ordered
     * and since this method returns a JS array, it can be awkward
     * to get an array sorted in the way you'd like. So you can pass
     * an optional sorting function too.
     *
     *     HashSet.of(1,2,3).toArray().sort()
     *     => [1,2,3]
     *
     *     HashSet.of(1,2,3).toArray({sortOn:x=>x})
     *     => [1,2,3]
     *
     *     HashSet.of(1,2,3).toArray({sortBy:(x,y)=>x-y})
     *     => [1,2,3]
     *
     * You can also pass an array in sortOn, listing lambdas to
     * several fields to sort by those fields, and also {desc:lambda}
     * to sort by some fields descending.
     */
    HashSet.prototype.toArray = function (sort) {
        var _a;
        if (!sort) {
            return Array.from(this.hamt.keys());
        }
        if (ISet_1.isSortOnSpec(sort)) {
            var sortOn = sort.sortOn instanceof Array ? sort.sortOn : [sort.sortOn];
            return (_a = Vector_1.Vector.ofIterable(this.hamt.keys())).sortOn.apply(_a, sortOn).toArray();
        }
        return Array.from(this.hamt.keys()).sort(sort.sortBy);
    };
    /**
     * Converts this set to an vector
     */
    HashSet.prototype.toVector = function () {
        return Vector_1.Vector.ofIterable(this.hamt.keys());
    };
    /**
     * Converts this set to an list
     */
    HashSet.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.ofIterable(this.hamt.keys());
    };
    /**
     * Returns the number of elements in the set.
     */
    HashSet.prototype.length = function () {
        return this.hamt.size;
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    HashSet.prototype.single = function () {
        return this.hamt.size === 1
            ? Option_1.Option.of(this.hamt.keys().next().value)
            : Option_1.Option.none();
    };
    /**
     * true if the set is empty, false otherwise.
     */
    HashSet.prototype.isEmpty = function () {
        return this.hamt.size === 0;
    };
    /**
     * Returns a new Set containing the difference
     * between this set and the other Set passed as parameter.
     * also see [[HashSet.intersect]]
     */
    HashSet.prototype.diff = function (elts) {
        return new HashSet(this.hamt.fold(function (acc, v, k) {
            return elts.contains(k) ? acc : acc.set(k, k);
        }, hamt.empty));
    };
    /**
     * Returns a new Set containing the intersection
     * of this set and the other Set passed as parameter
     * (the elements which are common to both sets)
     * also see [[HashSet.diff]]
     */
    HashSet.prototype.intersect = function (other) {
        return new HashSet(this.hamt.fold(function (acc, v, k) {
            return other.contains(k) ? acc.set(k, k) : acc;
        }, hamt.empty));
    };
    HashSet.prototype.isSubsetOf = function (other) {
        return this.allMatch(function (x) { return other.contains(x); });
    };
    /**
     * Returns a new set with the element you give removed
     * if it was present in the set.
     */
    HashSet.prototype.remove = function (elt) {
        return new HashSet(this.hamt.remove(elt));
    };
    /**
     * Returns a new set with all the elements of the current
     * Set, minus the elements of the iterable you give as a parameter.
     * If you call this function with a HashSet as parameter,
     * rather call 'diff', as it'll be faster.
     */
    HashSet.prototype.removeAll = function (elts) {
        return this.diff(HashSet.ofIterable(elts));
    };
    HashSet.prototype.allMatch = function (predicate) {
        var iterator = this.hamt.values();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (!predicate(curItem.value)) {
                return false;
            }
            curItem = iterator.next();
        }
        return true;
    };
    /**
     * Returns true if there the predicate returns true for any
     * element in the collection.
     */
    HashSet.prototype.anyMatch = function (predicate) {
        var iterator = this.hamt.values();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (predicate(curItem.value)) {
                return true;
            }
            curItem = iterator.next();
        }
        return false;
    };
    /**
     * Group elements in the collection using a classifier function.
     * Elements are then organized in a map. The key is the value of
     * the classifier, and in value we get the list of elements
     * matching that value.
     *
     * also see [[HashSet.arrangeBy]]
     */
    HashSet.prototype.groupBy = function (classifier) {
        var _this = this;
        // make a singleton set with the same equality as this
        var singletonHamtSet = function (v) { return hamt.make({
            hash: _this.hamt._config.hash, keyEq: _this.hamt._config.keyEq
        }).set(v, v); };
        // merge two mutable hamt sets, but I know the second has only 1 elt
        var mergeSets = function (v1, v2) {
            var k = v2.keys().next().value;
            v1.set(k, k);
            return v1;
        };
        return this.hamt.fold(
        // fold operation: combine a new value from the set with the accumulator
        function (acc, v, k) {
            return acc.putWithMerge(classifier(v), singletonHamtSet(v).beginMutation(), mergeSets);
        }, 
        // fold accumulator: the empty hashmap
        HashMap_1.HashMap.empty())
            .mapValues(function (h) { return new HashSet(h.endMutation()); });
    };
    /**
     * Matches each element with a unique key that you extract from it.
     * If the same key is present twice, the function will return None.
     *
     * also see [[HashSet.groupBy]]
     */
    HashSet.prototype.arrangeBy = function (getKey) {
        return SeqHelpers.arrangeBy(this, getKey);
    };
    HashSet.prototype.partition = function (predicate) {
        var r1 = hamt.make({
            hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq
        }).beginMutation();
        var r2 = hamt.make({
            hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq
        }).beginMutation();
        var iterator = this.hamt.values();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (predicate(curItem.value)) {
                r1.set(curItem.value, curItem.value);
            }
            else {
                r2.set(curItem.value, curItem.value);
            }
            curItem = iterator.next();
        }
        return [new HashSet(r1), new HashSet(r2)];
    };
    /**
     * Reduces the collection to a single value by repeatedly
     * calling the combine function.
     * No starting value. The order in which the elements are
     * passed to the combining function is undetermined.
     */
    HashSet.prototype.reduce = function (combine) {
        return SeqHelpers.reduce(this, combine);
    };
    /**
     * Compare values in the collection and return the smallest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[HashSet.minOn]]
     */
    HashSet.prototype.minBy = function (compare) {
        return SeqHelpers.minBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the smallest.
     * Returns Option.none if the collection is empty.
     *
     * also see [[HashSet.minBy]]
     */
    HashSet.prototype.minOn = function (getOrderable) {
        return SeqHelpers.minOn(this, getOrderable);
    };
    /**
     * Compare values in the collection and return the largest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[HashSet.maxOn]]
     */
    HashSet.prototype.maxBy = function (compare) {
        return SeqHelpers.maxBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the largest.
     * Returns Option.none if the collection is empty.
     *
     * also see [[HashSet.maxBy]]
     */
    HashSet.prototype.maxOn = function (getOrderable) {
        return SeqHelpers.maxOn(this, getOrderable);
    };
    /**
     * Call the function you give for each element in the collection
     * and sum all the numbers, return that sum.
     * Will return 0 if the collection is empty.
     *
     *     HashSet.of(1,2,3).sumOn(x=>x)
     *     => 6
     */
    HashSet.prototype.sumOn = function (getNumber) {
        return SeqHelpers.sumOn(this, getNumber);
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    HashSet.prototype.transform = function (converter) {
        return converter(this);
    };
    HashSet.prototype.toJsSet = function (keyConvert) {
        return this.foldLeft(new Set(), function (sofar, cur) { return sofar.add(keyConvert(cur)); });
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    HashSet.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        var sz = this.hamt.size;
        if (other === emptyHashSet && sz === 0) {
            // we could get that i'm not the empty map
            // but my size is zero, after some filtering and such.
            return true;
        }
        if (!other || !other.hamt) {
            return false;
        }
        if (sz !== other.hamt.size) {
            return false;
        }
        Contract_1.contractTrueEquality("HashSet.equals", this, other);
        var keys = Array.from(this.hamt.keys());
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            var hisVal = other.hamt.get(k);
            if (hisVal === undefined) {
                return false;
            }
            if (!Comparison_1.areEqual(k, hisVal)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    HashSet.prototype.hashCode = function () {
        return this.hamt.fold(function (acc, value, key) {
            return acc + Comparison_1.getHashCode(key);
        }, 0);
    };
    /**
     * Get a human-friendly string representation of that value.
     *
     * Also see [[HashSet.mkString]]
     */
    HashSet.prototype.toString = function () {
        return "HashSet(" +
            this.hamt.fold(function (acc, value, key) { acc.push(SeqHelpers.toStringHelper(key)); return acc; }, []).join(", ")
            + ")";
    };
    HashSet.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    /**
     * Joins elements of the collection by a separator.
     * Example:
     *
     *     HashSet.of(1,2,3).mkString(", ")
     *     => "1, 2, 3"
     *
     * (of course, order is not guaranteed)
     */
    HashSet.prototype.mkString = function (separator) {
        return this.hamt.fold(function (acc, value, key) { acc.push(SeqHelpers.toStringHelper(key, { quoteStrings: false })); return acc; }, []).join(separator);
    };
    return HashSet;
}());
exports.HashSet = HashSet;
// we need to override the empty hashmap
// because i don't know how to get the hash & keyset
// functions for the keys without a key value to get
// the functions from
var EmptyHashSet = /** @class */ (function (_super) {
    __extends(EmptyHashSet, _super);
    function EmptyHashSet() {
        return _super.call(this, {}) || this;
    }
    EmptyHashSet.prototype.add = function (elt) {
        Contract_1.contractTrueEquality("Error building a HashSet", elt);
        if (!elt) {
            // special case if we get null for the first element...
            // less optimized variant because we don't know
            // if we should use '===' or 'equals'
            return new HashSet(hamt.make({
                hash: function (v) { return Comparison_1.getHashCode(v); },
                keyEq: function (a, b) { return Comparison_1.areEqual(a, b); }
            }).set(elt, elt));
        }
        // if the element is not null, save a if later by finding
        // out right now whether we should call equals or ===
        if (Comparison_1.hasEquals(elt)) {
            return new HashSet(hamt.make({
                hash: function (v) { return v.hashCode(); },
                keyEq: function (a, b) { return a.equals(b); }
            }).set(elt, elt));
        }
        return new HashSet(hamt.make().set(elt, elt));
    };
    EmptyHashSet.prototype.addAll = function (elts) {
        var _a;
        var it = elts[Symbol.iterator]();
        var curItem = it.next();
        if (curItem.done) {
            return emptyHashSet;
        }
        return this.add(curItem.value).addAll((_a = {}, _a[Symbol.iterator] = function () { return it; }, _a));
    };
    EmptyHashSet.prototype.contains = function (elt) {
        return false;
    };
    EmptyHashSet.prototype.map = function (mapper) {
        return emptyHashSet;
    };
    EmptyHashSet.prototype.mapOption = function (mapper) {
        return emptyHashSet;
    };
    EmptyHashSet.prototype.forEach = function (fun) {
        return this;
    };
    EmptyHashSet.prototype.filter = function (predicate) {
        return this;
    };
    EmptyHashSet.prototype.findAny = function (predicate) {
        return Option_1.Option.none();
    };
    EmptyHashSet.prototype.foldLeft = function (zero, fn) {
        return zero;
    };
    EmptyHashSet.prototype.toArray = function (sort) {
        return [];
    };
    EmptyHashSet.prototype.toVector = function () {
        return Vector_1.Vector.empty();
    };
    EmptyHashSet.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.empty();
    };
    EmptyHashSet.prototype[Symbol.iterator] = function () {
        return { next: function () { return ({ done: true, value: undefined }); } };
    };
    EmptyHashSet.prototype.length = function () {
        return 0;
    };
    EmptyHashSet.prototype.isEmpty = function () {
        return true;
    };
    EmptyHashSet.prototype.diff = function (elts) {
        return this;
    };
    EmptyHashSet.prototype.intersect = function (other) {
        return this;
    };
    EmptyHashSet.prototype.anyMatch = function (predicate) {
        return false;
    };
    EmptyHashSet.prototype.groupBy = function (classifier) {
        return HashMap_1.HashMap.empty();
    };
    EmptyHashSet.prototype.allMatch = function (predicate) {
        return true;
    };
    EmptyHashSet.prototype.partition = function (predicate) {
        return [this, this];
    };
    EmptyHashSet.prototype.remove = function (elt) {
        return this;
    };
    EmptyHashSet.prototype.equals = function (other) {
        if (!other || !other.length) {
            return false;
        }
        return other === emptyHashSet || other.length() === 0;
    };
    EmptyHashSet.prototype.hashCode = function () {
        return 0;
    };
    EmptyHashSet.prototype.toString = function () {
        return "HashSet()";
    };
    EmptyHashSet.prototype.mkString = function (separator) {
        return "";
    };
    return EmptyHashSet;
}(HashSet));
var emptyHashSet = new EmptyHashSet();
//# sourceMappingURL=HashSet.js.map