"use strict";
exports.__esModule = true;
var Vector_1 = require("./Vector");
var Option_1 = require("./Option");
var Either_1 = require("./Either");
var HashMap_1 = require("./HashMap");
/**
 * A Future is the equivalent, and ultimately wraps, a javascript Promise.
 * While Futures support the [[Future.then]] call (so that among others
 * you can use `await` on them), you should call [[Future.map]] and
 * [[Future.flatMap]].
 *
 * Futures represent an asynchronous computation. A Future will only ever
 * be computed once at most. Once it's computed, calling [[Future.map]] or
 * `await` will return instantly.
 */
var Future = /** @class */ (function () {
    // careful cause i can't have my type be F<F<T>>
    // while the code does F<T> as JS's then does!!!
    // for that reason I wrap the value in an array
    // to make sure JS will never turn a Promise<Promise<T>>
    // in a Promise<T>
    function Future(promise) {
        this.promise = promise;
    }
    /**
     * Build a Future in the same way as the 'new Promise'
     * constructor.
     * You get one callback to signal success (resolve),
     * failure (reject), or you can throw to signal failure.
     *
     *     Future.ofPromiseCtor<string>((resolve,reject) => setTimeout(resolve, 10, "hello!"))
     */
    Future.ofPromiseCtor = function (executor) {
        return new Future(new Promise(executor).then(function (v) { return [v]; }));
    };
    /**
     * Build a Future from an existing javascript Promise.
     */
    Future.of = function (promise) {
        return new Future(promise.then(function (x) { return [x]; }));
    };
    /**
     * Build a Future from a node-style callback API, for instance:
     *
     *     Future.ofCallback<string>(cb => fs.readFile('/etc/passwd', 'utf-8', cb))
     */
    Future.ofCallback = function (fn) {
        return Future.ofPromiseCtor(function (resolve, reject) { return fn(function (err, data) {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        }); });
    };
    /**
     * Build a successful Future with the value you provide.
     */
    Future.ok = function (val) {
        return new Future(Promise.resolve([val]));
    };
    /**
     * Build a failed Future with the error data you provide.
     */
    Future.failed = function (reason) {
        return new Future(Promise.reject(reason));
    };
    /**
     * Creates a Future from a function returning a Promise,
     * which can be inline in the call, for instance:
     *
     *     const f1 = Future.ok(1);
     *     const f2 = Future.ok(2);
     *     return Future.do(async () => {
     *         const v1 = await f1;
     *         const v2 = await f2;
     *         return v1 + v2;
     *     });
     */
    Future["do"] = function (fn) {
        return Future.of(fn());
    };
    /**
     * The `then` call is not meant to be a part of the `Future` API,
     * we need then so that `await` works directly.
     *
     * Please rather use [[Future.map]] or [[Future.flatMap]].
     */
    Future.prototype.then = function (onfulfilled, onrejected) {
        return this.promise.then(function (_a) {
            var x = _a[0];
            return onfulfilled(x);
        }, function (rejected) { return onrejected ? onrejected(rejected) : Promise.reject(rejected); });
    };
    /**
     * Get a `Promise` from this `Future`.
     */
    Future.prototype.toPromise = function () {
        return this.promise.then(function (_a) {
            var x = _a[0];
            return x;
        });
    };
    /**
     * Returns a `Future` that'll complete when the first `Future` of
     * the iterable you give will complete, with the value of that first
     * future. Be careful, completing doesn't necessarily mean completing
     * successfully!
     *
     * Also see [[Future.firstSuccessfulOf]]
     */
    Future.firstCompletedOf = function (elts) {
        return Future.of(Promise.race(Vector_1.Vector.ofIterable(elts).map(function (f) { return f.toPromise(); })));
    };
    /**
     * Returns a `Future` that'll complete when the first `Future` of
     * the iterable you give will complete successfully, with the value of that first
     * future.
     *
     * Also see [[Future.firstCompletedOf]]
     */
    Future.firstSuccessfulOf = function (elts) {
        // https://stackoverflow.com/a/37235274/516188
        return Future.of(Promise.all(Vector_1.Vector.ofIterable(elts).map(function (p) {
            // If a request fails, count that as a resolution so it will keep
            // waiting for other possible successes. If a request succeeds,
            // treat it as a rejection so Promise.all immediately bails out.
            return p.then(function (val) { return Promise.reject(val); }, function (err) { return Promise.resolve(err); });
        })).then(
        // If '.all' resolved, we've just got an array of errors.
        function (errors) { return Promise.reject(errors); }, 
        // If '.all' rejected, we've got the result we wanted.
        function (val) { return Promise.resolve(val); }));
    };
    /**
     * Turns a list of futures in a future containing a list of items.
     * Useful in many contexts.
     *
     * But if a single future is failed, you get back a failed Future.
     *
     * Also see [[Future.traverse]]
     */
    Future.sequence = function (elts) {
        return Future.traverse(elts, function (x) { return x; });
    };
    /**
     * Takes a list, a function that can transform list elements
     * to futures, then return a Future containing a list of
     * the transformed elements.
     *
     * But if a single element results in failure, the result also
     * resolves to a failure.
     *
     * There is an optional third parameter to specify options.
     * You can specify `{maxConcurrent: number}` to request that
     * the futures are not all triggered at the same time, but
     * rather only 'number' at a time.
     *
     * Also see [[Future.sequence]]
     */
    Future.traverse = function (elts, fn, opts) {
        if (!opts) {
            return Future.of(Promise.all(Vector_1.Vector.ofIterable(elts).map(function (x) { return fn(x).toPromise(); }))
                .then(Vector_1.Vector.ofIterable));
        }
        // maxConcurrent algorithm inspired by https://stackoverflow.com/a/38778887/516188
        var index = 0;
        var active = [];
        var results = {};
        var it = elts[Symbol.iterator]();
        var failed;
        var addAsNeeded = function (_) {
            if (failed) {
                return failed;
            }
            var cur;
            var _loop_1 = function () {
                var p = fn(cur.value);
                active.push(p);
                var curIdx = index++;
                p.onComplete(function (eitherRes) {
                    active.splice(active.indexOf(p), 1);
                    if (eitherRes.isLeft()) {
                        failed = p;
                    }
                    else {
                        results[curIdx] = eitherRes.get();
                    }
                });
            };
            while (active.length < opts.maxConcurrent &&
                !(cur = it.next()).done) {
                _loop_1();
            }
            if (!failed && active.length === 0 && cur && cur.done) {
                return Future.ok(HashMap_1.HashMap.ofObjectDictionary(results)
                    .toVector()
                    .sortOn(function (kv) { return parseInt(kv[0]); })
                    .map(function (kv) { return kv[1]; }));
            }
            return Future.firstCompletedOf(active).flatMap(addAsNeeded);
        };
        return addAsNeeded();
    };
    /**
     * From the list of Futures you give, will attempt to find a successful
     * Future which value matches the predicate you give.
     * We return a Future of an [[Option]], which will [[None]] in case
     * no matching Future is found.
     */
    Future.find = function (elts, p) {
        var origElts = Vector_1.Vector.ofIterable(elts);
        if (origElts.isEmpty()) {
            return Future.ok(Option_1.Option.none());
        }
        // map the failures to successes with option.none
        // backup the original future object matching the new future
        var velts = origElts
            .map(function (f) { return f
            .map(function (item) { return [f, Option_1.Option.of(item)]; })
            .recoverWith(function (_) { return Future.ok([f, Option_1.Option.none()]); }); });
        // go for the first completed of the iterable
        // remember after our map they're all successful now
        var success = Future.firstCompletedOf(velts);
        return success
            .flatMap(function (_a) {
            var originalFuture = _a[0], option = _a[1];
            if (option.isSome() && p(option.get())) {
                // this successful future matches our predicate, that's it.
                return success.map(function (x) { return x[1]; });
            }
            else {
                // this future failed or doesn't match our predicate.
                // remove the future from the input list (we can do that
                // because we "backed up" the original future in the future
                // result), and try again only with the remaining candidates
                return Future.find(origElts.removeFirst(function (future) { return future === originalFuture; }), p);
            }
        });
    };
    /**
     * Applicative lifting for Future. 'p' stands for 'properties'.
     *
     * Takes a function which operates on a simple JS object, and turns it
     * in a function that operates on the same JS object type except which each field
     * wrapped in a Future ('lifts' the function).
     * It's an alternative to [[Future.liftA2]] when the number of parameters
     * is not two.
     *
     * @param A the object property type specifying the parameters for your function
     * @param B the type returned by your function, returned wrapped in a future by liftAp.
     */
    Future.liftAp = function (fn) {
        return function (x) {
            var fieldNames = Object.keys(x);
            var promisesAr = fieldNames.map(function (n) { return x[n]; });
            var i = 0;
            return Future.of(Promise.all(promisesAr)
                .then(function (resultAr) { return resultAr.reduce(function (sofar, cur) {
                sofar[fieldNames[i++]] = cur;
                return sofar;
            }, {}); })).map(fn);
        };
    };
    /**
     * Applicative lifting for Future.
     * Takes a function which operates on basic values, and turns it
     * in a function that operates on futures of these values ('lifts'
     * the function). The 2 is because it works on functions taking two
     * parameters.
     *
     * @param R1 the first future type
     * @param R2 the second future type
     * @param V the new future type as returned by the combining function.
     */
    Future.liftA2 = function (fn) {
        return function (p1, p2) { return p1.flatMap(function (a1) { return p2.map(function (a2) { return fn(a1, a2); }); }); };
    };
    /**
     * Take a function returning a Promise
     * and lift it to return a [[Future]] instead.
     */
    Future.lift = function (fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return Future.of(fn.apply(void 0, args));
        };
    };
    /**
     * Transform the value contained in a successful Future. Has no effect
     * if the Future was failed. Will turn a successful Future in a failed
     * one if you throw an exception in the map callback (but please don't
     * do it.. Rather use [[Future.filter]] or another mechanism).
     */
    Future.prototype.map = function (fn) {
        return new Future(this.promise.then(function (_a) {
            var x = _a[0];
            return [fn(x)];
        }));
    };
    /**
     * Transform the value contained in a successful Future. You return a
     * Future, but it is then "flattened" so we still return a Future<T>
     * (and not a Future<Future<T>>).
     * Has no effect if the Future was failed. Will turn a successful Future in a failed
     * one if you throw an exception in the map callback (but please don't
     * do it.. Rather use [[Future.filter]] or another mechanism).
     * This is the monadic bind.
     */
    Future.prototype.flatMap = function (fn) {
        return new Future(this.promise.then(function (_a) {
            var x = _a[0];
            return fn(x).promise;
        }));
    };
    /**
     * Transform the value contained in a failed Future. Has no effect
     * if the Future was successful.
     */
    Future.prototype.mapFailure = function (fn) {
        return new Future(this.promise["catch"](function (x) { throw fn(x); }));
    };
    /**
     * Execute the side-effecting function you give if the Future is a failure.
     *
     * The Future is unchanged by this call.
     */
    Future.prototype.onFailure = function (fn) {
        this.promise["catch"](function (x) { return fn(x); });
        return this;
    };
    /**
     * Execute the side-effecting function you give if the Future is a success.
     *
     * The Future is unchanged by this call.
     */
    Future.prototype.onSuccess = function (fn) {
        // we create a new promise here, need to catch errors on it,
        // to avoid node UnhandledPromiseRejectionWarning warnings
        this.promise.then(function (x) { fn(x[0]); return x; })["catch"](function (_) { });
        return this;
    };
    /**
     * Execute the side-effecting function you give when the Future is
     * completed. You get an [[Either]], a `Right` if the Future is a
     * success, a `Left` if it's a failure.
     *
     * The Future is unchanged by this call.
     */
    Future.prototype.onComplete = function (fn) {
        this.promise.then(function (x) { fn(Either_1.Either.right(x[0])); return x; }, function (x) { return fn(Either_1.Either.left(x)); });
        return this;
    };
    /**
     * Has no effect on a failed Future. If the Future was successful,
     * will check whether its value matches the predicate you give as
     * first parameter. If the value matches the predicate, an equivalent
     * Future to the input one is returned.
     *
     * If the value doesn't match predicate however, the second parameter
     * function is used to compute the contents of a failed Future that'll
     * be returned.
     */
    Future.prototype.filter = function (p, ifFail) {
        return this.flatMap(function (x) { return p(x) ? Future.ok(x) : Future.failed(ifFail(x)); });
    };
    /**
     * Has no effect if this Future is successful. If it's failed however,
     * the function you give will be called, receiving as parameter
     * the error contents, and a Future equivalent to the one your
     * function returns will be returned.
     */
    Future.prototype.recoverWith = function (f) {
        return new Future(this.promise["catch"](function (err) { return f(err).promise; }));
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    Future.prototype.transform = function (fn) {
        return fn(this);
    };
    return Future;
}());
exports.Future = Future;
//# sourceMappingURL=Future.js.map