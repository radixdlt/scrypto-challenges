"use strict";
exports.__esModule = true;
var Value_1 = require("./Value");
var Option_1 = require("./Option");
var Vector_1 = require("./Vector");
var LinkedList_1 = require("./LinkedList");
var Comparison_1 = require("./Comparison");
var SeqHelpers_1 = require("./SeqHelpers");
var Contract_1 = require("./Contract");
/**
 * Contains a pair of two values, which may or may not have the same type.
 * Compared to the builtin typescript [T,U] type, we get equality semantics
 * and helper functions (like mapping and so on).
 * @param T the first item type
 * @param U the second item type
 */
var Tuple2 = /** @class */ (function () {
    function Tuple2(_fst, _snd) {
        this._fst = _fst;
        this._snd = _snd;
    }
    /**
     * Build a pair of value from both values.
     */
    Tuple2.of = function (fst, snd) {
        return new Tuple2(fst, snd);
    };
    /**
     * Build a tuple2 from javascript array. Compared to [[Tuple2.ofPair]],
     * it checks the length of the array and will return [[None]] in case
     * the length isn't two. However the types of the elements aren't checked.
     */
    Tuple2.ofArray = function (pair) {
        if (pair && pair.length === 2) {
            return Option_1.Option.of(new Tuple2(pair[0], pair[1]));
        }
        return Option_1.Option.none();
    };
    /**
     * Build a tuple2 from javascript pair.
     * Also see [[Tuple2.ofArray]]
     */
    Tuple2.ofPair = function (pair) {
        return new Tuple2(pair[0], pair[1]);
    };
    /**
     * @hidden
     */
    Tuple2.prototype.hasTrueEquality = function () {
        return Option_1.Option.of(this.fst()).hasTrueEquality() &&
            Option_1.Option.of(this.snd()).hasTrueEquality();
    };
    /**
     * Extract the first value from the pair
     */
    Tuple2.prototype.fst = function () {
        return this._fst;
    };
    /**
     * Extract the second value from the pair
     */
    Tuple2.prototype.snd = function () {
        return this._snd;
    };
    /**
     * Maps the first component of this tuple to a new value.
     */
    Tuple2.prototype.map1 = function (fn) {
        return new Tuple2(fn(this._fst), this._snd);
    };
    /**
     * Maps the second component of this tuple to a new value.
     */
    Tuple2.prototype.map2 = function (fn) {
        return new Tuple2(this._fst, fn(this._snd));
    };
    /**
     * Make a new tuple by mapping both values inside this one.
     */
    Tuple2.prototype.map = function (fn) {
        return fn(this._fst, this._snd);
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    Tuple2.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    Tuple2.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if (!other || other._fst === undefined) {
            return false;
        }
        Contract_1.contractTrueEquality("Tuple2.equals", this, other);
        return Comparison_1.areEqual(this._fst, other._fst) &&
            Comparison_1.areEqual(this._snd, other._snd);
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    Tuple2.prototype.hashCode = function () {
        return Comparison_1.getHashCode(this._fst) * 53 + Comparison_1.getHashCode(this._snd);
    };
    /**
     * Convert the tuple to a javascript pair.
     * Compared to [[Tuple2.toArray]], it behaves the
     * same at runtime, the only difference is the
     * typescript type definition.
     */
    Tuple2.prototype.toPair = function () {
        return [this._fst, this._snd];
    };
    /**
     * Convert the tuple to a javascript array.
     * Compared to [[Tuple2.toPair]], it behaves the
     * same at runtime, the only difference is the
     * typescript type definition.
     */
    Tuple2.prototype.toArray = function () {
        return [this._fst, this._snd];
    };
    /**
     * Convert the tuple to a vector.
     */
    Tuple2.prototype.toVector = function () {
        return Vector_1.Vector.of(this._fst, this._snd);
    };
    /**
     * Convert the tuple to a linked list.
     */
    Tuple2.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.of(this._fst, this._snd);
    };
    /**
     * Get a human-friendly string representation of that value.
     */
    Tuple2.prototype.toString = function () {
        return "Tuple2(" + SeqHelpers_1.toStringHelper(this._fst) + ", " + SeqHelpers_1.toStringHelper(this._snd) + ")";
    };
    /**
     * Used by the node REPL to display values.
     * Most of the time should be the same as toString()
     */
    Tuple2.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return Tuple2;
}());
exports.Tuple2 = Tuple2;
//# sourceMappingURL=Tuple2.js.map