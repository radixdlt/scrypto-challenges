"use strict";
exports.__esModule = true;
/**
 * A sequence of values, organized in-memory as a strict linked list.
 * Each element has an head (value) and a tail (the rest of the list).
 *
 * The code is organized through the class [[EmptyLinkedList]] (empty list
 * or tail), the class [[ConsLinkedList]] (list value and pointer to next),
 * and the type alias [[LinkedList]] (empty or cons).
 *
 * Finally, "static" functions on Option are arranged in the class
 * [[LinkedListStatic]] and are accessed through the global constant LinkedList.
 *
 * Random access is expensive, appending is expensive, prepend or getting
 * the tail of the list is very cheap.
 * If you often need random access you should rather use [[Vector]].
 * Avoid appending at the end of the list in a loop, prefer prepending and
 * then reversing the list.
 *
 * Examples:
 *
 *     LinkedList.of(1,2,3);
 *     LinkedList.of(1,2,3).map(x => x*2).last();
 */
var Option_1 = require("./Option");
var Vector_1 = require("./Vector");
var Comparison_1 = require("./Comparison");
var Contract_1 = require("./Contract");
var Value_1 = require("./Value");
var HashMap_1 = require("./HashMap");
var HashSet_1 = require("./HashSet");
var SeqHelpers = require("./SeqHelpers");
/**
 * Holds the "static methods" for [[LinkedList]]
 */
var LinkedListStatic = /** @class */ (function () {
    function LinkedListStatic() {
    }
    /**
     * The empty stream
     */
    LinkedListStatic.prototype.empty = function () {
        return emptyLinkedList;
    };
    LinkedListStatic.prototype.of = function () {
        var elts = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elts[_i] = arguments[_i];
        }
        return exports.LinkedList.ofIterable(elts);
    };
    /**
     * Build a stream from any iterable, which means also
     * an array for instance.
     * @param T the item type
     */
    LinkedListStatic.prototype.ofIterable = function (elts) {
        var iterator = elts[Symbol.iterator]();
        var curItem = iterator.next();
        var result = emptyLinkedList;
        while (!curItem.done) {
            result = new ConsLinkedList(curItem.value, result);
            curItem = iterator.next();
        }
        return result.reverse();
    };
    /**
     * Curried type guard for LinkedList.
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(LinkedList.of(1), LinkedList.empty<number>())
     *         .filter(LinkedList.isEmpty)
     *     => Vector.of(LinkedList.empty<number>())
     */
    LinkedListStatic.prototype.isEmpty = function (l) {
        return l.isEmpty();
    };
    /**
     * Curried type guard for LinkedList.
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Stream.of(1), Stream.empty<number>())
     *         .filter(Stream.isNotEmpty)
     *         .map(s => s.head().get()+1)
     *     => Vector.of(2)
     */
    LinkedListStatic.prototype.isNotEmpty = function (l) {
        return !l.isEmpty();
    };
    /**
     * Dual to the foldRight function. Build a collection from a seed.
     * Takes a starting element and a function.
     * It applies the function on the starting element; if the
     * function returns None, it stops building the list, if it
     * returns Some of a pair, it adds the first element to the result
     * and takes the second element as a seed to keep going.
     *
     *     LinkedList.unfoldRight(
     *          10, x=>Option.of(x)
     *              .filter(x => x!==0)
     *              .map<[number,number]>(x => [x,x-1]))
     *     => LinkedList.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
     */
    LinkedListStatic.prototype.unfoldRight = function (seed, fn) {
        var nextVal = fn(seed);
        var result = emptyLinkedList;
        while (!nextVal.isNone()) {
            result = new ConsLinkedList(nextVal.get()[0], result);
            nextVal = fn(nextVal.get()[1]);
        }
        return result.reverse();
    };
    /**
     * Combine any number of iterables you give in as
     * parameters to produce a new collection which combines all,
     * in tuples. For instance:
     *
     *     LinkedList.zip(LinkedList.of(1,2,3), ["a","b","c"], Vector.of(8,9,10))
     *     => LinkedList.of([1,"a",8], [2,"b",9], [3,"c",10])
     *
     * The result collection will have the length of the shorter
     * of the input iterables. Extra elements will be discarded.
     *
     * Also see the non-static version [[ConsLinkedList.zip]], which only combines two
     * collections.
     * @param A A is the type of the tuple that'll be generated
     *          (`[number,string,number]` for the code sample)
     */
    LinkedListStatic.prototype.zip = function () {
        var iterables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            iterables[_i] = arguments[_i];
        }
        var r = exports.LinkedList.empty();
        var iterators = iterables.map(function (i) { return i[Symbol.iterator](); });
        var items = iterators.map(function (i) { return i.next(); });
        while (!items.some(function (item) { return item.done; })) {
            r = r.prepend(items.map(function (item) { return item.value; }));
            items = iterators.map(function (i) { return i.next(); });
        }
        return r.reverse();
    };
    return LinkedListStatic;
}());
exports.LinkedListStatic = LinkedListStatic;
/**
 * The LinkedList constant allows to call the LinkedList "static" methods
 */
exports.LinkedList = new LinkedListStatic();
/**
 * EmptyLinkedList is the empty linked list; every non-empty
 * linked list also has a pointer to an empty linked list
 * after its last element.
 * "static methods" available through [[LinkedListStatic]]
 * @param T the item type
 */
var EmptyLinkedList = /** @class */ (function () {
    function EmptyLinkedList() {
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * @hidden
     */
    EmptyLinkedList.prototype.hasTrueEquality = function () {
        return SeqHelpers.seqHasTrueEquality(this);
    };
    /**
     * Implementation of the Iterator interface.
     */
    EmptyLinkedList.prototype[Symbol.iterator] = function () {
        return {
            next: function () {
                return {
                    done: true,
                    value: undefined
                };
            }
        };
    };
    /**
     * View this Some a as LinkedList. Useful to help typescript type
     * inference sometimes.
     */
    EmptyLinkedList.prototype.asLinkedList = function () {
        return this;
    };
    /**
     * Get the length of the collection.
     */
    EmptyLinkedList.prototype.length = function () {
        return 0;
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    EmptyLinkedList.prototype.single = function () {
        return Option_1.Option.none();
    };
    /**
     * true if the collection is empty, false otherwise.
     */
    EmptyLinkedList.prototype.isEmpty = function () {
        return true;
    };
    /**
     * Get the first value of the collection, if any.
     * In this case the list is empty, so returns Option.none
     */
    EmptyLinkedList.prototype.head = function () {
        return Option_1.Option.none();
    };
    /**
     * Get all the elements in the collection but the first one.
     * If the collection is empty, return None.
     */
    EmptyLinkedList.prototype.tail = function () {
        return Option_1.Option.none();
    };
    /**
     * Get the last value of the collection, if any.
     * returns Option.Some if the collection is not empty,
     * Option.None if it's empty.
     */
    EmptyLinkedList.prototype.last = function () {
        return Option_1.Option.none();
    };
    /**
     * Retrieve the element at index idx.
     * Returns an option because the collection may
     * contain less elements than the index.
     *
     * Careful this is going to have poor performance
     * on LinkedList, which is not a good data structure
     * for random access!
     */
    EmptyLinkedList.prototype.get = function (idx) {
        return Option_1.Option.none();
    };
    /**
     * Search for an item matching the predicate you pass,
     * return Option.Some of that element if found,
     * Option.None otherwise.
     */
    EmptyLinkedList.prototype.find = function (predicate) {
        return Option_1.Option.none();
    };
    /**
     * Returns true if the item is in the collection,
     * false otherwise.
     */
    EmptyLinkedList.prototype.contains = function (v) {
        return false;
    };
    /**
     * Return a new stream keeping only the first n elements
     * from this stream.
     */
    EmptyLinkedList.prototype.take = function (n) {
        return this;
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate.
     */
    EmptyLinkedList.prototype.takeWhile = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate,
     * but starting from the end of the collection.
     *
     *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)
     *     => LinkedList.of(3,4)
     */
    EmptyLinkedList.prototype.takeRightWhile = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection with the first
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    EmptyLinkedList.prototype.drop = function (n) {
        return this;
    };
    /**
     * Returns a new collection, discarding the first elements
     * until one element fails the predicate. All elements
     * after that point are retained.
     */
    EmptyLinkedList.prototype.dropWhile = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection with the last
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    EmptyLinkedList.prototype.dropRight = function (n) {
        return this;
    };
    /**
     * Returns a new collection, discarding the last elements
     * until one element fails the predicate. All elements
     * before that point are retained.
     */
    EmptyLinkedList.prototype.dropRightWhile = function (predicate) {
        return this;
    };
    /**
     * Reduces the collection to a single value using the
     * associative binary function you give. Since the function
     * is associative, order of application doesn't matter.
     *
     * Example:
     *
     *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);
     *     => 6
     */
    EmptyLinkedList.prototype.fold = function (zero, fn) {
        return zero;
    };
    /**
     * Reduces the collection to a single value.
     * Left-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldLeft("!", (xs,x) => x+xs);
     *     => "cba!"
     *
     * @param zero The initial value
     * @param fn A function taking the previous value and
     *           the current collection item, and returning
     *           an updated value.
     */
    EmptyLinkedList.prototype.foldLeft = function (zero, fn) {
        return zero;
    };
    /**
     * Reduces the collection to a single value.
     * Right-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldRight("!", (x,xs) => xs+x);
     *     => "!cba"
     *
     * @param zero The initial value
     * @param fn A function taking the current collection item and
     *           the previous value , and returning
     *           an updated value.
     */
    EmptyLinkedList.prototype.foldRight = function (zero, fn) {
        return zero;
    };
    /**
     * Combine this collection with the collection you give in
     * parameter to produce a new collection which combines both,
     * in pairs. For instance:
     *
     *     Vector.of(1,2,3).zip(["a","b","c"])
     *     => Vector.of([1,"a"], [2,"b"], [3,"c"])
     *
     * The result collection will have the length of the shorter
     * of both collections. Extra elements will be discarded.
     *
     * Also see [[LinkedListStatic.zip]] (static version which can more than two
     * iterables)
     */
    EmptyLinkedList.prototype.zip = function (other) {
        return emptyLinkedList;
    };
    /**
     * Combine this collection with the index of the elements
     * in it. Handy if you need the index when you map on
     * the collection for instance:
     *
     *     LinkedList.of("a","b").zipWithIndex().map(([v,idx]) => v+idx);
     *     => LinkedList.of("a0", "b1")
     */
    EmptyLinkedList.prototype.zipWithIndex = function () {
        return this;
    };
    /**
     * Reverse the collection. For instance:
     *
     *     LinkedList.of(1,2,3).reverse();
     *     => LinkedList.of(3,2,1)
     */
    EmptyLinkedList.prototype.reverse = function () {
        return this;
    };
    /**
     * Takes a predicate; returns a pair of collections.
     * The first one is the longest prefix of this collection
     * which satisfies the predicate, and the second collection
     * is the remainder of the collection.
     *
     *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)
     *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]
     */
    EmptyLinkedList.prototype.span = function (predicate) {
        return [this, this];
    };
    /**
     * Split the collection at a specific index.
     *
     *     LinkedList.of(1,2,3,4,5).splitAt(3)
     *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]
     */
    EmptyLinkedList.prototype.splitAt = function (index) {
        return [this, this];
    };
    EmptyLinkedList.prototype.partition = function (predicate) {
        return [exports.LinkedList.empty(), exports.LinkedList.empty()];
    };
    /**
     * Group elements in the collection using a classifier function.
     * Elements are then organized in a map. The key is the value of
     * the classifier, and in value we get the list of elements
     * matching that value.
     *
     * also see [[ConsLinkedList.arrangeBy]]
     */
    EmptyLinkedList.prototype.groupBy = function (classifier) {
        return HashMap_1.HashMap.empty();
    };
    /**
     * Matches each element with a unique key that you extract from it.
     * If the same key is present twice, the function will return None.
     *
     * also see [[ConsLinkedList.groupBy]]
     */
    EmptyLinkedList.prototype.arrangeBy = function (getKey) {
        return SeqHelpers.arrangeBy(this, getKey);
    };
    /**
     * Randomly reorder the elements of the collection.
     */
    EmptyLinkedList.prototype.shuffle = function () {
        return this;
    };
    /**
     * Append an element at the end of this LinkedList.
     * Warning: appending in a loop on a linked list is going
     * to be very slow!
     */
    EmptyLinkedList.prototype.append = function (v) {
        return exports.LinkedList.of(v);
    };
    /*
     * Append multiple elements at the end of this LinkedList.
     */
    EmptyLinkedList.prototype.appendAll = function (elts) {
        return exports.LinkedList.ofIterable(elts);
    };
    /**
     * Remove multiple elements from a LinkedList
     *
     *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])
     *     => LinkedList.of(1,3,3,1)
     */
    EmptyLinkedList.prototype.removeAll = function (elts) {
        return this;
    };
    /**
     * Removes the first element matching the predicate
     * (use [[Seq.filter]] to remove all elements matching a predicate)
     */
    EmptyLinkedList.prototype.removeFirst = function (predicate) {
        return this;
    };
    /**
     * Prepend an element at the beginning of the collection.
     */
    EmptyLinkedList.prototype.prepend = function (elt) {
        return new ConsLinkedList(elt, this);
    };
    /**
     * Prepend multiple elements at the beginning of the collection.
     */
    EmptyLinkedList.prototype.prependAll = function (elt) {
        return exports.LinkedList.ofIterable(elt);
    };
    /**
     * Return a new collection where each element was transformed
     * by the mapper function you give.
     */
    EmptyLinkedList.prototype.map = function (mapper) {
        return emptyLinkedList;
    };
    /**
     * Apply the mapper function on every element of this collection.
     * The mapper function returns an Option; if the Option is a Some,
     * the value it contains is added to the result Collection, if it's
     * a None, the value is discarded.
     *
     *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?
     *         Option.of(x+1) : Option.none<number>())
     *     => LinkedList.of(3, 7)
     */
    EmptyLinkedList.prototype.mapOption = function (mapper) {
        return emptyLinkedList;
    };
    /**
     * Calls the function you give for each item in the collection,
     * your function returns a collection, all the collections are
     * concatenated.
     * This is the monadic bind.
     */
    EmptyLinkedList.prototype.flatMap = function (mapper) {
        return emptyLinkedList;
    };
    EmptyLinkedList.prototype.allMatch = function (predicate) {
        return true;
    };
    /**
     * Returns true if there the predicate returns true for any
     * element in the collection.
     */
    EmptyLinkedList.prototype.anyMatch = function (predicate) {
        return false;
    };
    EmptyLinkedList.prototype.filter = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection with elements
     * sorted according to the comparator you give.
     *
     *     const activityOrder = ["Writer", "Actor", "Director"];
     *     LinkedList.of({name:"George", activity: "Director"}, {name:"Robert", activity: "Actor"})
     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));
     *     => LinkedList.of({"name":"Robert","activity":"Actor"}, {"name":"George","activity":"Director"})
     *
     * also see [[ConsLinkedList.sortOn]]
     */
    EmptyLinkedList.prototype.sortBy = function (compare) {
        return this;
    };
    /**
     * Give a function associating a number or a string with
     * elements from the collection, and the elements
     * are sorted according to that value.
     *
     *     LinkedList.of({a:3,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a)
     *     => LinkedList.of({a:1,b:"test"},{a:2,b:"a"},{a:3,b:"b"})
     *
     * You can also sort by multiple criteria, and request 'descending'
     * sorting:
     *
     *     LinkedList.of({a:1,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})
     *     => LinkedList.of({a:1,b:"test"},{a:1,b:"b"},{a:2,b:"a"})
     *
     * also see [[ConsLinkedList.sortBy]]
     */
    EmptyLinkedList.prototype.sortOn = function () {
        var getKeys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            getKeys[_i] = arguments[_i];
        }
        return this;
    };
    /**
     * Remove duplicate items; elements are mapped to keys, those
     * get compared.
     *
     *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)
     *     => LinkedList.of(1,2,3)
     */
    EmptyLinkedList.prototype.distinctBy = function (keyExtractor) {
        return this;
    };
    /**
     * Call a function for element in the collection.
     */
    EmptyLinkedList.prototype.forEach = function (fn) {
        return this;
    };
    /**
     * Reduces the collection to a single value by repeatedly
     * calling the combine function.
     * No starting value. The order in which the elements are
     * passed to the combining function is undetermined.
     */
    EmptyLinkedList.prototype.reduce = function (combine) {
        return SeqHelpers.reduce(this, combine);
    };
    /**
     * Compare values in the collection and return the smallest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsLinkedList.minOn]]
     */
    EmptyLinkedList.prototype.minBy = function (compare) {
        return SeqHelpers.minBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the smallest.
     * Returns Option.none if the collection is empty.
     *
     *     LinkedList.of({name:"Joe", age:12}, {name:"Paula", age:6}).minOn(x=>x.age)
     *     => Option.of({name:"Paula", age:6})
     *
     * also see [[ConsLinkedList.minBy]]
     */
    EmptyLinkedList.prototype.minOn = function (getOrderable) {
        return SeqHelpers.minOn(this, getOrderable);
    };
    /**
     * Compare values in the collection and return the largest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsLinkedList.maxOn]]
     */
    EmptyLinkedList.prototype.maxBy = function (compare) {
        return SeqHelpers.maxBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the largest.
     * Returns Option.none if the collection is empty.
     *
     *     LinkedList.of({name:"Joe", age:12}, {name:"Paula", age:6}).maxOn(x=>x.age)
     *     => Option.of({name:"Joe", age:12})
     *
     * also see [[ConsLinkedList.maxBy]]
     */
    EmptyLinkedList.prototype.maxOn = function (getOrderable) {
        return SeqHelpers.maxOn(this, getOrderable);
    };
    /**
     * Call the function you give for each element in the collection
     * and sum all the numbers, return that sum.
     * Will return 0 if the collection is empty.
     *
     *     LinkedList.of(1,2,3).sumOn(x=>x)
     *     => 6
     */
    EmptyLinkedList.prototype.sumOn = function (getNumber) {
        return SeqHelpers.sumOn(this, getNumber);
    };
    /**
     * Slides a window of a specific size over the sequence.
     * Returns a lazy stream so memory use is not prohibitive.
     *
     *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)
     *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))
     */
    EmptyLinkedList.prototype.sliding = function (count) {
        return SeqHelpers.sliding(this, count);
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     * The last element of the result is the final cumulative result.
     *
     *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)
     *     => LinkedList.of(0,1,3,6)
     */
    EmptyLinkedList.prototype.scanLeft = function (init, fn) {
        return exports.LinkedList.of(init);
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     * The first element of the result is the final cumulative result.
     *
     *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)
     *     => LinkedList.of(6,5,3,0)
     */
    EmptyLinkedList.prototype.scanRight = function (init, fn) {
        return exports.LinkedList.of(init);
    };
    /**
     * Joins elements of the collection by a separator.
     * Example:
     *
     *     LinkedList.of(1,2,3).mkString(", ")
     *     => "1, 2, 3"
     */
    EmptyLinkedList.prototype.mkString = function (separator) {
        return "";
    };
    /**
     * Convert to array.
     * Don't do it on an infinite stream!
     */
    EmptyLinkedList.prototype.toArray = function () {
        return [];
    };
    /**
     * Convert to vector.
     * Don't do it on an infinite stream!
     */
    EmptyLinkedList.prototype.toVector = function () {
        return Vector_1.Vector.empty();
    };
    /**
     * Convert this collection to a map. You give a function which
     * for each element in the collection returns a pair. The
     * key of the pair will be used as a key in the map, the value,
     * as a value in the map. If several values get the same key,
     * entries will be lost.
     *
     *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])
     *     => HashMap.of(["1",1], ["2",2], ["3",3])
     */
    EmptyLinkedList.prototype.toMap = function (converter) {
        return HashMap_1.HashMap.empty();
    };
    /**
     * Convert this collection to a set. Since the elements of the
     * Seq may not support equality, you must pass a function returning
     * a value supporting equality.
     *
     *     LinkedList.of(1,2,3,3,4).toSet(x=>x)
     *     => HashSet.of(1,2,3,4)
     */
    EmptyLinkedList.prototype.toSet = function (converter) {
        return HashSet_1.HashSet.empty();
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    EmptyLinkedList.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    EmptyLinkedList.prototype.equals = function (other) {
        if (!other) {
            return false;
        }
        return other.isEmpty();
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    EmptyLinkedList.prototype.hashCode = function () {
        return 1;
    };
    EmptyLinkedList.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    /**
     * Get a human-friendly string representation of that value.
     *
     * Also see [[ConsLinkedList.mkString]]
     */
    EmptyLinkedList.prototype.toString = function () {
        return "LinkedList()";
    };
    return EmptyLinkedList;
}());
exports.EmptyLinkedList = EmptyLinkedList;
/**
 * ConsLinkedList holds a value and a pointer to a next element,
 * which could be [[ConsLinkedList]] or [[EmptyLinkedList]].
 * A ConsLinkedList is basically a non-empty linked list. It will
 * contain at least one element.
 * "static methods" available through [[LinkedListStatic]]
 * @param T the item type
 */
var ConsLinkedList = /** @class */ (function () {
    /**
     * @hidden
     */
    function ConsLinkedList(value, _tail) {
        this.value = value;
        this._tail = _tail;
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * @hidden
     */
    ConsLinkedList.prototype.hasTrueEquality = function () {
        return SeqHelpers.seqHasTrueEquality(this);
    };
    /**
     * View this Some a as LinkedList. Useful to help typescript type
     * inference sometimes.
     */
    ConsLinkedList.prototype.asLinkedList = function () {
        return this;
    };
    /**
     * Implementation of the Iterator interface.
     */
    ConsLinkedList.prototype[Symbol.iterator] = function () {
        var item = this;
        return {
            next: function () {
                if (item.isEmpty()) {
                    return { done: true, value: undefined };
                }
                var value = item.head().get();
                item = item.tail().get();
                return { done: false, value: value };
            }
        };
    };
    /**
     * Get the length of the collection.
     */
    ConsLinkedList.prototype.length = function () {
        return this.foldLeft(0, function (n, ignored) { return n + 1; });
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    ConsLinkedList.prototype.single = function () {
        return this._tail.isEmpty() ?
            Option_1.Option.of(this.value) :
            Option_1.Option.none();
    };
    /**
     * true if the collection is empty, false otherwise.
     */
    ConsLinkedList.prototype.isEmpty = function () {
        return false;
    };
    /**
     * Get the first value of the collection, if any.
     * In this case the list is not empty, so returns Option.some
     */
    ConsLinkedList.prototype.head = function () {
        return Option_1.Option.some(this.value);
    };
    /**
     * Get all the elements in the collection but the first one.
     * If the collection is empty, return None.
     */
    ConsLinkedList.prototype.tail = function () {
        return Option_1.Option.some(this._tail);
    };
    /**
     * Get the last value of the collection, if any.
     * returns Option.Some if the collection is not empty,
     * Option.None if it's empty.
     */
    ConsLinkedList.prototype.last = function () {
        var curItem = this;
        while (true) {
            var item = curItem.value;
            curItem = curItem._tail;
            if (curItem.isEmpty()) {
                return Option_1.Option.some(item);
            }
        }
    };
    /**
     * Retrieve the element at index idx.
     * Returns an option because the collection may
     * contain less elements than the index.
     *
     * Careful this is going to have poor performance
     * on LinkedList, which is not a good data structure
     * for random access!
     */
    ConsLinkedList.prototype.get = function (idx) {
        var curItem = this;
        var i = 0;
        while (!curItem.isEmpty()) {
            if (i === idx) {
                var item = curItem.value;
                return Option_1.Option.of(item);
            }
            curItem = curItem._tail;
            ++i;
        }
        return Option_1.Option.none();
    };
    /**
     * Search for an item matching the predicate you pass,
     * return Option.Some of that element if found,
     * Option.None otherwise.
     */
    ConsLinkedList.prototype.find = function (predicate) {
        var curItem = this;
        while (!curItem.isEmpty()) {
            var item = curItem.value;
            if (predicate(item)) {
                return Option_1.Option.of(item);
            }
            curItem = curItem._tail;
        }
        return Option_1.Option.none();
    };
    /**
     * Returns true if the item is in the collection,
     * false otherwise.
     */
    ConsLinkedList.prototype.contains = function (v) {
        return this.find(function (x) { return Comparison_1.areEqual(x, v); }).isSome();
    };
    /**
     * Return a new stream keeping only the first n elements
     * from this stream.
     */
    ConsLinkedList.prototype.take = function (n) {
        var result = emptyLinkedList;
        var curItem = this;
        var i = 0;
        while (i++ < n && (!curItem.isEmpty())) {
            result = new ConsLinkedList(curItem.value, result);
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate.
     */
    ConsLinkedList.prototype.takeWhile = function (predicate) {
        var result = emptyLinkedList;
        var curItem = this;
        while ((!curItem.isEmpty()) && predicate(curItem.value)) {
            result = new ConsLinkedList(curItem.value, result);
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate,
     * but starting from the end of the collection.
     *
     *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)
     *     => LinkedList.of(3,4)
     */
    ConsLinkedList.prototype.takeRightWhile = function (predicate) {
        return this.reverse().takeWhile(predicate).reverse();
    };
    /**
     * Returns a new collection with the first
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    ConsLinkedList.prototype.drop = function (n) {
        var i = n;
        var curItem = this;
        while (i-- > 0 && !curItem.isEmpty()) {
            curItem = curItem._tail;
        }
        return curItem;
    };
    /**
     * Returns a new collection, discarding the first elements
     * until one element fails the predicate. All elements
     * after that point are retained.
     */
    ConsLinkedList.prototype.dropWhile = function (predicate) {
        var curItem = this;
        while (!curItem.isEmpty() && predicate(curItem.value)) {
            curItem = curItem._tail;
        }
        return curItem;
    };
    /**
     * Returns a new collection with the last
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    ConsLinkedList.prototype.dropRight = function (n) {
        // going twice through the list...
        var length = this.length();
        return this.take(length - n);
    };
    /**
     * Returns a new collection, discarding the last elements
     * until one element fails the predicate. All elements
     * before that point are retained.
     */
    ConsLinkedList.prototype.dropRightWhile = function (predicate) {
        return this.reverse().dropWhile(predicate).reverse();
    };
    /**
     * Reduces the collection to a single value using the
     * associative binary function you give. Since the function
     * is associative, order of application doesn't matter.
     *
     * Example:
     *
     *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);
     *     => 6
     */
    ConsLinkedList.prototype.fold = function (zero, fn) {
        return this.foldLeft(zero, fn);
    };
    /**
     * Reduces the collection to a single value.
     * Left-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldLeft("!", (xs,x) => x+xs);
     *     => "cba!"
     *
     * @param zero The initial value
     * @param fn A function taking the previous value and
     *           the current collection item, and returning
     *           an updated value.
     */
    ConsLinkedList.prototype.foldLeft = function (zero, fn) {
        var r = zero;
        var curItem = this;
        while (!curItem.isEmpty()) {
            r = fn(r, curItem.value);
            curItem = curItem._tail;
        }
        return r;
    };
    /**
     * Reduces the collection to a single value.
     * Right-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldRight("!", (x,xs) => xs+x);
     *     => "!cba"
     *
     * @param zero The initial value
     * @param fn A function taking the current collection item and
     *           the previous value , and returning
     *           an updated value.
     */
    ConsLinkedList.prototype.foldRight = function (zero, fn) {
        return this.reverse().foldLeft(zero, function (xs, x) { return fn(x, xs); });
    };
    /**
     * Combine this collection with the collection you give in
     * parameter to produce a new collection which combines both,
     * in pairs. For instance:
     *
     *     Vector.of(1,2,3).zip(["a","b","c"])
     *     => Vector.of([1,"a"], [2,"b"], [3,"c"])
     *
     * The result collection will have the length of the shorter
     * of both collections. Extra elements will be discarded.
     *
     * Also see [[LinkedListStatic.zip]] (static version which can more than two
     * iterables)
     */
    ConsLinkedList.prototype.zip = function (other) {
        var otherIterator = other[Symbol.iterator]();
        var otherCurItem = otherIterator.next();
        var curItem = this;
        var result = emptyLinkedList;
        while ((!curItem.isEmpty()) && (!otherCurItem.done)) {
            result = new ConsLinkedList([curItem.value, otherCurItem.value], result);
            curItem = curItem._tail;
            otherCurItem = otherIterator.next();
        }
        return result.reverse();
    };
    /**
     * Combine this collection with the index of the elements
     * in it. Handy if you need the index when you map on
     * the collection for instance:
     *
     *     LinkedList.of("a","b").zipWithIndex().map(([v,idx]) => v+idx);
     *     => LinkedList.of("a0", "b1")
     */
    ConsLinkedList.prototype.zipWithIndex = function () {
        return SeqHelpers.zipWithIndex(this);
    };
    /**
     * Reverse the collection. For instance:
     *
     *     LinkedList.of(1,2,3).reverse();
     *     => LinkedList.of(3,2,1)
     */
    ConsLinkedList.prototype.reverse = function () {
        return this.foldLeft(emptyLinkedList, function (xs, x) { return xs.prepend(x); });
    };
    /**
     * Takes a predicate; returns a pair of collections.
     * The first one is the longest prefix of this collection
     * which satisfies the predicate, and the second collection
     * is the remainder of the collection.
     *
     *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)
     *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]
     */
    ConsLinkedList.prototype.span = function (predicate) {
        var first = emptyLinkedList;
        var curItem = this;
        while ((!curItem.isEmpty()) && predicate(curItem.value)) {
            first = new ConsLinkedList(curItem.value, first);
            curItem = curItem._tail;
        }
        return [first.reverse(), curItem];
    };
    /**
     * Split the collection at a specific index.
     *
     *     LinkedList.of(1,2,3,4,5).splitAt(3)
     *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]
     */
    ConsLinkedList.prototype.splitAt = function (index) {
        var first = emptyLinkedList;
        var curItem = this;
        var i = 0;
        while (i++ < index && (!curItem.isEmpty())) {
            first = new ConsLinkedList(curItem.value, first);
            curItem = curItem._tail;
        }
        return [first.reverse(), curItem];
    };
    ConsLinkedList.prototype.partition = function (predicate) {
        var fst = exports.LinkedList.empty();
        var snd = exports.LinkedList.empty();
        var curItem = this;
        while (!curItem.isEmpty()) {
            if (predicate(curItem.value)) {
                fst = new ConsLinkedList(curItem.value, fst);
            }
            else {
                snd = new ConsLinkedList(curItem.value, snd);
            }
            curItem = curItem._tail;
        }
        return [fst.reverse(), snd.reverse()];
    };
    /**
     * Group elements in the collection using a classifier function.
     * Elements are then organized in a map. The key is the value of
     * the classifier, and in value we get the list of elements
     * matching that value.
     *
     * also see [[ConsLinkedList.arrangeBy]]
     */
    ConsLinkedList.prototype.groupBy = function (classifier) {
        return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, v) {
            return acc.putWithMerge(classifier(v), exports.LinkedList.of(v), function (v1, v2) {
                return v1.prepend(v2.single().getOrThrow());
            });
        })
            .mapValues(function (l) { return l.reverse(); });
    };
    /**
     * Matches each element with a unique key that you extract from it.
     * If the same key is present twice, the function will return None.
     *
     * also see [[ConsLinkedList.groupBy]]
     */
    ConsLinkedList.prototype.arrangeBy = function (getKey) {
        return SeqHelpers.arrangeBy(this, getKey);
    };
    /**
     * Randomly reorder the elements of the collection.
     */
    ConsLinkedList.prototype.shuffle = function () {
        return exports.LinkedList.ofIterable(SeqHelpers.shuffle(this.toArray()));
    };
    /**
     * Append an element at the end of this LinkedList.
     * Warning: appending in a loop on a linked list is going
     * to be very slow!
     */
    ConsLinkedList.prototype.append = function (v) {
        return new ConsLinkedList(this.value, this._tail.append(v));
    };
    /*
     * Append multiple elements at the end of this LinkedList.
     */
    ConsLinkedList.prototype.appendAll = function (elts) {
        return exports.LinkedList.ofIterable(elts).prependAll(this);
    };
    /**
     * Remove multiple elements from a LinkedList
     *
     *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])
     *     => LinkedList.of(1,3,3,1)
     */
    ConsLinkedList.prototype.removeAll = function (elts) {
        return SeqHelpers.removeAll(this, elts);
    };
    /**
     * Removes the first element matching the predicate
     * (use [[Seq.filter]] to remove all elements matching a predicate)
     */
    ConsLinkedList.prototype.removeFirst = function (predicate) {
        var curItem = this;
        var result = emptyLinkedList;
        var removed = false;
        while (!curItem.isEmpty()) {
            if (predicate(curItem.value) && !removed) {
                removed = true;
            }
            else {
                result = new ConsLinkedList(curItem.value, result);
            }
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Prepend an element at the beginning of the collection.
     */
    ConsLinkedList.prototype.prepend = function (elt) {
        return new ConsLinkedList(elt, this);
    };
    /**
     * Prepend multiple elements at the beginning of the collection.
     */
    ConsLinkedList.prototype.prependAll = function (elts) {
        var leftToAdd = exports.LinkedList.ofIterable(elts).reverse();
        var result = this;
        while (!leftToAdd.isEmpty()) {
            result = new ConsLinkedList(leftToAdd.value, result);
            leftToAdd = leftToAdd._tail;
        }
        return result;
    };
    /**
     * Return a new collection where each element was transformed
     * by the mapper function you give.
     */
    ConsLinkedList.prototype.map = function (mapper) {
        var curItem = this;
        var result = emptyLinkedList;
        while (!curItem.isEmpty()) {
            result = new ConsLinkedList(mapper(curItem.value), result);
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Apply the mapper function on every element of this collection.
     * The mapper function returns an Option; if the Option is a Some,
     * the value it contains is added to the result Collection, if it's
     * a None, the value is discarded.
     *
     *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?
     *         Option.of(x+1) : Option.none<number>())
     *     => LinkedList.of(3, 7)
     */
    ConsLinkedList.prototype.mapOption = function (mapper) {
        var curItem = this;
        var result = emptyLinkedList;
        while (!curItem.isEmpty()) {
            var mapped = mapper(curItem.value);
            if (mapped.isSome()) {
                result = new ConsLinkedList(mapped.get(), result);
            }
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Calls the function you give for each item in the collection,
     * your function returns a collection, all the collections are
     * concatenated.
     * This is the monadic bind.
     */
    ConsLinkedList.prototype.flatMap = function (mapper) {
        var curItem = this;
        var result = emptyLinkedList;
        while (!curItem.isEmpty()) {
            result = result.prependAll(mapper(curItem.value).reverse());
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    ConsLinkedList.prototype.allMatch = function (predicate) {
        return this.find(function (x) { return !predicate(x); }).isNone();
    };
    /**
     * Returns true if there the predicate returns true for any
     * element in the collection.
     */
    ConsLinkedList.prototype.anyMatch = function (predicate) {
        return this.find(predicate).isSome();
    };
    ConsLinkedList.prototype.filter = function (predicate) {
        var curItem = this;
        var result = emptyLinkedList;
        while (!curItem.isEmpty()) {
            if (predicate(curItem.value)) {
                result = new ConsLinkedList(curItem.value, result);
            }
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Returns a new collection with elements
     * sorted according to the comparator you give.
     *
     *     const activityOrder = ["Writer", "Actor", "Director"];
     *     LinkedList.of({name:"George", activity: "Director"}, {name:"Robert", activity: "Actor"})
     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));
     *     => LinkedList.of({"name":"Robert","activity":"Actor"}, {"name":"George","activity":"Director"})
     *
     * also see [[ConsLinkedList.sortOn]]
     */
    ConsLinkedList.prototype.sortBy = function (compare) {
        return exports.LinkedList.ofIterable(this.toArray().sort(compare));
    };
    /**
     * Give a function associating a number or a string with
     * elements from the collection, and the elements
     * are sorted according to that value.
     *
     *     LinkedList.of({a:3,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a)
     *     => LinkedList.of({a:1,b:"test"},{a:2,b:"a"},{a:3,b:"b"})
     *
     * You can also sort by multiple criteria, and request 'descending'
     * sorting:
     *
     *     LinkedList.of({a:1,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})
     *     => LinkedList.of({a:1,b:"test"},{a:1,b:"b"},{a:2,b:"a"})
     *
     * also see [[ConsLinkedList.sortBy]]
     */
    ConsLinkedList.prototype.sortOn = function () {
        var getKeys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            getKeys[_i] = arguments[_i];
        }
        return SeqHelpers.sortOn(this, getKeys);
    };
    /**
     * Remove duplicate items; elements are mapped to keys, those
     * get compared.
     *
     *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)
     *     => LinkedList.of(1,2,3)
     */
    ConsLinkedList.prototype.distinctBy = function (keyExtractor) {
        return SeqHelpers.distinctBy(this, keyExtractor);
    };
    /**
     * Call a function for element in the collection.
     */
    ConsLinkedList.prototype.forEach = function (fn) {
        var curItem = this;
        while (!curItem.isEmpty()) {
            fn(curItem.value);
            curItem = curItem._tail;
        }
        return this;
    };
    /**
     * Reduces the collection to a single value by repeatedly
     * calling the combine function.
     * No starting value. The order in which the elements are
     * passed to the combining function is undetermined.
     */
    ConsLinkedList.prototype.reduce = function (combine) {
        return SeqHelpers.reduce(this, combine);
    };
    /**
     * Compare values in the collection and return the smallest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsLinkedList.minOn]]
     */
    ConsLinkedList.prototype.minBy = function (compare) {
        return SeqHelpers.minBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the smallest.
     * Returns Option.none if the collection is empty.
     *
     *     LinkedList.of({name:"Joe", age:12}, {name:"Paula", age:6}).minOn(x=>x.age)
     *     => Option.of({name:"Paula", age:6})
     *
     * also see [[ConsLinkedList.minBy]]
     */
    ConsLinkedList.prototype.minOn = function (getOrderable) {
        return SeqHelpers.minOn(this, getOrderable);
    };
    /**
     * Compare values in the collection and return the largest element.
     * Returns Option.none if the collection is empty.
     *
     *     LinkedList.of({name:"Joe", age:12}, {name:"Paula", age:6}).maxOn(x=>x.age)
     *     => Option.of({name:"Joe", age:12})
     *
     * also see [[ConsLinkedList.maxOn]]
     */
    ConsLinkedList.prototype.maxBy = function (compare) {
        return SeqHelpers.maxBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the largest.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsLinkedList.maxBy]]
     */
    ConsLinkedList.prototype.maxOn = function (getOrderable) {
        return SeqHelpers.maxOn(this, getOrderable);
    };
    /**
     * Call the function you give for each element in the collection
     * and sum all the numbers, return that sum.
     * Will return 0 if the collection is empty.
     *
     *     LinkedList.of(1,2,3).sumOn(x=>x)
     *     => 6
     */
    ConsLinkedList.prototype.sumOn = function (getNumber) {
        return SeqHelpers.sumOn(this, getNumber);
    };
    /**
     * Slides a window of a specific size over the sequence.
     * Returns a lazy stream so memory use is not prohibitive.
     *
     *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)
     *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))
     */
    ConsLinkedList.prototype.sliding = function (count) {
        return SeqHelpers.sliding(this, count);
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     *
     *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)
     *     => LinkedList.of(0,1,3,6)
     */
    ConsLinkedList.prototype.scanLeft = function (init, fn) {
        var result = exports.LinkedList.of(init);
        var curItem = this;
        var soFar = init;
        while (!curItem.isEmpty()) {
            soFar = fn(soFar, curItem.value);
            result = new ConsLinkedList(soFar, result);
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     * The first element of the result is the final cumulative result.
     *
     *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)
     *     => LinkedList.of(6,5,3,0)
     */
    ConsLinkedList.prototype.scanRight = function (init, fn) {
        var result = exports.LinkedList.of(init);
        var curItem = this.reverse();
        var soFar = init;
        while (!curItem.isEmpty()) {
            soFar = fn(curItem.value, soFar);
            result = new ConsLinkedList(soFar, result);
            curItem = curItem._tail;
        }
        return result;
    };
    /**
     * Joins elements of the collection by a separator.
     * Example:
     *
     *     LinkedList.of(1,2,3).mkString(", ")
     *     => "1, 2, 3"
     */
    ConsLinkedList.prototype.mkString = function (separator) {
        var r = "";
        var curItem = this;
        var isNotFirst = false;
        while (!curItem.isEmpty()) {
            if (isNotFirst) {
                r += separator;
            }
            r += SeqHelpers.toStringHelper(curItem.value, { quoteStrings: false });
            curItem = curItem._tail;
            isNotFirst = true;
        }
        return r;
    };
    /**
     * Convert to array.
     * Don't do it on an infinite stream!
     */
    ConsLinkedList.prototype.toArray = function () {
        var r = [];
        var curItem = this;
        while (!curItem.isEmpty()) {
            r.push(curItem.value);
            curItem = curItem._tail;
        }
        return r;
    };
    /**
     * Convert to vector.
     * Don't do it on an infinite stream!
     */
    ConsLinkedList.prototype.toVector = function () {
        return Vector_1.Vector.ofIterable(this.toArray());
    };
    /**
     * Convert this collection to a map. You give a function which
     * for each element in the collection returns a pair. The
     * key of the pair will be used as a key in the map, the value,
     * as a value in the map. If several values get the same key,
     * entries will be lost.
     *
     *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])
     *     => HashMap.of(["1",1], ["2",2], ["3",3])
     */
    ConsLinkedList.prototype.toMap = function (converter) {
        return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, cur) {
            var converted = converter(cur);
            return acc.put(converted[0], converted[1]);
        });
    };
    /**
     * Convert this collection to a set. Since the elements of the
     * Seq may not support equality, you must pass a function returning
     * a value supporting equality.
     *
     *     LinkedList.of(1,2,3,3,4).toSet(x=>x)
     *     => HashSet.of(1,2,3,4)
     */
    ConsLinkedList.prototype.toSet = function (converter) {
        return this.foldLeft(HashSet_1.HashSet.empty(), function (acc, cur) {
            return acc.add(converter(cur));
        });
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    ConsLinkedList.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    ConsLinkedList.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if (!other || !other.tail) {
            return false;
        }
        Contract_1.contractTrueEquality("LinkedList.equals", this, other);
        var myVal = this;
        var hisVal = other;
        while (true) {
            if (myVal.isEmpty() !== hisVal.isEmpty()) {
                return false;
            }
            if (myVal.isEmpty()) {
                // they are both empty, end of the stream
                return true;
            }
            var myHead = myVal.value;
            var hisHead = hisVal.value;
            if ((myHead === undefined) !== (hisHead === undefined)) {
                return false;
            }
            if (myHead === undefined || hisHead === undefined) {
                // they are both undefined, the || is for TS's flow analysis
                // so he realizes none of them is undefined after this.
                continue;
            }
            if (!Comparison_1.areEqual(myHead, hisHead)) {
                return false;
            }
            myVal = myVal._tail;
            hisVal = hisVal._tail;
        }
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    ConsLinkedList.prototype.hashCode = function () {
        var hash = 1;
        var curItem = this;
        while (!curItem.isEmpty()) {
            hash = 31 * hash + Comparison_1.getHashCode(curItem.value);
            curItem = curItem._tail;
        }
        return hash;
    };
    ConsLinkedList.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    /**
     * Get a human-friendly string representation of that value.
     *
     * Also see [[ConsLinkedList.mkString]]
     */
    ConsLinkedList.prototype.toString = function () {
        var curItem = this;
        var result = "LinkedList(";
        while (!curItem.isEmpty()) {
            result += SeqHelpers.toStringHelper(curItem.value);
            var tail = curItem._tail;
            curItem = tail;
            if (!curItem.isEmpty()) {
                result += ", ";
            }
        }
        return result + ")";
    };
    return ConsLinkedList;
}());
exports.ConsLinkedList = ConsLinkedList;
var emptyLinkedList = new EmptyLinkedList();
//# sourceMappingURL=LinkedList.js.map