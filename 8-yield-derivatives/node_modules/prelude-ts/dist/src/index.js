"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
exports.__esModule = true;
// Not re-exporting the abstract types such as Seq, Collection and so on,
// on purpose. Right now they are more an help to design the library, not meant
// for the user.
// Seq<T>.equals is a lot less type-precise than Vector<T>.equals, so I'd rather
// the users use concrete types.
__export(require("./Option"));
__export(require("./Either"));
__export(require("./Lazy"));
__export(require("./Vector"));
__export(require("./LinkedList"));
__export(require("./HashMap"));
__export(require("./HashSet"));
__export(require("./Tuple2"));
__export(require("./Value"));
__export(require("./Comparison"));
__export(require("./Stream"));
__export(require("./Contract"));
__export(require("./Predicate"));
__export(require("./Function"));
__export(require("./Future"));
//# sourceMappingURL=index.js.map