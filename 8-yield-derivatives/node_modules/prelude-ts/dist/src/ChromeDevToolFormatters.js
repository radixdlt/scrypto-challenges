"use strict";
//  http://bit.ly/object-formatters
var olStyle = "list-style-type:none; padding-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-left: 12px";
function getWithToArrayBody(elt) {
    return ["ol",
        { "style": olStyle }].concat(elt.toArray().map(function (x, idx) { return ["li", {},
        ["span", { "style": "color: rgb(136, 19, 145);" }, idx + ": "],
        ["object", { "object": x }]]; }));
}
var VectorHandler = /** @class */ (function () {
    function VectorHandler() {
        this.getBody = getWithToArrayBody;
    }
    VectorHandler.prototype.isElement = function (object) {
        return object.hashCode && object.equals &&
            object.replace && object.sortOn && object._list;
    };
    VectorHandler.prototype.getHeader = function (object) {
        return ["span", {}, "Vector(" + object.length() + ")"];
    };
    VectorHandler.prototype.hasBody = function (elt) {
        return !elt.isEmpty();
    };
    return VectorHandler;
}());
// not going to behave well with infinite streams...
var StreamHandler = /** @class */ (function () {
    function StreamHandler() {
        this.getBody = getWithToArrayBody;
    }
    StreamHandler.prototype.isElement = function (object) {
        return object.hashCode && object.equals && object.sortBy && object.cycle && object.toVector;
    };
    StreamHandler.prototype.getHeader = function (object) {
        // not displaying the length for streams in case
        // of infinite streams. the user can expand if needed.
        return ["span", {}, "Stream(?)"];
    };
    StreamHandler.prototype.hasBody = function (elt) {
        return !elt.isEmpty();
    };
    return StreamHandler;
}());
var ListHandler = /** @class */ (function () {
    function ListHandler() {
        this.getBody = getWithToArrayBody;
    }
    ListHandler.prototype.isElement = function (object) {
        return object.hashCode && object.equals && object.sortBy && object.toVector;
    };
    ListHandler.prototype.getHeader = function (object) {
        // not displaying the length for streams in case
        // of infinite streams. the user can expand if needed.
        return ["span", {}, "List(" + object.length() + ")"];
    };
    ListHandler.prototype.hasBody = function (elt) {
        return !elt.isEmpty();
    };
    return ListHandler;
}());
var HashSetHandler = /** @class */ (function () {
    function HashSetHandler() {
        this.getBody = getWithToArrayBody;
    }
    HashSetHandler.prototype.isElement = function (object) {
        return object.hashCode && object.equals && object.hamt && object.intersect;
    };
    HashSetHandler.prototype.getHeader = function (object) {
        return ["span", {}, "HashSet(" + object.length() + ")"];
    };
    HashSetHandler.prototype.hasBody = function (elt) {
        return !elt.isEmpty();
    };
    return HashSetHandler;
}());
var HashMapHandler = /** @class */ (function () {
    function HashMapHandler() {
    }
    HashMapHandler.prototype.isElement = function (object) {
        return object.hashCode && object.equals && object.hamt && object.valueIterable;
    };
    HashMapHandler.prototype.getHeader = function (object) {
        return ["span", {}, "HashMap(" + object.length() + ")"];
    };
    HashMapHandler.prototype.hasBody = function (elt) {
        return !elt.isEmpty();
    };
    HashMapHandler.prototype.getBody = function (elt) {
        return ["ol",
            { "style": olStyle }].concat(elt.toArray().map(function (kv, idx) {
            // using object.create to avoid the __proto__ in the GUI
            var obj = Object.create(null);
            obj.key = kv[0];
            obj.value = kv[1];
            return ["li", {},
                ["span", { "style": "color: rgb(136, 19, 145);" }, idx + ": "],
                ["object", { "object": obj }]];
        }));
    };
    return HashMapHandler;
}());
var handlers = [new VectorHandler(),
    new StreamHandler(),
    new ListHandler(),
    new HashSetHandler(),
    new HashMapHandler()];
function getHandler(object) {
    return handlers.find(function (h) { return h.isElement(object); });
}
var formatter = {
    header: function (object, config) {
        var handler = getHandler(object);
        return handler ? handler.getHeader(object) : null;
    },
    hasBody: function (object, config) {
        var handler = getHandler(object);
        return handler ? handler.hasBody(object) : false;
    },
    body: function (object, config) {
        var handler = getHandler(object);
        return handler ? handler.getBody(object) : null;
    }
};
if (!window.devtoolsFormatters) {
    window.devtoolsFormatters = [];
}
window.devtoolsFormatters.push(formatter);
//# sourceMappingURL=ChromeDevToolFormatters.js.map