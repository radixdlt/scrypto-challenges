"use strict";
exports.__esModule = true;
/**
 * A predicate is a function taking one parameter and returning a boolean.
 * In other words the predicate checks whether some proposition holds for the parameter.
 *
 * The Predicate interface offers normal function-calling, to make sure that the
 * predicate holds (just call predicate(x)), but also some helper methods to
 * deal with logical operations between propositions.
 *
 * You can build predicates using [[PredicateStatic]] through the
 * 'Predicate' global constant.
 *
 * Examples:
 *
 *     const check = Predicate.of((x: number) => x > 10).and(x => x < 20);
 *     check(12); // => true
 *     check(21);
 *     => false
 *
 *     Vector.of(1,2,3,4,5).filter(
 *         Predicate.isIn([2,3]).negate())
 *     => Vector.of(1, 4, 5)
 */
var Comparison_1 = require("./Comparison");
var Vector_1 = require("./Vector");
/**
 * The Predicates class offers some helper functions to deal
 * with [[Predicate]] including the ability to build [[Predicate]]
 * from functions using [[PredicateStatic.of]], some builtin predicates
 * like [[PredicateStatic.isIn]], and the ability to combine to combine
 * Predicates like with [[PredicateStatic.allOf]].
 */
var PredicateStatic = /** @class */ (function () {
    function PredicateStatic() {
    }
    /**
     * Take a predicate function and of it to become a [[Predicate]]
     * (enabling you to call [[Predicate.and]], and other logic operations on it)
     */
    PredicateStatic.prototype.of = function (fn) {
        var r = fn;
        r.and = function (other) { return exports.Predicate.of(function (x) { return r(x) && other(x); }); };
        r.or = function (other) { return exports.Predicate.of(function (x) { return r(x) || other(x); }); };
        r.negate = function () { return exports.Predicate.of(function (x) { return !fn(x); }); };
        return r;
    };
    /**
     * Return a [[Predicate]] checking whether a value is equal to the
     * value you give as parameter.
     */
    PredicateStatic.prototype.equals = function (other) {
        return exports.Predicate.of(function (x) { return Comparison_1.areEqual(other, x); });
    };
    /**
     * Return a [[Predicate]] checking whether a value is contained in the
     * list of values you give as parameter.
     */
    PredicateStatic.prototype.isIn = function (others) {
        return exports.Predicate.of(function (x) { return Vector_1.Vector.ofIterable(others).contains(x); });
    };
    /**
     * Return a [[Predicate]] checking whether all of the predicate functions given hold
     */
    PredicateStatic.prototype.allOf = function () {
        var predicates = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            predicates[_i] = arguments[_i];
        }
        return exports.Predicate.of(function (x) { return Vector_1.Vector.ofIterable(predicates).allMatch(function (p) { return p(x); }); });
    };
    /**
     * Return a [[Predicate]] checking whether any of the predicate functions given hold
     */
    PredicateStatic.prototype.anyOf = function () {
        var predicates = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            predicates[_i] = arguments[_i];
        }
        return exports.Predicate.of(function (x) { return Vector_1.Vector.ofIterable(predicates).anyMatch(function (p) { return p(x); }); });
    };
    /**
     * Return a [[Predicate]] checking whether none of the predicate functions given hold
     */
    PredicateStatic.prototype.noneOf = function () {
        var predicates = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            predicates[_i] = arguments[_i];
        }
        return exports.Predicate.of(function (x) { return !Vector_1.Vector.ofIterable(predicates).anyMatch(function (p) { return p(x); }); });
    };
    return PredicateStatic;
}());
exports.PredicateStatic = PredicateStatic;
/**
 * The Predicate constant allows to call the [[Predicate]] "static" methods.
 */
exports.Predicate = new PredicateStatic();
//# sourceMappingURL=Predicate.js.map