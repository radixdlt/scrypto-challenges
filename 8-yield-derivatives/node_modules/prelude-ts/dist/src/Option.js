"use strict";
/**
 * The [[Option]] type expresses that a value may be present or not.
 * The code is organized through the class [[None]] (value not
 * present), the class [[Some]] (value present), and the type alias
 * [[Option]] (Some or None).
 *
 * Finally, "static" functions on Option are arranged in the class
 * [[OptionStatic]] and are accessed through the global constant Option.
 *
 * Examples:
 *
 *     Option.of(5);
 *     Option.none<number>();
 *     Option.of(5).map(x => x*2);
 *
 * To get the value out of an option, you can use [[Some.getOrThrow]],
 * or [[Some.get]]. The latter is available if you've checked that you
 * indeed have a some, for example:
 *
 *     const opt = Option.of(5);
 *     if (opt.isSome()) {
 *         opt.get();
 *     }
 *
 * You also have other options like [[Some.getOrElse]], [[Some.getOrUndefined]]
 * and so on. [[Some]] and [[None]] have the same methods, except that
 * Some has the extra [[Some.get]] method that [[None]] doesn't have.
 */
exports.__esModule = true;
var Value_1 = require("./Value");
var Vector_1 = require("./Vector");
var Either_1 = require("./Either");
var Comparison_1 = require("./Comparison");
var SeqHelpers_1 = require("./SeqHelpers");
var Contract_1 = require("./Contract");
/**
 * Holds the "static methods" for [[Option]]
 */
var OptionStatic = /** @class */ (function () {
    function OptionStatic() {
    }
    /**
     * Builds an optional value.
     * * T is wrapped in a [[Some]]
     * * undefined becomes a [[None]]
     * * null becomes a [[Some]].
     *
     *     Option.of(5).isSome()
     *     => true
     *
     *     Option.of(undefined).isSome()
     *     => false
     *
     *     Option.of(null).isSome()
     *     => true
     *
     * Also see [[OptionStatic.some]], [[OptionStatic.ofNullable]]
     */
    OptionStatic.prototype.of = function (v) {
        return (v === undefined) ? exports.none : new Some(v);
    };
    /**
     * Build an optional value from a nullable.
     * * T is wrapped in a [[Some]]
     * * undefined becomes a [[None]]
     * * null becomes a [[None]].
     *
     *     Option.ofNullable(5).isSome()
     *     => true
     *
     *     Option.ofNullable(undefined).isSome()
     *     => false
     *
     *     Option.ofNullable(null).isSome()
     *     => false
     *
     * Also see [[OptionStatic.some]], [[OptionStatic.of]]
     */
    OptionStatic.prototype.ofNullable = function (v) {
        return (v !== undefined && v !== null) ? new Some(v) : exports.none;
    };
    /**
     * Build a [[Some]], unlike [[OptionStatic.of]], which may build a [[Some]]
     * or a [[None]].
     * Will throw if given undefined.
     *
     *     Option.some(5).isSome()
     *     => true
     *
     *     Option.some(undefined).isSome()
     *     => throws
     *
     *     Option.some(null).isSome()
     *     => true
     *
     * Also see [[OptionStatic.of]], [[OptionStatic.ofNullable]]
     */
    OptionStatic.prototype.some = function (v) {
        // the reason I decided to add a some in addition to 'of'
        // instead of making 'of' smarter (which is possible in
        // typescript, see https://github.com/bcherny/tsoption)
        // is that sometimes you really want an Option, not a Some.
        // for instance you can't mix an a Some and an Option in a list
        // if you put the Some first, without calling asOption().
        if (typeof v === "undefined") {
            throw "Option.some got undefined!";
        }
        return new Some(v);
    };
    /**
     * The optional value expressing a missing value.
     */
    OptionStatic.prototype.none = function () {
        return exports.none;
    };
    /**
     * Curried type guard for Option
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Option.of(2), Option.none<number>())
     *         .filter(Option.isSome)
     *         .map(o => o.get())
     *     => Vector.of(2)
     */
    OptionStatic.prototype.isSome = function (o) {
        return o.isSome();
    };
    /**
     * Curried type guard for Option
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Option.of(2), Option.none<number>())
     *         .filter(Option.isNone)
     *     => Vector.of(Option.none<number>())
     */
    OptionStatic.prototype.isNone = function (o) {
        return o.isNone();
    };
    /**
     * Turns a list of options in an option containing a list of items.
     * Useful in many contexts.
     *
     *     Option.sequence(Vector.of(Option.of(1),Option.of(2)))
     *     => Option.of(Vector.of(1,2))
     *
     * But if a single element is None, everything is discarded:
     *
     *     Option.sequence(Vector.of(Option.of(1), Option.none()))
     *     => Option.none()
     *
     * Also see [[OptionStatic.traverse]]
     */
    OptionStatic.prototype.sequence = function (elts) {
        return exports.Option.traverse(elts, function (x) { return x; });
    };
    /**
     * Takes a list, a function that can transform list elements
     * to options, then return an option containing a list of
     * the transformed elements.
     *
     *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?
     *         Option.of("user" + x.toString()) : Option.none();
     *     Option.traverse([4, 3, 2], getUserById);
     *     => Option.of(Vector.of("user4", "user3", "user2"))
     *
     * But if a single element results in None, everything is discarded:
     *
     *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?
     *         Option.of("user" + x.toString()) : Option.none();
     *     Option.traverse([4, -3, 2], getUserById);
     *     => Option.none()
     *
     * Also see [[OptionStatic.sequence]]
     */
    OptionStatic.prototype.traverse = function (elts, fn) {
        var r = Vector_1.Vector.empty();
        var iterator = elts[Symbol.iterator]();
        var curItem = iterator.next();
        while (!curItem.done) {
            var v = fn(curItem.value);
            if (v.isNone()) {
                return exports.none;
            }
            r = r.append(v.get());
            curItem = iterator.next();
        }
        return exports.Option.of(r);
    };
    /**
     * Applicative lifting for Option.
     * Takes a function which operates on basic values, and turns it
     * in a function that operates on options of these values ('lifts'
     * the function). The 2 is because it works on functions taking two
     * parameters.
     *
     *     const lifted = Option.liftA2((x:number,y:number) => x+y);
     *     lifted(Option.of(5), Option.of(6));
     *     => Option.of(11)
     *
     *     const lifted2 = Option.liftA2((x:number,y:number) => x+y);
     *     lifted2(Option.of(5), Option.none<number>());
     *     => Option.none()
     *
     * @param T the first option type
     * @param U the second option type
     * @param V the new type as returned by the combining function.
     */
    OptionStatic.prototype.liftA2 = function (fn) {
        return function (p1, p2) { return p1.flatMap(function (a1) { return p2.map(function (a2) { return fn(a1, a2); }); }); };
    };
    /**
     * Applicative lifting for Option. 'p' stands for 'properties'.
     *
     * Takes a function which operates on a simple JS object, and turns it
     * in a function that operates on the same JS object type except which each field
     * wrapped in an Option ('lifts' the function).
     * It's an alternative to [[OptionStatic.liftA2]] when the number of parameters
     * is not two.
     *
     *     const lifted = Option.liftAp((x:{a:number,b:number,c:number}) => x.a+x.b+x.c);
     *     lifted({a:Option.of(5), b:Option.of(6), c:Option.of(3)});
     *     => Option.of(14)
     *
     *     const lifted = Option.liftAp((x:{a:number,b:number}) => x.a+x.b);
     *     lifted({a:Option.of(5), b:Option.none<number>()});
     *     => Option.none()
     *
     * @param A the object property type specifying the parameters for your function
     * @param B the type returned by your function, returned wrapped in an option by liftAp.
     */
    OptionStatic.prototype.liftAp = function (fn) {
        return function (x) {
            var copy = {};
            for (var p in x) {
                if (x[p].isNone()) {
                    return exports.Option.none();
                }
                copy[p] = x[p].getOrThrow();
            }
            return exports.Option.of(fn(copy));
        };
    };
    /**
     * Take a partial function (may return undefined or throw),
     * and lift it to return an [[Option]] instead.
     * undefined becomes a [[None]], everything else a [[Some]]
     *
     *     const plus = Option.lift((x:number,y:number)=>x+y);
     *     plus(1,2);
     *     => Option.of(3)
     *
     *     const undef = Option.lift((x:number)=>undefined);
     *     undef(1);
     *     => Option.none()
     *
     *     const nl = Option.lift((x:number,y:number,z:number)=>null);
     *     nl(1,2,3);
     *     => Option.some(null)
     *
     *     const throws = Option.lift((x:number,y:number)=>{throw "x"});
     *     throws(1,2);
     *     => Option.none()
     */
    OptionStatic.prototype.lift = function (fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                return exports.Option.of(fn.apply(void 0, args));
            }
            catch (_a) {
                return exports.Option.none();
            }
        };
    };
    /**
     * Take a partial function (may return undefined or throw),
     * and lift it to return an [[Option]] instead.
     * null and undefined become a [[None]], everything else a [[Some]]
     *
     *     const plus = Option.liftNullable((x:number,y:number)=>x+y);
     *     plus(1,2);
     *     => Option.of(3)
     *
     *     const undef = Option.liftNullable((x:number,y:number,z:string)=>undefined);
     *     undef(1,2,"");
     *     => Option.none()
     *
     *     const nl = Option.liftNullable((x:number)=>null);
     *     nl(1);
     *     => Option.none()
     *
     *     const throws = Option.liftNullable((x:number,y:number)=>{throw "x"});
     *     throws(1,2);
     *     => Option.none()
     */
    OptionStatic.prototype.liftNullable = function (fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                return exports.Option.ofNullable(fn.apply(void 0, args));
            }
            catch (_a) {
                return exports.Option.none();
            }
        };
    };
    /**
     * Take a no-parameter partial function (may return undefined or throw),
     * and call it, return an [[Option]] instead.
     * undefined becomes a [[None]], everything else a [[Some]]
     *
     *     Option.try_(Math.random);
     *     => Option.of(0.49884723907769635)
     *
     *     Option.try_(()=>undefined);
     *     => Option.none()
     *
     *     Option.try_(()=>null);
     *     => Option.of(null)
     *
     *     Option.try_(()=>{throw "x"});
     *     => Option.none()
     *
     * Also see [[OptionStatic.tryNullable]], [[OptionStatic.lift]],
     * [[OptionStatic.liftNullable]], [[EitherStatic.try_]].
     */
    OptionStatic.prototype.try_ = function (fn) {
        return exports.Option.lift(fn)();
    };
    /**
     * Take a no-parameter partial function (may return null, undefined or throw),
     * and call it, return an [[Option]] instead.
     * null and undefined become a [[None]], everything else a [[Some]]
     *
     *     Option.tryNullable(Math.random);
     *     => Option.of(0.49884723907769635)
     *
     *     Option.tryNullable(()=>undefined);
     *     => Option.none()
     *
     *     Option.tryNullable(()=>null);
     *     => Option.none()
     *
     *     Option.tryNullable(()=>{throw "x"});
     *     => Option.none()
     *
     * Also see [[OptionStatic.try_]], [[OptionStatic.liftNullable]],
     * [[OptionStatic.lift]], [[EitherStatic.try_]].
     */
    OptionStatic.prototype.tryNullable = function (fn) {
        return exports.Option.liftNullable(fn)();
    };
    return OptionStatic;
}());
exports.OptionStatic = OptionStatic;
/**
 * The Option constant allows to call the option "static" methods
 */
exports.Option = new OptionStatic();
function optionHasTrueEquality(opt) {
    return opt.flatMap(function (x) { return (x && x.hasTrueEquality) ?
        exports.Option.of(x.hasTrueEquality()) :
        Comparison_1.hasTrueEquality(x); })
        .getOrElse(true);
}
/**
 * Some represents an [[Option]] with a value.
 * "static methods" available through [[OptionStatic]]
 *
 * [[Some]] and [[None]] have the same methods, except that
 * Some has the extra [[Some.get]] method that [[None]] doesn't have.
 * @param T the item type
 */
var Some = /** @class */ (function () {
    /**
     * @hidden
     */
    function Some(value) {
        this.value = value;
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * Returns true since this is a Some (contains a value)
     */
    Some.prototype.isSome = function () {
        return true;
    };
    /**
     * Returns false since this is a Some (contains a value)
     */
    Some.prototype.isNone = function () {
        return false;
    };
    /**
     * View this Some a as Option. Useful to help typescript type
     * inference sometimes.
     */
    Some.prototype.asOption = function () {
        return this;
    };
    /**
     * Get the value contained in this option.
     * NOTE: we know it's there, since this method
     * belongs to Some, not Option.
     */
    Some.prototype.get = function () {
        return this.value;
    };
    /**
     * Combines two options. If this option is a Some, returns it.
     * If it's a None, returns the other one.
     */
    Some.prototype.orElse = function (other) {
        return this;
    };
    /**
     * Get the value from this option if it's a Some, otherwise
     * throw an exception.
     * You can optionally pass a message that'll be used as the
     * exception message.
     */
    Some.prototype.getOrThrow = function (errorInfo) {
        return this.value;
    };
    /**
     * Returns true if the option is a Some and contains the
     * value you give, false otherwise.
     */
    Some.prototype.contains = function (v) {
        return v === this.value;
    };
    /**
     * Get the value contained in the option if it's a Some,
     * return undefined if it's a None.
     *
     *     Option.of(5).getOrUndefined()
     *     => 5
     *
     *     Option.none<number>().getOrUndefined()
     *     => undefined
     */
    Some.prototype.getOrUndefined = function () {
        return this.value;
    };
    /**
     * Get the value contained in the option if it's a Some,
     * return null if it's a None.
     *
     *     Option.of(5).getOrNull()
     *     => 5
     *
     *     Option.none<number>().getOrNull()
     *     => null
     */
    Some.prototype.getOrNull = function () {
        return this.value;
    };
    /**
     * Get the value from this option; if it's a None (no value
     * present), then return the default value that you give.
     */
    Some.prototype.getOrElse = function (alt) {
        return this.value;
    };
    /**
     * Get the value from this option; if it's a None (no value
     * present), then return the value returned by the function that you give.
     *
     *     Option.of(5).getOrCall(() => 6)
     *     => 5
     *
     *     Option.none<number>().getOrCall(() => 6)
     *     => 6
     */
    Some.prototype.getOrCall = function (fn) {
        return this.value;
    };
    /**
     * Return a new option where the element (if present) was transformed
     * by the mapper function you give. If the option was None it'll stay None.
     *
     *     Option.of(5).map(x => x*2)
     *     => Option.of(10)
     *
     *     Option.of(5).map(x => null)
     *     => Option.of(null)
     *
     * Also see [[Some.mapNullable]], [[Some.flatMap]]
     */
    Some.prototype.map = function (fn) {
        return exports.Option.of(fn(this.value));
    };
    /**
     * Return a new option where the element (if present) was transformed
     * by the mapper function you give. If the mapped value is `null` or
     * `undefined`, then a Some will turn into a None.
     * If the option was None it'll stay None.
     *
     *     Option.of(5).mapNullable(x => x*2)
     *     => Option.of(10)
     *
     *     Option.of(5).mapNullable(x => null)
     *     => Option.none()
     *
     * Also see [[Some.map]], [[Some.flatMap]]
     */
    Some.prototype.mapNullable = function (fn) {
        return exports.Option.ofNullable(fn(this.value));
    };
    /**
     * If this is a Some, calls the function you give on
     * the item in the option and return its result.
     * If the option is a None, return none.
     * This is the monadic bind.
     */
    Some.prototype.flatMap = function (mapper) {
        return mapper(this.value);
    };
    Some.prototype.filter = function (fn) {
        return fn(this.value) ? this : exports.Option.none();
    };
    /**
     * Execute a side-effecting function if the option
     * is a Some; returns the option.
     */
    Some.prototype.ifSome = function (fn) {
        fn(this.value);
        return this;
    };
    /**
     * Execute a side-effecting function if the option
     * is a None; returns the option.
     */
    Some.prototype.ifNone = function (fn) {
        return this;
    };
    /**
     * Handle both branches of the option and return a value
     * (can also be used for side-effects).
     * This is the catamorphism for option.
     *
     *     Option.of(5).match({
     *         Some: x  => "got " + x,
     *         None: () => "got nothing!"
     *     });
     *     => "got 5"
     */
    Some.prototype.match = function (cases) {
        return cases.Some(this.value);
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    Some.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Convert to a vector. If it's a None, it's the empty
     * vector, if it's a Some, it's a one-element vector with
     * the contents of the option.
     */
    Some.prototype.toVector = function () {
        return Vector_1.Vector.of(this.value);
    };
    /**
     * Convert to an either. You must provide a left value
     * in case this is a None.
     */
    Some.prototype.toEither = function (left) {
        return Either_1.Either.right(this.value);
    };
    /**
     * If this is a Some, return this object.
     * If this is a None, return the result of the function.
     */
    Some.prototype.orCall = function (_) {
        return this;
    };
    Some.prototype.hasTrueEquality = function () {
        return optionHasTrueEquality(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    Some.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        // the .isSome doesn't test if it's a Some, but
        // if the object has a field called isSome.
        if (other === exports.none || !other || !other.isSome) {
            return false;
        }
        var someOther = other;
        Contract_1.contractTrueEquality("Option.equals", this, someOther);
        return Comparison_1.areEqual(this.value, someOther.value);
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    Some.prototype.hashCode = function () {
        return Comparison_1.getHashCode(this.value);
    };
    /**
     * Get a human-friendly string representation of that value.
     */
    Some.prototype.toString = function () {
        return "Some(" + SeqHelpers_1.toStringHelper(this.value) + ")";
    };
    /**
     * Used by the node REPL to display values.
     */
    Some.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return Some;
}());
exports.Some = Some;
/**
 * None represents an [[Option]] without value.
 * "static methods" available through [[OptionStatic]]
 *
 * [[Some]] and [[None]] have the same methods, except that
 * Some has the extra [[Some.get]] method that [[None]] doesn't have.
 * @param T the item type
 */
var None = /** @class */ (function () {
    function None() {
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * Returns false since this is a None (doesn'tcontains a value)
     */
    None.prototype.isSome = function () {
        return false;
    };
    /**
     * Returns true since this is a None (doesn'tcontains a value)
     */
    None.prototype.isNone = function () {
        return true;
    };
    /**
     * View this Some a as Option. Useful to help typescript type
     * inference sometimes.
     */
    None.prototype.asOption = function () {
        return this;
    };
    /**
     * Combines two options. If this option is a Some, returns it.
     * If it's a None, returns the other one.
     */
    None.prototype.orElse = function (other) {
        return other;
    };
    /**
     * Get the value from this option if it's a Some, otherwise
     * throw an exception.
     * You can optionally pass a message that'll be used as the
     * exception message, or an Error object.
     */
    None.prototype.getOrThrow = function (errorInfo) {
        if (typeof errorInfo === 'string') {
            throw new Error(errorInfo || "getOrThrow called on none!");
        }
        throw errorInfo || new Error("getOrThrow called on none!");
    };
    /**
     * Returns true if the option is a Some and contains the
     * value you give, false otherwise.
     */
    None.prototype.contains = function (v) {
        return false;
    };
    /**
     * Get the value contained in the option if it's a Some,
     * return undefined if it's a None.
     *
     *     Option.of(5).getOrUndefined()
     *     => 5
     *
     *     Option.none<number>().getOrUndefined()
     *     => undefined
     */
    None.prototype.getOrUndefined = function () {
        return undefined;
    };
    /**
     * Get the value contained in the option if it's a Some,
     * return null if it's a None.
     *
     *     Option.of(5).getOrNull()
     *     => 5
     *
     *     Option.none<number>().getOrNull()
     *     => null
     */
    None.prototype.getOrNull = function () {
        return null;
    };
    /**
     * Get the value from this option; if it's a None (no value
     * present), then return the default value that you give.
     */
    None.prototype.getOrElse = function (alt) {
        return alt;
    };
    /**
     * Get the value from this option; if it's a None (no value
     * present), then return the value returned by the function that you give.
     *
     *     Option.of(5).getOrCall(() => 6)
     *     => 5
     *
     *     Option.none<number>().getOrCall(() => 6)
     *     => 6
     */
    None.prototype.getOrCall = function (fn) {
        return fn();
    };
    /**
     * Return a new option where the element (if present) was transformed
     * by the mapper function you give. If the option was None it'll stay None.
     *
     *     Option.of(5).map(x => x*2)
     *     => Option.of(10)
     *
     *     Option.of(5).map(x => null)
     *     => Option.of(null)
     *
     * Also see [[None.mapNullable]], [[None.flatMap]]
     */
    None.prototype.map = function (fn) {
        return exports.none;
    };
    /**
     * Return a new option where the element (if present) was transformed
     * by the mapper function you give. If the mapped value is `null` or
     * `undefined`, then a Some will turn into a None.
     * If the option was None it'll stay None.
     *
     *     Option.of(5).mapNullable(x => x*2)
     *     => Option.of(10)
     *
     *     Option.of(5).mapNullable(x => null)
     *     => Option.none()
     *
     * Also see [[None.map]], [[None.flatMap]]
     */
    None.prototype.mapNullable = function (fn) {
        return exports.none;
    };
    /**
     * If this is a Some, calls the function you give on
     * the item in the option and return its result.
     * If the option is a None, return none.
     * This is the monadic bind.
     */
    None.prototype.flatMap = function (mapper) {
        return exports.none;
    };
    None.prototype.filter = function (fn) {
        return exports.none;
    };
    /**
     * Execute a side-effecting function if the option
     * is a Some; returns the option.
     */
    None.prototype.ifSome = function (fn) {
        return this;
    };
    /**
     * Execute a side-effecting function if the option
     * is a Some; returns the option.
     */
    None.prototype.ifNone = function (fn) {
        fn();
        return this;
    };
    /**
     * Handle both branches of the option and return a value
     * (can also be used for side-effects).
     * This is the catamorphism for option.
     *
     *     Option.of(5).match({
     *         Some: x  => "got " + x,
     *         None: () => "got nothing!"
     *     });
     *     => "got 5"
     */
    None.prototype.match = function (cases) {
        return cases.None();
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    None.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Convert to a vector. If it's a None, it's the empty
     * vector, if it's a Some, it's a one-element vector with
     * the contents of the option.
     */
    None.prototype.toVector = function () {
        return Vector_1.Vector.empty();
    };
    /**
     * Convert to an either. You must provide a left value
     * in case this is a None.
     */
    None.prototype.toEither = function (left) {
        return Either_1.Either.left(left);
    };
    /**
     * If this is a Some, return this object.
     * If this is a None, return the result of the function.
     */
    None.prototype.orCall = function (fn) {
        return fn();
    };
    None.prototype.hasTrueEquality = function () {
        return optionHasTrueEquality(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    None.prototype.equals = function (other) {
        return other === exports.none;
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    None.prototype.hashCode = function () {
        return 1;
    };
    /**
     * Get a human-friendly string representation of that value.
     */
    None.prototype.toString = function () {
        return "None()";
    };
    /**
     * Used by the node REPL to display values.
     */
    None.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return None;
}());
exports.None = None;
/**
 * @hidden
 */
exports.none = new None();
//# sourceMappingURL=Option.js.map