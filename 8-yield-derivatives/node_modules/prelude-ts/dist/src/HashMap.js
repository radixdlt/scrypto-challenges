"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Comparison_1 = require("./Comparison");
var SeqHelpers_1 = require("./SeqHelpers");
var Contract_1 = require("./Contract");
var Option_1 = require("./Option");
var HashSet_1 = require("./HashSet");
var Vector_1 = require("./Vector");
var LinkedList_1 = require("./LinkedList");
var SeqHelpers = require("./SeqHelpers");
var Value_1 = require("./Value");
var hamt = require("hamt_plus");
// HashMap could extend Collection, conceptually. But I'm
// not super happy of having the callbacks get a pair, for instance
// 'HashMap.filter' takes two parameters in the current HashMap;
// if HashMap did implement Collection, it would have to take a k,v
// pair. There's also another trick with 'contains'. The Collection signature
// says T&WithEquality, but here we get [K&WithEquality,V&WithEquality],
// but arrays don't have equality so that doesn't type-check :-(
/**
 * A dictionary, mapping keys to values.
 * @param K the key type
 * @param V the value type
 */
var HashMap = /** @class */ (function () {
    /**
     * @hidden
     */
    function HashMap(hamt) {
        this.hamt = hamt;
    }
    /**
     * The empty map.
     * @param K the key type
     * @param V the value type
     */
    HashMap.empty = function () {
        return emptyHashMap;
    };
    /**
     * Build a HashMap from key-value pairs.
     *
     *     HashMap.of([1,"a"],[2,"b"])
     *
     */
    HashMap.of = function () {
        var entries = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            entries[_i] = arguments[_i];
        }
        return HashMap.ofIterable(entries);
    };
    /**
     * Build a HashMap from an iterable containing key-value pairs.
     *
     *    HashMap.ofIterable(Vector.of<[number,string]>([1,"a"],[2,"b"]));
     */
    HashMap.ofIterable = function (entries) {
        // remember we must set up the hamt with the custom equality
        var iterator = entries[Symbol.iterator]();
        var curItem = iterator.next();
        if (curItem.done) {
            return new EmptyHashMap();
        }
        // emptyhashmap.put sets up the custom equality+hashcode
        var startH = (new EmptyHashMap()).put(curItem.value[0], curItem.value[1]).hamt;
        curItem = iterator.next();
        return new HashMap(startH.mutate(function (h) {
            while (!curItem.done) {
                h.set(curItem.value[0], curItem.value[1]);
                curItem = iterator.next();
            }
        }));
    };
    /**
     * Build a HashMap from a javascript object literal representing
     * a dictionary. Note that the key type must always be string,
     * as that's the way it works in javascript.
     * Also note that entries with undefined values will be stripped
     * from the map.
     *
     *     HashMap.ofObjectDictionary<number>({a:1,b:2})
     *     => HashMap.of(["a",1],["b",2])
     */
    HashMap.ofObjectDictionary = function (object) {
        // no need to bother with the proper equals & hashcode
        // as I know the key type supports ===
        var h = hamt.make().beginMutation();
        for (var property in object) {
            // the reason we strip entries with undefined values on
            // import from object dictionaries are: sanity, and also
            // partial object definitions like {[TKey in MyEnum]?:number}
            // where typescript sees the value type as 'number|undefined'
            // (there is a test covering that)
            if (object.hasOwnProperty(property) &&
                (typeof object[property] !== "undefined")) {
                h.set(property, object[property]);
            }
        }
        return new HashMap(h.endMutation());
    };
    /**
     * Curried predicate to find out whether the HashMap is empty.
     *
     *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())
     *         .filter(HashMap.isEmpty)
     *     => Vector.of(HashMap.empty<number,number>())
     */
    HashMap.isEmpty = function (v) {
        return v.isEmpty();
    };
    /**
     * Curried predicate to find out whether the HashMap is empty.
     *
     *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())
     *         .filter(HashMap.isNotEmpty)
     *     => Vector.of(HashMap.of([1,2]))
     */
    HashMap.isNotEmpty = function (v) {
        return !v.isEmpty();
    };
    /**
     * Get the value for the key you give, if the key is present.
     */
    HashMap.prototype.get = function (k) {
        return Option_1.Option.of(this.hamt.get(k));
    };
    /**
     * Implementation of the Iterator interface.
     */
    HashMap.prototype[Symbol.iterator] = function () {
        return this.hamt.entries();
    };
    /**
     * @hidden
     */
    HashMap.prototype.hasTrueEquality = function () {
        // for true equality, need both key & value to have true
        // equality. but i can't check when they're in an array,
        // as array doesn't have true equality => extract them
        // and check them separately.
        return Option_1.Option.of(this.hamt.entries().next().value)
            .map(function (x) { return x[0]; }).hasTrueEquality() &&
            Option_1.Option.of(this.hamt.entries().next().value)
                .map(function (x) { return x[1]; }).hasTrueEquality();
    };
    /**
     * Add a new entry in the map. If there was entry with the same
     * key, it will be overwritten.
     * @param k the key
     * @param v the value
     */
    HashMap.prototype.put = function (k, v) {
        return new HashMap(this.hamt.set(k, v));
    };
    /**
     * Return a new map with the key you give removed.
     */
    HashMap.prototype.remove = function (k) {
        return new HashMap(this.hamt.remove(k));
    };
    /**
     * Add a new entry in the map; in case there was already an
     * entry with the same key, the merge function will be invoked
     * with the old and the new value to produce the value to take
     * into account.
     *
     * It is guaranteed that the merge function first parameter
     * will be the entry from this map, and the second parameter
     * from the map you give.
     * @param k the key
     * @param v the value
     * @param merge a function to merge old and new values in case of conflict.
     */
    HashMap.prototype.putWithMerge = function (k, v, merge) {
        return new HashMap(this.hamt.modify(k, function (curV) {
            if (curV === undefined) {
                return v;
            }
            return merge(curV, v);
        }));
    };
    /**
     * number of items in the map
     */
    HashMap.prototype.length = function () {
        return this.hamt.size;
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    HashMap.prototype.single = function () {
        return this.hamt.size === 1
            ? Option_1.Option.of(this.hamt.entries().next().value)
            : Option_1.Option.none();
    };
    /**
     * true if the map is empty, false otherwise.
     */
    HashMap.prototype.isEmpty = function () {
        return this.hamt.size === 0;
    };
    /**
     * Get a Set containing all the keys in the map
     */
    HashMap.prototype.keySet = function () {
        return HashSet_1.HashSet.ofIterable(this.hamt.keys());
    };
    /**
     * Get an iterable containing all the values in the map
     * (can't return a set as we don't constrain map values
     * to have equality in the generics type)
     */
    HashMap.prototype.valueIterable = function () {
        var _a;
        var hamt = this.hamt;
        return _a = {},
            _a[Symbol.iterator] = function () { return hamt.values(); },
            _a;
    };
    /**
     * Create a new map combining the entries of this map, and
     * the other map you give. In case an entry from this map
     * and the other map have the same key, the merge function
     * will be invoked to get a combined value.
     *
     * It is guaranteed that the merge function first parameter
     * will be the entry from this map, and the second parameter
     * from the map you give.
     * @param other another map to merge with this one
     * @param merge a merge function to combine two values
     *        in case two entries share the same key.
     */
    HashMap.prototype.mergeWith = function (elts, merge) {
        var iterator = elts[Symbol.iterator]();
        var map = this;
        var curItem = iterator.next();
        while (!curItem.done) {
            map = map.putWithMerge(curItem.value[0], curItem.value[1], merge);
            curItem = iterator.next();
        }
        return map;
    };
    /**
     * Return a new map where each entry was transformed
     * by the mapper function you give. You return key,value
     * as pairs.
     */
    HashMap.prototype.map = function (fn) {
        return this.hamt.fold(function (acc, value, key) {
            var _a = fn(key, value), newk = _a[0], newv = _a[1];
            return acc.put(newk, newv);
        }, HashMap.empty());
    };
    /**
     * Return a new map where keys are the same as in this one,
     * but values are transformed
     * by the mapper function you give. You return key,value
     * as pairs.
     */
    HashMap.prototype.mapValues = function (fn) {
        return this.hamt.fold(function (acc, value, key) {
            return acc.put(key, fn(value));
        }, HashMap.empty());
    };
    /**
     * Call a function for element in the collection.
     */
    HashMap.prototype.forEach = function (fun) {
        var iterator = this.hamt.entries();
        var curItem = iterator.next();
        while (!curItem.done) {
            fun(curItem.value);
            curItem = iterator.next();
        }
        return this;
    };
    /**
     * Calls the function you give for each item in the map,
     * your function returns a map, all the maps are
     * merged.
     */
    HashMap.prototype.flatMap = function (fn) {
        return this.foldLeft(HashMap.empty(), function (soFar, cur) { return soFar.mergeWith(fn(cur[0], cur[1]), function (a, b) { return b; }); });
    };
    /**
     * Returns true if the predicate returns true for all the
     * elements in the collection.
     */
    HashMap.prototype.allMatch = function (predicate) {
        var iterator = this.hamt.entries();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (!predicate(curItem.value[0], curItem.value[1])) {
                return false;
            }
            curItem = iterator.next();
        }
        return true;
    };
    /**
     * Returns true if there the predicate returns true for any
     * element in the collection.
     */
    HashMap.prototype.anyMatch = function (predicate) {
        var iterator = this.hamt.entries();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (predicate(curItem.value[0], curItem.value[1])) {
                return true;
            }
            curItem = iterator.next();
        }
        return false;
    };
    /**
     * Returns true if the item is in the collection,
     * false otherwise.
     */
    HashMap.prototype.contains = function (val) {
        return Comparison_1.areEqual(this.hamt.get(val[0]), val[1]);
    };
    /**
     * Returns true if there is item with that key in the collection,
     * false otherwise.
     *
     *     HashMap.of<number,string>([1,"a"],[2,"b"]).containsKey(1);
     *     => true
     *
     *     HashMap.of<number,string>([1,"a"],[2,"b"]).containsKey(3);
     *     => false
     */
    HashMap.prototype.containsKey = function (key) {
        return this.hamt.has(key);
    };
    /**
     * Call a predicate for each element in the collection,
     * build a new collection holding only the elements
     * for which the predicate returned true.
     */
    HashMap.prototype.filter = function (predicate) {
        var _this = this;
        return new HashMap(hamt.make({ hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq }).mutate(function (h) {
            var iterator = _this.hamt.entries();
            var curItem = iterator.next();
            while (!curItem.done) {
                if (predicate(curItem.value[0], curItem.value[1])) {
                    h.set(curItem.value[0], curItem.value[1]);
                }
                curItem = iterator.next();
            }
        }));
    };
    /**
     * Search for an item matching the predicate you pass,
     * return Option.Some of that element if found,
     * Option.None otherwise.
     * We name the method findAny instead of find to emphasize
     * that there is not ordering in a hashset.
     *
     *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])
     *         .findAny((k,v) => k>=2 && v === "c")
     *     => Option.of([3,'c'])
     *
     *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])
     *         .findAny((k,v) => k>=3 && v === "b")
     *     => Option.none<[number,string]>()
     */
    HashMap.prototype.findAny = function (predicate) {
        var iterator = this.hamt.entries();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (predicate(curItem.value[0], curItem.value[1])) {
                return Option_1.Option.of(curItem.value);
            }
            curItem = iterator.next();
        }
        return Option_1.Option.none();
    };
    HashMap.prototype.filterKeys = function (predicate) {
        return this.filter(function (k, v) { return predicate(k); });
    };
    HashMap.prototype.filterValues = function (predicate) {
        return this.filter(function (k, v) { return predicate(v); });
    };
    /**
     * Reduces the collection to a single value using the
     * associative binary function you give. Since the function
     * is associative, order of application doesn't matter.
     *
     * Example:
     *
     *     HashMap.of<number,string>([1,"a"],[2,"b"],[3,"c"])
     *      .fold([0,""], ([a,b],[c,d])=>[a+c, b>d?b:d])
     *     => [6,"c"]
     */
    HashMap.prototype.fold = function (zero, fn) {
        return this.foldLeft(zero, fn);
    };
    /**
     * Reduces the collection to a single value.
     * Left-associative.
     * No guarantees for the order of items in a hashset!
     *
     * Example:
     *
     *     HashMap.of([1,"a"], [2,"bb"], [3,"ccc"])
     *     .foldLeft(0, (soFar,[item,val])=>soFar+val.length);
     *     => 6
     *
     * @param zero The initial value
     * @param fn A function taking the previous value and
     *           the current collection item, and returning
     *           an updated value.
     */
    HashMap.prototype.foldLeft = function (zero, fn) {
        return this.hamt.fold(function (acc, v, k) {
            return fn(acc, [k, v]);
        }, zero);
    };
    /**
     * Reduces the collection to a single value.
     * Right-associative.
     * No guarantees for the order of items in a hashset!
     *
     * Example:
     *
     *     HashMap.of([1,"a"], [2,"bb"], [3,"ccc"])
     *     .foldRight(0, ([item,value],soFar)=>soFar+value.length);
     *     => 6
     *
     * @param zero The initial value
     * @param fn A function taking the current collection item and
     *           the previous value , and returning
     *           an updated value.
     */
    HashMap.prototype.foldRight = function (zero, fn) {
        return this.foldLeft(zero, function (cur, soFar) { return fn(soFar, cur); });
    };
    /**
     * Reduces the collection to a single value by repeatedly
     * calling the combine function.
     * No starting value. The order in which the elements are
     * passed to the combining function is undetermined.
     */
    HashMap.prototype.reduce = function (combine) {
        // not really glorious with any...
        return SeqHelpers.reduce(this, combine);
    };
    /**
     * Convert to array.
     */
    HashMap.prototype.toArray = function () {
        return this.hamt.fold(function (acc, value, key) { acc.push([key, value]); return acc; }, []);
    };
    /**
     * Convert this map to a vector of key,value pairs.
     * Note that Map is already an iterable of key,value pairs!
     */
    HashMap.prototype.toVector = function () {
        return this.hamt.fold(function (acc, value, key) {
            return acc.append([key, value]);
        }, Vector_1.Vector.empty());
    };
    /**
     * Convert this map to a list of key,value pairs.
     * Note that Map is already an iterable of key,value pairs!
     */
    HashMap.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.ofIterable(this);
    };
    /**
     * Convert to a javascript object dictionary
     * You must provide a function to convert the
     * key to a string.
     *
     *     HashMap.of<string,number>(["a",1],["b",2])
     *         .toObjectDictionary(x=>x);
     *     => {a:1,b:2}
     */
    HashMap.prototype.toObjectDictionary = function (keyConvert) {
        return this.foldLeft({}, function (soFar, cur) {
            soFar[keyConvert(cur[0])] = cur[1];
            return soFar;
        });
    };
    HashMap.prototype.toJsMap = function (keyConvert) {
        return this.foldLeft(new Map(), function (soFar, cur) { return soFar.set(keyConvert(cur[0]), cur[1]); });
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    HashMap.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    HashMap.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if (!other || !other.valueIterable) {
            return false;
        }
        Contract_1.contractTrueEquality("HashMap.equals", this, other);
        var sz = this.hamt.size;
        if (other.length() === 0 && sz === 0) {
            // we could get that i'm not the empty map
            // but my size is zero, after some filtering and such.
            return true;
        }
        if (sz !== other.length()) {
            return false;
        }
        var keys = Array.from(this.hamt.keys());
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            var myVal = this.hamt.get(k);
            var hisVal = other.get(k).getOrUndefined();
            if (myVal === undefined || hisVal === undefined) {
                return false;
            }
            if (!Comparison_1.areEqual(myVal, hisVal)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    HashMap.prototype.hashCode = function () {
        // references:
        // https://github.com/clojure/clojure/blob/5ffe3833508495ca7c635d47ad7a1c8b820eab76/src/jvm/clojure/lang/APersistentMap.java#L98
        // https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/19fb8f93c59dfd791f62d41f332db9e306bc1422/src/java.base/share/classes/java/util/HashMap.java#L296
        // Both the Clojure and AdoptOpenJDK references calculate the bitwise XOR
        // of the key/value pairs. The significance of the bitwise XOR is that,
        // unlike just adding the hashcode of the key and value pair, they become
        // intertwined, which prevents collisions when identical values are swapped
        // between keys.
        // This algorithm only intertwines the keys and the values. The calculations
        // for the pairs are summed up, to make sure that we get the same result
        // if the pairs are in a different order.
        // The Clojure implementation also caches the result of the calculation, but
        // we've decided not to do that yet, see the discussion on the PR for context:
        // https://github.com/emmanueltouzery/prelude-ts/pull/67
        return this.hamt.fold(function (acc, value, key) {
            return acc + (Comparison_1.getHashCode(key) ^ Comparison_1.getHashCode(value));
        }, 0);
    };
    /*
     * Get a human-friendly string representation of that value.
     */
    HashMap.prototype.toString = function () {
        return "HashMap(" +
            this.hamt.fold(function (acc, value, key) {
                acc.push(SeqHelpers_1.toStringHelper(key, { quoteStrings: false }) +
                    ": " + SeqHelpers_1.toStringHelper(value));
                return acc;
            }, [])
                .join(", ") + ")";
    };
    HashMap.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return HashMap;
}());
exports.HashMap = HashMap;
// we need to override the empty hashmap
// because i don't know how to get the hash & keyset
// functions for the keys without a key value to get
// the functions from
var EmptyHashMap = /** @class */ (function (_super) {
    __extends(EmptyHashMap, _super);
    function EmptyHashMap() {
        return _super.call(this, {}) || this;
    }
    EmptyHashMap.prototype.get = function (k) {
        return Option_1.none;
    };
    EmptyHashMap.prototype[Symbol.iterator] = function () {
        return { next: function () { return ({ done: true, value: undefined }); } };
    };
    EmptyHashMap.prototype.put = function (k, v) {
        Contract_1.contractTrueEquality("Error building a HashMap", k);
        if (Comparison_1.hasEquals(k)) {
            return new HashMap(hamt.make({
                hash: function (v) { return v.hashCode(); },
                keyEq: function (a, b) { return a.equals(b); }
            }).set(k, v));
        }
        return new HashMap(hamt.make().set(k, v));
    };
    EmptyHashMap.prototype.remove = function (k) {
        return this;
    };
    EmptyHashMap.prototype.hasTrueEquality = function () {
        return true;
    };
    EmptyHashMap.prototype.putWithMerge = function (k, v, merge) {
        return this.put(k, v);
    };
    EmptyHashMap.prototype.length = function () {
        return 0;
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    EmptyHashMap.prototype.single = function () {
        return Option_1.Option.none();
    };
    EmptyHashMap.prototype.isEmpty = function () {
        return true;
    };
    EmptyHashMap.prototype.keySet = function () {
        return HashSet_1.HashSet.empty();
    };
    EmptyHashMap.prototype.valueIterable = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                return {
                    next: function () {
                        return {
                            done: true,
                            value: undefined
                        };
                    }
                };
            },
            _a;
    };
    EmptyHashMap.prototype.mergeWith = function (other, merge) {
        return HashMap.ofIterable(other);
    };
    EmptyHashMap.prototype.map = function (fn) {
        return HashMap.empty();
    };
    EmptyHashMap.prototype.mapValues = function (fn) {
        return HashMap.empty();
    };
    EmptyHashMap.prototype.forEach = function (fun) {
        return this;
    };
    EmptyHashMap.prototype.allMatch = function (predicate) {
        return true;
    };
    EmptyHashMap.prototype.anyMatch = function (predicate) {
        return false;
    };
    EmptyHashMap.prototype.contains = function (val) {
        return false;
    };
    EmptyHashMap.prototype.containsKey = function (key) {
        return false;
    };
    EmptyHashMap.prototype.filter = function (predicate) {
        return this;
    };
    EmptyHashMap.prototype.findAny = function (predicate) {
        return Option_1.Option.none();
    };
    EmptyHashMap.prototype.foldLeft = function (zero, fn) {
        return zero;
    };
    EmptyHashMap.prototype.toArray = function () {
        return [];
    };
    EmptyHashMap.prototype.toVector = function () {
        return Vector_1.Vector.empty();
    };
    EmptyHashMap.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.empty();
    };
    EmptyHashMap.prototype.equals = function (other) {
        if (!other || !other.valueIterable) {
            return false;
        }
        return other === emptyHashMap || other.length() === 0;
    };
    EmptyHashMap.prototype.hashCode = function () {
        return 0;
    };
    EmptyHashMap.prototype.toString = function () {
        return "HashMap()";
    };
    return EmptyHashMap;
}(HashMap));
var emptyHashMap = new EmptyHashMap();
//# sourceMappingURL=HashMap.js.map