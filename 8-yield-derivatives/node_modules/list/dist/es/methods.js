import { List } from "./fantasy-land";
import * as L from "./fantasy-land";
export * from "./index";
List.prototype.append = function (value) {
    return L.append(value, this);
};
List.prototype.intersperse = function (separator) {
    return L.intersperse(separator, this);
};
List.prototype.nth = function (index) {
    return L.nth(index, this);
};
List.prototype.empty = function () {
    return L.empty();
};
List.prototype.of = function (b) {
    return L.of(b);
};
List.prototype.prepend = function (value) {
    return L.prepend(value, this);
};
List.prototype.append = function (value) {
    return L.append(value, this);
};
List.prototype.first = function () {
    return L.first(this);
};
List.prototype.head = List.prototype.first;
List.prototype.last = function () {
    return L.last(this);
};
List.prototype.map = function (f) {
    return L.map(f, this);
};
List.prototype.pluck = function (key) {
    return L.pluck(key, this);
};
List.prototype.foldl = function foldl(f, initial) {
    return L.foldl(f, initial, this);
};
List.prototype.reduce = List.prototype.foldl;
List.prototype.scan = function scan(f, initial) {
    return L.scan(f, initial, this);
};
List.prototype.foldr = function (f, initial) {
    return L.foldr(f, initial, this);
};
List.prototype.reduceRight = List.prototype.foldr;
List.prototype.foldlWhile = function foldlWhile(predicate, f, initial) {
    return L.foldlWhile(predicate, f, initial, this);
};
List.prototype.reduceWhile = List.prototype.foldlWhile;
List.prototype.traverse = function (of, f) {
    return L.traverse(of, f, this);
};
List.prototype.sequence = function (of) {
    return L.sequence(of, this);
};
List.prototype.forEach = function (callback) {
    return L.forEach(callback, this);
};
List.prototype.filter = function (predicate) {
    return L.filter(predicate, this);
};
List.prototype.reject = function (predicate) {
    return L.reject(predicate, this);
};
List.prototype.partition = function (predicate) {
    return L.partition(predicate, this);
};
List.prototype.join = function (separator) {
    return L.join(separator, this);
};
List.prototype.ap = function (listF) {
    return L.ap(listF, this);
};
List.prototype.flatten = function () {
    return L.flatten(this);
};
List.prototype.flatMap = function (f) {
    return L.flatMap(f, this);
};
List.prototype.chain = List.prototype.flatMap;
List.prototype.every = function (predicate) {
    return L.every(predicate, this);
};
List.prototype.some = function (predicate) {
    return L.some(predicate, this);
};
List.prototype.none = function (predicate) {
    return L.none(predicate, this);
};
List.prototype.indexOf = function (element) {
    return L.indexOf(element, this);
};
List.prototype.lastIndexOf = function (element) {
    return L.lastIndexOf(element, this);
};
List.prototype.find = function find(predicate) {
    return L.find(predicate, this);
};
List.prototype.findLast = function findLast(predicate) {
    return L.findLast(predicate, this);
};
List.prototype.findIndex = function (predicate) {
    return L.findIndex(predicate, this);
};
List.prototype.includes = function (element) {
    return L.includes(element, this);
};
List.prototype.equals = function (secondList) {
    return L.equals(this, secondList);
};
List.prototype.equalsWith = function (f, secondList) {
    return L.equalsWith(f, this, secondList);
};
List.prototype.concat = function (right) {
    return L.concat(this, right);
};
List.prototype.update = function (index, a) {
    return L.update(index, a, this);
};
List.prototype.adjust = function (index, f) {
    return L.adjust(index, f, this);
};
List.prototype.slice = function (from, to) {
    return L.slice(from, to, this);
};
List.prototype.take = function (n) {
    return L.take(n, this);
};
List.prototype.takeWhile = function (predicate) {
    return L.takeWhile(predicate, this);
};
List.prototype.takeLast = function (n) {
    return L.takeLast(n, this);
};
List.prototype.takeLastWhile = function (predicate) {
    return L.takeLastWhile(predicate, this);
};
List.prototype.splitAt = function (index) {
    return L.splitAt(index, this);
};
List.prototype.splitWhen = function (predicate) {
    return L.splitWhen(predicate, this);
};
List.prototype.splitEvery = function (size) {
    return L.splitEvery(size, this);
};
List.prototype.remove = function (from, amount) {
    return L.remove(from, amount, this);
};
List.prototype.drop = function (n) {
    return L.drop(n, this);
};
List.prototype.dropWhile = function (predicate) {
    return L.dropWhile(predicate, this);
};
List.prototype.dropRepeats = function () {
    return L.dropRepeats(this);
};
List.prototype.dropRepeatsWith = function (predicate) {
    return L.dropRepeatsWith(predicate, this);
};
List.prototype.dropLast = function (n) {
    return L.dropLast(n, this);
};
List.prototype.pop = function () {
    return L.pop(this);
};
List.prototype.tail = function () {
    return L.tail(this);
};
List.prototype.toArray = function () {
    return L.toArray(this);
};
List.prototype.insert = function (index, element) {
    return L.insert(index, element, this);
};
List.prototype.insertAll = function (index, elements) {
    return L.insertAll(index, elements, this);
};
List.prototype.reverse = function () {
    return L.reverse(this);
};
List.prototype.backwards = function () {
    return L.backwards(this);
};
List.prototype.zipWith = function (f, bs) {
    return L.zipWith(f, this, bs);
};
List.prototype.zip = function (bs) {
    return L.zip(this, bs);
};
List.prototype.sort = function () {
    return L.sort(this);
};
List.prototype.sortWith = function (comparator) {
    return L.sortWith(comparator, this);
};
List.prototype.sortBy = function (f) {
    return L.sortBy(f, this);
};
List.prototype.group = function () {
    return L.group(this);
};
List.prototype.groupWith = function (f) {
    return L.groupWith(f, this);
};
List.prototype.isEmpty = function () {
    return L.isEmpty(this);
};
