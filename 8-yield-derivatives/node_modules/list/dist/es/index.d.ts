export declare type Sizes = number[] | undefined;
export declare class Node {
    sizes: Sizes;
    array: any[];
    constructor(sizes: Sizes, array: any[]);
}
export declare class List<A> implements Iterable<A> {
    readonly bits: number;
    readonly offset: number;
    readonly length: number;
    readonly prefix: A[];
    readonly root: Node | undefined;
    readonly suffix: A[];
    constructor(bits: number, offset: number, length: number, prefix: A[], root: Node | undefined, suffix: A[]);
    [Symbol.iterator](): Iterator<A>;
    toJSON(): A[];
}
export declare function backwards<A>(l: List<A>): Iterable<A>;
export declare function list<A>(...elements: A[]): List<A>;
export declare function empty<A = any>(): List<A>;
export declare function of<A>(a: A): List<A>;
export declare function pair<A>(first: A, second: A): List<A>;
export declare function from<A>(sequence: A[] | ArrayLike<A> | Iterable<A>): List<A>;
export declare function range(start: number, end: number): List<number>;
export declare function repeat<A>(value: A, times: number): List<A>;
export declare function times<A>(func: (index: number) => A, times: number): List<A>;
export declare function nth<A>(index: number, l: List<A>): A | undefined;
export declare function prepend<A>(value: A, l: List<A>): List<A>;
export declare function append<A>(value: A, l: List<A>): List<A>;
export declare function length(l: List<any>): number;
export declare function first<A>(l: List<A>): A | undefined;
export declare const head: typeof first;
export declare function last<A>(l: List<A>): A | undefined;
export declare function map<A, B>(f: (a: A) => B, l: List<A>): List<B>;
export declare function pluck<A, K extends keyof A>(key: K, l: List<A>): List<A[K]>;
export declare function foldl<A, B>(f: (acc: B, value: A) => B, initial: B, l: List<A>): B;
export declare const reduce: typeof foldl;
export interface Of {
    "fantasy-land/of"<B>(a: B): Applicative<B>;
}
export interface Applicative<A> {
    "fantasy-land/map"<B>(f: (a: A) => B): Applicative<B>;
    "fantasy-land/ap"<B>(fa: Applicative<(a: A) => B>): Applicative<B>;
}
export declare function traverse<A, B>(of: Of, f: (a: A) => Applicative<B>, l: List<A>): any;
export declare function sequence<A>(ofObj: Of, l: List<Applicative<A>>): any;
export declare function scan<A, B>(f: (acc: B, value: A) => B, initial: B, l: List<A>): List<B>;
export declare function forEach<A>(callback: (a: A) => void, l: List<A>): void;
export declare function filter<A, B extends A>(predicate: (a: A) => a is B, l: List<A>): List<B>;
export declare function filter<A>(predicate: (a: A) => boolean, l: List<A>): List<A>;
export declare function reject<A>(predicate: (a: A) => boolean, l: List<A>): List<A>;
export declare function partition<A, B extends A>(predicate: (a: A) => a is B, l: List<A>): [List<B>, List<Exclude<A, B>>];
export declare function partition<A>(predicate: (a: A) => boolean, l: List<A>): [List<A>, List<A>];
export declare function join(separator: string, l: List<string>): string;
export declare function foldr<A, B>(f: (value: A, acc: B) => B, initial: B, l: List<A>): B;
export declare const reduceRight: typeof foldr;
export declare function ap<A, B>(listF: List<(a: A) => B>, l: List<A>): List<B>;
export declare function flatten<A>(nested: List<List<A>>): List<A>;
export declare function flatMap<A, B>(f: (a: A) => List<B>, l: List<A>): List<B>;
export declare const chain: typeof flatMap;
export declare function foldlWhile<A, B>(predicate: (acc: B, value: A) => boolean, f: (acc: B, value: A) => B, initial: B, l: List<A>): B;
export declare const reduceWhile: typeof foldlWhile;
export declare function every<A>(predicate: (a: A) => boolean, l: List<A>): boolean;
export declare const all: typeof every;
export declare function some<A>(predicate: (a: A) => boolean, l: List<A>): boolean;
export declare const any: typeof some;
export declare function none<A>(predicate: (a: A) => boolean, l: List<A>): boolean;
export declare function find<A>(predicate: (a: A) => boolean, l: List<A>): A | undefined;
export declare function findLast<A>(predicate: (a: A) => boolean, l: List<A>): A | undefined;
export declare function indexOf<A>(element: A, l: List<A>): number;
export declare function lastIndexOf<A>(element: A, l: List<A>): number;
export declare function findIndex<A>(predicate: (a: A) => boolean, l: List<A>): number;
export declare function includes<A>(element: A, l: List<A>): boolean;
export declare const contains: typeof includes;
export declare function equals<A>(l1: List<A>, l2: List<A>): boolean;
export declare function equalsWith<A>(f: (a: A, b: A) => boolean, l1: List<A>, l2: List<A>): boolean;
export declare function concat<A>(left: List<A>, right: List<A>): List<A>;
export declare function update<A>(index: number, a: A, l: List<A>): List<A>;
export declare function adjust<A>(index: number, f: (a: A) => A, l: List<A>): List<A>;
export declare function slice<A>(from: number, to: number, l: List<A>): List<A>;
export declare function take<A>(n: number, l: List<A>): List<A>;
export declare function takeWhile<A>(predicate: (a: A) => boolean, l: List<A>): List<A>;
export declare function takeLastWhile<A>(predicate: (a: A) => boolean, l: List<A>): List<A>;
export declare function dropWhile<A>(predicate: (a: A) => boolean, l: List<A>): List<A>;
export declare function dropRepeats<A>(l: List<A>): List<A>;
export declare function dropRepeatsWith<A>(predicate: (a: A, b: A) => Boolean, l: List<A>): List<A>;
export declare function takeLast<A>(n: number, l: List<A>): List<A>;
export declare function splitAt<A>(index: number, l: List<A>): [List<A>, List<A>];
export declare function splitWhen<A>(predicate: (a: A) => boolean, l: List<A>): [List<A>, List<A>];
export declare function splitEvery<A>(size: number, l: List<A>): List<List<A>>;
export declare function remove<A>(from: number, amount: number, l: List<A>): List<A>;
export declare function drop<A>(n: number, l: List<A>): List<A>;
export declare function dropLast<A>(n: number, l: List<A>): List<A>;
export declare function pop<A>(l: List<A>): List<A>;
export declare const init: typeof pop;
export declare function tail<A>(l: List<A>): List<A>;
export declare function toArray<A>(l: List<A>): A[];
export declare function insert<A>(index: number, element: A, l: List<A>): List<A>;
export declare function insertAll<A>(index: number, elements: List<A>, l: List<A>): List<A>;
export declare function reverse<A>(l: List<A>): List<A>;
export declare function isList<A>(l: any): l is List<A>;
export declare function zip<A, B>(as: List<A>, bs: List<B>): List<[A, B]>;
export declare function zipWith<A, B, C>(f: (a: A, b: B) => C, as: List<A>, bs: List<B>): List<C>;
export declare type Ordering = -1 | 0 | 1;
export interface Ord {
    "fantasy-land/lte"(b: any): boolean;
}
export declare type Comparable = number | string | Ord;
export declare function sort<A extends Comparable>(l: List<A>): List<A>;
export declare function sortWith<A>(comparator: (a: A, b: A) => Ordering, l: List<A>): List<A>;
export declare function sortBy<A, B extends Comparable>(f: (a: A) => B, l: List<A>): List<A>;
export declare function group<A>(l: List<A>): List<List<A>>;
export declare function groupWith<A>(f: (a: A, b: A) => boolean, l: List<A>): List<List<A>>;
export declare function intersperse<A>(separator: A, l: List<A>): List<A>;
export declare function isEmpty(l: List<any>): boolean;
