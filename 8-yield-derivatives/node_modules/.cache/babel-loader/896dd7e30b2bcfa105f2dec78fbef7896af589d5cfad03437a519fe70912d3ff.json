{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\nvar preludeTsContractViolationCb = function (msg) {\n  throw new Error(msg);\n};\n/**\n * Some programmatic errors are only detectable at runtime\n * (for instance trying to setup a <code>HashSet</code> of <code>Option&lt;number[]&gt;</code>: you\n * can't reliably compare a <code>number[]</code> therefore you can't compare\n * an <code>Option&lt;number[]&gt;</code>.. but we can't detect this error at compile-time\n * in typescript). So when we detect them at runtime, prelude-ts throws\n * an exception by default.\n * This function allows you to change that default action\n * (for instance, you could display an error message in the console,\n * or log the error)\n *\n * You can reproduce the issue easily by running for instance:\n *\n *  HashSet.of(Option.of([1]))\n *  => throws\n */\nfunction setContractViolationAction(action) {\n  preludeTsContractViolationCb = action;\n}\nexports.setContractViolationAction = setContractViolationAction;\n/**\n * @hidden\n */\nfunction reportContractViolation(msg) {\n  preludeTsContractViolationCb(msg);\n}\nexports.reportContractViolation = reportContractViolation;\n/**\n * @hidden\n */\nfunction contractTrueEquality(context) {\n  var vals = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    vals[_i - 1] = arguments[_i];\n  }\n  for (var _a = 0, vals_1 = vals; _a < vals_1.length; _a++) {\n    var val = vals_1[_a];\n    if (val) {\n      if (val.hasTrueEquality && !val.hasTrueEquality()) {\n        reportContractViolation(context + \": element doesn't support true equality: \" + SeqHelpers_1.toStringHelper(val));\n      }\n      if (!Comparison_1.hasTrueEquality(val).getOrThrow()) {\n        reportContractViolation(context + \": element doesn't support equality: \" + SeqHelpers_1.toStringHelper(val));\n      }\n      // the first element i find is looking good, aborting\n      return;\n    }\n  }\n}\nexports.contractTrueEquality = contractTrueEquality;","map":{"version":3,"names":["exports","__esModule","Comparison_1","require","SeqHelpers_1","preludeTsContractViolationCb","msg","Error","setContractViolationAction","action","reportContractViolation","contractTrueEquality","context","vals","_i","arguments","length","_a","vals_1","val","hasTrueEquality","toStringHelper","getOrThrow"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/dist/src/Contract.js"],"sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\nvar preludeTsContractViolationCb = function (msg) { throw new Error(msg); };\n/**\n * Some programmatic errors are only detectable at runtime\n * (for instance trying to setup a <code>HashSet</code> of <code>Option&lt;number[]&gt;</code>: you\n * can't reliably compare a <code>number[]</code> therefore you can't compare\n * an <code>Option&lt;number[]&gt;</code>.. but we can't detect this error at compile-time\n * in typescript). So when we detect them at runtime, prelude-ts throws\n * an exception by default.\n * This function allows you to change that default action\n * (for instance, you could display an error message in the console,\n * or log the error)\n *\n * You can reproduce the issue easily by running for instance:\n *\n *  HashSet.of(Option.of([1]))\n *  => throws\n */\nfunction setContractViolationAction(action) {\n    preludeTsContractViolationCb = action;\n}\nexports.setContractViolationAction = setContractViolationAction;\n/**\n * @hidden\n */\nfunction reportContractViolation(msg) {\n    preludeTsContractViolationCb(msg);\n}\nexports.reportContractViolation = reportContractViolation;\n/**\n * @hidden\n */\nfunction contractTrueEquality(context) {\n    var vals = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        vals[_i - 1] = arguments[_i];\n    }\n    for (var _a = 0, vals_1 = vals; _a < vals_1.length; _a++) {\n        var val = vals_1[_a];\n        if (val) {\n            if (val.hasTrueEquality && (!val.hasTrueEquality())) {\n                reportContractViolation(context + \": element doesn't support true equality: \" + SeqHelpers_1.toStringHelper(val));\n            }\n            if (!Comparison_1.hasTrueEquality(val).getOrThrow()) {\n                reportContractViolation(context + \": element doesn't support equality: \" + SeqHelpers_1.toStringHelper(val));\n            }\n            // the first element i find is looking good, aborting\n            return;\n        }\n    }\n}\nexports.contractTrueEquality = contractTrueEquality;\n//# sourceMappingURL=Contract.js.map"],"mappings":"AAAA,YAAY;;AACZA,OAAO,CAACC,UAAU,GAAG,IAAI;AACzB,IAAIC,YAAY,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC1C,IAAIC,YAAY,GAAGD,OAAO,CAAC,cAAc,CAAC;AAC1C,IAAIE,4BAA4B,GAAG,SAAAA,CAAUC,GAAG,EAAE;EAAE,MAAM,IAAIC,KAAK,CAACD,GAAG,CAAC;AAAE,CAAC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,0BAA0BA,CAACC,MAAM,EAAE;EACxCJ,4BAA4B,GAAGI,MAAM;AACzC;AACAT,OAAO,CAACQ,0BAA0B,GAAGA,0BAA0B;AAC/D;AACA;AACA;AACA,SAASE,uBAAuBA,CAACJ,GAAG,EAAE;EAClCD,4BAA4B,CAACC,GAAG,CAAC;AACrC;AACAN,OAAO,CAACU,uBAAuB,GAAGA,uBAAuB;AACzD;AACA;AACA;AACA,SAASC,oBAAoBA,CAACC,OAAO,EAAE;EACnC,IAAIC,IAAI,GAAG,EAAE;EACb,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;IAC1CD,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;EAChC;EACA,KAAK,IAAIG,EAAE,GAAG,CAAC,EAAEC,MAAM,GAAGL,IAAI,EAAEI,EAAE,GAAGC,MAAM,CAACF,MAAM,EAAEC,EAAE,EAAE,EAAE;IACtD,IAAIE,GAAG,GAAGD,MAAM,CAACD,EAAE,CAAC;IACpB,IAAIE,GAAG,EAAE;MACL,IAAIA,GAAG,CAACC,eAAe,IAAK,CAACD,GAAG,CAACC,eAAe,CAAC,CAAE,EAAE;QACjDV,uBAAuB,CAACE,OAAO,GAAG,2CAA2C,GAAGR,YAAY,CAACiB,cAAc,CAACF,GAAG,CAAC,CAAC;MACrH;MACA,IAAI,CAACjB,YAAY,CAACkB,eAAe,CAACD,GAAG,CAAC,CAACG,UAAU,CAAC,CAAC,EAAE;QACjDZ,uBAAuB,CAACE,OAAO,GAAG,sCAAsC,GAAGR,YAAY,CAACiB,cAAc,CAACF,GAAG,CAAC,CAAC;MAChH;MACA;MACA;IACJ;EACJ;AACJ;AACAnB,OAAO,CAACW,oBAAoB,GAAGA,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}