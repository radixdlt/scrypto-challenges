{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n/**\n * A lazy, potentially infinite, sequence of values.\n *\n * The code is organized through the class [[EmptyStream]] (empty list\n * or tail), the class [[ConsStream]] (list value and lazy pointer to next),\n * and the type alias [[Stream]] (empty or cons).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[StreamStatic]] and are accessed through the global constant Stream.\n *\n * Use take() for instance to reduce an infinite stream to a finite one.\n *\n * Examples:\n *\n *     Stream.iterate(1, x => x*2).take(4);\n *     => Stream.of(1,2,4,8)\n *\n *     Stream.continually(Math.random).take(2);\n *     => Stream.of(0.49884723907769635, 0.3226548779864311)\n */\nvar Option_1 = require(\"./Option\");\nvar Vector_1 = require(\"./Vector\");\nvar Comparison_1 = require(\"./Comparison\");\nvar Contract_1 = require(\"./Contract\");\nvar Value_1 = require(\"./Value\");\nvar HashMap_1 = require(\"./HashMap\");\nvar HashSet_1 = require(\"./HashSet\");\nvar Lazy_1 = require(\"./Lazy\");\nvar LinkedList_1 = require(\"./LinkedList\");\nvar SeqHelpers = require(\"./SeqHelpers\");\n/**\n * Holds the \"static methods\" for [[Stream]]\n */\nvar StreamStatic = /** @class */function () {\n  function StreamStatic() {}\n  /**\n   * The empty stream\n   */\n  StreamStatic.prototype.empty = function () {\n    return emptyStream;\n  };\n  StreamStatic.prototype.of = function () {\n    var elts = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      elts[_i] = arguments[_i];\n    }\n    return exports.Stream.ofIterable(elts);\n  };\n  /**\n   * Build a stream from any iterable, which means also\n   * an array for instance.\n   * @param T the item type\n   */\n  StreamStatic.prototype.ofIterable = function (elts) {\n    // need to eagerly copy the iterable. the reason\n    // is, if we would build the stream based on the iterator\n    // in the iterable, Stream.tail() would do it.next().\n    // but it.next() modifies the iterator (mutability),\n    // and you would end up with getting two different tails\n    // for the same stream if you call .tail() twice in a row\n    if (Array.isArray(elts)) {\n      return exports.Stream.ofArray(elts);\n    }\n    return exports.Stream.ofArray(Array.from(elts));\n  };\n  /**\n   * Curried type guard for Stream.\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Stream.of(1), Stream.empty<number>())\n   *         .filter(Stream.isEmpty)\n   *     => Vector.of(Stream.empty<number>())\n   */\n  StreamStatic.prototype.isEmpty = function (s) {\n    return s.isEmpty();\n  };\n  /**\n   * Curried type guard for Stream.\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Stream.of(1), Stream.empty<number>())\n   *         .filter(Stream.isNotEmpty)\n   *         .map(s => s.head().get()+1)\n   *     => Vector.of(2)\n   */\n  StreamStatic.prototype.isNotEmpty = function (s) {\n    return !s.isEmpty();\n  };\n  /**\n   * @hidden\n   */\n  StreamStatic.prototype.ofArray = function (elts) {\n    if (elts.length === 0) {\n      return emptyStream;\n    }\n    var head = elts[0];\n    return new ConsStream(head, Lazy_1.Lazy.of(function () {\n      return exports.Stream.ofArray(elts.slice(1));\n    }));\n  };\n  /**\n   * Build an infinite stream from a seed and a transformation function.\n   *\n   *     Stream.iterate(1, x => x*2).take(4);\n   *     => Stream.of(1,2,4,8)\n   */\n  StreamStatic.prototype.iterate = function (seed, fn) {\n    return new ConsStream(seed, Lazy_1.Lazy.of(function () {\n      return exports.Stream.iterate(fn(seed), fn);\n    }));\n  };\n  /**\n   * Build an infinite stream by calling repeatedly a function.\n   *\n   *     Stream.continually(() => 1).take(4);\n   *     => Stream.of(1,1,1,1)\n   *\n   *     Stream.continually(Math.random).take(2);\n   *     => Stream.of(0.49884723907769635, 0.3226548779864311)\n   */\n  StreamStatic.prototype.continually = function (fn) {\n    return new ConsStream(fn(), Lazy_1.Lazy.of(function () {\n      return exports.Stream.continually(fn);\n    }));\n  };\n  /**\n   * Dual to the foldRight function. Build a collection from a seed.\n   * Takes a starting element and a function.\n   * It applies the function on the starting element; if the\n   * function returns None, it stops building the list, if it\n   * returns Some of a pair, it adds the first element to the result\n   * and takes the second element as a seed to keep going.\n   *\n   *     Stream.unfoldRight(\n   *          10, x=>Option.of(x)\n   *              .filter(x => x!==0)\n   *              .map<[number,number]>(x => [x,x-1]));\n   *     => Stream.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n   */\n  StreamStatic.prototype.unfoldRight = function (seed, fn) {\n    var nextVal = fn(seed);\n    if (nextVal.isNone()) {\n      return emptyStream;\n    }\n    return new ConsStream(nextVal.get()[0], Lazy_1.Lazy.of(function () {\n      return exports.Stream.unfoldRight(nextVal.getOrThrow()[1], fn);\n    }));\n  };\n  /**\n   * Combine any number of iterables you give in as\n   * parameters to produce a new collection which combines all,\n   * in tuples. For instance:\n   *\n   *     Stream.zip(Stream.of(1,2,3), [\"a\",\"b\",\"c\"], LinkedList.of(8,9,10))\n   *     => Stream.of([1,\"a\",8], [2,\"b\",9], [3,\"c\",10])\n   *\n   * The result collection will have the length of the shorter\n   * of the input iterables. Extra elements will be discarded.\n   *\n   * Also see the non-static version [[ConsStream.zip]], which only combines two\n   * collections.\n   * @param A A is the type of the tuple that'll be generated\n   *          (`[number,string,number]` for the code sample)\n   */\n  StreamStatic.prototype.zip = function () {\n    var iterables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      iterables[_i] = arguments[_i];\n    }\n    var iterators = iterables.map(function (i) {\n      return i[Symbol.iterator]();\n    });\n    var items = iterators.map(function (i) {\n      return i.next();\n    });\n    if (items.some(function (item) {\n      return item.done;\n    })) {\n      return emptyStream;\n    }\n    return new ConsStream(items.map(function (item) {\n      return item.value;\n    }), Lazy_1.Lazy.of(function () {\n      return exports.Stream.zip.apply(exports.Stream, iterators.map(function (i) {\n        var _a;\n        return _a = {}, _a[Symbol.iterator] = function () {\n          return i;\n        }, _a;\n      }));\n    }));\n  };\n  return StreamStatic;\n}();\nexports.StreamStatic = StreamStatic;\n/**\n * The Stream constant allows to call the Stream \"static\" methods\n */\nexports.Stream = new StreamStatic();\n/**\n * EmptyStream is the empty stream; every non-empty\n * stream also has a pointer to an empty stream\n * after its last element.\n * \"static methods\" available through [[StreamStatic]]\n * @param T the item type\n */\nvar EmptyStream = /** @class */function () {\n  function EmptyStream() {\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * Implementation of the Iterator interface.\n   */\n  EmptyStream.prototype[Symbol.iterator] = function () {\n    return {\n      next: function () {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  };\n  /**\n   * View this Some a as Stream. Useful to help typescript type\n   * inference sometimes.\n   */\n  EmptyStream.prototype.asStream = function () {\n    return this;\n  };\n  /**\n   * @hidden\n   */\n  EmptyStream.prototype.hasTrueEquality = function () {\n    return SeqHelpers.seqHasTrueEquality(this);\n  };\n  /**\n   * Get the length of the collection.\n   */\n  EmptyStream.prototype.length = function () {\n    return 0;\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  EmptyStream.prototype.single = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * true if the collection is empty, false otherwise.\n   */\n  EmptyStream.prototype.isEmpty = function () {\n    return true;\n  };\n  /**\n   * Get the first value of the collection, if any.\n   * returns Option.Some if the collection is not empty,\n   * Option.None if it's empty.\n   */\n  EmptyStream.prototype.head = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * Get all the elements in the collection but the first one.\n   * If the collection is empty, return None.\n   */\n  EmptyStream.prototype.tail = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * Get the last value of the collection, if any.\n   * returns Option.Some if the collection is not empty,\n   * Option.None if it's empty.\n   */\n  EmptyStream.prototype.last = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * Retrieve the element at index idx.\n   * Returns an option because the collection may\n   * contain less elements than the index.\n   *\n   * Careful this is going to have poor performance\n   * on Stream, which is not a good data structure\n   * for random access!\n   */\n  EmptyStream.prototype.get = function (idx) {\n    return Option_1.Option.none();\n  };\n  /**\n   * Search for an item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   */\n  EmptyStream.prototype.find = function (predicate) {\n    return Option_1.Option.none();\n  };\n  /**\n   * Returns true if the item is in the collection,\n   * false otherwise.\n   */\n  EmptyStream.prototype.contains = function (v) {\n    return false;\n  };\n  /**\n   * Return a new stream keeping only the first n elements\n   * from this stream.\n   */\n  EmptyStream.prototype.take = function (n) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate.\n   */\n  EmptyStream.prototype.takeWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate,\n   * but starting from the end of the collection.\n   *\n   *     Stream.of(1,2,3,4).takeRightWhile(x => x > 2)\n   *     => Stream.of(3,4)\n   */\n  EmptyStream.prototype.takeRightWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection with the first\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  EmptyStream.prototype.drop = function (n) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the first elements\n   * until one element fails the predicate. All elements\n   * after that point are retained.\n   */\n  EmptyStream.prototype.dropWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection with the last\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  EmptyStream.prototype.dropRight = function (n) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the last elements\n   * until one element fails the predicate. All elements\n   * before that point are retained.\n   */\n  EmptyStream.prototype.dropRightWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Reduces the collection to a single value using the\n   * associative binary function you give. Since the function\n   * is associative, order of application doesn't matter.\n   *\n   * Example:\n   *\n   *     Stream.of(1,2,3).fold(0, (a,b) => a + b);\n   *     => 6\n   */\n  EmptyStream.prototype.fold = function (zero, fn) {\n    return zero;\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Left-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n   *     => \"cba!\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the previous value and\n   *           the current collection item, and returning\n   *           an updated value.\n   */\n  EmptyStream.prototype.foldLeft = function (zero, fn) {\n    return zero;\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Right-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n   *     => \"!cba\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the current collection item and\n   *           the previous value , and returning\n   *           an updated value.\n   */\n  EmptyStream.prototype.foldRight = function (zero, fn) {\n    return zero;\n  };\n  /**\n   * Combine this collection with the collection you give in\n   * parameter to produce a new collection which combines both,\n   * in pairs. For instance:\n   *\n   *     Stream.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n   *     => Stream.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n   *\n   * The result collection will have the length of the shorter\n   * of both collections. Extra elements will be discarded.\n   *\n   * Also see [[StreamStatic.zip]] (static version which can more than two\n   * iterables)\n   */\n  EmptyStream.prototype.zip = function (other) {\n    return emptyStream;\n  };\n  /**\n   * Combine this collection with the index of the elements\n   * in it. Handy if you need the index when you map on\n   * the collection for instance:\n   *\n   *     Stream.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n   *     => Stream.of(\"a0\", \"b1\")\n   */\n  EmptyStream.prototype.zipWithIndex = function () {\n    return SeqHelpers.zipWithIndex(this);\n  };\n  /**\n   * Reverse the collection. For instance:\n   *\n   *     Stream.of(1,2,3).reverse();\n   *     => Stream.of(3,2,1)\n   */\n  EmptyStream.prototype.reverse = function () {\n    return this;\n  };\n  /**\n   * Takes a predicate; returns a pair of collections.\n   * The first one is the longest prefix of this collection\n   * which satisfies the predicate, and the second collection\n   * is the remainder of the collection.\n   *\n   *    Stream.of(1,2,3,4,5,6).span(x => x <3)\n   *    => [Stream.of(1,2), Stream.of(3,4,5,6)]\n   */\n  EmptyStream.prototype.span = function (predicate) {\n    return [this, this];\n  };\n  /**\n   * Split the collection at a specific index.\n   *\n   *     Stream.of(1,2,3,4,5).splitAt(3)\n   *     => [Stream.of(1,2,3), Stream.of(4,5)]\n   */\n  EmptyStream.prototype.splitAt = function (index) {\n    return [this, this];\n  };\n  EmptyStream.prototype.partition = function (predicate) {\n    return [exports.Stream.empty(), exports.Stream.empty()];\n  };\n  /**\n   * Group elements in the collection using a classifier function.\n   * Elements are then organized in a map. The key is the value of\n   * the classifier, and in value we get the list of elements\n   * matching that value.\n   *\n   * also see [[ConsStream.arrangeBy]]\n   */\n  EmptyStream.prototype.groupBy = function (classifier) {\n    return HashMap_1.HashMap.empty();\n  };\n  /**\n   * Matches each element with a unique key that you extract from it.\n   * If the same key is present twice, the function will return None.\n   *\n   * also see [[ConsStream.groupBy]]\n   */\n  EmptyStream.prototype.arrangeBy = function (getKey) {\n    return SeqHelpers.arrangeBy(this, getKey);\n  };\n  /**\n   * Randomly reorder the elements of the collection.\n   */\n  EmptyStream.prototype.shuffle = function () {\n    return exports.Stream.ofIterable(SeqHelpers.shuffle(this.toArray()));\n  };\n  /**\n   * Append an element at the end of this Stream.\n   */\n  EmptyStream.prototype.append = function (v) {\n    return exports.Stream.of(v);\n  };\n  /*\n   * Append multiple elements at the end of this Stream.\n   */\n  EmptyStream.prototype.appendAll = function (elts) {\n    return exports.Stream.ofIterable(elts);\n  };\n  /**\n   * Remove multiple elements from a stream\n   *\n   *     Stream.of(1,2,3,4,3,2,1).removeAll([2,4])\n   *     => Stream.of(1,3,3,1)\n   */\n  EmptyStream.prototype.removeAll = function (elts) {\n    return this;\n  };\n  /**\n   * Removes the first element matching the predicate\n   * (use [[ConsStream.filter]] to remove all elements matching a predicate)\n   */\n  EmptyStream.prototype.removeFirst = function (predicate) {\n    return this;\n  };\n  /*\n   * Append another Stream at the end of this Stream.\n   *\n   * There is no function taking a javascript iterator,\n   * because iterators are stateful and Streams lazy.\n   * If we would create two Streams working on the same iterator,\n   * the streams would interact with one another.\n   * It also breaks the cycle() function.\n   */\n  EmptyStream.prototype.appendStream = function (elts) {\n    return elts;\n  };\n  /**\n   * Prepend an element at the beginning of the collection.\n   */\n  EmptyStream.prototype.prepend = function (elt) {\n    return exports.Stream.of(elt);\n  };\n  /**\n   * Prepend multiple elements at the beginning of the collection.\n   */\n  EmptyStream.prototype.prependAll = function (elt) {\n    return exports.Stream.ofIterable(elt);\n  };\n  /**\n   * Repeat infinitely this Stream.\n   * For instance:\n   *\n   *     Stream.of(1,2,3).cycle().take(8)\n   *     => Stream.of(1,2,3,1,2,3,1,2)\n   */\n  EmptyStream.prototype.cycle = function () {\n    return emptyStream;\n  };\n  /**\n   * Return a new collection where each element was transformed\n   * by the mapper function you give.\n   */\n  EmptyStream.prototype.map = function (mapper) {\n    return emptyStream;\n  };\n  /**\n   * Apply the mapper function on every element of this collection.\n   * The mapper function returns an Option; if the Option is a Some,\n   * the value it contains is added to the result Collection, if it's\n   * a None, the value is discarded.\n   *\n   *     Stream.of(1,2,6).mapOption(x => x%2===0 ?\n   *         Option.of(x+1) : Option.none<number>())\n   *     => Stream.of(3, 7)\n   */\n  EmptyStream.prototype.mapOption = function (mapper) {\n    return emptyStream;\n  };\n  /**\n   * Calls the function you give for each item in the collection,\n   * your function returns a collection, all the collections are\n   * concatenated.\n   * This is the monadic bind.\n   */\n  EmptyStream.prototype.flatMap = function (mapper) {\n    return emptyStream;\n  };\n  EmptyStream.prototype.allMatch = function (predicate) {\n    return true;\n  };\n  /**\n   * Returns true if there the predicate returns true for any\n   * element in the collection.\n   */\n  EmptyStream.prototype.anyMatch = function (predicate) {\n    return false;\n  };\n  EmptyStream.prototype.filter = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection with elements\n   * sorted according to the comparator you give.\n   *\n   *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n   *     Stream.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n   *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n   *     => Stream.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n   *\n   * also see [[ConsStream.sortOn]]\n   */\n  EmptyStream.prototype.sortBy = function (compare) {\n    return this;\n  };\n  /**\n   * Give a function associating a number or a string with\n   * elements from the collection, and the elements\n   * are sorted according to that value.\n   *\n   *     Stream.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n   *     => Stream.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n   *\n   * You can also sort by multiple criteria, and request 'descending'\n   * sorting:\n   *\n   *     Stream.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n   *     => Stream.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n   *\n   * also see [[ConsStream.sortBy]]\n   */\n  EmptyStream.prototype.sortOn = function () {\n    var getKeys = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      getKeys[_i] = arguments[_i];\n    }\n    return this;\n  };\n  /**\n   * Remove duplicate items; elements are mapped to keys, those\n   * get compared.\n   *\n   *     Stream.of(1,1,2,3,2,3,1).distinctBy(x => x);\n   *     => Stream.of(1,2,3)\n   */\n  EmptyStream.prototype.distinctBy = function (keyExtractor) {\n    return this;\n  };\n  /**\n   * Call a function for element in the collection.\n   */\n  EmptyStream.prototype.forEach = function (fn) {\n    return this;\n  };\n  /**\n   * Reduces the collection to a single value by repeatedly\n   * calling the combine function.\n   * No starting value. The order in which the elements are\n   * passed to the combining function is undetermined.\n   */\n  EmptyStream.prototype.reduce = function (combine) {\n    return SeqHelpers.reduce(this, combine);\n  };\n  /**\n   * Compare values in the collection and return the smallest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsStream.minOn]]\n   */\n  EmptyStream.prototype.minBy = function (compare) {\n    return Option_1.Option.none();\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the smallest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     Stream.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n   *     => Option.of({name:\"Paula\", age:6})\n   *\n   * also see [[ConsStream.minBy]]\n   */\n  EmptyStream.prototype.minOn = function (getOrderable) {\n    return Option_1.Option.none();\n  };\n  /**\n   * Compare values in the collection and return the largest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsStream.maxOn]]\n   */\n  EmptyStream.prototype.maxBy = function (compare) {\n    return Option_1.Option.none();\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the largest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     Stream.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n   *     => Option.of({name:\"Joe\", age:12})\n   *\n   * also see [[ConsStream.maxBy]]\n   */\n  EmptyStream.prototype.maxOn = function (getOrderable) {\n    return Option_1.Option.none();\n  };\n  /**\n   * Call the function you give for each element in the collection\n   * and sum all the numbers, return that sum.\n   * Will return 0 if the collection is empty.\n   *\n   *     Stream.of(1,2,3).sumOn(x=>x)\n   *     => 6\n   */\n  EmptyStream.prototype.sumOn = function (getNumber) {\n    return 0;\n  };\n  /**\n   * Slides a window of a specific size over the sequence.\n   * Returns a lazy stream so memory use is not prohibitive.\n   *\n   *     Stream.of(1,2,3,4,5,6,7,8).sliding(3)\n   *     => Stream.of(Stream.of(1,2,3), Stream.of(4,5,6), Stream.of(7,8))\n   */\n  EmptyStream.prototype.sliding = function (count) {\n    return SeqHelpers.sliding(this, count);\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   *\n   *     Stream.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n   *     => Stream.of(0,1,3,6)\n   */\n  EmptyStream.prototype.scanLeft = function (init, fn) {\n    return new ConsStream(init, Lazy_1.Lazy.of(function () {\n      return emptyStream;\n    }));\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   * The first element of the result is the final cumulative result.\n   *\n   *     Stream.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n   *     => Stream.of(6,5,3,0)\n   */\n  EmptyStream.prototype.scanRight = function (init, fn) {\n    return new ConsStream(init, Lazy_1.Lazy.of(function () {\n      return emptyStream;\n    }));\n  };\n  /**\n   * Joins elements of the collection by a separator.\n   * Example:\n   *\n   *     Vector.of(1,2,3).mkString(\", \")\n   *     => \"1, 2, 3\"\n   */\n  EmptyStream.prototype.mkString = function (separator) {\n    return \"\";\n  };\n  /**\n   * Convert to array.\n   * Don't do it on an infinite stream!\n   */\n  EmptyStream.prototype.toArray = function () {\n    return [];\n  };\n  /**\n   * Convert to vector.\n   * Don't do it on an infinite stream!\n   */\n  EmptyStream.prototype.toVector = function () {\n    return Vector_1.Vector.empty();\n  };\n  /**\n   * Convert this collection to a map. You give a function which\n   * for each element in the collection returns a pair. The\n   * key of the pair will be used as a key in the map, the value,\n   * as a value in the map. If several values get the same key,\n   * entries will be lost.\n   *\n   *     Stream.of(1,2,3).toMap(x=>[x.toString(), x])\n   *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n   */\n  EmptyStream.prototype.toMap = function (converter) {\n    return HashMap_1.HashMap.empty();\n  };\n  /**\n   * Convert this collection to a set. Since the elements of the\n   * Seq may not support equality, you must pass a function returning\n   * a value supporting equality.\n   *\n   *     Stream.of(1,2,3,3,4).toSet(x=>x)\n   *     => HashSet.of(1,2,3,4)\n   */\n  EmptyStream.prototype.toSet = function (converter) {\n    return HashSet_1.HashSet.empty();\n  };\n  /**\n   * Convert this collection to a list.\n   */\n  EmptyStream.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.ofIterable(this);\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  EmptyStream.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  EmptyStream.prototype.equals = function (other) {\n    if (!other) {\n      return false;\n    }\n    return other.isEmpty();\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  EmptyStream.prototype.hashCode = function () {\n    return 1;\n  };\n  EmptyStream.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   *\n   * Also see [[ConsStream.mkString]]\n   */\n  EmptyStream.prototype.toString = function () {\n    return \"[]\";\n  };\n  return EmptyStream;\n}();\nexports.EmptyStream = EmptyStream;\n/**\n * ConsStream holds a value and a lazy pointer to a next element,\n * which could be [[ConsStream]] or [[EmptyStream]].\n * A ConsStream is basically a non-empty stream. It will\n * contain at least one element.\n * \"static methods\" available through [[StreamStatic]]\n * @param T the item type\n */\nvar ConsStream = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function ConsStream(value, _tail) {\n    this.value = value;\n    this._tail = _tail;\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * Implementation of the Iterator interface.\n   */\n  ConsStream.prototype[Symbol.iterator] = function () {\n    var item = this;\n    return {\n      next: function () {\n        if (item.isEmpty()) {\n          return {\n            done: true,\n            value: undefined\n          };\n        }\n        var value = item.head().get();\n        item = item.tail().get();\n        return {\n          done: false,\n          value: value\n        };\n      }\n    };\n  };\n  /**\n   * View this Some a as Stream. Useful to help typescript type\n   * inference sometimes.\n   */\n  ConsStream.prototype.asStream = function () {\n    return this;\n  };\n  /**\n   * @hidden\n   */\n  ConsStream.prototype.hasTrueEquality = function () {\n    return SeqHelpers.seqHasTrueEquality(this);\n  };\n  /**\n   * Get the length of the collection.\n   */\n  ConsStream.prototype.length = function () {\n    return this.foldLeft(0, function (n, ignored) {\n      return n + 1;\n    });\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  ConsStream.prototype.single = function () {\n    return this._tail.get().isEmpty() ? Option_1.Option.of(this.value) : Option_1.Option.none();\n  };\n  /**\n   * true if the collection is empty, false otherwise.\n   */\n  ConsStream.prototype.isEmpty = function () {\n    return false;\n  };\n  /**\n   * Get the first value of the collection, if any.\n   * returns Option.Some if the collection is not empty,\n   * Option.None if it's empty.\n   */\n  ConsStream.prototype.head = function () {\n    return Option_1.Option.some(this.value);\n  };\n  /**\n   * Get all the elements in the collection but the first one.\n   * If the collection is empty, return None.\n   */\n  ConsStream.prototype.tail = function () {\n    return Option_1.Option.some(this._tail.get());\n  };\n  /**\n   * Get the last value of the collection, if any.\n   * returns Option.Some if the collection is not empty,\n   * Option.None if it's empty.\n   */\n  ConsStream.prototype.last = function () {\n    var curItem = this;\n    while (true) {\n      var item = curItem.value;\n      curItem = curItem._tail.get();\n      if (curItem.isEmpty()) {\n        return Option_1.Option.some(item);\n      }\n    }\n  };\n  /**\n   * Retrieve the element at index idx.\n   * Returns an option because the collection may\n   * contain less elements than the index.\n   *\n   * Careful this is going to have poor performance\n   * on Stream, which is not a good data structure\n   * for random access!\n   */\n  ConsStream.prototype.get = function (idx) {\n    var curItem = this;\n    var i = 0;\n    while (!curItem.isEmpty()) {\n      if (i === idx) {\n        var item = curItem.value;\n        return Option_1.Option.of(item);\n      }\n      curItem = curItem._tail.get();\n      ++i;\n    }\n    return Option_1.Option.none();\n  };\n  /**\n   * Search for an item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   */\n  ConsStream.prototype.find = function (predicate) {\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      var item = curItem.value;\n      if (predicate(item)) {\n        return Option_1.Option.of(item);\n      }\n      curItem = curItem._tail.get();\n    }\n    return Option_1.Option.none();\n  };\n  /**\n   * Returns true if the item is in the collection,\n   * false otherwise.\n   */\n  ConsStream.prototype.contains = function (v) {\n    return this.find(function (x) {\n      return Comparison_1.areEqual(x, v);\n    }).isSome();\n  };\n  /**\n   * Return a new stream keeping only the first n elements\n   * from this stream.\n   */\n  ConsStream.prototype.take = function (n) {\n    var _this = this;\n    if (n < 1) {\n      return emptyStream;\n    }\n    return new ConsStream(this.value, Lazy_1.Lazy.of(function () {\n      return _this._tail.get().take(n - 1);\n    }));\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate.\n   */\n  ConsStream.prototype.takeWhile = function (predicate) {\n    var _this = this;\n    if (!predicate(this.value)) {\n      return emptyStream;\n    }\n    return new ConsStream(this.value, Lazy_1.Lazy.of(function () {\n      return _this._tail.get().takeWhile(predicate);\n    }));\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate,\n   * but starting from the end of the collection.\n   *\n   *     Stream.of(1,2,3,4).takeRightWhile(x => x > 2)\n   *     => Stream.of(3,4)\n   */\n  ConsStream.prototype.takeRightWhile = function (predicate) {\n    return this.reverse().takeWhile(predicate).reverse();\n  };\n  /**\n   * Returns a new collection with the first\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  ConsStream.prototype.drop = function (n) {\n    var i = n;\n    var curItem = this;\n    while (i-- > 0 && !curItem.isEmpty()) {\n      curItem = curItem._tail.get();\n    }\n    return curItem;\n  };\n  /**\n   * Returns a new collection, discarding the first elements\n   * until one element fails the predicate. All elements\n   * after that point are retained.\n   */\n  ConsStream.prototype.dropWhile = function (predicate) {\n    var curItem = this;\n    while (!curItem.isEmpty() && predicate(curItem.value)) {\n      curItem = curItem._tail.get();\n    }\n    return curItem;\n  };\n  /**\n   * Returns a new collection with the last\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  ConsStream.prototype.dropRight = function (n) {\n    // going twice through the list...\n    var length = this.length();\n    return this.take(length - n);\n  };\n  /**\n   * Returns a new collection, discarding the last elements\n   * until one element fails the predicate. All elements\n   * before that point are retained.\n   */\n  ConsStream.prototype.dropRightWhile = function (predicate) {\n    return this.reverse().dropWhile(predicate).reverse();\n  };\n  /**\n   * Reduces the collection to a single value using the\n   * associative binary function you give. Since the function\n   * is associative, order of application doesn't matter.\n   *\n   * Example:\n   *\n   *     Stream.of(1,2,3).fold(0, (a,b) => a + b);\n   *     => 6\n   */\n  ConsStream.prototype.fold = function (zero, fn) {\n    return this.foldLeft(zero, fn);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Left-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n   *     => \"cba!\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the previous value and\n   *           the current collection item, and returning\n   *           an updated value.\n   */\n  ConsStream.prototype.foldLeft = function (zero, fn) {\n    var r = zero;\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      r = fn(r, curItem.value);\n      curItem = curItem._tail.get();\n    }\n    return r;\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Right-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n   *     => \"!cba\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the current collection item and\n   *           the previous value , and returning\n   *           an updated value.\n   */\n  ConsStream.prototype.foldRight = function (zero, fn) {\n    return this.reverse().foldLeft(zero, function (xs, x) {\n      return fn(x, xs);\n    });\n  };\n  /**\n   * Combine this collection with the collection you give in\n   * parameter to produce a new collection which combines both,\n   * in pairs. For instance:\n   *\n   *     Stream.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n   *     => Stream.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n   *\n   * The result collection will have the length of the shorter\n   * of both collections. Extra elements will be discarded.\n   *\n   * Also see [[StreamStatic.zip]] (static version which can more than two\n   * iterables)\n   */\n  ConsStream.prototype.zip = function (other) {\n    var _this = this;\n    var otherIterator = other[Symbol.iterator]();\n    var otherCurItem = otherIterator.next();\n    if (this.isEmpty() || otherCurItem.done) {\n      return emptyStream;\n    }\n    return new ConsStream([this.value, otherCurItem.value], Lazy_1.Lazy.of(function () {\n      var _a;\n      return _this._tail.get().zip((_a = {}, _a[Symbol.iterator] = function () {\n        return otherIterator;\n      }, _a));\n    }));\n  };\n  /**\n   * Combine this collection with the index of the elements\n   * in it. Handy if you need the index when you map on\n   * the collection for instance:\n   *\n   *     Stream.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n   *     => Stream.of(\"a0\", \"b1\")\n   */\n  ConsStream.prototype.zipWithIndex = function () {\n    return SeqHelpers.zipWithIndex(this);\n  };\n  /**\n   * Reverse the collection. For instance:\n   *\n   *     Stream.of(1,2,3).reverse();\n   *     => Stream.of(3,2,1)\n   */\n  ConsStream.prototype.reverse = function () {\n    return this.foldLeft(emptyStream, function (xs, x) {\n      return xs.prepend(x);\n    });\n  };\n  /**\n   * Takes a predicate; returns a pair of collections.\n   * The first one is the longest prefix of this collection\n   * which satisfies the predicate, and the second collection\n   * is the remainder of the collection.\n   *\n   *    Stream.of(1,2,3,4,5,6).span(x => x <3)\n   *    => [Stream.of(1,2), Stream.of(3,4,5,6)]\n   */\n  ConsStream.prototype.span = function (predicate) {\n    return [this.takeWhile(predicate), this.dropWhile(predicate)];\n  };\n  /**\n   * Split the collection at a specific index.\n   *\n   *     Stream.of(1,2,3,4,5).splitAt(3)\n   *     => [Stream.of(1,2,3), Stream.of(4,5)]\n   */\n  ConsStream.prototype.splitAt = function (index) {\n    return [this.take(index), this.drop(index)];\n  };\n  ConsStream.prototype.partition = function (predicate) {\n    // goes twice over the list, but since we want a lazy behavior...\n    return [this.filter(predicate), this.filter(function (x) {\n      return !predicate(x);\n    })];\n  };\n  /**\n   * Group elements in the collection using a classifier function.\n   * Elements are then organized in a map. The key is the value of\n   * the classifier, and in value we get the list of elements\n   * matching that value.\n   *\n   * also see [[ConsStream.arrangeBy]]\n   */\n  ConsStream.prototype.groupBy = function (classifier) {\n    return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, v) {\n      return acc.putWithMerge(classifier(v), exports.Stream.of(v), function (v1, v2) {\n        return v1.appendStream(v2);\n      });\n    });\n  };\n  /**\n   * Matches each element with a unique key that you extract from it.\n   * If the same key is present twice, the function will return None.\n   *\n   * also see [[ConsStream.groupBy]]\n   */\n  ConsStream.prototype.arrangeBy = function (getKey) {\n    return SeqHelpers.arrangeBy(this, getKey);\n  };\n  /**\n   * Randomly reorder the elements of the collection.\n   */\n  ConsStream.prototype.shuffle = function () {\n    return exports.Stream.ofIterable(SeqHelpers.shuffle(this.toArray()));\n  };\n  /**\n   * Append an element at the end of this Stream.\n   */\n  ConsStream.prototype.append = function (v) {\n    var tail = this._tail.get();\n    return new ConsStream(this.value, Lazy_1.Lazy.of(function () {\n      return tail.append(v);\n    }));\n  };\n  /*\n   * Append multiple elements at the end of this Stream.\n   */\n  ConsStream.prototype.appendAll = function (elts) {\n    return this.appendStream(exports.Stream.ofIterable(elts));\n  };\n  /**\n   * Remove multiple elements from a stream\n   *\n   *     Stream.of(1,2,3,4,3,2,1).removeAll([2,4])\n   *     => Stream.of(1,3,3,1)\n   */\n  ConsStream.prototype.removeAll = function (elts) {\n    return SeqHelpers.removeAll(this, elts);\n  };\n  /**\n   * Removes the first element matching the predicate\n   * (use [[ConsStream.filter]] to remove all elements matching a predicate)\n   */\n  ConsStream.prototype.removeFirst = function (predicate) {\n    var tail = this._tail.get();\n    return predicate(this.value) ? tail : new ConsStream(this.value, Lazy_1.Lazy.of(function () {\n      return tail.removeFirst(predicate);\n    }));\n  };\n  /*\n   * Append another Stream at the end of this Stream.\n   *\n   * There is no function taking a javascript iterator,\n   * because iterators are stateful and Streams lazy.\n   * If we would create two Streams working on the same iterator,\n   * the streams would interact with one another.\n   * It also breaks the cycle() function.\n   */\n  ConsStream.prototype.appendStream = function (elts) {\n    var tail = this._tail.get();\n    return new ConsStream(this.value, Lazy_1.Lazy.of(function () {\n      return tail.appendStream(elts);\n    }));\n  };\n  /**\n   * Prepend an element at the beginning of the collection.\n   */\n  ConsStream.prototype.prepend = function (elt) {\n    var _this = this;\n    return new ConsStream(elt, Lazy_1.Lazy.of(function () {\n      return _this;\n    }));\n  };\n  /**\n   * Prepend multiple elements at the beginning of the collection.\n   */\n  ConsStream.prototype.prependAll = function (elts) {\n    return exports.Stream.ofIterable(elts).appendAll(this);\n  };\n  /**\n   * Repeat infinitely this Stream.\n   * For instance:\n   *\n   *     Stream.of(1,2,3).cycle().take(8)\n   *     => Stream.of(1,2,3,1,2,3,1,2)\n   */\n  ConsStream.prototype.cycle = function () {\n    return this._cycle(this);\n  };\n  ConsStream.prototype._cycle = function (toRepeat) {\n    var tail = this._tail.get();\n    return new ConsStream(this.value, Lazy_1.Lazy.of(function () {\n      return tail.isEmpty() ? toRepeat.cycle() : tail._cycle(toRepeat);\n    }));\n  };\n  /**\n   * Return a new collection where each element was transformed\n   * by the mapper function you give.\n   */\n  ConsStream.prototype.map = function (mapper) {\n    var _this = this;\n    return new ConsStream(mapper(this.value), Lazy_1.Lazy.of(function () {\n      return _this._tail.get().map(mapper);\n    }));\n  };\n  /**\n   * Apply the mapper function on every element of this collection.\n   * The mapper function returns an Option; if the Option is a Some,\n   * the value it contains is added to the result Collection, if it's\n   * a None, the value is discarded.\n   *\n   *     Stream.of(1,2,6).mapOption(x => x%2===0 ?\n   *         Option.of(x+1) : Option.none<number>())\n   *     => Stream.of(3, 7)\n   */\n  ConsStream.prototype.mapOption = function (mapper) {\n    var _this = this;\n    var mapped = mapper(this.value);\n    return mapped.isSome() ? new ConsStream(mapped.get(), Lazy_1.Lazy.of(function () {\n      return _this._tail.get().mapOption(mapper);\n    })) : this._tail.get().mapOption(mapper);\n  };\n  /**\n   * Calls the function you give for each item in the collection,\n   * your function returns a collection, all the collections are\n   * concatenated.\n   * This is the monadic bind.\n   */\n  ConsStream.prototype.flatMap = function (mapper) {\n    return mapper(this.value).appendStream(this._tail.get().flatMap(mapper));\n  };\n  ConsStream.prototype.allMatch = function (predicate) {\n    return this.find(function (x) {\n      return !predicate(x);\n    }).isNone();\n  };\n  /**\n   * Returns true if there the predicate returns true for any\n   * element in the collection.\n   */\n  ConsStream.prototype.anyMatch = function (predicate) {\n    return this.find(predicate).isSome();\n  };\n  ConsStream.prototype.filter = function (predicate) {\n    var _this = this;\n    return predicate(this.value) ? new ConsStream(this.value, Lazy_1.Lazy.of(function () {\n      return _this._tail.get().filter(predicate);\n    })) : this._tail.get().filter(predicate);\n  };\n  /**\n   * Returns a new collection with elements\n   * sorted according to the comparator you give.\n   *\n   *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n   *     Stream.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n   *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n   *     => Stream.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n   *\n   * also see [[ConsStream.sortOn]]\n   */\n  ConsStream.prototype.sortBy = function (compare) {\n    return exports.Stream.ofIterable(this.toArray().sort(compare));\n  };\n  /**\n   * Give a function associating a number or a string with\n   * elements from the collection, and the elements\n   * are sorted according to that value.\n   *\n   *     Stream.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n   *     => Stream.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n   *\n   * You can also sort by multiple criteria, and request 'descending'\n   * sorting:\n   *\n   *     Stream.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n   *     => Stream.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n   *\n   * also see [[ConsStream.sortBy]]\n   */\n  ConsStream.prototype.sortOn = function () {\n    var getKeys = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      getKeys[_i] = arguments[_i];\n    }\n    return SeqHelpers.sortOn(this, getKeys);\n  };\n  /**\n   * Remove duplicate items; elements are mapped to keys, those\n   * get compared.\n   *\n   *     Stream.of(1,1,2,3,2,3,1).distinctBy(x => x);\n   *     => Stream.of(1,2,3)\n   */\n  ConsStream.prototype.distinctBy = function (keyExtractor) {\n    return SeqHelpers.distinctBy(this, keyExtractor);\n  };\n  /**\n   * Call a function for element in the collection.\n   */\n  ConsStream.prototype.forEach = function (fn) {\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      fn(curItem.value);\n      curItem = curItem._tail.get();\n    }\n    return this;\n  };\n  /**\n   * Reduces the collection to a single value by repeatedly\n   * calling the combine function.\n   * No starting value. The order in which the elements are\n   * passed to the combining function is undetermined.\n   */\n  ConsStream.prototype.reduce = function (combine) {\n    return SeqHelpers.reduce(this, combine);\n  };\n  /**\n   * Compare values in the collection and return the smallest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsStream.minOn]]\n   */\n  ConsStream.prototype.minBy = function (compare) {\n    return SeqHelpers.minBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the smallest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     Stream.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n   *     => Option.of({name:\"Paula\", age:6})\n   *\n   * also see [[ConsStream.minBy]]\n   */\n  ConsStream.prototype.minOn = function (getOrderable) {\n    return SeqHelpers.minOn(this, getOrderable);\n  };\n  /**\n   * Compare values in the collection and return the largest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsStream.maxOn]]\n   */\n  ConsStream.prototype.maxBy = function (compare) {\n    return SeqHelpers.maxBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the largest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     Stream.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n   *     => Option.of({name:\"Joe\", age:12})\n   *\n   * also see [[ConsStream.maxBy]]\n   */\n  ConsStream.prototype.maxOn = function (getOrderable) {\n    return SeqHelpers.maxOn(this, getOrderable);\n  };\n  /**\n   * Call the function you give for each element in the collection\n   * and sum all the numbers, return that sum.\n   * Will return 0 if the collection is empty.\n   *\n   *     Stream.of(1,2,3).sumOn(x=>x)\n   *     => 6\n   */\n  ConsStream.prototype.sumOn = function (getNumber) {\n    return SeqHelpers.sumOn(this, getNumber);\n  };\n  /**\n   * Slides a window of a specific size over the sequence.\n   * Returns a lazy stream so memory use is not prohibitive.\n   *\n   *     Stream.of(1,2,3,4,5,6,7,8).sliding(3)\n   *     => Stream.of(Stream.of(1,2,3), Stream.of(4,5,6), Stream.of(7,8))\n   */\n  ConsStream.prototype.sliding = function (count) {\n    return SeqHelpers.sliding(this, count);\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   *\n   *     Stream.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n   *     => Stream.of(0,1,3,6)\n   */\n  ConsStream.prototype.scanLeft = function (init, fn) {\n    var _this = this;\n    return new ConsStream(init, Lazy_1.Lazy.of(function () {\n      return _this._tail.get().scanLeft(fn(init, _this.value), fn);\n    }));\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   * The first element of the result is the final cumulative result.\n   *\n   *     Stream.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n   *     => Stream.of(6,5,3,0)\n   */\n  ConsStream.prototype.scanRight = function (init, fn) {\n    // can't be lazy\n    var fn2 = function (x, y) {\n      return fn(y, x);\n    };\n    return this.reverse().scanLeft(init, fn2).reverse();\n  };\n  /**\n   * Joins elements of the collection by a separator.\n   * Example:\n   *\n   *     Vector.of(1,2,3).mkString(\", \")\n   *     => \"1, 2, 3\"\n   */\n  ConsStream.prototype.mkString = function (separator) {\n    var r = \"\";\n    var curItem = this;\n    var isNotFirst = false;\n    while (!curItem.isEmpty()) {\n      if (isNotFirst) {\n        r += separator;\n      }\n      r += SeqHelpers.toStringHelper(curItem.value, {\n        quoteStrings: false\n      });\n      curItem = curItem._tail.get();\n      isNotFirst = true;\n    }\n    return r;\n  };\n  /**\n   * Convert to array.\n   * Don't do it on an infinite stream!\n   */\n  ConsStream.prototype.toArray = function () {\n    var r = [];\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      r.push(curItem.value);\n      curItem = curItem._tail.get();\n    }\n    return r;\n  };\n  /**\n   * Convert to vector.\n   * Don't do it on an infinite stream!\n   */\n  ConsStream.prototype.toVector = function () {\n    return Vector_1.Vector.ofIterable(this.toArray());\n  };\n  /**\n   * Convert this collection to a map. You give a function which\n   * for each element in the collection returns a pair. The\n   * key of the pair will be used as a key in the map, the value,\n   * as a value in the map. If several values get the same key,\n   * entries will be lost.\n   *\n   *     Stream.of(1,2,3).toMap(x=>[x.toString(), x])\n   *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n   */\n  ConsStream.prototype.toMap = function (converter) {\n    return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, cur) {\n      var converted = converter(cur);\n      return acc.put(converted[0], converted[1]);\n    });\n  };\n  /**\n   * Convert this collection to a set. Since the elements of the\n   * Seq may not support equality, you must pass a function returning\n   * a value supporting equality.\n   *\n   *     Stream.of(1,2,3,3,4).toSet(x=>x)\n   *     => HashSet.of(1,2,3,4)\n   */\n  ConsStream.prototype.toSet = function (converter) {\n    return this.foldLeft(HashSet_1.HashSet.empty(), function (acc, cur) {\n      return acc.add(converter(cur));\n    });\n  };\n  /**\n   * Convert this collection to a list.\n   */\n  ConsStream.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.ofIterable(this);\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  ConsStream.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  ConsStream.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || !other.tail) {\n      return false;\n    }\n    Contract_1.contractTrueEquality(\"Stream.equals\", this, other);\n    var myVal = this;\n    var hisVal = other;\n    while (true) {\n      if (myVal.isEmpty() !== hisVal.isEmpty()) {\n        return false;\n      }\n      if (myVal.isEmpty()) {\n        // they are both empty, end of the stream\n        return true;\n      }\n      var myHead = myVal.value;\n      var hisHead = hisVal.value;\n      if (myHead === undefined !== (hisHead === undefined)) {\n        return false;\n      }\n      if (myHead === undefined || hisHead === undefined) {\n        // they are both undefined, the || is for TS's flow analysis\n        // so he realizes none of them is undefined after this.\n        continue;\n      }\n      if (!Comparison_1.areEqual(myHead, hisHead)) {\n        return false;\n      }\n      myVal = myVal._tail.get();\n      hisVal = hisVal._tail.get();\n    }\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  ConsStream.prototype.hashCode = function () {\n    var hash = 1;\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      hash = 31 * hash + Comparison_1.getHashCode(curItem.value);\n      curItem = curItem._tail.get();\n    }\n    return hash;\n  };\n  ConsStream.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   *\n   * Also see [[ConsStream.mkString]]\n   */\n  ConsStream.prototype.toString = function () {\n    var curItem = this;\n    var result = \"Stream(\";\n    while (!curItem.isEmpty()) {\n      result += SeqHelpers.toStringHelper(curItem.value);\n      var tail = curItem._tail;\n      if (!tail.isEvaluated()) {\n        result += \", ?\";\n        break;\n      }\n      curItem = tail.get();\n      if (!curItem.isEmpty()) {\n        result += \", \";\n      }\n    }\n    return result + \")\";\n  };\n  return ConsStream;\n}();\nexports.ConsStream = ConsStream;\nvar emptyStream = new EmptyStream();","map":{"version":3,"names":["Option_1","require","Vector_1","Comparison_1","Contract_1","Value_1","HashMap_1","HashSet_1","Lazy_1","LinkedList_1","SeqHelpers","StreamStatic","prototype","empty","emptyStream","of","elts","_i","arguments","length","exports","Stream","ofIterable","Array","isArray","ofArray","from","isEmpty","s","isNotEmpty","head","ConsStream","Lazy","slice","iterate","seed","fn","continually","unfoldRight","nextVal","isNone","get","getOrThrow","zip","iterables","iterators","map","i","Symbol","iterator","items","next","some","item","done","value","apply","_a","EmptyStream","className","undefined","asStream","hasTrueEquality","seqHasTrueEquality","single","Option","none","tail","last","idx","find","predicate","contains","v","take","n","takeWhile","takeRightWhile","drop","dropWhile","dropRight","dropRightWhile","fold","zero","foldLeft","foldRight","other","zipWithIndex","reverse","span","splitAt","index","partition","groupBy","classifier","HashMap","arrangeBy","getKey","shuffle","toArray","append","appendAll","removeAll","removeFirst","appendStream","prepend","elt","prependAll","cycle","mapper","mapOption","flatMap","allMatch","anyMatch","filter","sortBy","compare","sortOn","getKeys","distinctBy","keyExtractor","forEach","reduce","combine","minBy","minOn","getOrderable","maxBy","maxOn","sumOn","getNumber","sliding","count","scanLeft","init","scanRight","mkString","separator","toVector","Vector","toMap","converter","toSet","HashSet","toLinkedList","LinkedList","transform","equals","hashCode","inspect","toString","_tail","ignored","curItem","x","areEqual","isSome","_this","r","xs","otherIterator","otherCurItem","acc","putWithMerge","v1","v2","_cycle","toRepeat","mapped","sort","fn2","y","isNotFirst","toStringHelper","quoteStrings","push","cur","converted","put","add","contractTrueEquality","myVal","hisVal","myHead","hisHead","hash","getHashCode","result","isEvaluated"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/Stream.ts"],"sourcesContent":["/**\n * A lazy, potentially infinite, sequence of values.\n *\n * The code is organized through the class [[EmptyStream]] (empty list\n * or tail), the class [[ConsStream]] (list value and lazy pointer to next),\n * and the type alias [[Stream]] (empty or cons).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[StreamStatic]] and are accessed through the global constant Stream.\n *\n * Use take() for instance to reduce an infinite stream to a finite one.\n *\n * Examples:\n *\n *     Stream.iterate(1, x => x*2).take(4);\n *     => Stream.of(1,2,4,8)\n *\n *     Stream.continually(Math.random).take(2);\n *     => Stream.of(0.49884723907769635, 0.3226548779864311)\n */\nimport { Option, Some } from \"./Option\";\nimport { Vector } from \"./Vector\";\nimport { WithEquality, getHashCode,\n         areEqual, Ordering, ToOrderable } from \"./Comparison\";\nimport { contractTrueEquality } from \"./Contract\";\nimport { inspect } from \"./Value\";\nimport { HashMap } from \"./HashMap\";\nimport { HashSet } from \"./HashSet\";\nimport { Seq, IterableArray } from \"./Seq\";\nimport { Lazy } from \"./Lazy\";\nimport { LinkedList } from \"./LinkedList\";\nimport * as SeqHelpers from \"./SeqHelpers\";\n\n/**\n * A Stream is either [[EmptyStream]] or [[ConsStream]]\n * \"static methods\" available through [[StreamStatic]]\n * @param T the item type\n */\nexport type Stream<T> = EmptyStream<T> | ConsStream<T>;\n\n/**\n * Holds the \"static methods\" for [[Stream]]\n */\nexport class StreamStatic {\n    /**\n     * The empty stream\n     */\n    empty<T>(): Stream<T> {\n        return <EmptyStream<T>>emptyStream;\n    }\n\n    /**\n     * Create a Stream with the elements you give.\n     */\n    of<T>(elt:T, ...elts:T[]): ConsStream<T>;\n    of<T>(...elts:T[]): Stream<T>;\n    of<T>(...elts:T[]): Stream<T> {\n        return Stream.ofIterable(elts);\n    }\n\n    /**\n     * Build a stream from any iterable, which means also\n     * an array for instance.\n     * @param T the item type\n     */\n    ofIterable<T>(elts: Iterable<T>): Stream<T> {\n        // need to eagerly copy the iterable. the reason\n        // is, if we would build the stream based on the iterator\n        // in the iterable, Stream.tail() would do it.next().\n        // but it.next() modifies the iterator (mutability),\n        // and you would end up with getting two different tails\n        // for the same stream if you call .tail() twice in a row\n        if (Array.isArray(elts)) {\n            return Stream.ofArray(elts);\n        }\n        return Stream.ofArray(Array.from(elts));\n    }\n\n    /**\n     * Curried type guard for Stream.\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Stream.of(1), Stream.empty<number>())\n     *         .filter(Stream.isEmpty)\n     *     => Vector.of(Stream.empty<number>())\n     */\n    isEmpty<T>(s: Stream<T>): s is EmptyStream<T> {\n        return s.isEmpty();\n    }\n\n    /**\n     * Curried type guard for Stream.\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Stream.of(1), Stream.empty<number>())\n     *         .filter(Stream.isNotEmpty)\n     *         .map(s => s.head().get()+1)\n     *     => Vector.of(2)\n     */\n    isNotEmpty<T>(s: Stream<T>): s is ConsStream<T> {\n        return !s.isEmpty();\n    }\n\n    /**\n     * @hidden\n     */\n    private ofArray<T>(elts: Array<T>): Stream<T> {\n        if (elts.length === 0) {\n            return <EmptyStream<T>>emptyStream;\n        }\n        const head = elts[0];\n        return new ConsStream(head, Lazy.of(() => Stream.ofArray(elts.slice(1))));\n    }\n\n    /**\n     * Build an infinite stream from a seed and a transformation function.\n     *\n     *     Stream.iterate(1, x => x*2).take(4);\n     *     => Stream.of(1,2,4,8)\n     */\n    iterate<T>(seed:T, fn: (v:T)=>T): ConsStream<T> {\n        return new ConsStream(seed, Lazy.of(()=>Stream.iterate(fn(seed), fn)));\n    }\n\n    /**\n     * Build an infinite stream by calling repeatedly a function.\n     *\n     *     Stream.continually(() => 1).take(4);\n     *     => Stream.of(1,1,1,1)\n     *\n     *     Stream.continually(Math.random).take(2);\n     *     => Stream.of(0.49884723907769635, 0.3226548779864311)\n     */\n    continually<T>(fn: ()=>T): ConsStream<T> {\n        return new ConsStream(fn(), Lazy.of(() => Stream.continually(fn)));\n    }\n\n    /**\n     * Dual to the foldRight function. Build a collection from a seed.\n     * Takes a starting element and a function.\n     * It applies the function on the starting element; if the\n     * function returns None, it stops building the list, if it\n     * returns Some of a pair, it adds the first element to the result\n     * and takes the second element as a seed to keep going.\n     *\n     *     Stream.unfoldRight(\n     *          10, x=>Option.of(x)\n     *              .filter(x => x!==0)\n     *              .map<[number,number]>(x => [x,x-1]));\n     *     => Stream.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n     */\n    unfoldRight<T,U>(seed: T, fn: (x:T)=>Option<[U,T]>): Stream<U> {\n        let nextVal = fn(seed);\n        if (nextVal.isNone()) {\n            return <EmptyStream<U>>emptyStream;\n        }\n        return new ConsStream(\n            nextVal.get()[0],\n            Lazy.of(()=>Stream.unfoldRight(nextVal.getOrThrow()[1], fn)));\n    }\n\n    /**\n     * Combine any number of iterables you give in as\n     * parameters to produce a new collection which combines all,\n     * in tuples. For instance:\n     *\n     *     Stream.zip(Stream.of(1,2,3), [\"a\",\"b\",\"c\"], LinkedList.of(8,9,10))\n     *     => Stream.of([1,\"a\",8], [2,\"b\",9], [3,\"c\",10])\n     *\n     * The result collection will have the length of the shorter\n     * of the input iterables. Extra elements will be discarded.\n     *\n     * Also see the non-static version [[ConsStream.zip]], which only combines two\n     * collections.\n     * @param A A is the type of the tuple that'll be generated\n     *          (`[number,string,number]` for the code sample)\n     */\n    zip<A extends any[]>(...iterables: IterableArray<A>): Stream<A> {\n        const iterators: Iterator<A>[] = iterables.map(i => i[Symbol.iterator]());\n        let items = iterators.map(i => i.next());\n\n        if (items.some(item => item.done)) {\n            return <EmptyStream<A>>emptyStream;\n        }\n\n        return new ConsStream(items.map(item => item.value) as A,\n                              Lazy.of(() => Stream.zip<A>(...\n                                  <any>iterators.map(i=>({ [Symbol.iterator]: ()=>i})))));\n    }\n\n}\n\n/**\n * The Stream constant allows to call the Stream \"static\" methods\n */\nexport const Stream = new StreamStatic();\n\n/**\n * EmptyStream is the empty stream; every non-empty\n * stream also has a pointer to an empty stream\n * after its last element.\n * \"static methods\" available through [[StreamStatic]]\n * @param T the item type\n */\nexport class EmptyStream<T> implements Seq<T> {\n\n    /**\n     * @hidden\n     */\n    readonly className: \"EmptyStream\" = <any>undefined;  // https://stackoverflow.com/a/47841595/516188\n\n    /**\n     * Implementation of the Iterator interface.\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return {\n            next(): IteratorResult<T> {\n                return {\n                    done: true,\n                    value: <any>undefined\n                };\n            }\n        }\n    }\n\n    /**\n     * View this Some a as Stream. Useful to help typescript type\n     * inference sometimes.\n     */\n    asStream(): Stream<T> {\n        return this;\n    }\n\n    /**\n     * @hidden\n     */\n    hasTrueEquality(): boolean {\n        return SeqHelpers.seqHasTrueEquality<T>(this);\n    }\n\n    /**\n     * Get the length of the collection.\n     */\n    length(): number {\n        return 0;\n    }\n\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    single(): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * true if the collection is empty, false otherwise.\n     */\n    isEmpty(): this is EmptyStream<T> {\n        return true;\n    }\n\n    /**\n     * Get the first value of the collection, if any.\n     * returns Option.Some if the collection is not empty,\n     * Option.None if it's empty.\n     */\n    head(): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * Get all the elements in the collection but the first one.\n     * If the collection is empty, return None.\n     */\n    tail(): Option<Stream<T>> {\n        return Option.none<Stream<T>>();\n    }\n\n    /**\n     * Get the last value of the collection, if any.\n     * returns Option.Some if the collection is not empty,\n     * Option.None if it's empty.\n     */\n    last(): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * Retrieve the element at index idx.\n     * Returns an option because the collection may\n     * contain less elements than the index.\n     *\n     * Careful this is going to have poor performance\n     * on Stream, which is not a good data structure\n     * for random access!\n     */\n    get(idx: number): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * Search for an item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     */\n    find(predicate:(v:T)=>boolean): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * Returns true if the item is in the collection,\n     * false otherwise.\n     */\n    contains(v:T&WithEquality): boolean {\n        return false;\n    }\n\n    /**\n     * Return a new stream keeping only the first n elements\n     * from this stream.\n     */\n    take(n: number): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate.\n     */\n    takeWhile(predicate: (x:T)=>boolean): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate,\n     * but starting from the end of the collection.\n     *\n     *     Stream.of(1,2,3,4).takeRightWhile(x => x > 2)\n     *     => Stream.of(3,4)\n     */\n    takeRightWhile(predicate:(x:T)=>boolean): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection with the first\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    drop(n:number): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection, discarding the first elements\n     * until one element fails the predicate. All elements\n     * after that point are retained.\n     */\n    dropWhile(predicate:(x:T)=>boolean): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection with the last\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    dropRight(n:number): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection, discarding the last elements\n     * until one element fails the predicate. All elements\n     * before that point are retained.\n     */\n    dropRightWhile(predicate:(x:T)=>boolean): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Reduces the collection to a single value using the\n     * associative binary function you give. Since the function\n     * is associative, order of application doesn't matter.\n     *\n     * Example:\n     *\n     *     Stream.of(1,2,3).fold(0, (a,b) => a + b);\n     *     => 6\n     */\n    fold(zero:T, fn:(v1:T,v2:T)=>T): T {\n        return zero;\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Left-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n     *     => \"cba!\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the previous value and\n     *           the current collection item, and returning\n     *           an updated value.\n     */\n    foldLeft<U>(zero: U, fn:(soFar:U,cur:T)=>U): U {\n        return zero;\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Right-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n     *     => \"!cba\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the current collection item and\n     *           the previous value , and returning\n     *           an updated value.\n     */\n    foldRight<U>(zero: U, fn:(cur:T, soFar:U)=>U): U {\n        return zero;\n    }\n\n    /**\n     * Combine this collection with the collection you give in\n     * parameter to produce a new collection which combines both,\n     * in pairs. For instance:\n     *\n     *     Stream.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n     *     => Stream.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n     *\n     * The result collection will have the length of the shorter\n     * of both collections. Extra elements will be discarded.\n     *\n     * Also see [[StreamStatic.zip]] (static version which can more than two\n     * iterables)\n     */\n    zip<U>(other: Iterable<U>): Stream<[T,U]> {\n        return <EmptyStream<[T,U]>>emptyStream;\n    }\n\n    /**\n     * Combine this collection with the index of the elements\n     * in it. Handy if you need the index when you map on\n     * the collection for instance:\n     *\n     *     Stream.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n     *     => Stream.of(\"a0\", \"b1\")\n     */\n    zipWithIndex(): Stream<[T,number]> {\n        return <Stream<[T,number]>>SeqHelpers.zipWithIndex<T>(this);\n    }\n\n    /**\n     * Reverse the collection. For instance:\n     *\n     *     Stream.of(1,2,3).reverse();\n     *     => Stream.of(3,2,1)\n     */\n    reverse(): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Takes a predicate; returns a pair of collections.\n     * The first one is the longest prefix of this collection\n     * which satisfies the predicate, and the second collection\n     * is the remainder of the collection.\n     *\n     *    Stream.of(1,2,3,4,5,6).span(x => x <3)\n     *    => [Stream.of(1,2), Stream.of(3,4,5,6)]\n     */\n    span(predicate:(x:T)=>boolean): [Stream<T>,Stream<T>] {\n        return [this, this];\n    }\n\n    /**\n     * Split the collection at a specific index.\n     *\n     *     Stream.of(1,2,3,4,5).splitAt(3)\n     *     => [Stream.of(1,2,3), Stream.of(4,5)]\n     */\n    splitAt(index:number): [Stream<T>,Stream<T>] {\n        return [this, this];\n    }\n\n    /**\n     * Returns a pair of two collections; the first one\n     * will only contain the items from this collection for\n     * which the predicate you give returns true, the second\n     * will only contain the items from this collection where\n     * the predicate returns false.\n     *\n     *     Stream.of(1,2,3,4).partition(x => x%2===0)\n     *     => [Stream.of(2,4),Stream.of(1,3)]\n     */\n    partition<U extends T>(predicate:(v:T)=>v is U): [Stream<U>,Stream<Exclude<T,U>>];\n    partition(predicate:(x:T)=>boolean): [Stream<T>,Stream<T>];\n    partition<U extends T>(predicate:(v:T)=>boolean): [Stream<U>,Stream<any>] {\n        return [Stream.empty<U>(), Stream.empty<T>()];\n    }\n\n    /**\n     * Group elements in the collection using a classifier function.\n     * Elements are then organized in a map. The key is the value of\n     * the classifier, and in value we get the list of elements\n     * matching that value.\n     *\n     * also see [[ConsStream.arrangeBy]]\n     */\n    groupBy<C>(classifier: (v:T)=>C & WithEquality): HashMap<C,Stream<T>> {\n        return HashMap.empty<C,Stream<T>>();\n    }\n\n    /**\n     * Matches each element with a unique key that you extract from it.\n     * If the same key is present twice, the function will return None.\n     *\n     * also see [[ConsStream.groupBy]]\n     */\n    arrangeBy<K>(getKey: (v:T)=>K&WithEquality): Option<HashMap<K,T>> {\n        return SeqHelpers.arrangeBy<T,K>(this, getKey);\n    }\n\n    /**\n     * Randomly reorder the elements of the collection.\n     */\n    shuffle(): Stream<T> {\n        return Stream.ofIterable(SeqHelpers.shuffle(this.toArray()));\n    }\n\n    /**\n     * Append an element at the end of this Stream.\n     */\n    append(v:T): Stream<T> {\n        return Stream.of(v);\n    }\n\n    /*\n     * Append multiple elements at the end of this Stream.\n     */\n    appendAll(elts:Iterable<T>): Stream<T> {\n        return Stream.ofIterable(elts);\n    }\n\n    /**\n     * Remove multiple elements from a stream\n     *\n     *     Stream.of(1,2,3,4,3,2,1).removeAll([2,4])\n     *     => Stream.of(1,3,3,1)\n     */\n    removeAll(elts:Iterable<T&WithEquality>): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Removes the first element matching the predicate\n     * (use [[ConsStream.filter]] to remove all elements matching a predicate)\n     */\n    removeFirst(predicate: (x:T)=>boolean): Stream<T> {\n        return this;\n    }\n\n    /*\n     * Append another Stream at the end of this Stream.\n     *\n     * There is no function taking a javascript iterator,\n     * because iterators are stateful and Streams lazy.\n     * If we would create two Streams working on the same iterator,\n     * the streams would interact with one another.\n     * It also breaks the cycle() function.\n     */\n    appendStream(elts:Stream<T>): Stream<T> {\n        return elts;\n    }\n\n    /**\n     * Prepend an element at the beginning of the collection.\n     */\n    prepend(elt: T): Stream<T> {\n        return Stream.of(elt);\n    }\n\n    /**\n     * Prepend multiple elements at the beginning of the collection.\n     */\n    prependAll(elt: Iterable<T>): Stream<T> {\n        return Stream.ofIterable(elt);\n    }\n\n    /**\n     * Repeat infinitely this Stream.\n     * For instance:\n     *\n     *     Stream.of(1,2,3).cycle().take(8)\n     *     => Stream.of(1,2,3,1,2,3,1,2)\n     */\n    cycle(): Stream<T> {\n        return <EmptyStream<T>>emptyStream;\n    }\n\n    /**\n     * Return a new collection where each element was transformed\n     * by the mapper function you give.\n     */\n    map<U>(mapper:(v:T)=>U): Stream<U> {\n        return <EmptyStream<U>>emptyStream;\n    }\n\n    /**\n     * Apply the mapper function on every element of this collection.\n     * The mapper function returns an Option; if the Option is a Some,\n     * the value it contains is added to the result Collection, if it's\n     * a None, the value is discarded.\n     *\n     *     Stream.of(1,2,6).mapOption(x => x%2===0 ?\n     *         Option.of(x+1) : Option.none<number>())\n     *     => Stream.of(3, 7)\n     */\n    mapOption<U>(mapper:(v:T)=>Option<U>): Stream<U> {\n        return <EmptyStream<U>>emptyStream;\n    }\n\n    /**\n     * Calls the function you give for each item in the collection,\n     * your function returns a collection, all the collections are\n     * concatenated.\n     * This is the monadic bind.\n     */\n    flatMap<U>(mapper:(v:T)=>Stream<U>): Stream<U> {\n        return <EmptyStream<U>>emptyStream;\n    }\n\n    /**\n     * Returns true if the predicate returns true for all the\n     * elements in the collection.\n     */\n    allMatch<U extends T>(predicate:(v:T)=>v is U): this is Stream<U>;\n    allMatch(predicate:(v:T)=>boolean): boolean;\n    allMatch(predicate:(v:T)=>boolean): boolean {\n        return true;\n    }\n\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    anyMatch(predicate:(v:T)=>boolean): boolean {\n        return false;\n    }\n\n    /**\n     * Call a predicate for each element in the collection,\n     * build a new collection holding only the elements\n     * for which the predicate returned true.\n     */\n    filter<U extends T>(predicate:(v:T)=>v is U): Stream<U>;\n    filter(predicate:(v:T)=>boolean): Stream<T>;\n    filter(predicate:(v:T)=>boolean): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection with elements\n     * sorted according to the comparator you give.\n     *\n     *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n     *     Stream.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n     *     => Stream.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n     *\n     * also see [[ConsStream.sortOn]]\n     */\n    sortBy(compare: (v1:T,v2:T)=>Ordering): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Give a function associating a number or a string with\n     * elements from the collection, and the elements\n     * are sorted according to that value.\n     *\n     *     Stream.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n     *     => Stream.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n     *\n     * You can also sort by multiple criteria, and request 'descending'\n     * sorting:\n     *\n     *     Stream.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n     *     => Stream.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n     *\n     * also see [[ConsStream.sortBy]]\n     */\n    sortOn(...getKeys: Array<ToOrderable<T>|{desc:ToOrderable<T>}>): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Remove duplicate items; elements are mapped to keys, those\n     * get compared.\n     *\n     *     Stream.of(1,1,2,3,2,3,1).distinctBy(x => x);\n     *     => Stream.of(1,2,3)\n     */\n    distinctBy<U>(keyExtractor: (x:T)=>U&WithEquality): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Call a function for element in the collection.\n     */\n    forEach(fn: (v:T)=>void): Stream<T> {\n        return this;\n    }\n\n    /**\n     * Reduces the collection to a single value by repeatedly\n     * calling the combine function.\n     * No starting value. The order in which the elements are\n     * passed to the combining function is undetermined.\n     */\n    reduce(combine: (v1:T,v2:T)=>T): Option<T> {\n        return SeqHelpers.reduce(this, combine);\n    }\n\n    /**\n     * Compare values in the collection and return the smallest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsStream.minOn]]\n     */\n    minBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the smallest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     Stream.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n     *     => Option.of({name:\"Paula\", age:6})\n     *\n     * also see [[ConsStream.minBy]]\n     */\n    minOn(getOrderable: ToOrderable<T>): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * Compare values in the collection and return the largest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsStream.maxOn]]\n     */\n    maxBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the largest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     Stream.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n     *     => Option.of({name:\"Joe\", age:12})\n     *\n     * also see [[ConsStream.maxBy]]\n     */\n    maxOn(getOrderable: ToOrderable<T>): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * Call the function you give for each element in the collection\n     * and sum all the numbers, return that sum.\n     * Will return 0 if the collection is empty.\n     *\n     *     Stream.of(1,2,3).sumOn(x=>x)\n     *     => 6\n     */\n    sumOn(getNumber: (v:T)=>number): number {\n        return 0;\n    }\n\n    /**\n     * Slides a window of a specific size over the sequence.\n     * Returns a lazy stream so memory use is not prohibitive.\n     *\n     *     Stream.of(1,2,3,4,5,6,7,8).sliding(3)\n     *     => Stream.of(Stream.of(1,2,3), Stream.of(4,5,6), Stream.of(7,8))\n     */\n    sliding(count:number): Stream<Stream<T>> {\n        return <Stream<Stream<T>>>SeqHelpers.sliding(this, count);\n    }\n\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     *\n     *     Stream.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n     *     => Stream.of(0,1,3,6)\n     */\n    scanLeft<U>(init:U, fn:(soFar:U,cur:T)=>U): Stream<U> {\n        return new ConsStream(init, Lazy.of(()=><EmptyStream<U>>emptyStream));\n    }\n\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     * The first element of the result is the final cumulative result.\n     *\n     *     Stream.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n     *     => Stream.of(6,5,3,0)\n     */\n    scanRight<U>(init:U, fn:(cur:T,soFar:U)=>U): Stream<U> {\n        return new ConsStream(init, Lazy.of(()=><EmptyStream<U>>emptyStream));\n    }\n\n    /**\n     * Joins elements of the collection by a separator.\n     * Example:\n     *\n     *     Vector.of(1,2,3).mkString(\", \")\n     *     => \"1, 2, 3\"\n     */\n    mkString(separator: string): string {\n        return \"\";\n    }\n\n    /**\n     * Convert to array.\n     * Don't do it on an infinite stream!\n     */\n    toArray(): T[] {\n        return [];\n    }\n\n    /**\n     * Convert to vector.\n     * Don't do it on an infinite stream!\n     */\n    toVector(): Vector<T> {\n        return Vector.empty<T>();\n    }\n\n    /**\n     * Convert this collection to a map. You give a function which\n     * for each element in the collection returns a pair. The\n     * key of the pair will be used as a key in the map, the value,\n     * as a value in the map. If several values get the same key,\n     * entries will be lost.\n     *\n     *     Stream.of(1,2,3).toMap(x=>[x.toString(), x])\n     *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n     */\n    toMap<K,V>(converter:(x:T)=>[K & WithEquality,V]): HashMap<K,V> {\n        return HashMap.empty<K,V>();\n    }\n\n    /**\n     * Convert this collection to a set. Since the elements of the\n     * Seq may not support equality, you must pass a function returning\n     * a value supporting equality.\n     *\n     *     Stream.of(1,2,3,3,4).toSet(x=>x)\n     *     => HashSet.of(1,2,3,4)\n     */\n    toSet<K>(converter:(x:T)=>K&WithEquality): HashSet<K> {\n        return HashSet.empty<K>();\n    }\n\n    /**\n     * Convert this collection to a list.\n     */\n    toLinkedList(): LinkedList<T> {\n        return LinkedList.ofIterable(this);\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:Stream<T>)=>U): U {\n        return converter(this);\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other: Stream<T&WithEquality>): boolean {\n        if (!other) {\n            return false;\n        }\n        return other.isEmpty();\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        return 1;\n    }\n\n    [inspect](): string {\n        return this.toString();\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     *\n     * Also see [[ConsStream.mkString]]\n     */\n    toString(): string {\n        return \"[]\";\n    }\n}\n\n/**\n * ConsStream holds a value and a lazy pointer to a next element,\n * which could be [[ConsStream]] or [[EmptyStream]].\n * A ConsStream is basically a non-empty stream. It will\n * contain at least one element.\n * \"static methods\" available through [[StreamStatic]]\n * @param T the item type\n */\nexport class ConsStream<T> implements Seq<T> {\n\n    /**\n     * @hidden\n     */\n    readonly className: \"ConsStream\" = <any>undefined;  // https://stackoverflow.com/a/47841595/516188\n\n    /**\n     * @hidden\n     */\n    public constructor(protected value: T, protected _tail: Lazy<Stream<T>>) {}\n\n    /**\n     * Implementation of the Iterator interface.\n     */\n    [Symbol.iterator](): Iterator<T> {\n        let item: Stream<T> = this;\n        return {\n            next(): IteratorResult<T> {\n                if (item.isEmpty()) {\n                    return { done: true, value: <any>undefined };\n                }\n                const value = item.head().get();\n                item = item.tail().get();\n                return {done: false, value};\n            }\n        };\n    }\n\n    /**\n     * View this Some a as Stream. Useful to help typescript type\n     * inference sometimes.\n     */\n    asStream(): Stream<T> {\n        return this;\n    }\n\n    /**\n     * @hidden\n     */\n    hasTrueEquality(): boolean {\n        return SeqHelpers.seqHasTrueEquality<T>(this);\n    }\n\n    /**\n     * Get the length of the collection.\n     */\n    length(): number {\n        return this.foldLeft(0, (n, ignored) => n + 1);\n    }\n\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    single(): Option<T> {\n        return this._tail.get().isEmpty() ?\n            Option.of(this.value) :\n            Option.none<T>();\n    }\n\n    /**\n     * true if the collection is empty, false otherwise.\n     */\n    isEmpty(): this is EmptyStream<T> {\n        return false;\n    }\n\n    /**\n     * Get the first value of the collection, if any.\n     * returns Option.Some if the collection is not empty,\n     * Option.None if it's empty.\n     */\n    head(): Some<T> {\n        return Option.some(this.value);\n    }\n\n    /**\n     * Get all the elements in the collection but the first one.\n     * If the collection is empty, return None.\n     */\n    tail(): Some<Stream<T>> {\n        return Option.some(this._tail.get());\n    }\n\n    /**\n     * Get the last value of the collection, if any.\n     * returns Option.Some if the collection is not empty,\n     * Option.None if it's empty.\n     */\n    last(): Some<T> {\n        let curItem: Stream<T> = this;\n        while (true) {\n            const item = (<ConsStream<T>>curItem).value;\n            curItem = (<ConsStream<T>>curItem)._tail.get();\n            if (curItem.isEmpty()) {\n                return Option.some(item);\n            }\n        }\n    }\n\n    /**\n     * Retrieve the element at index idx.\n     * Returns an option because the collection may\n     * contain less elements than the index.\n     *\n     * Careful this is going to have poor performance\n     * on Stream, which is not a good data structure\n     * for random access!\n     */\n    get(idx: number): Option<T> {\n        let curItem: Stream<T> = this;\n        let i=0;\n        while (!curItem.isEmpty()) {\n            if (i === idx) {\n                const item = curItem.value;\n                return Option.of(item);\n            }\n            curItem = curItem._tail.get();\n            ++i;\n        }\n        return Option.none<T>();\n    }\n\n    /**\n     * Search for an item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     */\n    find(predicate:(v:T)=>boolean): Option<T> {\n        let curItem: Stream<T> = this;\n        while (!curItem.isEmpty()) {\n            const item = curItem.value;\n            if (predicate(item)) {\n                return Option.of(item);\n            }\n            curItem = curItem._tail.get();\n        }\n        return Option.none<T>();\n    }\n\n    /**\n     * Returns true if the item is in the collection,\n     * false otherwise.\n     */\n    contains(v:T&WithEquality): boolean {\n        return this.find(x => areEqual(x,v)).isSome();\n    }\n\n    /**\n     * Return a new stream keeping only the first n elements\n     * from this stream.\n     */\n    take(n: number): Stream<T> {\n        if (n < 1) {\n            return <EmptyStream<T>>emptyStream;\n        }\n        return new ConsStream(this.value,\n                              Lazy.of(() => this._tail.get().take(n-1)));\n    }\n\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate.\n     */\n    takeWhile(predicate: (x:T)=>boolean): Stream<T> {\n        if (!predicate(this.value)) {\n            return <EmptyStream<T>>emptyStream;\n        }\n        return new ConsStream(this.value,\n                              Lazy.of(() => this._tail.get().takeWhile(predicate)));\n    }\n\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate,\n     * but starting from the end of the collection.\n     *\n     *     Stream.of(1,2,3,4).takeRightWhile(x => x > 2)\n     *     => Stream.of(3,4)\n     */\n    takeRightWhile(predicate:(x:T)=>boolean): Stream<T> {\n        return this.reverse().takeWhile(predicate).reverse();\n    }\n\n    /**\n     * Returns a new collection with the first\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    drop(n:number): Stream<T> {\n        let i = n;\n        let curItem: Stream<T> = this;\n        while (i-- > 0 && !curItem.isEmpty()) {\n            curItem = curItem._tail.get();\n        }\n        return curItem;\n    }\n\n    /**\n     * Returns a new collection, discarding the first elements\n     * until one element fails the predicate. All elements\n     * after that point are retained.\n     */\n    dropWhile(predicate:(x:T)=>boolean): Stream<T> {\n        let curItem: Stream<T> = this;\n        while (!curItem.isEmpty() && predicate(curItem.value)) {\n            curItem = curItem._tail.get();\n        }\n        return curItem;\n    }\n\n    /**\n     * Returns a new collection with the last\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    dropRight(n:number): Stream<T> {\n        // going twice through the list...\n        const length = this.length();\n        return this.take(length-n);\n    }\n\n    /**\n     * Returns a new collection, discarding the last elements\n     * until one element fails the predicate. All elements\n     * before that point are retained.\n     */\n    dropRightWhile(predicate:(x:T)=>boolean): Stream<T> {\n        return this.reverse().dropWhile(predicate).reverse();\n    }\n\n    /**\n     * Reduces the collection to a single value using the\n     * associative binary function you give. Since the function\n     * is associative, order of application doesn't matter.\n     *\n     * Example:\n     *\n     *     Stream.of(1,2,3).fold(0, (a,b) => a + b);\n     *     => 6\n     */\n    fold(zero:T, fn:(v1:T,v2:T)=>T): T {\n        return this.foldLeft(zero, fn);\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Left-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n     *     => \"cba!\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the previous value and\n     *           the current collection item, and returning\n     *           an updated value.\n     */\n    foldLeft<U>(zero: U, fn:(soFar:U,cur:T)=>U): U {\n        let r = zero;\n        let curItem: Stream<T> = this;\n        while (!curItem.isEmpty()) {\n            r = fn(r, curItem.value);\n            curItem = curItem._tail.get();\n        }\n        return r;\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Right-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n     *     => \"!cba\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the current collection item and\n     *           the previous value , and returning\n     *           an updated value.\n     */\n    foldRight<U>(zero: U, fn:(cur:T, soFar:U)=>U): U {\n        return this.reverse().foldLeft(zero, (xs,x)=>fn(x,xs));\n    }\n\n    /**\n     * Combine this collection with the collection you give in\n     * parameter to produce a new collection which combines both,\n     * in pairs. For instance:\n     *\n     *     Stream.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n     *     => Stream.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n     *\n     * The result collection will have the length of the shorter\n     * of both collections. Extra elements will be discarded.\n     *\n     * Also see [[StreamStatic.zip]] (static version which can more than two\n     * iterables)\n     */\n    zip<U>(other: Iterable<U>): Stream<[T,U]> {\n        const otherIterator = other[Symbol.iterator]();\n        let otherCurItem = otherIterator.next();\n\n        if (this.isEmpty() || otherCurItem.done) {\n            return <EmptyStream<[T,U]>>emptyStream;\n        }\n\n        return new ConsStream([this.value, otherCurItem.value] as [T,U],\n                              Lazy.of(() => this._tail.get().zip(\n                                  { [Symbol.iterator]: ()=>otherIterator})));\n    }\n\n    /**\n     * Combine this collection with the index of the elements\n     * in it. Handy if you need the index when you map on\n     * the collection for instance:\n     *\n     *     Stream.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n     *     => Stream.of(\"a0\", \"b1\")\n     */\n    zipWithIndex(): Stream<[T,number]> {\n        return <Stream<[T,number]>>SeqHelpers.zipWithIndex<T>(this);\n    }\n\n    /**\n     * Reverse the collection. For instance:\n     *\n     *     Stream.of(1,2,3).reverse();\n     *     => Stream.of(3,2,1)\n     */\n    reverse(): Stream<T> {\n        return this.foldLeft(<Stream<T>><EmptyStream<T>>emptyStream, (xs,x) => xs.prepend(x));\n    }\n\n    /**\n     * Takes a predicate; returns a pair of collections.\n     * The first one is the longest prefix of this collection\n     * which satisfies the predicate, and the second collection\n     * is the remainder of the collection.\n     *\n     *    Stream.of(1,2,3,4,5,6).span(x => x <3)\n     *    => [Stream.of(1,2), Stream.of(3,4,5,6)]\n     */\n    span(predicate:(x:T)=>boolean): [Stream<T>,Stream<T>] {\n        return [this.takeWhile(predicate), this.dropWhile(predicate)];\n    }\n\n    /**\n     * Split the collection at a specific index.\n     *\n     *     Stream.of(1,2,3,4,5).splitAt(3)\n     *     => [Stream.of(1,2,3), Stream.of(4,5)]\n     */\n    splitAt(index:number): [Stream<T>,Stream<T>] {\n        return [this.take(index), this.drop(index)];\n    }\n\n    /**\n     * Returns a pair of two collections; the first one\n     * will only contain the items from this collection for\n     * which the predicate you give returns true, the second\n     * will only contain the items from this collection where\n     * the predicate returns false.\n     *\n     *     Stream.of(1,2,3,4).partition(x => x%2===0)\n     *     => [Stream.of(2,4),Stream.of(1,3)]\n     */\n    partition<U extends T>(predicate:(v:T)=>v is U): [Stream<U>,Stream<Exclude<T,U>>];\n    partition(predicate:(x:T)=>boolean): [Stream<T>,Stream<T>];\n    partition(predicate:(v:T)=>boolean): [Stream<T>,Stream<T>] {\n        // goes twice over the list, but since we want a lazy behavior...\n        return [this.filter(predicate), this.filter(x => !predicate(x))];\n    }\n\n    /**\n     * Group elements in the collection using a classifier function.\n     * Elements are then organized in a map. The key is the value of\n     * the classifier, and in value we get the list of elements\n     * matching that value.\n     *\n     * also see [[ConsStream.arrangeBy]]\n     */\n    groupBy<C>(classifier: (v:T)=>C & WithEquality): HashMap<C,Stream<T>> {\n        return this.foldLeft(\n            HashMap.empty<C,Stream<T>>(),\n            (acc: HashMap<C,Stream<T>>, v:T) =>\n                acc.putWithMerge(\n                    classifier(v), Stream.of(v),\n                    (v1:Stream<T>,v2:Stream<T>)=>v1.appendStream(v2)));\n    }\n\n    /**\n     * Matches each element with a unique key that you extract from it.\n     * If the same key is present twice, the function will return None.\n     *\n     * also see [[ConsStream.groupBy]]\n     */\n    arrangeBy<K>(getKey: (v:T)=>K&WithEquality): Option<HashMap<K,T>> {\n        return SeqHelpers.arrangeBy<T,K>(this, getKey);\n    }\n\n    /**\n     * Randomly reorder the elements of the collection.\n     */\n    shuffle(): Stream<T> {\n        return Stream.ofIterable(SeqHelpers.shuffle(this.toArray()));\n    }\n\n    /**\n     * Append an element at the end of this Stream.\n     */\n    append(v:T): Stream<T> {\n        const tail = this._tail.get();\n        return new ConsStream(\n            this.value,\n            Lazy.of(()=>tail.append(v)));\n    }\n\n    /*\n     * Append multiple elements at the end of this Stream.\n     */\n    appendAll(elts:Iterable<T>): Stream<T> {\n        return this.appendStream(Stream.ofIterable(elts));\n    }\n\n    /**\n     * Remove multiple elements from a stream\n     *\n     *     Stream.of(1,2,3,4,3,2,1).removeAll([2,4])\n     *     => Stream.of(1,3,3,1)\n     */\n    removeAll(elts:Iterable<T&WithEquality>): Stream<T> {\n        return <Stream<T>><any>SeqHelpers.removeAll(this, elts);\n    }\n\n    /**\n     * Removes the first element matching the predicate\n     * (use [[ConsStream.filter]] to remove all elements matching a predicate)\n     */\n    removeFirst(predicate: (x:T)=>boolean): Stream<T> {\n        const tail = this._tail.get();\n        return predicate(this.value) ?\n            tail :\n            new ConsStream(this.value,\n                           Lazy.of(()=>tail.removeFirst(predicate)));\n    }\n\n    /*\n     * Append another Stream at the end of this Stream.\n     *\n     * There is no function taking a javascript iterator,\n     * because iterators are stateful and Streams lazy.\n     * If we would create two Streams working on the same iterator,\n     * the streams would interact with one another.\n     * It also breaks the cycle() function.\n     */\n    appendStream(elts:Stream<T>): Stream<T> {\n        const tail = this._tail.get();\n        return new ConsStream(\n            this.value,\n            Lazy.of(() => tail.appendStream(elts)));\n    }\n\n    /**\n     * Prepend an element at the beginning of the collection.\n     */\n    prepend(elt: T): Stream<T> {\n        return new ConsStream(\n            elt,\n            Lazy.of(()=>this));\n    }\n\n    /**\n     * Prepend multiple elements at the beginning of the collection.\n     */\n    prependAll(elts: Iterable<T>): Stream<T> {\n        return Stream.ofIterable(elts).appendAll(this);\n    }\n\n    /**\n     * Repeat infinitely this Stream.\n     * For instance:\n     *\n     *     Stream.of(1,2,3).cycle().take(8)\n     *     => Stream.of(1,2,3,1,2,3,1,2)\n     */\n    cycle(): Stream<T> {\n        return this._cycle(this);\n    }\n\n    private _cycle(toRepeat: Stream<T>): Stream<T> {\n        const tail = this._tail.get();\n        return new ConsStream(\n            this.value,\n            Lazy.of(() => tail.isEmpty() ? toRepeat.cycle() : tail._cycle(toRepeat)));\n    }\n\n    /**\n     * Return a new collection where each element was transformed\n     * by the mapper function you give.\n     */\n    map<U>(mapper:(v:T)=>U): Stream<U> {\n        return new ConsStream(mapper(this.value),\n                              Lazy.of(() => this._tail.get().map(mapper)));\n    }\n\n    /**\n     * Apply the mapper function on every element of this collection.\n     * The mapper function returns an Option; if the Option is a Some,\n     * the value it contains is added to the result Collection, if it's\n     * a None, the value is discarded.\n     *\n     *     Stream.of(1,2,6).mapOption(x => x%2===0 ?\n     *         Option.of(x+1) : Option.none<number>())\n     *     => Stream.of(3, 7)\n     */\n    mapOption<U>(mapper:(v:T)=>Option<U>): Stream<U> {\n        const mapped = mapper(this.value);\n        return mapped.isSome() ?\n            new ConsStream(mapped.get(),\n                           Lazy.of(() => this._tail.get().mapOption(mapper))) :\n            this._tail.get().mapOption(mapper);\n    }\n\n    /**\n     * Calls the function you give for each item in the collection,\n     * your function returns a collection, all the collections are\n     * concatenated.\n     * This is the monadic bind.\n     */\n    flatMap<U>(mapper:(v:T)=>Stream<U>): Stream<U> {\n        return mapper(this.value).appendStream(\n            this._tail.get().flatMap(mapper));\n    }\n\n    /**\n     * Returns true if the predicate returns true for all the\n     * elements in the collection.\n     */\n    allMatch<U extends T>(predicate:(v:T)=>v is U): this is Stream<U>;\n    allMatch(predicate:(v:T)=>boolean): boolean;\n    allMatch(predicate:(v:T)=>boolean): boolean {\n        return this.find(x => !predicate(x)).isNone();\n    }\n\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    anyMatch(predicate:(v:T)=>boolean): boolean {\n        return this.find(predicate).isSome();\n    }\n\n    /**\n     * Call a predicate for each element in the collection,\n     * build a new collection holding only the elements\n     * for which the predicate returned true.\n     */\n    filter<U extends T>(predicate:(v:T)=>v is U): Stream<U>;\n    filter(predicate:(v:T)=>boolean): Stream<T>;\n    filter(predicate:(v:T)=>boolean): Stream<T> {\n        return predicate(this.value) ?\n            new ConsStream(this.value,\n                           Lazy.of(() => this._tail.get().filter(predicate))) :\n            this._tail.get().filter(predicate);\n    }\n\n    /**\n     * Returns a new collection with elements\n     * sorted according to the comparator you give.\n     *\n     *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n     *     Stream.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n     *     => Stream.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n     *\n     * also see [[ConsStream.sortOn]]\n     */\n    sortBy(compare: (v1:T,v2:T)=>Ordering): Stream<T> {\n        return Stream.ofIterable<T>(this.toArray().sort(compare));\n    }\n\n    /**\n     * Give a function associating a number or a string with\n     * elements from the collection, and the elements\n     * are sorted according to that value.\n     *\n     *     Stream.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n     *     => Stream.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n     *\n     * You can also sort by multiple criteria, and request 'descending'\n     * sorting:\n     *\n     *     Stream.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n     *     => Stream.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n     *\n     * also see [[ConsStream.sortBy]]\n     */\n    sortOn(...getKeys: Array<ToOrderable<T>|{desc:ToOrderable<T>}>): Stream<T> {\n        return <Stream<T>>SeqHelpers.sortOn<T>(this, getKeys);\n    }\n\n    /**\n     * Remove duplicate items; elements are mapped to keys, those\n     * get compared.\n     *\n     *     Stream.of(1,1,2,3,2,3,1).distinctBy(x => x);\n     *     => Stream.of(1,2,3)\n     */\n    distinctBy<U>(keyExtractor: (x:T)=>U&WithEquality): Stream<T> {\n        return <Stream<T>>SeqHelpers.distinctBy(this, keyExtractor);\n    }\n\n    /**\n     * Call a function for element in the collection.\n     */\n    forEach(fn: (v:T)=>void): Stream<T> {\n        let curItem: Stream<T> = this;\n        while (!curItem.isEmpty()) {\n            fn(curItem.value);\n            curItem = curItem._tail.get();\n        }\n        return this;\n    }\n\n    /**\n     * Reduces the collection to a single value by repeatedly\n     * calling the combine function.\n     * No starting value. The order in which the elements are\n     * passed to the combining function is undetermined.\n     */\n    reduce(combine: (v1:T,v2:T)=>T): Option<T> {\n        return SeqHelpers.reduce(this, combine);\n    }\n\n    /**\n     * Compare values in the collection and return the smallest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsStream.minOn]]\n     */\n    minBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return SeqHelpers.minBy(this, compare);\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the smallest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     Stream.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n     *     => Option.of({name:\"Paula\", age:6})\n     *\n     * also see [[ConsStream.minBy]]\n     */\n    minOn(getOrderable: ToOrderable<T>): Option<T> {\n        return SeqHelpers.minOn(this, getOrderable);\n    }\n\n    /**\n     * Compare values in the collection and return the largest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsStream.maxOn]]\n     */\n    maxBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return SeqHelpers.maxBy(this, compare);\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the largest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     Stream.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n     *     => Option.of({name:\"Joe\", age:12})\n     *\n     * also see [[ConsStream.maxBy]]\n     */\n    maxOn(getOrderable: ToOrderable<T>): Option<T> {\n        return SeqHelpers.maxOn(this, getOrderable);\n    }\n\n    /**\n     * Call the function you give for each element in the collection\n     * and sum all the numbers, return that sum.\n     * Will return 0 if the collection is empty.\n     *\n     *     Stream.of(1,2,3).sumOn(x=>x)\n     *     => 6\n     */\n    sumOn(getNumber: (v:T)=>number): number {\n        return SeqHelpers.sumOn(this, getNumber);\n    }\n\n    /**\n     * Slides a window of a specific size over the sequence.\n     * Returns a lazy stream so memory use is not prohibitive.\n     *\n     *     Stream.of(1,2,3,4,5,6,7,8).sliding(3)\n     *     => Stream.of(Stream.of(1,2,3), Stream.of(4,5,6), Stream.of(7,8))\n     */\n    sliding(count:number): Stream<Stream<T>> {\n        return <Stream<Stream<T>>>SeqHelpers.sliding(this, count);\n    }\n\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     *\n     *     Stream.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n     *     => Stream.of(0,1,3,6)\n     */\n    scanLeft<U>(init:U, fn:(soFar:U,cur:T)=>U): Stream<U> {\n        return new ConsStream(\n            init,\n            Lazy.of(()=>this._tail.get().scanLeft(fn(init, this.value), fn)));\n    }\n\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     * The first element of the result is the final cumulative result.\n     *\n     *     Stream.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n     *     => Stream.of(6,5,3,0)\n     */\n    scanRight<U>(init:U, fn:(cur:T,soFar:U)=>U): Stream<U> {\n        // can't be lazy\n        const fn2 = (x:U,y:T)=>fn(y,x);\n        return this.reverse().scanLeft(init, fn2).reverse();\n    }\n\n    /**\n     * Joins elements of the collection by a separator.\n     * Example:\n     *\n     *     Vector.of(1,2,3).mkString(\", \")\n     *     => \"1, 2, 3\"\n     */\n    mkString(separator: string): string {\n        let r = \"\";\n        let curItem: Stream<T> = this;\n        let isNotFirst = false;\n        while (!curItem.isEmpty()) {\n            if (isNotFirst) {\n                r += separator;\n            }\n            r += SeqHelpers.toStringHelper(curItem.value, {quoteStrings:false});\n            curItem = curItem._tail.get();\n            isNotFirst = true;\n        }\n        return r;\n    }\n\n    /**\n     * Convert to array.\n     * Don't do it on an infinite stream!\n     */\n    toArray(): T[] {\n        let r:T[] = [];\n        let curItem: Stream<T> = this;\n        while (!curItem.isEmpty()) {\n            r.push(curItem.value);\n            curItem = curItem._tail.get();\n        }\n        return r;\n    }\n\n    /**\n     * Convert to vector.\n     * Don't do it on an infinite stream!\n     */\n    toVector(): Vector<T> {\n        return Vector.ofIterable<T>(this.toArray());\n    }\n\n    /**\n     * Convert this collection to a map. You give a function which\n     * for each element in the collection returns a pair. The\n     * key of the pair will be used as a key in the map, the value,\n     * as a value in the map. If several values get the same key,\n     * entries will be lost.\n     *\n     *     Stream.of(1,2,3).toMap(x=>[x.toString(), x])\n     *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n     */\n    toMap<K,V>(converter:(x:T)=>[K & WithEquality,V]): HashMap<K,V> {\n        return this.foldLeft(HashMap.empty<K,V>(), (acc,cur) => {\n            const converted = converter(cur);\n            return acc.put(converted[0], converted[1]);\n        });\n    }\n\n    /**\n     * Convert this collection to a set. Since the elements of the\n     * Seq may not support equality, you must pass a function returning\n     * a value supporting equality.\n     *\n     *     Stream.of(1,2,3,3,4).toSet(x=>x)\n     *     => HashSet.of(1,2,3,4)\n     */\n    toSet<K>(converter:(x:T)=>K&WithEquality): HashSet<K> {\n        return this.foldLeft(HashSet.empty<K>(), (acc,cur) => {\n            return acc.add(converter(cur));\n        });\n    }\n\n    /**\n     * Convert this collection to a list.\n     */\n    toLinkedList(): LinkedList<T> {\n        return LinkedList.ofIterable(this);\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:Stream<T>)=>U): U {\n        return converter(this);\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other: Stream<T&WithEquality>): boolean {\n        if (<any>other === this) {\n            return true;\n        }\n        if (!other || !other.tail) {\n            return false;\n        }\n        contractTrueEquality(\"Stream.equals\", this, other);\n        let myVal: Stream<T> = this;\n        let hisVal = other;\n        while (true) {\n            if (myVal.isEmpty() !== hisVal.isEmpty()) {\n                return false;\n            }\n            if (myVal.isEmpty()) {\n                // they are both empty, end of the stream\n                return true;\n            }\n            const myHead = myVal.value;\n            const hisHead = (<ConsStream<T>>hisVal).value;\n\n            if ((myHead === undefined) !== (hisHead === undefined)) {\n                return false;\n            }\n            if (myHead === undefined || hisHead === undefined) {\n                // they are both undefined, the || is for TS's flow analysis\n                // so he realizes none of them is undefined after this.\n                continue;\n            }\n            if (!areEqual(myHead, hisHead)) {\n                return false;\n            }\n            myVal = myVal._tail.get();\n            hisVal = (<ConsStream<T&WithEquality>>hisVal)._tail.get();\n        }\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        let hash = 1;\n        let curItem: Stream<T> = this;\n        while (!curItem.isEmpty()) {\n            hash = 31 * hash + getHashCode(curItem.value);\n            curItem = curItem._tail.get();\n        }\n        return hash;\n    }\n\n    [inspect](): string {\n        return this.toString();\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     *\n     * Also see [[ConsStream.mkString]]\n     */\n    toString(): string {\n        let curItem: Stream<T> = this;\n        let result = \"Stream(\";\n\n        while (!curItem.isEmpty()) {\n            result += SeqHelpers.toStringHelper(curItem.value);\n            const tail: Lazy<Stream<T>> = curItem._tail;\n            if (!tail.isEvaluated()) {\n                result += \", ?\";\n                break;\n            }\n            curItem = tail.get();\n            if (!curItem.isEmpty()) {\n                result += \", \";\n            }\n        }\n\n        return result + \")\";\n    }\n}\n\nconst emptyStream = new EmptyStream<any>();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}