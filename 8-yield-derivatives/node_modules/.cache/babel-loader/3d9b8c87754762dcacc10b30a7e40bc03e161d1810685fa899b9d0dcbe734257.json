{"ast":null,"code":"/**\n * Supported cipher modes.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\nforge.cipher = forge.cipher || {};\n\n// supported cipher modes\nvar modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};\n\n/** Electronic codebook (ECB) (Don't use this; it's not secure) **/\n\nmodes.ecb = function (options) {\n  options = options || {};\n  this.name = 'ECB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\nmodes.ecb.prototype.start = function (options) {};\nmodes.ecb.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\nmodes.ecb.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\nmodes.ecb.prototype.pad = function (input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n  input.fillWithByte(padding, padding);\n  return true;\n};\nmodes.ecb.prototype.unpad = function (output, options) {\n  // check for error: input data not a multiple of blockSize\n  if (options.overflow > 0) {\n    return false;\n  }\n\n  // ensure padding byte count is valid\n  var len = output.length();\n  var count = output.at(len - 1);\n  if (count > this.blockSize << 2) {\n    return false;\n  }\n\n  // trim off padding bytes\n  output.truncate(count);\n  return true;\n};\n\n/** Cipher-block Chaining (CBC) **/\n\nmodes.cbc = function (options) {\n  options = options || {};\n  this.name = 'CBC';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\nmodes.cbc.prototype.start = function (options) {\n  // Note: legacy support for using IV residue (has security flaws)\n  // if IV is null, reuse block from previous processing\n  if (options.iv === null) {\n    // must have a previous block\n    if (!this._prev) {\n      throw new Error('Invalid IV parameter.');\n    }\n    this._iv = this._prev.slice(0);\n  } else if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } else {\n    // save IV as \"previous\" block\n    this._iv = transformIV(options.iv, this.blockSize);\n    this._prev = this._iv.slice(0);\n  }\n};\nmodes.cbc.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  // CBC XOR's IV (or previous block) with plaintext\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = this._prev[i] ^ input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output, save previous block\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n  this._prev = this._outBlock;\n};\nmodes.cbc.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output, save previous ciphered block\n  // CBC XOR's IV (or previous block) with ciphertext\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._prev[i] ^ this._outBlock[i]);\n  }\n  this._prev = this._inBlock.slice(0);\n};\nmodes.cbc.prototype.pad = function (input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n  input.fillWithByte(padding, padding);\n  return true;\n};\nmodes.cbc.prototype.unpad = function (output, options) {\n  // check for error: input data not a multiple of blockSize\n  if (options.overflow > 0) {\n    return false;\n  }\n\n  // ensure padding byte count is valid\n  var len = output.length();\n  var count = output.at(len - 1);\n  if (count > this.blockSize << 2) {\n    return false;\n  }\n\n  // trim off padding bytes\n  output.truncate(count);\n  return true;\n};\n\n/** Cipher feedback (CFB) **/\n\nmodes.cfb = function (options) {\n  options = options || {};\n  this.name = 'CFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\nmodes.cfb.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\nmodes.cfb.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if (inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\n      output.putInt32(this._inBlock[i]);\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if (partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output, write input as partial output\n  this._partialOutput.clear();\n  for (var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\n    this._partialOutput.putInt32(this._partialBlock[i]);\n  }\n  if (partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if (this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n  if (partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\nmodes.cfb.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n  if (inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block (CFB always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32();\n      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if (partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output, write input as partial output\n  this._partialOutput.clear();\n  for (var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32();\n    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\n  }\n  if (partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if (this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n  if (partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\n/** Output feedback (OFB) **/\n\nmodes.ofb = function (options) {\n  options = options || {};\n  this.name = 'OFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\nmodes.ofb.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\nmodes.ofb.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if (input.length() === 0) {\n    return true;\n  }\n\n  // encrypt block (OFB always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output and update next input\n    for (var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n      this._inBlock[i] = this._outBlock[i];\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if (partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output\n  this._partialOutput.clear();\n  for (var i = 0; i < this._ints; ++i) {\n    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n  }\n  if (partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._outBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if (this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n  if (partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\nmodes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\n\n/** Counter (CTR) **/\n\nmodes.ctr = function (options) {\n  options = options || {};\n  this.name = 'CTR';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\nmodes.ctr.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\nmodes.ctr.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if (inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block (CTR always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for (var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if (partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    }\n\n    // XOR input with output\n    this._partialOutput.clear();\n    for (var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n    if (partialBytes > 0) {\n      // block still incomplete, restore input buffer\n      input.read -= this.blockSize;\n    }\n\n    // skip any previous partial bytes\n    if (this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n    if (partialBytes > 0 && !finish) {\n      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  }\n\n  // block complete, increment counter (input block)\n  inc32(this._inBlock);\n};\nmodes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\n\n/** Galois/Counter Mode (GCM) **/\n\nmodes.gcm = function (options) {\n  options = options || {};\n  this.name = 'GCM';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n\n  // R is actually this value concatenated with 120 more zero bits, but\n  // we only XOR against R so the other zeros have no effect -- we just\n  // apply this value to the first integer in a block\n  this._R = 0xE1000000;\n};\nmodes.gcm.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // ensure IV is a byte buffer\n  var iv = forge.util.createBuffer(options.iv);\n\n  // no ciphered data processed yet\n  this._cipherLength = 0;\n\n  // default additional data is none\n  var additionalData;\n  if ('additionalData' in options) {\n    additionalData = forge.util.createBuffer(options.additionalData);\n  } else {\n    additionalData = forge.util.createBuffer();\n  }\n\n  // default tag length is 128 bits\n  if ('tagLength' in options) {\n    this._tagLength = options.tagLength;\n  } else {\n    this._tagLength = 128;\n  }\n\n  // if tag is given, ensure tag matches tag length\n  this._tag = null;\n  if (options.decrypt) {\n    // save tag to check later\n    this._tag = forge.util.createBuffer(options.tag).getBytes();\n    if (this._tag.length !== this._tagLength / 8) {\n      throw new Error('Authentication tag does not match tag length.');\n    }\n  }\n\n  // create tmp storage for hash calculation\n  this._hashBlock = new Array(this._ints);\n\n  // no tag generated yet\n  this.tag = null;\n\n  // generate hash subkey\n  // (apply block cipher to \"zero\" block)\n  this._hashSubkey = new Array(this._ints);\n  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);\n\n  // generate table M\n  // use 4-bit tables (32 component decomposition of a 16 byte value)\n  // 8-bit tables take more space and are known to have security\n  // vulnerabilities (in native implementations)\n  this.componentBits = 4;\n  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);\n\n  // Note: support IV length different from 96 bits? (only supporting\n  // 96 bits is recommended by NIST SP-800-38D)\n  // generate J_0\n  var ivLength = iv.length();\n  if (ivLength === 12) {\n    // 96-bit IV\n    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];\n  } else {\n    // IV is NOT 96-bits\n    this._j0 = [0, 0, 0, 0];\n    while (iv.length() > 0) {\n      this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);\n    }\n    this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));\n  }\n\n  // generate ICB (initial counter block)\n  this._inBlock = this._j0.slice(0);\n  inc32(this._inBlock);\n  this._partialBytes = 0;\n\n  // consume authentication data\n  additionalData = forge.util.createBuffer(additionalData);\n  // save additional data length as a BE 64-bit number\n  this._aDataLength = from64To32(additionalData.length() * 8);\n  // pad additional data to 128 bit (16 byte) block size\n  var overflow = additionalData.length() % this.blockSize;\n  if (overflow) {\n    additionalData.fillWithByte(0, this.blockSize - overflow);\n  }\n  this._s = [0, 0, 0, 0];\n  while (additionalData.length() > 0) {\n    this._s = this.ghash(this._hashSubkey, this._s, [additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32()]);\n  }\n};\nmodes.gcm.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if (inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for (var i = 0; i < this._ints; ++i) {\n      output.putInt32(this._outBlock[i] ^= input.getInt32());\n    }\n    this._cipherLength += this.blockSize;\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if (partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    }\n\n    // XOR input with output\n    this._partialOutput.clear();\n    for (var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n    if (partialBytes <= 0 || finish) {\n      // handle overflow prior to hashing\n      if (finish) {\n        // get block overflow\n        var overflow = inputLength % this.blockSize;\n        this._cipherLength += overflow;\n        // truncate for hash function\n        this._partialOutput.truncate(this.blockSize - overflow);\n      } else {\n        this._cipherLength += this.blockSize;\n      }\n\n      // get output block for hashing\n      for (var i = 0; i < this._ints; ++i) {\n        this._outBlock[i] = this._partialOutput.getInt32();\n      }\n      this._partialOutput.read -= this.blockSize;\n    }\n\n    // skip any previous partial bytes\n    if (this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n    if (partialBytes > 0 && !finish) {\n      // block still incomplete, restore input buffer, get partial output,\n      // and return early\n      input.read -= this.blockSize;\n      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  }\n\n  // update hash block S\n  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);\n\n  // increment counter (input block)\n  inc32(this._inBlock);\n};\nmodes.gcm.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n  if (inputLength < this.blockSize && !(finish && inputLength > 0)) {\n    return true;\n  }\n\n  // encrypt block (GCM always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // increment counter (input block)\n  inc32(this._inBlock);\n\n  // update hash block S\n  this._hashBlock[0] = input.getInt32();\n  this._hashBlock[1] = input.getInt32();\n  this._hashBlock[2] = input.getInt32();\n  this._hashBlock[3] = input.getInt32();\n  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);\n\n  // XOR hash input with output\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\n  }\n\n  // increment cipher data length\n  if (inputLength < this.blockSize) {\n    this._cipherLength += inputLength % this.blockSize;\n  } else {\n    this._cipherLength += this.blockSize;\n  }\n};\nmodes.gcm.prototype.afterFinish = function (output, options) {\n  var rval = true;\n\n  // handle overflow\n  if (options.decrypt && options.overflow) {\n    output.truncate(this.blockSize - options.overflow);\n  }\n\n  // handle authentication tag\n  this.tag = forge.util.createBuffer();\n\n  // concatenate additional data length with cipher length\n  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));\n\n  // include lengths in hash\n  this._s = this.ghash(this._hashSubkey, this._s, lengths);\n\n  // do GCTR(J_0, S)\n  var tag = [];\n  this.cipher.encrypt(this._j0, tag);\n  for (var i = 0; i < this._ints; ++i) {\n    this.tag.putInt32(this._s[i] ^ tag[i]);\n  }\n\n  // trim tag to length\n  this.tag.truncate(this.tag.length() % (this._tagLength / 8));\n\n  // check authentication tag\n  if (options.decrypt && this.tag.bytes() !== this._tag) {\n    rval = false;\n  }\n  return rval;\n};\n\n/**\n * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois\n * field multiplication. The field, GF(2^128), is defined by the polynomial:\n *\n * x^128 + x^7 + x^2 + x + 1\n *\n * Which is represented in little-endian binary form as: 11100001 (0xe1). When\n * the value of a coefficient is 1, a bit is set. The value R, is the\n * concatenation of this value and 120 zero bits, yielding a 128-bit value\n * which matches the block size.\n *\n * This function will multiply two elements (vectors of bytes), X and Y, in\n * the field GF(2^128). The result is initialized to zero. For each bit of\n * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)\n * by the current value of Y. For each bit, the value of Y will be raised by\n * a power of x (multiplied by the polynomial x). This can be achieved by\n * shifting Y once to the right. If the current value of Y, prior to being\n * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.\n * Otherwise, we must divide by R after shifting to find the remainder.\n *\n * @param x the first block to multiply by the second.\n * @param y the second block to multiply by the first.\n *\n * @return the block result of the multiplication.\n */\nmodes.gcm.prototype.multiply = function (x, y) {\n  var z_i = [0, 0, 0, 0];\n  var v_i = y.slice(0);\n\n  // calculate Z_128 (block has 128 bits)\n  for (var i = 0; i < 128; ++i) {\n    // if x_i is 0, Z_{i+1} = Z_i (unchanged)\n    // else Z_{i+1} = Z_i ^ V_i\n    // get x_i by finding 32-bit int position, then left shift 1 by remainder\n    var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;\n    if (x_i) {\n      z_i[0] ^= v_i[0];\n      z_i[1] ^= v_i[1];\n      z_i[2] ^= v_i[2];\n      z_i[3] ^= v_i[3];\n    }\n\n    // if LSB(V_i) is 1, V_i = V_i >> 1\n    // else V_i = (V_i >> 1) ^ R\n    this.pow(v_i, v_i);\n  }\n  return z_i;\n};\nmodes.gcm.prototype.pow = function (x, out) {\n  // if LSB(x) is 1, x = x >>> 1\n  // else x = (x >>> 1) ^ R\n  var lsb = x[3] & 1;\n\n  // always do x >>> 1:\n  // starting with the rightmost integer, shift each integer to the right\n  // one bit, pulling in the bit from the integer to the left as its top\n  // most bit (do this for the last 3 integers)\n  for (var i = 3; i > 0; --i) {\n    out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;\n  }\n  // shift the first integer normally\n  out[0] = x[0] >>> 1;\n\n  // if lsb was not set, then polynomial had a degree of 127 and doesn't\n  // need to divided; otherwise, XOR with R to find the remainder; we only\n  // need to XOR the first integer since R technically ends w/120 zero bits\n  if (lsb) {\n    out[0] ^= this._R;\n  }\n};\nmodes.gcm.prototype.tableMultiply = function (x) {\n  // assumes 4-bit tables are used\n  var z = [0, 0, 0, 0];\n  for (var i = 0; i < 32; ++i) {\n    var idx = i / 8 | 0;\n    var x_i = x[idx] >>> (7 - i % 8) * 4 & 0xF;\n    var ah = this._m[i][x_i];\n    z[0] ^= ah[0];\n    z[1] ^= ah[1];\n    z[2] ^= ah[2];\n    z[3] ^= ah[3];\n  }\n  return z;\n};\n\n/**\n * A continuing version of the GHASH algorithm that operates on a single\n * block. The hash block, last hash value (Ym) and the new block to hash\n * are given.\n *\n * @param h the hash block.\n * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.\n * @param x the block to hash.\n *\n * @return the hashed value (Ym).\n */\nmodes.gcm.prototype.ghash = function (h, y, x) {\n  y[0] ^= x[0];\n  y[1] ^= x[1];\n  y[2] ^= x[2];\n  y[3] ^= x[3];\n  return this.tableMultiply(y);\n  //return this.multiply(y, h);\n};\n\n/**\n * Precomputes a table for multiplying against the hash subkey. This\n * mechanism provides a substantial speed increase over multiplication\n * performed without a table. The table-based multiplication this table is\n * for solves X * H by multiplying each component of X by H and then\n * composing the results together using XOR.\n *\n * This function can be used to generate tables with different bit sizes\n * for the components, however, this implementation assumes there are\n * 32 components of X (which is a 16 byte vector), therefore each component\n * takes 4-bits (so the table is constructed with bits=4).\n *\n * @param h the hash subkey.\n * @param bits the bit size for a component.\n */\nmodes.gcm.prototype.generateHashTable = function (h, bits) {\n  // TODO: There are further optimizations that would use only the\n  // first table M_0 (or some variant) along with a remainder table;\n  // this can be explored in the future\n  var multiplier = 8 / bits;\n  var perInt = 4 * multiplier;\n  var size = 16 * multiplier;\n  var m = new Array(size);\n  for (var i = 0; i < size; ++i) {\n    var tmp = [0, 0, 0, 0];\n    var idx = i / perInt | 0;\n    var shft = (perInt - 1 - i % perInt) * bits;\n    tmp[idx] = 1 << bits - 1 << shft;\n    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\n  }\n  return m;\n};\n\n/**\n * Generates a table for multiplying against the hash subkey for one\n * particular component (out of all possible component values).\n *\n * @param mid the pre-multiplied value for the middle key of the table.\n * @param bits the bit size for a component.\n */\nmodes.gcm.prototype.generateSubHashTable = function (mid, bits) {\n  // compute the table quickly by minimizing the number of\n  // POW operations -- they only need to be performed for powers of 2,\n  // all other entries can be composed from those powers using XOR\n  var size = 1 << bits;\n  var half = size >>> 1;\n  var m = new Array(size);\n  m[half] = mid.slice(0);\n  var i = half >>> 1;\n  while (i > 0) {\n    // raise m0[2 * i] and store in m0[i]\n    this.pow(m[2 * i], m[i] = []);\n    i >>= 1;\n  }\n  i = 2;\n  while (i < half) {\n    for (var j = 1; j < i; ++j) {\n      var m_i = m[i];\n      var m_j = m[j];\n      m[i + j] = [m_i[0] ^ m_j[0], m_i[1] ^ m_j[1], m_i[2] ^ m_j[2], m_i[3] ^ m_j[3]];\n    }\n    i *= 2;\n  }\n  m[0] = [0, 0, 0, 0];\n  /* Note: We could avoid storing these by doing composition during multiply\n  calculate top half using composition by speed is preferred. */\n  for (i = half + 1; i < size; ++i) {\n    var c = m[i ^ half];\n    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];\n  }\n  return m;\n};\n\n/** Utility functions */\n\nfunction transformIV(iv, blockSize) {\n  if (typeof iv === 'string') {\n    // convert iv string into byte buffer\n    iv = forge.util.createBuffer(iv);\n  }\n  if (forge.util.isArray(iv) && iv.length > 4) {\n    // convert iv byte array into byte buffer\n    var tmp = iv;\n    iv = forge.util.createBuffer();\n    for (var i = 0; i < tmp.length; ++i) {\n      iv.putByte(tmp[i]);\n    }\n  }\n  if (iv.length() < blockSize) {\n    throw new Error('Invalid IV length; got ' + iv.length() + ' bytes and expected ' + blockSize + ' bytes.');\n  }\n  if (!forge.util.isArray(iv)) {\n    // convert iv byte buffer into 32-bit integer array\n    var ints = [];\n    var blocks = blockSize / 4;\n    for (var i = 0; i < blocks; ++i) {\n      ints.push(iv.getInt32());\n    }\n    iv = ints;\n  }\n  return iv;\n}\nfunction inc32(block) {\n  // increment last 32 bits of block only\n  block[block.length - 1] = block[block.length - 1] + 1 & 0xFFFFFFFF;\n}\nfunction from64To32(num) {\n  // convert 64-bit number to two BE Int32s\n  return [num / 0x100000000 | 0, num & 0xFFFFFFFF];\n}","map":{"version":3,"names":["forge","require","cipher","modes","module","exports","ecb","options","name","blockSize","_ints","_inBlock","Array","_outBlock","prototype","start","encrypt","input","output","finish","length","i","getInt32","putInt32","decrypt","pad","padding","fillWithByte","unpad","overflow","len","count","at","truncate","cbc","iv","_prev","Error","_iv","slice","transformIV","cfb","_partialBlock","_partialOutput","util","createBuffer","_partialBytes","inputLength","partialBytes","clear","read","getBytes","putBytes","ofb","ctr","inc32","gcm","_R","_cipherLength","additionalData","_tagLength","tagLength","_tag","tag","_hashBlock","_hashSubkey","componentBits","_m","generateHashTable","ivLength","_j0","ghash","concat","from64To32","_aDataLength","_s","afterFinish","rval","lengths","bytes","multiply","x","y","z_i","v_i","x_i","pow","out","lsb","tableMultiply","z","idx","ah","h","bits","multiplier","perInt","size","m","tmp","shft","generateSubHashTable","mid","half","j","m_i","m_j","c","isArray","putByte","ints","blocks","push","block","num"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/node-forge/lib/cipherModes.js"],"sourcesContent":["/**\n * Supported cipher modes.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nforge.cipher = forge.cipher || {};\n\n// supported cipher modes\nvar modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};\n\n/** Electronic codebook (ECB) (Don't use this; it's not secure) **/\n\nmodes.ecb = function(options) {\n  options = options || {};\n  this.name = 'ECB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.ecb.prototype.start = function(options) {};\n\nmodes.ecb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.pad = function(input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = (input.length() === this.blockSize ?\n    this.blockSize : (this.blockSize - input.length()));\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.ecb.prototype.unpad = function(output, options) {\n  // check for error: input data not a multiple of blockSize\n  if(options.overflow > 0) {\n    return false;\n  }\n\n  // ensure padding byte count is valid\n  var len = output.length();\n  var count = output.at(len - 1);\n  if(count > (this.blockSize << 2)) {\n    return false;\n  }\n\n  // trim off padding bytes\n  output.truncate(count);\n  return true;\n};\n\n/** Cipher-block Chaining (CBC) **/\n\nmodes.cbc = function(options) {\n  options = options || {};\n  this.name = 'CBC';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.cbc.prototype.start = function(options) {\n  // Note: legacy support for using IV residue (has security flaws)\n  // if IV is null, reuse block from previous processing\n  if(options.iv === null) {\n    // must have a previous block\n    if(!this._prev) {\n      throw new Error('Invalid IV parameter.');\n    }\n    this._iv = this._prev.slice(0);\n  } else if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } else {\n    // save IV as \"previous\" block\n    this._iv = transformIV(options.iv, this.blockSize);\n    this._prev = this._iv.slice(0);\n  }\n};\n\nmodes.cbc.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  // CBC XOR's IV (or previous block) with plaintext\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = this._prev[i] ^ input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output, save previous block\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n  this._prev = this._outBlock;\n};\n\nmodes.cbc.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output, save previous ciphered block\n  // CBC XOR's IV (or previous block) with ciphertext\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._prev[i] ^ this._outBlock[i]);\n  }\n  this._prev = this._inBlock.slice(0);\n};\n\nmodes.cbc.prototype.pad = function(input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = (input.length() === this.blockSize ?\n    this.blockSize : (this.blockSize - input.length()));\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.cbc.prototype.unpad = function(output, options) {\n  // check for error: input data not a multiple of blockSize\n  if(options.overflow > 0) {\n    return false;\n  }\n\n  // ensure padding byte count is valid\n  var len = output.length();\n  var count = output.at(len - 1);\n  if(count > (this.blockSize << 2)) {\n    return false;\n  }\n\n  // trim off padding bytes\n  output.truncate(count);\n  return true;\n};\n\n/** Cipher feedback (CFB) **/\n\nmodes.cfb = function(options) {\n  options = options || {};\n  this.name = 'CFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\n      output.putInt32(this._inBlock[i]);\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output, write input as partial output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\n    this._partialOutput.putInt32(this._partialBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block (CFB always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32();\n      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output, write input as partial output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32();\n    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\n/** Output feedback (OFB) **/\n\nmodes.ofb = function(options) {\n  options = options || {};\n  this.name = 'OFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(input.length() === 0) {\n    return true;\n  }\n\n  // encrypt block (OFB always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output and update next input\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n      this._inBlock[i] = this._outBlock[i];\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._outBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\n\n/** Counter (CTR) **/\n\nmodes.ctr = function(options) {\n  options = options || {};\n  this.name = 'CTR';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block (CTR always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if(partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    }\n\n    // XOR input with output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if(partialBytes > 0) {\n      // block still incomplete, restore input buffer\n      input.read -= this.blockSize;\n    }\n\n    // skip any previous partial bytes\n    if(this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if(partialBytes > 0 && !finish) {\n      output.putBytes(this._partialOutput.getBytes(\n        partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(\n      inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  }\n\n  // block complete, increment counter (input block)\n  inc32(this._inBlock);\n};\n\nmodes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\n\n/** Galois/Counter Mode (GCM) **/\n\nmodes.gcm = function(options) {\n  options = options || {};\n  this.name = 'GCM';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n\n  // R is actually this value concatenated with 120 more zero bits, but\n  // we only XOR against R so the other zeros have no effect -- we just\n  // apply this value to the first integer in a block\n  this._R = 0xE1000000;\n};\n\nmodes.gcm.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // ensure IV is a byte buffer\n  var iv = forge.util.createBuffer(options.iv);\n\n  // no ciphered data processed yet\n  this._cipherLength = 0;\n\n  // default additional data is none\n  var additionalData;\n  if('additionalData' in options) {\n    additionalData = forge.util.createBuffer(options.additionalData);\n  } else {\n    additionalData = forge.util.createBuffer();\n  }\n\n  // default tag length is 128 bits\n  if('tagLength' in options) {\n    this._tagLength = options.tagLength;\n  } else {\n    this._tagLength = 128;\n  }\n\n  // if tag is given, ensure tag matches tag length\n  this._tag = null;\n  if(options.decrypt) {\n    // save tag to check later\n    this._tag = forge.util.createBuffer(options.tag).getBytes();\n    if(this._tag.length !== (this._tagLength / 8)) {\n      throw new Error('Authentication tag does not match tag length.');\n    }\n  }\n\n  // create tmp storage for hash calculation\n  this._hashBlock = new Array(this._ints);\n\n  // no tag generated yet\n  this.tag = null;\n\n  // generate hash subkey\n  // (apply block cipher to \"zero\" block)\n  this._hashSubkey = new Array(this._ints);\n  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);\n\n  // generate table M\n  // use 4-bit tables (32 component decomposition of a 16 byte value)\n  // 8-bit tables take more space and are known to have security\n  // vulnerabilities (in native implementations)\n  this.componentBits = 4;\n  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);\n\n  // Note: support IV length different from 96 bits? (only supporting\n  // 96 bits is recommended by NIST SP-800-38D)\n  // generate J_0\n  var ivLength = iv.length();\n  if(ivLength === 12) {\n    // 96-bit IV\n    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];\n  } else {\n    // IV is NOT 96-bits\n    this._j0 = [0, 0, 0, 0];\n    while(iv.length() > 0) {\n      this._j0 = this.ghash(\n        this._hashSubkey, this._j0,\n        [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);\n    }\n    this._j0 = this.ghash(\n      this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));\n  }\n\n  // generate ICB (initial counter block)\n  this._inBlock = this._j0.slice(0);\n  inc32(this._inBlock);\n  this._partialBytes = 0;\n\n  // consume authentication data\n  additionalData = forge.util.createBuffer(additionalData);\n  // save additional data length as a BE 64-bit number\n  this._aDataLength = from64To32(additionalData.length() * 8);\n  // pad additional data to 128 bit (16 byte) block size\n  var overflow = additionalData.length() % this.blockSize;\n  if(overflow) {\n    additionalData.fillWithByte(0, this.blockSize - overflow);\n  }\n  this._s = [0, 0, 0, 0];\n  while(additionalData.length() > 0) {\n    this._s = this.ghash(this._hashSubkey, this._s, [\n      additionalData.getInt32(),\n      additionalData.getInt32(),\n      additionalData.getInt32(),\n      additionalData.getInt32()\n    ]);\n  }\n};\n\nmodes.gcm.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(this._outBlock[i] ^= input.getInt32());\n    }\n    this._cipherLength += this.blockSize;\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if(partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    }\n\n    // XOR input with output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if(partialBytes <= 0 || finish) {\n      // handle overflow prior to hashing\n      if(finish) {\n        // get block overflow\n        var overflow = inputLength % this.blockSize;\n        this._cipherLength += overflow;\n        // truncate for hash function\n        this._partialOutput.truncate(this.blockSize - overflow);\n      } else {\n        this._cipherLength += this.blockSize;\n      }\n\n      // get output block for hashing\n      for(var i = 0; i < this._ints; ++i) {\n        this._outBlock[i] = this._partialOutput.getInt32();\n      }\n      this._partialOutput.read -= this.blockSize;\n    }\n\n    // skip any previous partial bytes\n    if(this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if(partialBytes > 0 && !finish) {\n      // block still incomplete, restore input buffer, get partial output,\n      // and return early\n      input.read -= this.blockSize;\n      output.putBytes(this._partialOutput.getBytes(\n        partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(\n      inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  }\n\n  // update hash block S\n  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);\n\n  // increment counter (input block)\n  inc32(this._inBlock);\n};\n\nmodes.gcm.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n  if(inputLength < this.blockSize && !(finish && inputLength > 0)) {\n    return true;\n  }\n\n  // encrypt block (GCM always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // increment counter (input block)\n  inc32(this._inBlock);\n\n  // update hash block S\n  this._hashBlock[0] = input.getInt32();\n  this._hashBlock[1] = input.getInt32();\n  this._hashBlock[2] = input.getInt32();\n  this._hashBlock[3] = input.getInt32();\n  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);\n\n  // XOR hash input with output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\n  }\n\n  // increment cipher data length\n  if(inputLength < this.blockSize) {\n    this._cipherLength += inputLength % this.blockSize;\n  } else {\n    this._cipherLength += this.blockSize;\n  }\n};\n\nmodes.gcm.prototype.afterFinish = function(output, options) {\n  var rval = true;\n\n  // handle overflow\n  if(options.decrypt && options.overflow) {\n    output.truncate(this.blockSize - options.overflow);\n  }\n\n  // handle authentication tag\n  this.tag = forge.util.createBuffer();\n\n  // concatenate additional data length with cipher length\n  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));\n\n  // include lengths in hash\n  this._s = this.ghash(this._hashSubkey, this._s, lengths);\n\n  // do GCTR(J_0, S)\n  var tag = [];\n  this.cipher.encrypt(this._j0, tag);\n  for(var i = 0; i < this._ints; ++i) {\n    this.tag.putInt32(this._s[i] ^ tag[i]);\n  }\n\n  // trim tag to length\n  this.tag.truncate(this.tag.length() % (this._tagLength / 8));\n\n  // check authentication tag\n  if(options.decrypt && this.tag.bytes() !== this._tag) {\n    rval = false;\n  }\n\n  return rval;\n};\n\n/**\n * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois\n * field multiplication. The field, GF(2^128), is defined by the polynomial:\n *\n * x^128 + x^7 + x^2 + x + 1\n *\n * Which is represented in little-endian binary form as: 11100001 (0xe1). When\n * the value of a coefficient is 1, a bit is set. The value R, is the\n * concatenation of this value and 120 zero bits, yielding a 128-bit value\n * which matches the block size.\n *\n * This function will multiply two elements (vectors of bytes), X and Y, in\n * the field GF(2^128). The result is initialized to zero. For each bit of\n * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)\n * by the current value of Y. For each bit, the value of Y will be raised by\n * a power of x (multiplied by the polynomial x). This can be achieved by\n * shifting Y once to the right. If the current value of Y, prior to being\n * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.\n * Otherwise, we must divide by R after shifting to find the remainder.\n *\n * @param x the first block to multiply by the second.\n * @param y the second block to multiply by the first.\n *\n * @return the block result of the multiplication.\n */\nmodes.gcm.prototype.multiply = function(x, y) {\n  var z_i = [0, 0, 0, 0];\n  var v_i = y.slice(0);\n\n  // calculate Z_128 (block has 128 bits)\n  for(var i = 0; i < 128; ++i) {\n    // if x_i is 0, Z_{i+1} = Z_i (unchanged)\n    // else Z_{i+1} = Z_i ^ V_i\n    // get x_i by finding 32-bit int position, then left shift 1 by remainder\n    var x_i = x[(i / 32) | 0] & (1 << (31 - i % 32));\n    if(x_i) {\n      z_i[0] ^= v_i[0];\n      z_i[1] ^= v_i[1];\n      z_i[2] ^= v_i[2];\n      z_i[3] ^= v_i[3];\n    }\n\n    // if LSB(V_i) is 1, V_i = V_i >> 1\n    // else V_i = (V_i >> 1) ^ R\n    this.pow(v_i, v_i);\n  }\n\n  return z_i;\n};\n\nmodes.gcm.prototype.pow = function(x, out) {\n  // if LSB(x) is 1, x = x >>> 1\n  // else x = (x >>> 1) ^ R\n  var lsb = x[3] & 1;\n\n  // always do x >>> 1:\n  // starting with the rightmost integer, shift each integer to the right\n  // one bit, pulling in the bit from the integer to the left as its top\n  // most bit (do this for the last 3 integers)\n  for(var i = 3; i > 0; --i) {\n    out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31);\n  }\n  // shift the first integer normally\n  out[0] = x[0] >>> 1;\n\n  // if lsb was not set, then polynomial had a degree of 127 and doesn't\n  // need to divided; otherwise, XOR with R to find the remainder; we only\n  // need to XOR the first integer since R technically ends w/120 zero bits\n  if(lsb) {\n    out[0] ^= this._R;\n  }\n};\n\nmodes.gcm.prototype.tableMultiply = function(x) {\n  // assumes 4-bit tables are used\n  var z = [0, 0, 0, 0];\n  for(var i = 0; i < 32; ++i) {\n    var idx = (i / 8) | 0;\n    var x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF;\n    var ah = this._m[i][x_i];\n    z[0] ^= ah[0];\n    z[1] ^= ah[1];\n    z[2] ^= ah[2];\n    z[3] ^= ah[3];\n  }\n  return z;\n};\n\n/**\n * A continuing version of the GHASH algorithm that operates on a single\n * block. The hash block, last hash value (Ym) and the new block to hash\n * are given.\n *\n * @param h the hash block.\n * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.\n * @param x the block to hash.\n *\n * @return the hashed value (Ym).\n */\nmodes.gcm.prototype.ghash = function(h, y, x) {\n  y[0] ^= x[0];\n  y[1] ^= x[1];\n  y[2] ^= x[2];\n  y[3] ^= x[3];\n  return this.tableMultiply(y);\n  //return this.multiply(y, h);\n};\n\n/**\n * Precomputes a table for multiplying against the hash subkey. This\n * mechanism provides a substantial speed increase over multiplication\n * performed without a table. The table-based multiplication this table is\n * for solves X * H by multiplying each component of X by H and then\n * composing the results together using XOR.\n *\n * This function can be used to generate tables with different bit sizes\n * for the components, however, this implementation assumes there are\n * 32 components of X (which is a 16 byte vector), therefore each component\n * takes 4-bits (so the table is constructed with bits=4).\n *\n * @param h the hash subkey.\n * @param bits the bit size for a component.\n */\nmodes.gcm.prototype.generateHashTable = function(h, bits) {\n  // TODO: There are further optimizations that would use only the\n  // first table M_0 (or some variant) along with a remainder table;\n  // this can be explored in the future\n  var multiplier = 8 / bits;\n  var perInt = 4 * multiplier;\n  var size = 16 * multiplier;\n  var m = new Array(size);\n  for(var i = 0; i < size; ++i) {\n    var tmp = [0, 0, 0, 0];\n    var idx = (i / perInt) | 0;\n    var shft = ((perInt - 1 - (i % perInt)) * bits);\n    tmp[idx] = (1 << (bits - 1)) << shft;\n    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\n  }\n  return m;\n};\n\n/**\n * Generates a table for multiplying against the hash subkey for one\n * particular component (out of all possible component values).\n *\n * @param mid the pre-multiplied value for the middle key of the table.\n * @param bits the bit size for a component.\n */\nmodes.gcm.prototype.generateSubHashTable = function(mid, bits) {\n  // compute the table quickly by minimizing the number of\n  // POW operations -- they only need to be performed for powers of 2,\n  // all other entries can be composed from those powers using XOR\n  var size = 1 << bits;\n  var half = size >>> 1;\n  var m = new Array(size);\n  m[half] = mid.slice(0);\n  var i = half >>> 1;\n  while(i > 0) {\n    // raise m0[2 * i] and store in m0[i]\n    this.pow(m[2 * i], m[i] = []);\n    i >>= 1;\n  }\n  i = 2;\n  while(i < half) {\n    for(var j = 1; j < i; ++j) {\n      var m_i = m[i];\n      var m_j = m[j];\n      m[i + j] = [\n        m_i[0] ^ m_j[0],\n        m_i[1] ^ m_j[1],\n        m_i[2] ^ m_j[2],\n        m_i[3] ^ m_j[3]\n      ];\n    }\n    i *= 2;\n  }\n  m[0] = [0, 0, 0, 0];\n  /* Note: We could avoid storing these by doing composition during multiply\n  calculate top half using composition by speed is preferred. */\n  for(i = half + 1; i < size; ++i) {\n    var c = m[i ^ half];\n    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];\n  }\n  return m;\n};\n\n/** Utility functions */\n\nfunction transformIV(iv, blockSize) {\n  if(typeof iv === 'string') {\n    // convert iv string into byte buffer\n    iv = forge.util.createBuffer(iv);\n  }\n\n  if(forge.util.isArray(iv) && iv.length > 4) {\n    // convert iv byte array into byte buffer\n    var tmp = iv;\n    iv = forge.util.createBuffer();\n    for(var i = 0; i < tmp.length; ++i) {\n      iv.putByte(tmp[i]);\n    }\n  }\n\n  if(iv.length() < blockSize) {\n    throw new Error(\n      'Invalid IV length; got ' + iv.length() +\n      ' bytes and expected ' + blockSize + ' bytes.');\n  }\n\n  if(!forge.util.isArray(iv)) {\n    // convert iv byte buffer into 32-bit integer array\n    var ints = [];\n    var blocks = blockSize / 4;\n    for(var i = 0; i < blocks; ++i) {\n      ints.push(iv.getInt32());\n    }\n    iv = ints;\n  }\n\n  return iv;\n}\n\nfunction inc32(block) {\n  // increment last 32 bits of block only\n  block[block.length - 1] = (block[block.length - 1] + 1) & 0xFFFFFFFF;\n}\n\nfunction from64To32(num) {\n  // convert 64-bit number to two BE Int32s\n  return [(num / 0x100000000) | 0, num & 0xFFFFFFFF];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}