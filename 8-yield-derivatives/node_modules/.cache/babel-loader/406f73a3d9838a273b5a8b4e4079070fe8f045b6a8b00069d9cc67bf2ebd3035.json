{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\nvar Transform = require('stream').Transform;\nvar StringDecoder = require('string_decoder').StringDecoder;\nvar inherits = require('inherits');\nfunction CipherBase(hashMode) {\n  Transform.call(this);\n  this.hashMode = typeof hashMode === 'string';\n  if (this.hashMode) {\n    this[hashMode] = this._finalOrDigest;\n  } else {\n    this.final = this._finalOrDigest;\n  }\n  if (this._final) {\n    this.__final = this._final;\n    this._final = null;\n  }\n  this._decoder = null;\n  this._encoding = null;\n}\ninherits(CipherBase, Transform);\nCipherBase.prototype.update = function (data, inputEnc, outputEnc) {\n  if (typeof data === 'string') {\n    data = Buffer.from(data, inputEnc);\n  }\n  var outData = this._update(data);\n  if (this.hashMode) return this;\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc);\n  }\n  return outData;\n};\nCipherBase.prototype.setAutoPadding = function () {};\nCipherBase.prototype.getAuthTag = function () {\n  throw new Error('trying to get auth tag in unsupported state');\n};\nCipherBase.prototype.setAuthTag = function () {\n  throw new Error('trying to set auth tag in unsupported state');\n};\nCipherBase.prototype.setAAD = function () {\n  throw new Error('trying to set aad in unsupported state');\n};\nCipherBase.prototype._transform = function (data, _, next) {\n  var err;\n  try {\n    if (this.hashMode) {\n      this._update(data);\n    } else {\n      this.push(this._update(data));\n    }\n  } catch (e) {\n    err = e;\n  } finally {\n    next(err);\n  }\n};\nCipherBase.prototype._flush = function (done) {\n  var err;\n  try {\n    this.push(this.__final());\n  } catch (e) {\n    err = e;\n  }\n  done(err);\n};\nCipherBase.prototype._finalOrDigest = function (outputEnc) {\n  var outData = this.__final() || Buffer.alloc(0);\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc, true);\n  }\n  return outData;\n};\nCipherBase.prototype._toString = function (value, enc, fin) {\n  if (!this._decoder) {\n    this._decoder = new StringDecoder(enc);\n    this._encoding = enc;\n  }\n  if (this._encoding !== enc) throw new Error('can\\'t switch encodings');\n  var out = this._decoder.write(value);\n  if (fin) {\n    out += this._decoder.end();\n  }\n  return out;\n};\nmodule.exports = CipherBase;","map":{"version":3,"names":["Buffer","require","Transform","StringDecoder","inherits","CipherBase","hashMode","call","_finalOrDigest","final","_final","__final","_decoder","_encoding","prototype","update","data","inputEnc","outputEnc","from","outData","_update","_toString","setAutoPadding","getAuthTag","Error","setAuthTag","setAAD","_transform","_","next","err","push","e","_flush","done","alloc","value","enc","fin","out","write","end","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/cipher-base/index.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar Transform = require('stream').Transform\nvar StringDecoder = require('string_decoder').StringDecoder\nvar inherits = require('inherits')\n\nfunction CipherBase (hashMode) {\n  Transform.call(this)\n  this.hashMode = typeof hashMode === 'string'\n  if (this.hashMode) {\n    this[hashMode] = this._finalOrDigest\n  } else {\n    this.final = this._finalOrDigest\n  }\n  if (this._final) {\n    this.__final = this._final\n    this._final = null\n  }\n  this._decoder = null\n  this._encoding = null\n}\ninherits(CipherBase, Transform)\n\nCipherBase.prototype.update = function (data, inputEnc, outputEnc) {\n  if (typeof data === 'string') {\n    data = Buffer.from(data, inputEnc)\n  }\n\n  var outData = this._update(data)\n  if (this.hashMode) return this\n\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc)\n  }\n\n  return outData\n}\n\nCipherBase.prototype.setAutoPadding = function () {}\nCipherBase.prototype.getAuthTag = function () {\n  throw new Error('trying to get auth tag in unsupported state')\n}\n\nCipherBase.prototype.setAuthTag = function () {\n  throw new Error('trying to set auth tag in unsupported state')\n}\n\nCipherBase.prototype.setAAD = function () {\n  throw new Error('trying to set aad in unsupported state')\n}\n\nCipherBase.prototype._transform = function (data, _, next) {\n  var err\n  try {\n    if (this.hashMode) {\n      this._update(data)\n    } else {\n      this.push(this._update(data))\n    }\n  } catch (e) {\n    err = e\n  } finally {\n    next(err)\n  }\n}\nCipherBase.prototype._flush = function (done) {\n  var err\n  try {\n    this.push(this.__final())\n  } catch (e) {\n    err = e\n  }\n\n  done(err)\n}\nCipherBase.prototype._finalOrDigest = function (outputEnc) {\n  var outData = this.__final() || Buffer.alloc(0)\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc, true)\n  }\n  return outData\n}\n\nCipherBase.prototype._toString = function (value, enc, fin) {\n  if (!this._decoder) {\n    this._decoder = new StringDecoder(enc)\n    this._encoding = enc\n  }\n\n  if (this._encoding !== enc) throw new Error('can\\'t switch encodings')\n\n  var out = this._decoder.write(value)\n  if (fin) {\n    out += this._decoder.end()\n  }\n\n  return out\n}\n\nmodule.exports = CipherBase\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}