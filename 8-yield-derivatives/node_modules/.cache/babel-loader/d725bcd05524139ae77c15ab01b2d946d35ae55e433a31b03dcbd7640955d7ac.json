{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Mnemonic = exports.byteCountFromEntropyStrength = exports.entropyInBitsFromWordCount = exports.strengthFromWordCount = exports.mnemonicStrengthSupportedByBIP39 = exports.languagesSupportedByBIP39 = exports.wordlistFromLanguage = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\nconst _types_1 = require(\"./_types\");\nconst bip39_1 = require(\"bip39\");\nconst util_1 = require(\"@radixdlt/util\");\nconst wordlistFromLanguage = language => {\n  const key = _types_1.LanguageT[language].toLowerCase();\n  return bip39_1.wordlists[key];\n};\nexports.wordlistFromLanguage = wordlistFromLanguage;\nexports.languagesSupportedByBIP39 = [_types_1.LanguageT.CZECH, _types_1.LanguageT.CHINESE_SIMPLIFIED, _types_1.LanguageT.CHINESE_TRADITIONAL, _types_1.LanguageT.KOREAN, _types_1.LanguageT.FRENCH, _types_1.LanguageT.ITALIAN, _types_1.LanguageT.SPANISH, _types_1.LanguageT.JAPANESE, _types_1.LanguageT.ENGLISH];\nexports.mnemonicStrengthSupportedByBIP39 = [_types_1.StrengthT.WORD_COUNT_12, _types_1.StrengthT.WORD_COUNT_15, _types_1.StrengthT.WORD_COUNT_18, _types_1.StrengthT.WORD_COUNT_21, _types_1.StrengthT.WORD_COUNT_24];\nconst separator = ' ';\nconst strengthFromWordCount = wordCount => wordCount === 24 ? (0, neverthrow_1.ok)(_types_1.StrengthT.WORD_COUNT_24) : wordCount === 21 ? (0, neverthrow_1.ok)(_types_1.StrengthT.WORD_COUNT_21) : wordCount === 18 ? (0, neverthrow_1.ok)(_types_1.StrengthT.WORD_COUNT_18) : wordCount === 15 ? (0, neverthrow_1.ok)(_types_1.StrengthT.WORD_COUNT_15) : wordCount === 12 ? (0, neverthrow_1.ok)(_types_1.StrengthT.WORD_COUNT_12) : (0, neverthrow_1.err)(Error(`Unsupported wordcount ${wordCount}`));\nexports.strengthFromWordCount = strengthFromWordCount;\nconst entropyInBitsFromWordCount = wordCount => {\n  const checksumBitsPerWord = 3;\n  return wordCount / checksumBitsPerWord * 32;\n};\nexports.entropyInBitsFromWordCount = entropyInBitsFromWordCount;\nconst byteCountFromEntropyStrength = strenght => strenght.valueOf() / 8;\nexports.byteCountFromEntropyStrength = byteCountFromEntropyStrength;\nconst create = input => {\n  const wordCount = input.words.length;\n  return (0, exports.strengthFromWordCount)(wordCount).andThen(strengthFromWC => {\n    if (strengthFromWC !== input.strength) {\n      const errMsg = `Mismatch between 'words' and 'strenght'.`;\n      util_1.log.error(errMsg);\n      return (0, neverthrow_1.err)(new Error(errMsg));\n    }\n    if ((0, exports.entropyInBitsFromWordCount)(wordCount) !== input.entropy.length * 8) {\n      const errMsg = `Mismatch 'words' and 'entropy'.`;\n      util_1.log.error(errMsg);\n      return (0, neverthrow_1.err)(new Error(errMsg));\n    }\n    if ((0, exports.byteCountFromEntropyStrength)(input.strength) !== input.entropy.length) {\n      const errMsg = `Mismatch 'strength' and 'entropy'.`;\n      util_1.log.error(errMsg);\n      return (0, neverthrow_1.err)(new Error(errMsg));\n    }\n    const wordlist = (0, exports.wordlistFromLanguage)(input.language);\n    const languageName = _types_1.LanguageT[input.language];\n    if (input.words.join(separator) !== input.phrase) {\n      const errMsg = `Mismatch between 'words' and 'phrase' ('phrase' possible non normalized (NFKD).).`;\n      util_1.log.error(errMsg);\n      return (0, neverthrow_1.err)(new Error(errMsg));\n    }\n    for (const word of input.words) {\n      if (!wordlist.includes(word)) {\n        const errMsg = `Mismatch between 'words' and 'language'`;\n        util_1.log.error(errMsg);\n        util_1.log.debug(`The word '${word}' was not found in mnemonic word list for language '${languageName}'`);\n        return (0, neverthrow_1.err)(new Error(errMsg));\n      }\n    }\n    return (0, neverthrow_1.ok)({\n      witness: 'valid input'\n    });\n  }).map(_ => Object.assign(Object.assign({}, input), {\n    toString: () => input.phrase,\n    equals: other => (0, util_1.buffersEquals)(input.entropy, other.entropy)\n  })).map(mnemonic => {\n    util_1.log.debug(`Successfully created mnemonic.`);\n    return mnemonic;\n  });\n};\nconst fromEntropyAndMaybeStrength = input => {\n  var _a;\n  const language = (_a = input === null || input === void 0 ? void 0 : input.language) !== null && _a !== void 0 ? _a : _types_1.LanguageT.ENGLISH;\n  const wordlist = (0, exports.wordlistFromLanguage)(language);\n  const phrase = (0, bip39_1.entropyToMnemonic)(input.entropy, wordlist);\n  if (!(0, bip39_1.validateMnemonic)(phrase, wordlist)) throw new Error('Incorrect implementation, should be able to always generate valid mnemonic');\n  const normalizedPhrase = phrase.normalize('NFKD');\n  const words = normalizedPhrase.split(separator);\n  const strengthOf = input.strength !== undefined ? (0, neverthrow_1.ok)(input.strength) : (0, exports.strengthFromWordCount)(words.length);\n  return strengthOf.andThen(strength => create(Object.assign(Object.assign({}, input), {\n    language,\n    strength,\n    phrase: normalizedPhrase,\n    words\n  })));\n};\nconst fromEntropy = input => fromEntropyAndMaybeStrength(input);\nconst generateNew = input => {\n  var _a, _b;\n  const strength = (_a = input === null || input === void 0 ? void 0 : input.strength) !== null && _a !== void 0 ? _a : _types_1.StrengthT.WORD_COUNT_12;\n  const secureRandom = (_b = input === null || input === void 0 ? void 0 : input.secureRandom) !== null && _b !== void 0 ? _b : util_1.secureRandomGenerator;\n  const entropyByteCount = (0, exports.byteCountFromEntropyStrength)(strength);\n  const entropy = Buffer.from(secureRandom.randomSecureBytes(entropyByteCount), 'hex');\n  return fromEntropyAndMaybeStrength(Object.assign(Object.assign({}, input), {\n    entropy,\n    strength\n  }))._unsafeUnwrap();\n};\nconst fromPhraseInLanguage = input => {\n  const wordlist = (0, exports.wordlistFromLanguage)(input.language);\n  const phrase = input.phrase;\n  let entropy;\n  try {\n    entropy = Buffer.from((0, bip39_1.mnemonicToEntropy)(phrase, wordlist), 'hex');\n  } catch (e) {\n    const errMsg = (0, util_1.msgFromError)(e);\n    if (errMsg === 'Invalid mnemonic checksum') {\n      const notChecksummedErr = 'Invalid mnemonic, it is not checksummed.';\n      util_1.log.error(notChecksummedErr);\n      return (0, neverthrow_1.err)(new Error(notChecksummedErr));\n    }\n    return (0, neverthrow_1.err)(e);\n  }\n  const normalizedPhrase = phrase.normalize('NFKD');\n  const words = normalizedPhrase.split(separator);\n  return (0, exports.strengthFromWordCount)(words.length).map(strength => Object.assign(Object.assign({}, input), {\n    phrase: normalizedPhrase,\n    words,\n    entropy,\n    strength\n  })).andThen(create);\n};\nconst fromWordsInLanguage = input => fromPhraseInLanguage({\n  phrase: input.words.join(separator),\n  language: input.language\n});\nconst fromEnglishPhrase = phrase => fromPhraseInLanguage({\n  phrase,\n  language: _types_1.LanguageT.ENGLISH\n});\nconst fromEnglishWords = words => fromWordsInLanguage({\n  words,\n  language: _types_1.LanguageT.ENGLISH\n});\nexports.Mnemonic = {\n  generateNew,\n  fromEntropy,\n  fromPhraseInLanguage,\n  fromWordsInLanguage,\n  fromEnglishPhrase,\n  fromEnglishWords\n};","map":{"version":3,"names":["neverthrow_1","require","_types_1","bip39_1","util_1","wordlistFromLanguage","language","key","LanguageT","toLowerCase","wordlists","exports","languagesSupportedByBIP39","CZECH","CHINESE_SIMPLIFIED","CHINESE_TRADITIONAL","KOREAN","FRENCH","ITALIAN","SPANISH","JAPANESE","ENGLISH","mnemonicStrengthSupportedByBIP39","StrengthT","WORD_COUNT_12","WORD_COUNT_15","WORD_COUNT_18","WORD_COUNT_21","WORD_COUNT_24","separator","strengthFromWordCount","wordCount","ok","err","Error","entropyInBitsFromWordCount","checksumBitsPerWord","byteCountFromEntropyStrength","strenght","valueOf","create","input","words","length","andThen","strengthFromWC","strength","errMsg","log","error","entropy","wordlist","languageName","join","phrase","word","includes","debug","witness","map","_","Object","assign","toString","equals","other","buffersEquals","mnemonic","fromEntropyAndMaybeStrength","_a","entropyToMnemonic","validateMnemonic","normalizedPhrase","normalize","split","strengthOf","undefined","fromEntropy","generateNew","secureRandom","_b","secureRandomGenerator","entropyByteCount","Buffer","from","randomSecureBytes","_unsafeUnwrap","fromPhraseInLanguage","mnemonicToEntropy","e","msgFromError","notChecksummedErr","fromWordsInLanguage","fromEnglishPhrase","fromEnglishWords","Mnemonic"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/src/elliptic-curve/hd/bip39/mnemonic.ts"],"sourcesContent":["import { err, ok, Result } from 'neverthrow'\nimport { LanguageT, MnemomicT, MnemonicProps, StrengthT } from './_types'\nimport {\n\tentropyToMnemonic,\n\tmnemonicToEntropy,\n\tvalidateMnemonic,\n\twordlists,\n} from 'bip39'\nimport {\n\tlog,\n\tbuffersEquals,\n\tSecureRandom,\n\tsecureRandomGenerator,\n\tValidationWitness,\n\tmsgFromError,\n} from '@radixdlt/util'\n\nexport const wordlistFromLanguage = (language: LanguageT): string[] => {\n\tconst key = LanguageT[language].toLowerCase()\n\treturn wordlists[key]\n}\n\nexport const languagesSupportedByBIP39: LanguageT[] = [\n\tLanguageT.CZECH,\n\tLanguageT.CHINESE_SIMPLIFIED,\n\tLanguageT.CHINESE_TRADITIONAL,\n\tLanguageT.KOREAN,\n\tLanguageT.FRENCH,\n\tLanguageT.ITALIAN,\n\tLanguageT.SPANISH,\n\tLanguageT.JAPANESE,\n\tLanguageT.ENGLISH,\n]\n\nexport const mnemonicStrengthSupportedByBIP39: StrengthT[] = [\n\tStrengthT.WORD_COUNT_12,\n\tStrengthT.WORD_COUNT_15,\n\tStrengthT.WORD_COUNT_18,\n\tStrengthT.WORD_COUNT_21,\n\tStrengthT.WORD_COUNT_24,\n]\n\nconst separator = ' '\n\nexport const strengthFromWordCount = (\n\twordCount: number,\n): Result<StrengthT, Error> =>\n\twordCount === 24\n\t\t? ok(StrengthT.WORD_COUNT_24)\n\t\t: wordCount === 21\n\t\t? ok(StrengthT.WORD_COUNT_21)\n\t\t: wordCount === 18\n\t\t? ok(StrengthT.WORD_COUNT_18)\n\t\t: wordCount === 15\n\t\t? ok(StrengthT.WORD_COUNT_15)\n\t\t: wordCount === 12\n\t\t? ok(StrengthT.WORD_COUNT_12)\n\t\t: err(Error(`Unsupported wordcount ${wordCount}`))\n\nexport const entropyInBitsFromWordCount = (wordCount: number): number => {\n\tconst checksumBitsPerWord = 3\n\treturn (wordCount / checksumBitsPerWord) * 32\n}\n\nexport const byteCountFromEntropyStrength = (strenght: StrengthT): number =>\n\tstrenght.valueOf() / 8\n\nconst create = (input: MnemonicProps): Result<MnemomicT, Error> => {\n\tconst wordCount = input.words.length\n\treturn strengthFromWordCount(wordCount)\n\t\t.andThen(\n\t\t\t(strengthFromWC: StrengthT): Result<ValidationWitness, Error> => {\n\t\t\t\tif (strengthFromWC !== input.strength) {\n\t\t\t\t\tconst errMsg = `Mismatch between 'words' and 'strenght'.`\n\t\t\t\t\tlog.error(errMsg)\n\t\t\t\t\treturn err(new Error(errMsg))\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tentropyInBitsFromWordCount(wordCount) !==\n\t\t\t\t\tinput.entropy.length * 8\n\t\t\t\t) {\n\t\t\t\t\tconst errMsg = `Mismatch 'words' and 'entropy'.`\n\t\t\t\t\tlog.error(errMsg)\n\t\t\t\t\treturn err(new Error(errMsg))\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tbyteCountFromEntropyStrength(input.strength) !==\n\t\t\t\t\tinput.entropy.length\n\t\t\t\t) {\n\t\t\t\t\tconst errMsg = `Mismatch 'strength' and 'entropy'.`\n\t\t\t\t\tlog.error(errMsg)\n\t\t\t\t\treturn err(new Error(errMsg))\n\t\t\t\t}\n\n\t\t\t\tconst wordlist = wordlistFromLanguage(input.language)\n\t\t\t\tconst languageName: string = LanguageT[input.language]\n\n\t\t\t\tif (input.words.join(separator) !== input.phrase) {\n\t\t\t\t\tconst errMsg = `Mismatch between 'words' and 'phrase' ('phrase' possible non normalized (NFKD).).`\n\t\t\t\t\tlog.error(errMsg)\n\t\t\t\t\treturn err(new Error(errMsg))\n\t\t\t\t}\n\n\t\t\t\tfor (const word of input.words) {\n\t\t\t\t\tif (!wordlist.includes(word)) {\n\t\t\t\t\t\tconst errMsg = `Mismatch between 'words' and 'language'`\n\t\t\t\t\t\tlog.error(errMsg)\n\t\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t\t`The word '${word}' was not found in mnemonic word list for language '${languageName}'`,\n\t\t\t\t\t\t)\n\t\t\t\t\t\treturn err(new Error(errMsg))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ok({ witness: 'valid input' })\n\t\t\t},\n\t\t)\n\t\t.map(\n\t\t\t(_): MnemomicT => ({\n\t\t\t\t...input,\n\t\t\t\ttoString: () => input.phrase,\n\t\t\t\tequals: (other: MnemomicT): boolean =>\n\t\t\t\t\tbuffersEquals(input.entropy, other.entropy),\n\t\t\t}),\n\t\t)\n\t\t.map(mnemonic => {\n\t\t\tlog.debug(`Successfully created mnemonic.`)\n\t\t\treturn mnemonic\n\t\t})\n}\n\nconst fromEntropyAndMaybeStrength = (\n\tinput: Readonly<{\n\t\tentropy: Buffer\n\t\tstrength?: StrengthT\n\t\tlanguage?: LanguageT\n\t}>,\n): Result<MnemomicT, Error> => {\n\tconst language = input?.language ?? LanguageT.ENGLISH\n\tconst wordlist = wordlistFromLanguage(language)\n\tconst phrase = entropyToMnemonic(input.entropy, wordlist)\n\tif (!validateMnemonic(phrase, wordlist))\n\t\tthrow new Error(\n\t\t\t'Incorrect implementation, should be able to always generate valid mnemonic',\n\t\t)\n\n\tconst normalizedPhrase = phrase.normalize('NFKD')\n\tconst words = normalizedPhrase.split(separator)\n\n\tconst strengthOf: Result<StrengthT, Error> =\n\t\tinput.strength !== undefined\n\t\t\t? ok(input.strength)\n\t\t\t: strengthFromWordCount(words.length)\n\n\treturn strengthOf.andThen(strength =>\n\t\tcreate({\n\t\t\t...input,\n\t\t\tlanguage,\n\t\t\tstrength,\n\t\t\tphrase: normalizedPhrase,\n\t\t\twords,\n\t\t}),\n\t)\n}\n\nconst fromEntropy = (\n\tinput: Readonly<{\n\t\tentropy: Buffer\n\t\tlanguage?: LanguageT\n\t}>,\n): Result<MnemomicT, Error> => fromEntropyAndMaybeStrength(input)\n\nconst generateNew = (\n\tinput?: Readonly<{\n\t\tstrength?: StrengthT // defaults to 12 words (128 bits)\n\t\tlanguage?: LanguageT // defaults to English\n\t\tsecureRandom?: SecureRandom // defaults to default\n\t}>,\n): MnemomicT => {\n\tconst strength = input?.strength ?? StrengthT.WORD_COUNT_12\n\tconst secureRandom = input?.secureRandom ?? secureRandomGenerator\n\tconst entropyByteCount = byteCountFromEntropyStrength(strength)\n\tconst entropy = Buffer.from(\n\t\tsecureRandom.randomSecureBytes(entropyByteCount),\n\t\t'hex',\n\t)\n\treturn fromEntropyAndMaybeStrength({\n\t\t...input,\n\t\tentropy,\n\t\tstrength,\n\t})._unsafeUnwrap()\n}\n\nconst fromPhraseInLanguage = (\n\tinput: Readonly<{\n\t\tphrase: string\n\t\tlanguage: LanguageT\n\t}>,\n): Result<MnemomicT, Error> => {\n\tconst wordlist = wordlistFromLanguage(input.language)\n\tconst phrase = input.phrase\n\n\tlet entropy: Buffer\n\ttry {\n\t\tentropy = Buffer.from(mnemonicToEntropy(phrase, wordlist), 'hex')\n\t} catch (e) {\n\t\tconst errMsg = msgFromError(e)\n\t\tif (errMsg === 'Invalid mnemonic checksum') {\n\t\t\tconst notChecksummedErr = 'Invalid mnemonic, it is not checksummed.'\n\t\t\tlog.error(notChecksummedErr)\n\t\t\treturn err(new Error(notChecksummedErr))\n\t\t}\n\n\t\treturn err(e as Error)\n\t}\n\tconst normalizedPhrase = phrase.normalize('NFKD')\n\tconst words = normalizedPhrase.split(separator)\n\n\treturn strengthFromWordCount(words.length)\n\t\t.map(strength => ({\n\t\t\t...input,\n\t\t\tphrase: normalizedPhrase,\n\t\t\twords,\n\t\t\tentropy,\n\t\t\tstrength,\n\t\t}))\n\t\t.andThen(create)\n}\n\nconst fromWordsInLanguage = (\n\tinput: Readonly<{\n\t\twords: string[]\n\t\tlanguage: LanguageT\n\t}>,\n): Result<MnemomicT, Error> =>\n\tfromPhraseInLanguage({\n\t\tphrase: input.words.join(separator),\n\t\tlanguage: input.language,\n\t})\n\nconst fromEnglishPhrase = (phrase: string): Result<MnemomicT, Error> =>\n\tfromPhraseInLanguage({\n\t\tphrase,\n\t\tlanguage: LanguageT.ENGLISH,\n\t})\n\nconst fromEnglishWords = (words: string[]): Result<MnemomicT, Error> =>\n\tfromWordsInLanguage({\n\t\twords,\n\t\tlanguage: LanguageT.ENGLISH,\n\t})\n\nexport const Mnemonic = {\n\tgenerateNew,\n\tfromEntropy,\n\tfromPhraseInLanguage,\n\tfromWordsInLanguage,\n\tfromEnglishPhrase,\n\tfromEnglishWords,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}