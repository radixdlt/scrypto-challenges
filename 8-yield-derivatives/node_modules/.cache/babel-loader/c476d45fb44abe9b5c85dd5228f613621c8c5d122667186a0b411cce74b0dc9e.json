{"ast":null,"code":"'use strict';\n\nvar IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;\nvar customRuleCode = require('./dotjs/custom');\nvar definitionSchema = require('./definition_schema');\nmodule.exports = {\n  add: addKeyword,\n  get: getKeyword,\n  remove: removeKeyword,\n  validate: validateKeyword\n};\n\n/**\n * Define custom keyword\n * @this  Ajv\n * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).\n * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.\n * @return {Ajv} this for method chaining\n */\nfunction addKeyword(keyword, definition) {\n  /* jshint validthis: true */\n  /* eslint no-shadow: 0 */\n  var RULES = this.RULES;\n  if (RULES.keywords[keyword]) throw new Error('Keyword ' + keyword + ' is already defined');\n  if (!IDENTIFIER.test(keyword)) throw new Error('Keyword ' + keyword + ' is not a valid identifier');\n  if (definition) {\n    this.validateKeyword(definition, true);\n    var dataType = definition.type;\n    if (Array.isArray(dataType)) {\n      for (var i = 0; i < dataType.length; i++) _addRule(keyword, dataType[i], definition);\n    } else {\n      _addRule(keyword, dataType, definition);\n    }\n    var metaSchema = definition.metaSchema;\n    if (metaSchema) {\n      if (definition.$data && this._opts.$data) {\n        metaSchema = {\n          anyOf: [metaSchema, {\n            '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#'\n          }]\n        };\n      }\n      definition.validateSchema = this.compile(metaSchema, true);\n    }\n  }\n  RULES.keywords[keyword] = RULES.all[keyword] = true;\n  function _addRule(keyword, dataType, definition) {\n    var ruleGroup;\n    for (var i = 0; i < RULES.length; i++) {\n      var rg = RULES[i];\n      if (rg.type == dataType) {\n        ruleGroup = rg;\n        break;\n      }\n    }\n    if (!ruleGroup) {\n      ruleGroup = {\n        type: dataType,\n        rules: []\n      };\n      RULES.push(ruleGroup);\n    }\n    var rule = {\n      keyword: keyword,\n      definition: definition,\n      custom: true,\n      code: customRuleCode,\n      implements: definition.implements\n    };\n    ruleGroup.rules.push(rule);\n    RULES.custom[keyword] = rule;\n  }\n  return this;\n}\n\n/**\n * Get keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.\n */\nfunction getKeyword(keyword) {\n  /* jshint validthis: true */\n  var rule = this.RULES.custom[keyword];\n  return rule ? rule.definition : this.RULES.keywords[keyword] || false;\n}\n\n/**\n * Remove keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Ajv} this for method chaining\n */\nfunction removeKeyword(keyword) {\n  /* jshint validthis: true */\n  var RULES = this.RULES;\n  delete RULES.keywords[keyword];\n  delete RULES.all[keyword];\n  delete RULES.custom[keyword];\n  for (var i = 0; i < RULES.length; i++) {\n    var rules = RULES[i].rules;\n    for (var j = 0; j < rules.length; j++) {\n      if (rules[j].keyword == keyword) {\n        rules.splice(j, 1);\n        break;\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Validate keyword definition\n * @this  Ajv\n * @param {Object} definition keyword definition object.\n * @param {Boolean} throwError true to throw exception if definition is invalid\n * @return {boolean} validation result\n */\nfunction validateKeyword(definition, throwError) {\n  validateKeyword.errors = null;\n  var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);\n  if (v(definition)) return true;\n  validateKeyword.errors = v.errors;\n  if (throwError) throw new Error('custom keyword definition is invalid: ' + this.errorsText(v.errors));else return false;\n}","map":{"version":3,"names":["IDENTIFIER","customRuleCode","require","definitionSchema","module","exports","add","addKeyword","get","getKeyword","remove","removeKeyword","validate","validateKeyword","keyword","definition","RULES","keywords","Error","test","dataType","type","Array","isArray","i","length","_addRule","metaSchema","$data","_opts","anyOf","validateSchema","compile","all","ruleGroup","rg","rules","push","rule","custom","code","implements","j","splice","throwError","errors","v","_validateKeyword","errorsText"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/ajv/lib/keyword.js"],"sourcesContent":["'use strict';\n\nvar IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;\nvar customRuleCode = require('./dotjs/custom');\nvar definitionSchema = require('./definition_schema');\n\nmodule.exports = {\n  add: addKeyword,\n  get: getKeyword,\n  remove: removeKeyword,\n  validate: validateKeyword\n};\n\n\n/**\n * Define custom keyword\n * @this  Ajv\n * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).\n * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.\n * @return {Ajv} this for method chaining\n */\nfunction addKeyword(keyword, definition) {\n  /* jshint validthis: true */\n  /* eslint no-shadow: 0 */\n  var RULES = this.RULES;\n  if (RULES.keywords[keyword])\n    throw new Error('Keyword ' + keyword + ' is already defined');\n\n  if (!IDENTIFIER.test(keyword))\n    throw new Error('Keyword ' + keyword + ' is not a valid identifier');\n\n  if (definition) {\n    this.validateKeyword(definition, true);\n\n    var dataType = definition.type;\n    if (Array.isArray(dataType)) {\n      for (var i=0; i<dataType.length; i++)\n        _addRule(keyword, dataType[i], definition);\n    } else {\n      _addRule(keyword, dataType, definition);\n    }\n\n    var metaSchema = definition.metaSchema;\n    if (metaSchema) {\n      if (definition.$data && this._opts.$data) {\n        metaSchema = {\n          anyOf: [\n            metaSchema,\n            { '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }\n          ]\n        };\n      }\n      definition.validateSchema = this.compile(metaSchema, true);\n    }\n  }\n\n  RULES.keywords[keyword] = RULES.all[keyword] = true;\n\n\n  function _addRule(keyword, dataType, definition) {\n    var ruleGroup;\n    for (var i=0; i<RULES.length; i++) {\n      var rg = RULES[i];\n      if (rg.type == dataType) {\n        ruleGroup = rg;\n        break;\n      }\n    }\n\n    if (!ruleGroup) {\n      ruleGroup = { type: dataType, rules: [] };\n      RULES.push(ruleGroup);\n    }\n\n    var rule = {\n      keyword: keyword,\n      definition: definition,\n      custom: true,\n      code: customRuleCode,\n      implements: definition.implements\n    };\n    ruleGroup.rules.push(rule);\n    RULES.custom[keyword] = rule;\n  }\n\n  return this;\n}\n\n\n/**\n * Get keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.\n */\nfunction getKeyword(keyword) {\n  /* jshint validthis: true */\n  var rule = this.RULES.custom[keyword];\n  return rule ? rule.definition : this.RULES.keywords[keyword] || false;\n}\n\n\n/**\n * Remove keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Ajv} this for method chaining\n */\nfunction removeKeyword(keyword) {\n  /* jshint validthis: true */\n  var RULES = this.RULES;\n  delete RULES.keywords[keyword];\n  delete RULES.all[keyword];\n  delete RULES.custom[keyword];\n  for (var i=0; i<RULES.length; i++) {\n    var rules = RULES[i].rules;\n    for (var j=0; j<rules.length; j++) {\n      if (rules[j].keyword == keyword) {\n        rules.splice(j, 1);\n        break;\n      }\n    }\n  }\n  return this;\n}\n\n\n/**\n * Validate keyword definition\n * @this  Ajv\n * @param {Object} definition keyword definition object.\n * @param {Boolean} throwError true to throw exception if definition is invalid\n * @return {boolean} validation result\n */\nfunction validateKeyword(definition, throwError) {\n  validateKeyword.errors = null;\n  var v = this._validateKeyword = this._validateKeyword\n                                  || this.compile(definitionSchema, true);\n\n  if (v(definition)) return true;\n  validateKeyword.errors = v.errors;\n  if (throwError)\n    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));\n  else\n    return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}