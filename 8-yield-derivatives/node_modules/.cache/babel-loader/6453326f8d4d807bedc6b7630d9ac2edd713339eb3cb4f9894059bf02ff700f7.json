{"ast":null,"code":"var debug = require('debug')('assert-args');\nvar exists = require('101/exists');\nvar isObject = require('101/is-object');\nvar not = require('101/not');\nvar isOptionalKey = require('./lib/is-optional-key.js');\nvar isSpreadKey = require('./lib/is-spread-key.js');\nvar validate = require('./lib/validate.js');\nvar isRequiredKey = not(isOptionalKey);\nmodule.exports = assertArgs;\nfunction assertArgs(args, validation) {\n  if (typeof args !== 'object' || !exists(args.length)) {\n    throw new TypeError('\"args\" must be an array or array-like object (arguments)');\n  }\n  if (!isObject(validation)) {\n    // strict object\n    throw new TypeError('\"validation\" must be an object');\n  }\n\n  // copy args\n  var argsLeft = Array.prototype.slice.call(args);\n  var firstOptionalErr;\n  var ret = {};\n  var argKeys = Object.keys(validation);\n  var outKey;\n  if (argKeys.filter(isSpreadKey).length > 1) {\n    throw new Error('assert-args only supports a single spread argument');\n  }\n  argKeys.forEach(function (key, i) {\n    var spreadArgs;\n    var validator = validation[key];\n    var arg = argsLeft[0];\n    if (isSpreadKey(key)) {\n      debug('is spread key: ' + key);\n      debug('argKeys.length', argKeys.length);\n      debug('argsLeft.length', argsLeft.length);\n      var requiredKeysLeft = argKeys.slice(i + 1).filter(isRequiredKey);\n      debug('requiredKeysLeft', requiredKeysLeft);\n      spreadArgs = argsLeft.slice(0, argsLeft.length - requiredKeysLeft.length); // copy\n      debug('spreadArgs', spreadArgs);\n      debug('spreadArgs.length', spreadArgs.length);\n      if (isOptionalKey(key)) {\n        debug('is optional spread key: ' + key);\n        outKey = key.slice(4, -1);\n        ret[outKey] = [];\n        spreadArgs.forEach(function (arg) {\n          if (!exists(arg)) {\n            // non-existant args pass as optional args\n            firstOptionalErr = null; // reset after a pass\n            argsLeft.shift(); // pass, remains [...]\n            return;\n          }\n          try {\n            validate(key.slice(1, -1), arg, validator, true);\n            // optional arg passes validator\n            firstOptionalErr = null;\n            ret[outKey].push(arg); // pass\n            argsLeft.shift();\n          } catch (err) {\n            debug('spread validate err: ' + err.message);\n            debug('spread validate argsLeft: ' + argsLeft);\n            if (firstOptionalErr) {\n              // other optional error already occurred, throw first.\n              throw firstOptionalErr;\n            } else {\n              firstOptionalErr = err;\n            }\n          }\n        });\n      } else {\n        // isSpreadKey && isRequiredKey\n        debug('is required spread key: ' + key);\n        outKey = key.slice(3);\n        ret[outKey] = [];\n        if (spreadArgs.length === 0) {\n          // missing trailing required arg, fail\n          throw new TypeError('\"' + key + '\" is required');\n        }\n        spreadArgs.forEach(function (arg) {\n          try {\n            validate(key, arg, validator, true);\n            // optional arg passes validator\n            firstOptionalErr = null;\n            ret[outKey].push(arg); // pass\n            argsLeft.shift();\n          } catch (err) {\n            debug('spread validate err: ' + err.message);\n            debug('spread validate argsLeft: ' + argsLeft);\n            debug('spread validate argKeys: ' + argKeys);\n            if (i === argKeys.length - 1) {\n              // spread is last arg.\n              // spread assumes all args passed are used.\n              // there are no args left. and this failed for spread. throw it.\n              if (firstOptionalErr) {\n                if (argsLeft.length - 1 > requiredKeysLeft.length) {\n                  throw firstOptionalErr;\n                } else {\n                  throw err;\n                }\n              } else {\n                throw err;\n              }\n            } else {\n              // leading/middle spread arg\n              if (firstOptionalErr) {\n                // other optional error already occurred, throw first.\n                throw firstOptionalErr;\n              } else {\n                // set optional err\n                firstOptionalErr = err;\n              }\n            }\n          }\n        });\n      }\n      return;\n    } else if (isOptionalKey(key)) {\n      debug('is optional key: ' + key);\n      key = key.slice(1, -1);\n      if (argsLeft.length === 0) {\n        // missing trailing optional arg, pass\n        ret[key] = undefined;\n        return;\n      } else if (!exists(arg)) {\n        // non-existant args pass as optional args\n        firstOptionalErr = null;\n        ret[key] = argsLeft.shift(); // pass\n        return;\n      }\n      try {\n        validate(key, arg, validator);\n        // optional arg passes validator\n        firstOptionalErr = null;\n        ret[key] = argsLeft.shift();\n        return;\n      } catch (err) {\n        // optional arg failed validator\n        // * set as undefined and pass for now\n        // * save the error in case there are no more required args\n        firstOptionalErr = firstOptionalErr || err;\n        ret[key] = undefined;\n        return;\n      }\n    } else {\n      // isRequiredKey\n      debug('is required key: ' + key);\n      if (argsLeft.length === 0) {\n        // missing trailing required arg, fail\n        throw new TypeError('\"' + key + '\" is required');\n      }\n      try {\n        validate(key, arg, validator);\n        // required arg passes validator, pass\n        firstOptionalErr = null;\n        ret[key] = argsLeft.shift();\n      } catch (err) {\n        if (firstOptionalErr && argsLeft.length > 1) {\n          // optional err was thrown before and this is not the last arg\n          throw firstOptionalErr;\n        }\n        throw err;\n      }\n      return;\n    }\n  });\n  if (firstOptionalErr) {\n    throw firstOptionalErr;\n  }\n  return ret;\n}","map":{"version":3,"names":["debug","require","exists","isObject","not","isOptionalKey","isSpreadKey","validate","isRequiredKey","module","exports","assertArgs","args","validation","length","TypeError","argsLeft","Array","prototype","slice","call","firstOptionalErr","ret","argKeys","Object","keys","outKey","filter","Error","forEach","key","i","spreadArgs","validator","arg","requiredKeysLeft","shift","push","err","message","undefined"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/assert-args/index.js"],"sourcesContent":["var debug = require('debug')('assert-args')\nvar exists = require('101/exists')\nvar isObject = require('101/is-object')\nvar not = require('101/not')\n\nvar isOptionalKey = require('./lib/is-optional-key.js')\nvar isSpreadKey = require('./lib/is-spread-key.js')\nvar validate = require('./lib/validate.js')\n\nvar isRequiredKey = not(isOptionalKey)\n\nmodule.exports = assertArgs\n\nfunction assertArgs (args, validation) {\n  if (typeof args !== 'object' || !exists(args.length)) {\n    throw new TypeError('\"args\" must be an array or array-like object (arguments)')\n  }\n  if (!isObject(validation)) { // strict object\n    throw new TypeError('\"validation\" must be an object')\n  }\n\n  // copy args\n  var argsLeft = Array.prototype.slice.call(args)\n  var firstOptionalErr\n  var ret = {}\n  var argKeys = Object.keys(validation)\n  var outKey\n\n  if (argKeys.filter(isSpreadKey).length > 1) {\n    throw new Error('assert-args only supports a single spread argument')\n  }\n\n  argKeys.forEach(function (key, i) {\n    var spreadArgs\n    var validator = validation[key]\n    var arg = argsLeft[0]\n\n    if (isSpreadKey(key)) {\n      debug('is spread key: ' + key)\n      debug('argKeys.length', argKeys.length)\n      debug('argsLeft.length', argsLeft.length)\n      var requiredKeysLeft = argKeys.slice(i + 1).filter(isRequiredKey)\n      debug('requiredKeysLeft', requiredKeysLeft)\n      spreadArgs = argsLeft.slice(0, argsLeft.length - requiredKeysLeft.length) // copy\n      debug('spreadArgs', spreadArgs)\n      debug('spreadArgs.length', spreadArgs.length)\n\n      if (isOptionalKey(key)) {\n        debug('is optional spread key: ' + key)\n        outKey = key.slice(4, -1)\n        ret[outKey] = []\n\n        spreadArgs.forEach(function (arg) {\n          if (!exists(arg)) {\n            // non-existant args pass as optional args\n            firstOptionalErr = null // reset after a pass\n            argsLeft.shift() // pass, remains [...]\n            return\n          }\n          try {\n            validate(key.slice(1, -1), arg, validator, true)\n            // optional arg passes validator\n            firstOptionalErr = null\n            ret[outKey].push(arg) // pass\n            argsLeft.shift()\n          } catch (err) {\n            debug('spread validate err: ' + err.message)\n            debug('spread validate argsLeft: ' + argsLeft)\n            if (firstOptionalErr) {\n              // other optional error already occurred, throw first.\n              throw firstOptionalErr\n            } else {\n              firstOptionalErr = err\n            }\n          }\n        })\n      } else { // isSpreadKey && isRequiredKey\n        debug('is required spread key: ' + key)\n        outKey = key.slice(3)\n        ret[outKey] = []\n\n        if (spreadArgs.length === 0) {\n          // missing trailing required arg, fail\n          throw new TypeError('\"' + key + '\" is required')\n        }\n        spreadArgs.forEach(function (arg) {\n          try {\n            validate(key, arg, validator, true)\n            // optional arg passes validator\n            firstOptionalErr = null\n            ret[outKey].push(arg) // pass\n            argsLeft.shift()\n          } catch (err) {\n            debug('spread validate err: ' + err.message)\n            debug('spread validate argsLeft: ' + argsLeft)\n            debug('spread validate argKeys: ' + argKeys)\n\n            if (i === (argKeys.length - 1)) {\n              // spread is last arg.\n              // spread assumes all args passed are used.\n              // there are no args left. and this failed for spread. throw it.\n              if (firstOptionalErr) {\n                if ((argsLeft.length - 1) > requiredKeysLeft.length) {\n                  throw firstOptionalErr\n                } else {\n                  throw err\n                }\n              } else {\n                throw err\n              }\n            } else {\n              // leading/middle spread arg\n              if (firstOptionalErr) {\n                // other optional error already occurred, throw first.\n                throw firstOptionalErr\n              } else {\n                // set optional err\n                firstOptionalErr = err\n              }\n            }\n          }\n        })\n      }\n      return\n    } else if (isOptionalKey(key)) {\n      debug('is optional key: ' + key)\n      key = key.slice(1, -1)\n\n      if (argsLeft.length === 0) {\n        // missing trailing optional arg, pass\n        ret[key] = undefined\n        return\n      } else if (!exists(arg)) {\n        // non-existant args pass as optional args\n        firstOptionalErr = null\n        ret[key] = argsLeft.shift() // pass\n        return\n      }\n\n      try {\n        validate(key, arg, validator)\n        // optional arg passes validator\n        firstOptionalErr = null\n        ret[key] = argsLeft.shift()\n        return\n      } catch (err) {\n        // optional arg failed validator\n        // * set as undefined and pass for now\n        // * save the error in case there are no more required args\n        firstOptionalErr = firstOptionalErr || err\n        ret[key] = undefined\n        return\n      }\n    } else { // isRequiredKey\n      debug('is required key: ' + key)\n      if (argsLeft.length === 0) {\n        // missing trailing required arg, fail\n        throw new TypeError('\"' + key + '\" is required')\n      }\n      try {\n        validate(key, arg, validator)\n        // required arg passes validator, pass\n        firstOptionalErr = null\n        ret[key] = argsLeft.shift()\n      } catch (err) {\n        if (firstOptionalErr && argsLeft.length > 1) {\n          // optional err was thrown before and this is not the last arg\n          throw firstOptionalErr\n        }\n        throw err\n      }\n      return\n    }\n  })\n\n  if (firstOptionalErr) {\n    throw firstOptionalErr\n  }\n\n  return ret\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}