{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar Value_1 = require(\"./Value\");\nvar Option_1 = require(\"./Option\");\nvar Vector_1 = require(\"./Vector\");\nvar LinkedList_1 = require(\"./LinkedList\");\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\nvar Contract_1 = require(\"./Contract\");\n/**\n * Contains a pair of two values, which may or may not have the same type.\n * Compared to the builtin typescript [T,U] type, we get equality semantics\n * and helper functions (like mapping and so on).\n * @param T the first item type\n * @param U the second item type\n */\nvar Tuple2 = /** @class */function () {\n  function Tuple2(_fst, _snd) {\n    this._fst = _fst;\n    this._snd = _snd;\n  }\n  /**\n   * Build a pair of value from both values.\n   */\n  Tuple2.of = function (fst, snd) {\n    return new Tuple2(fst, snd);\n  };\n  /**\n   * Build a tuple2 from javascript array. Compared to [[Tuple2.ofPair]],\n   * it checks the length of the array and will return [[None]] in case\n   * the length isn't two. However the types of the elements aren't checked.\n   */\n  Tuple2.ofArray = function (pair) {\n    if (pair && pair.length === 2) {\n      return Option_1.Option.of(new Tuple2(pair[0], pair[1]));\n    }\n    return Option_1.Option.none();\n  };\n  /**\n   * Build a tuple2 from javascript pair.\n   * Also see [[Tuple2.ofArray]]\n   */\n  Tuple2.ofPair = function (pair) {\n    return new Tuple2(pair[0], pair[1]);\n  };\n  /**\n   * @hidden\n   */\n  Tuple2.prototype.hasTrueEquality = function () {\n    return Option_1.Option.of(this.fst()).hasTrueEquality() && Option_1.Option.of(this.snd()).hasTrueEquality();\n  };\n  /**\n   * Extract the first value from the pair\n   */\n  Tuple2.prototype.fst = function () {\n    return this._fst;\n  };\n  /**\n   * Extract the second value from the pair\n   */\n  Tuple2.prototype.snd = function () {\n    return this._snd;\n  };\n  /**\n   * Maps the first component of this tuple to a new value.\n   */\n  Tuple2.prototype.map1 = function (fn) {\n    return new Tuple2(fn(this._fst), this._snd);\n  };\n  /**\n   * Maps the second component of this tuple to a new value.\n   */\n  Tuple2.prototype.map2 = function (fn) {\n    return new Tuple2(this._fst, fn(this._snd));\n  };\n  /**\n   * Make a new tuple by mapping both values inside this one.\n   */\n  Tuple2.prototype.map = function (fn) {\n    return fn(this._fst, this._snd);\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  Tuple2.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  Tuple2.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || other._fst === undefined) {\n      return false;\n    }\n    Contract_1.contractTrueEquality(\"Tuple2.equals\", this, other);\n    return Comparison_1.areEqual(this._fst, other._fst) && Comparison_1.areEqual(this._snd, other._snd);\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  Tuple2.prototype.hashCode = function () {\n    return Comparison_1.getHashCode(this._fst) * 53 + Comparison_1.getHashCode(this._snd);\n  };\n  /**\n   * Convert the tuple to a javascript pair.\n   * Compared to [[Tuple2.toArray]], it behaves the\n   * same at runtime, the only difference is the\n   * typescript type definition.\n   */\n  Tuple2.prototype.toPair = function () {\n    return [this._fst, this._snd];\n  };\n  /**\n   * Convert the tuple to a javascript array.\n   * Compared to [[Tuple2.toPair]], it behaves the\n   * same at runtime, the only difference is the\n   * typescript type definition.\n   */\n  Tuple2.prototype.toArray = function () {\n    return [this._fst, this._snd];\n  };\n  /**\n   * Convert the tuple to a vector.\n   */\n  Tuple2.prototype.toVector = function () {\n    return Vector_1.Vector.of(this._fst, this._snd);\n  };\n  /**\n   * Convert the tuple to a linked list.\n   */\n  Tuple2.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.of(this._fst, this._snd);\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   */\n  Tuple2.prototype.toString = function () {\n    return \"Tuple2(\" + SeqHelpers_1.toStringHelper(this._fst) + \", \" + SeqHelpers_1.toStringHelper(this._snd) + \")\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   * Most of the time should be the same as toString()\n   */\n  Tuple2.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return Tuple2;\n}();\nexports.Tuple2 = Tuple2;","map":{"version":3,"names":["Value_1","require","Option_1","Vector_1","LinkedList_1","Comparison_1","SeqHelpers_1","Contract_1","Tuple2","_fst","_snd","of","fst","snd","ofArray","pair","length","Option","none","ofPair","prototype","hasTrueEquality","map1","fn","map2","map","transform","converter","equals","other","undefined","contractTrueEquality","areEqual","hashCode","getHashCode","toPair","toArray","toVector","Vector","toLinkedList","LinkedList","toString","toStringHelper","inspect","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/Tuple2.ts"],"sourcesContent":["import { Value, inspect } from \"./Value\";\nimport { Option } from \"./Option\";\nimport { Vector } from \"./Vector\";\nimport { LinkedList, ConsLinkedList } from \"./LinkedList\";\nimport { WithEquality, areEqual, getHashCode } from \"./Comparison\";\nimport { toStringHelper } from \"./SeqHelpers\";\nimport { contractTrueEquality } from \"./Contract\";\n\n/**\n * Contains a pair of two values, which may or may not have the same type.\n * Compared to the builtin typescript [T,U] type, we get equality semantics\n * and helper functions (like mapping and so on).\n * @param T the first item type\n * @param U the second item type\n */\nexport class Tuple2<T,U> implements Value {\n\n    private constructor(private _fst: T,\n                        private _snd: U) {}\n\n    /**\n     * Build a pair of value from both values.\n     */\n    static of<T,U>(fst: T, snd: U) {\n        return new Tuple2(fst,snd);\n    }\n\n    /**\n     * Build a tuple2 from javascript array. Compared to [[Tuple2.ofPair]],\n     * it checks the length of the array and will return [[None]] in case\n     * the length isn't two. However the types of the elements aren't checked.\n     */\n    static ofArray<T,U>(pair: Array<T|U>): Option<Tuple2<T,U>> {\n        if (pair && pair.length === 2) {\n            return Option.of(new Tuple2<T,U>(<T>pair[0], <U>pair[1]));\n        }\n        return Option.none<Tuple2<T,U>>();\n    }\n\n    /**\n     * Build a tuple2 from javascript pair.\n     * Also see [[Tuple2.ofArray]]\n     */\n    static ofPair<T,U>(pair: [T, U]): Tuple2<T,U> {\n        return new Tuple2(pair[0], pair[1]);\n    }\n\n    /**\n     * @hidden\n     */\n    hasTrueEquality(): boolean {\n        return Option.of(this.fst()).hasTrueEquality() &&\n            Option.of(this.snd()).hasTrueEquality();\n    }\n\n    /**\n     * Extract the first value from the pair\n     */\n    fst(): T {\n        return this._fst;\n    }\n\n    /**\n     * Extract the second value from the pair\n     */\n    snd(): U {\n        return this._snd;\n    }\n\n    /**\n     * Maps the first component of this tuple to a new value.\n     */\n    map1<V>(fn: (v:T)=>V): Tuple2<V,U> {\n        return new Tuple2(fn(this._fst), this._snd);\n    }\n\n    /**\n     * Maps the second component of this tuple to a new value.\n     */\n    map2<V>(fn: (v:U)=>V): Tuple2<T,V> {\n        return new Tuple2(this._fst, fn(this._snd));\n    }\n\n    /**\n     * Make a new tuple by mapping both values inside this one.\n     */\n    map<T1,U1>(fn: (a:T,b:U)=> Tuple2<T1,U1>): Tuple2<T1,U1> {\n        return fn(this._fst, this._snd);\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<V>(converter:(x:Tuple2<T,U>)=>V): V {\n        return converter(this);\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other: Tuple2<T&WithEquality,U&WithEquality>): boolean {\n        if (<any>other === this) {\n            return true;\n        }\n        if (!other || other._fst === undefined) {\n            return false;\n        }\n        contractTrueEquality(\"Tuple2.equals\", this, other);\n        return areEqual(this._fst, other._fst) &&\n            areEqual(this._snd, other._snd);\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        return getHashCode(this._fst)*53 + getHashCode(this._snd);\n    }\n\n    /**\n     * Convert the tuple to a javascript pair.\n     * Compared to [[Tuple2.toArray]], it behaves the\n     * same at runtime, the only difference is the\n     * typescript type definition.\n     */\n    toPair(): [T,U] {\n        return [this._fst, this._snd];\n    }\n\n    /**\n     * Convert the tuple to a javascript array.\n     * Compared to [[Tuple2.toPair]], it behaves the\n     * same at runtime, the only difference is the\n     * typescript type definition.\n     */\n    toArray(): Array<T|U> {\n        return [this._fst, this._snd];\n    }\n\n    /**\n     * Convert the tuple to a vector.\n     */\n    toVector(): Vector<T|U> {\n        return Vector.of<T|U>(this._fst, this._snd);\n    }\n\n    /**\n     * Convert the tuple to a linked list.\n     */\n    toLinkedList(): ConsLinkedList<T|U> {\n        return LinkedList.of<T|U>(this._fst, this._snd);\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     */\n    toString(): string {\n        return `Tuple2(${toStringHelper(this._fst)}, ${toStringHelper(this._snd)})`;\n    }\n\n    /**\n     * Used by the node REPL to display values.\n     * Most of the time should be the same as toString()\n     */\n    [inspect](): string {\n        return this.toString();\n    }\n}\n"],"mappings":";;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,QAAA,GAAAD,OAAA;AACA,IAAAE,QAAA,GAAAF,OAAA;AACA,IAAAG,YAAA,GAAAH,OAAA;AACA,IAAAI,YAAA,GAAAJ,OAAA;AACA,IAAAK,YAAA,GAAAL,OAAA;AACA,IAAAM,UAAA,GAAAN,OAAA;AAEA;;;;;;;AAOA,IAAAO,MAAA;EAEI,SAAAA,OAA4BC,IAAO,EACPC,IAAO;IADP,KAAAD,IAAI,GAAJA,IAAI;IACJ,KAAAC,IAAI,GAAJA,IAAI;EAAM;EAEtC;;;EAGOF,MAAA,CAAAG,EAAE,GAAT,UAAeC,GAAM,EAAEC,GAAM;IACzB,OAAO,IAAIL,MAAM,CAACI,GAAG,EAACC,GAAG,CAAC;EAC9B,CAAC;EAED;;;;;EAKOL,MAAA,CAAAM,OAAO,GAAd,UAAoBC,IAAgB;IAChC,IAAIA,IAAI,IAAIA,IAAI,CAACC,MAAM,KAAK,CAAC,EAAE;MAC3B,OAAOd,QAAA,CAAAe,MAAM,CAACN,EAAE,CAAC,IAAIH,MAAM,CAASO,IAAI,CAAC,CAAC,CAAC,EAAKA,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;;IAE7D,OAAOb,QAAA,CAAAe,MAAM,CAACC,IAAI,EAAe;EACrC,CAAC;EAED;;;;EAIOV,MAAA,CAAAW,MAAM,GAAb,UAAmBJ,IAAY;IAC3B,OAAO,IAAIP,MAAM,CAACO,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;EACvC,CAAC;EAED;;;EAGAP,MAAA,CAAAY,SAAA,CAAAC,eAAe,GAAf;IACI,OAAOnB,QAAA,CAAAe,MAAM,CAACN,EAAE,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,CAACS,eAAe,EAAE,IAC1CnB,QAAA,CAAAe,MAAM,CAACN,EAAE,CAAC,IAAI,CAACE,GAAG,EAAE,CAAC,CAACQ,eAAe,EAAE;EAC/C,CAAC;EAED;;;EAGAb,MAAA,CAAAY,SAAA,CAAAR,GAAG,GAAH;IACI,OAAO,IAAI,CAACH,IAAI;EACpB,CAAC;EAED;;;EAGAD,MAAA,CAAAY,SAAA,CAAAP,GAAG,GAAH;IACI,OAAO,IAAI,CAACH,IAAI;EACpB,CAAC;EAED;;;EAGAF,MAAA,CAAAY,SAAA,CAAAE,IAAI,GAAJ,UAAQC,EAAY;IAChB,OAAO,IAAIf,MAAM,CAACe,EAAE,CAAC,IAAI,CAACd,IAAI,CAAC,EAAE,IAAI,CAACC,IAAI,CAAC;EAC/C,CAAC;EAED;;;EAGAF,MAAA,CAAAY,SAAA,CAAAI,IAAI,GAAJ,UAAQD,EAAY;IAChB,OAAO,IAAIf,MAAM,CAAC,IAAI,CAACC,IAAI,EAAEc,EAAE,CAAC,IAAI,CAACb,IAAI,CAAC,CAAC;EAC/C,CAAC;EAED;;;EAGAF,MAAA,CAAAY,SAAA,CAAAK,GAAG,GAAH,UAAWF,EAA6B;IACpC,OAAOA,EAAE,CAAC,IAAI,CAACd,IAAI,EAAE,IAAI,CAACC,IAAI,CAAC;EACnC,CAAC;EAED;;;;EAIAF,MAAA,CAAAY,SAAA,CAAAM,SAAS,GAAT,UAAaC,SAA4B;IACrC,OAAOA,SAAS,CAAC,IAAI,CAAC;EAC1B,CAAC;EAED;;;;;EAKAnB,MAAA,CAAAY,SAAA,CAAAQ,MAAM,GAAN,UAAOC,KAA4C;IAC/C,IAASA,KAAK,KAAK,IAAI,EAAE;MACrB,OAAO,IAAI;;IAEf,IAAI,CAACA,KAAK,IAAIA,KAAK,CAACpB,IAAI,KAAKqB,SAAS,EAAE;MACpC,OAAO,KAAK;;IAEhBvB,UAAA,CAAAwB,oBAAoB,CAAC,eAAe,EAAE,IAAI,EAAEF,KAAK,CAAC;IAClD,OAAOxB,YAAA,CAAA2B,QAAQ,CAAC,IAAI,CAACvB,IAAI,EAAEoB,KAAK,CAACpB,IAAI,CAAC,IAClCJ,YAAA,CAAA2B,QAAQ,CAAC,IAAI,CAACtB,IAAI,EAAEmB,KAAK,CAACnB,IAAI,CAAC;EACvC,CAAC;EAED;;;;;EAKAF,MAAA,CAAAY,SAAA,CAAAa,QAAQ,GAAR;IACI,OAAO5B,YAAA,CAAA6B,WAAW,CAAC,IAAI,CAACzB,IAAI,CAAC,GAAC,EAAE,GAAGJ,YAAA,CAAA6B,WAAW,CAAC,IAAI,CAACxB,IAAI,CAAC;EAC7D,CAAC;EAED;;;;;;EAMAF,MAAA,CAAAY,SAAA,CAAAe,MAAM,GAAN;IACI,OAAO,CAAC,IAAI,CAAC1B,IAAI,EAAE,IAAI,CAACC,IAAI,CAAC;EACjC,CAAC;EAED;;;;;;EAMAF,MAAA,CAAAY,SAAA,CAAAgB,OAAO,GAAP;IACI,OAAO,CAAC,IAAI,CAAC3B,IAAI,EAAE,IAAI,CAACC,IAAI,CAAC;EACjC,CAAC;EAED;;;EAGAF,MAAA,CAAAY,SAAA,CAAAiB,QAAQ,GAAR;IACI,OAAOlC,QAAA,CAAAmC,MAAM,CAAC3B,EAAE,CAAM,IAAI,CAACF,IAAI,EAAE,IAAI,CAACC,IAAI,CAAC;EAC/C,CAAC;EAED;;;EAGAF,MAAA,CAAAY,SAAA,CAAAmB,YAAY,GAAZ;IACI,OAAOnC,YAAA,CAAAoC,UAAU,CAAC7B,EAAE,CAAM,IAAI,CAACF,IAAI,EAAE,IAAI,CAACC,IAAI,CAAC;EACnD,CAAC;EAED;;;EAGAF,MAAA,CAAAY,SAAA,CAAAqB,QAAQ,GAAR;IACI,OAAO,YAAUnC,YAAA,CAAAoC,cAAc,CAAC,IAAI,CAACjC,IAAI,CAAC,UAAKH,YAAA,CAAAoC,cAAc,CAAC,IAAI,CAAChC,IAAI,CAAC,MAAG;EAC/E,CAAC;EAED;;;;EAIAF,MAAA,CAAAY,SAAA,CAACpB,OAAA,CAAA2C,OAAO,CAAC,GAAT;IACI,OAAO,IAAI,CAACF,QAAQ,EAAE;EAC1B,CAAC;EACL,OAAAjC,MAAC;AAAD,CAAC,CA7JD;AAAaoC,OAAA,CAAApC,MAAA,GAAAA,MAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}