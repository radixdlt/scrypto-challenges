{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\nconst util = require('util');\nconst Decoder = require('./decoder');\nconst Simple = require('./simple');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst bignumber = require('bignumber.js').BigNumber;\nconst NoFilter = require('nofilter');\nconst MT = constants.MT;\nconst SYMS = constants.SYMS;\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends {stream.Transform}\n */\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {Object} [options={}] - options for creation\n   * @param {string} [options.separator='\\n'] - output between detected objects\n   * @param {boolean} [options.stream_errors=false] - put error info into the\n   *   output stream\n   * @param {number} [options.max_depth=-1] - -1 for \"until you run out of\n   *   memory\".  Set this to a finite positive number for un-trusted inputs.\n   *   Most standard inputs won't nest more than 100 or so levels; I've tested\n   *   into the millions before running out of memory.\n   */\n  constructor(options) {\n    const opts = Object.assign({\n      separator: '\\n',\n      stream_errors: false\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    const separator = opts.separator;\n    delete opts.separator;\n    const stream_errors = opts.stream_errors;\n    delete opts.stream_errors;\n    super(opts);\n    this.float_bytes = -1;\n    this.separator = separator;\n    this.stream_errors = stream_errors;\n    this.parser = new Decoder(opts);\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('data', this._on_data.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n  }\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb);\n  }\n  _flush(cb) {\n    return this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er);\n        }\n        return cb();\n      } else {\n        return cb(er);\n      }\n    });\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {(Buffer|string)} input - the CBOR bytes to format\n   * @param {string} [encoding='hex'] - the encoding of input, ignored if\n   *   input is Buffer\n   * @param {function(Error, string): undefined} cb - callback\n   * @returns {Promise} if callback not specified\n   */\n  static diagnose(input, encoding, cb) {\n    if (input == null) {\n      throw new Error('input required');\n    }\n    let opts = {};\n    let encod = 'hex';\n    switch (typeof encoding) {\n      case 'function':\n        cb = encoding;\n        encod = utils.guessEncoding(input);\n        break;\n      case 'object':\n        opts = utils.extend({}, encoding);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n        break;\n      default:\n        encod = encoding != null ? encoding : 'hex';\n    }\n    const bs = new NoFilter();\n    const d = new Diagnose(opts);\n    let p = null;\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')));\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')));\n        return d.on('error', reject);\n      });\n    }\n    d.pipe(bs);\n    d.end(input, encod);\n    return p;\n  }\n  _on_error(er) {\n    if (this.stream_errors) {\n      return this.push(er.toString());\n    } else {\n      return this.emit('error', er);\n    }\n  }\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      return this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3\n      }[len];\n    }\n  }\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          return this.push(', ');\n        }\n        break;\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            return this.push(': ');\n          } else {\n            return this.push(', ');\n          }\n        }\n    }\n  }\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return;\n    }\n    this._fore(parent_mt, pos);\n    return this.push((() => {\n      switch (false) {\n        case val !== SYMS.NULL:\n          return 'null';\n        case val !== SYMS.UNDEFINED:\n          return 'undefined';\n        case typeof val !== 'string':\n          return JSON.stringify(val);\n        case !(this.float_bytes > 0):\n          const fb = this.float_bytes;\n          this.float_bytes = -1;\n          return util.inspect(val) + '_' + fb;\n        case !Buffer.isBuffer(val):\n          return 'h\\'' + val.toString('hex') + '\\'';\n        case !(val instanceof bignumber):\n          return val.toString();\n        default:\n          return util.inspect(val);\n      }\n    })());\n  }\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos);\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`);\n        break;\n      case MT.ARRAY:\n        this.push('[');\n        break;\n      case MT.MAP:\n        this.push('{');\n        break;\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(');\n        break;\n    }\n    if (tag === SYMS.STREAM) {\n      return this.push('_ ');\n    }\n  }\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        return this.push(')');\n      case MT.ARRAY:\n        return this.push(']');\n      case MT.MAP:\n        return this.push('}');\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        return this.push(')');\n    }\n  }\n  _on_data() {\n    return this.push(this.separator);\n  }\n}\nmodule.exports = Diagnose;","map":{"version":3,"names":["stream","require","util","Decoder","Simple","utils","constants","bignumber","BigNumber","NoFilter","MT","SYMS","Diagnose","Transform","constructor","options","opts","Object","assign","separator","stream_errors","readableObjectMode","writableObjectMode","float_bytes","parser","on","_on_more","bind","_on_value","_on_start","_on_stop","_on_data","_on_error","_transform","fresh","encoding","cb","write","_flush","er","diagnose","input","Error","encod","guessEncoding","extend","bs","d","p","toString","Promise","resolve","reject","pipe","end","push","emit","mt","len","parent_mt","pos","SIMPLE_FLOAT","_fore","BYTE_STRING","UTF8_STRING","ARRAY","MAP","val","BREAK","NULL","UNDEFINED","JSON","stringify","fb","inspect","Buffer","isBuffer","tag","TAG","STREAM","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/cbor/lib/diagnose.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst util = require('util')\nconst Decoder = require('./decoder')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst constants = require('./constants')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\n\nconst MT = constants.MT\nconst SYMS = constants.SYMS\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends {stream.Transform}\n */\nclass Diagnose extends stream.Transform {\n\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {Object} [options={}] - options for creation\n   * @param {string} [options.separator='\\n'] - output between detected objects\n   * @param {boolean} [options.stream_errors=false] - put error info into the\n   *   output stream\n   * @param {number} [options.max_depth=-1] - -1 for \"until you run out of\n   *   memory\".  Set this to a finite positive number for un-trusted inputs.\n   *   Most standard inputs won't nest more than 100 or so levels; I've tested\n   *   into the millions before running out of memory.\n   */\n  constructor(options) {\n    const opts = Object.assign({\n      separator: '\\n',\n      stream_errors: false\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    })\n    const separator = opts.separator\n    delete opts.separator\n    const stream_errors = opts.stream_errors\n    delete opts.stream_errors\n    super(opts)\n\n    this.float_bytes = -1\n    this.separator = separator\n    this.stream_errors = stream_errors\n    this.parser = new Decoder(opts)\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('data', this._on_data.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n  }\n\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb)\n  }\n\n  _flush(cb) {\n    return this.parser._flush((er) => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er)\n        }\n        return cb()\n      } else {\n        return cb(er)\n      }\n    })\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {(Buffer|string)} input - the CBOR bytes to format\n   * @param {string} [encoding='hex'] - the encoding of input, ignored if\n   *   input is Buffer\n   * @param {function(Error, string): undefined} cb - callback\n   * @returns {Promise} if callback not specified\n   */\n  static diagnose(input, encoding, cb) {\n    if (input == null) {\n      throw new Error('input required')\n    }\n    let opts = {}\n    let encod = 'hex'\n    switch (typeof encoding) {\n      case 'function':\n        cb = encoding\n        encod = utils.guessEncoding(input)\n        break\n      case 'object':\n        opts = utils.extend({}, encoding)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n        break\n      default:\n        encod = (encoding != null) ? encoding : 'hex'\n    }\n    const bs = new NoFilter()\n    const d = new Diagnose(opts)\n    let p = null\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')))\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')))\n        return d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    d.end(input, encod)\n    return p\n  }\n\n  _on_error(er) {\n    if (this.stream_errors) {\n      return this.push(er.toString())\n    } else {\n      return this.emit('error', er)\n    }\n  }\n\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      return this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3\n      }[len]\n    }\n  }\n\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          return this.push(', ')\n        }\n        break\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            return this.push(': ')\n          } else {\n            return this.push(', ')\n          }\n        }\n    }\n  }\n\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return\n    }\n    this._fore(parent_mt, pos)\n    return this.push((() => {\n      switch (false) {\n        case val !== SYMS.NULL:\n          return 'null'\n        case val !== SYMS.UNDEFINED:\n          return 'undefined'\n        case typeof val !== 'string':\n          return JSON.stringify(val)\n        case !(this.float_bytes > 0):\n          const fb = this.float_bytes\n          this.float_bytes = -1\n          return (util.inspect(val)) + '_' + fb\n        case !Buffer.isBuffer(val):\n          return 'h\\'' + (val.toString('hex')) + '\\''\n        case !(val instanceof bignumber):\n          return val.toString()\n        default:\n          return util.inspect(val)\n      }\n    })())\n  }\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos)\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`)\n        break\n      case MT.ARRAY:\n        this.push('[')\n        break\n      case MT.MAP:\n        this.push('{')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(')\n        break\n    }\n    if (tag === SYMS.STREAM) {\n      return this.push('_ ')\n    }\n  }\n\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        return this.push(')')\n      case MT.ARRAY:\n        return this.push(']')\n      case MT.MAP:\n        return this.push('}')\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        return this.push(')')\n    }\n  }\n\n  _on_data() {\n    return this.push(this.separator)\n  }\n}\n\nmodule.exports = Diagnose\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}