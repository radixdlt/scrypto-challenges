{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readBuffer = exports.BufferReader = void 0;\n/* eslint-disable */\nconst neverthrow_1 = require(\"neverthrow\");\nconst createBufferReader = buf => {\n  if (!Buffer.isBuffer(buf)) {\n    buf = Buffer.from(buf); // Convert Uint8Array to Buffer for Electron renderer compatibility ðŸ’©\n  }\n  let offset = 0;\n  let bytesLeftToRead = buf.length;\n  const readNextBuffer = byteCount => {\n    if (byteCount < 0) return neverthrow_1.err(new Error(`'byteCount' must be no negative`));\n    if (byteCount === 0) {\n      return neverthrow_1.ok(Buffer.alloc(0));\n    }\n    if (offset + byteCount > buf.length) return neverthrow_1.err(new Error(`Out of buffer's boundary`));\n    const bufToReturn = Buffer.alloc(byteCount);\n    buf.copy(bufToReturn, 0, offset, offset + byteCount);\n    if (bufToReturn.length !== byteCount) {\n      throw new Error(`Incorrect length of newly read buffer...`);\n    }\n    offset += byteCount;\n    bytesLeftToRead -= byteCount;\n    // console.log(`\n    // \tðŸ§µðŸ§µðŸ§µ\n    // \t\tread: #${byteCount} bytes,\n    // \t\tread buffer: '0x${bufToReturn.toString('hex')}',\n    // \t\toffset: ${offset},\n    // \t\tsource buffer: '0x${buf.toString('hex')}',\n    // \t\tlength of source buffer: #${buf.length} bytes.\n    // \t\tbytesLeftToRead: #${bytesLeftToRead}\n    // \tðŸ§µðŸ§µðŸ§µ\n    // `)\n    return neverthrow_1.ok(bufToReturn);\n  };\n  const finishedParsing = () => {\n    if (bytesLeftToRead < 0) {\n      throw new Error(`Incorrect implementation, read too many bytes.`);\n    }\n    return bytesLeftToRead === 0;\n  };\n  return {\n    readNextBuffer,\n    finishedParsing,\n    remainingBytes: () => {\n      if (finishedParsing()) return Buffer.alloc(0);\n      const leftBuf = Buffer.alloc(bytesLeftToRead);\n      buf.copy(leftBuf, 0, offset);\n      return leftBuf;\n    }\n  };\n};\nexports.BufferReader = {\n  create: createBufferReader\n};\nconst readBuffer = buffer => {\n  const bufferReader = createBufferReader(buffer);\n  return bufferReader.readNextBuffer;\n};\nexports.readBuffer = readBuffer;\n/* eslint-enable */","map":{"version":3,"names":["neverthrow_1","require","createBufferReader","buf","Buffer","isBuffer","from","offset","bytesLeftToRead","length","readNextBuffer","byteCount","err","Error","ok","alloc","bufToReturn","copy","finishedParsing","remainingBytes","leftBuf","exports","BufferReader","create","readBuffer","buffer","bufferReader"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/util/src/bufferReader.ts"],"sourcesContent":["/* eslint-disable */\nimport { err, ok, Result } from 'neverthrow'\n\nexport type BufferReaderT = Readonly<{\n\tfinishedParsing: () => boolean\n\treadNextBuffer: (byteCount: number) => Result<Buffer, Error>\n\tremainingBytes: () => Buffer\n}>\n\nconst createBufferReader = (buf: Buffer): BufferReaderT => {\n\tif (!Buffer.isBuffer(buf)) {\n\t\tbuf = Buffer.from(buf) // Convert Uint8Array to Buffer for Electron renderer compatibility ðŸ’©\n\t}\n\n\tlet offset = 0\n\tlet bytesLeftToRead = buf.length\n\n\tconst readNextBuffer = (byteCount: number): Result<Buffer, Error> => {\n\t\tif (byteCount < 0)\n\t\t\treturn err(new Error(`'byteCount' must be no negative`))\n\t\tif (byteCount === 0) {\n\t\t\treturn ok(Buffer.alloc(0))\n\t\t}\n\t\tif (offset + byteCount > buf.length)\n\t\t\treturn err(new Error(`Out of buffer's boundary`))\n\t\tconst bufToReturn = Buffer.alloc(byteCount)\n\t\tbuf.copy(bufToReturn, 0, offset, offset + byteCount)\n\n\t\tif (bufToReturn.length !== byteCount) {\n\t\t\tthrow new Error(`Incorrect length of newly read buffer...`)\n\t\t}\n\n\t\toffset += byteCount\n\t\tbytesLeftToRead -= byteCount\n\n\t\t// console.log(`\n\t\t// \tðŸ§µðŸ§µðŸ§µ\n\t\t// \t\tread: #${byteCount} bytes,\n\t\t// \t\tread buffer: '0x${bufToReturn.toString('hex')}',\n\t\t// \t\toffset: ${offset},\n\t\t// \t\tsource buffer: '0x${buf.toString('hex')}',\n\t\t// \t\tlength of source buffer: #${buf.length} bytes.\n\t\t// \t\tbytesLeftToRead: #${bytesLeftToRead}\n\t\t// \tðŸ§µðŸ§µðŸ§µ\n\t\t// `)\n\n\t\treturn ok(bufToReturn)\n\t}\n\n\tconst finishedParsing = (): boolean => {\n\t\tif (bytesLeftToRead < 0) {\n\t\t\tthrow new Error(`Incorrect implementation, read too many bytes.`)\n\t\t}\n\t\treturn bytesLeftToRead === 0\n\t}\n\n\treturn {\n\t\treadNextBuffer,\n\t\tfinishedParsing,\n\t\tremainingBytes: (): Buffer => {\n\t\t\tif (finishedParsing()) return Buffer.alloc(0)\n\t\t\tconst leftBuf = Buffer.alloc(bytesLeftToRead)\n\t\t\tbuf.copy(leftBuf, 0, offset)\n\t\t\treturn leftBuf\n\t\t},\n\t}\n}\nexport const BufferReader = {\n\tcreate: createBufferReader,\n}\n\nexport const readBuffer = (\n\tbuffer: Buffer,\n): ((byteCount: number) => Result<Buffer, Error>) => {\n\tconst bufferReader: BufferReaderT = createBufferReader(buffer)\n\treturn bufferReader.readNextBuffer\n}\n\n/* eslint-enable */\n"],"mappings":";;;;;;AAAA;AACA,MAAAA,YAAA,GAAAC,OAAA;AAQA,MAAMC,kBAAkB,GAAIC,GAAW,IAAmB;EACzD,IAAI,CAACC,MAAM,CAACC,QAAQ,CAACF,GAAG,CAAC,EAAE;IAC1BA,GAAG,GAAGC,MAAM,CAACE,IAAI,CAACH,GAAG,CAAC,EAAC;;EAGxB,IAAII,MAAM,GAAG,CAAC;EACd,IAAIC,eAAe,GAAGL,GAAG,CAACM,MAAM;EAEhC,MAAMC,cAAc,GAAIC,SAAiB,IAA2B;IACnE,IAAIA,SAAS,GAAG,CAAC,EAChB,OAAOX,YAAA,CAAAY,GAAG,CAAC,IAAIC,KAAK,CAAC,iCAAiC,CAAC,CAAC;IACzD,IAAIF,SAAS,KAAK,CAAC,EAAE;MACpB,OAAOX,YAAA,CAAAc,EAAE,CAACV,MAAM,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC;;IAE3B,IAAIR,MAAM,GAAGI,SAAS,GAAGR,GAAG,CAACM,MAAM,EAClC,OAAOT,YAAA,CAAAY,GAAG,CAAC,IAAIC,KAAK,CAAC,0BAA0B,CAAC,CAAC;IAClD,MAAMG,WAAW,GAAGZ,MAAM,CAACW,KAAK,CAACJ,SAAS,CAAC;IAC3CR,GAAG,CAACc,IAAI,CAACD,WAAW,EAAE,CAAC,EAAET,MAAM,EAAEA,MAAM,GAAGI,SAAS,CAAC;IAEpD,IAAIK,WAAW,CAACP,MAAM,KAAKE,SAAS,EAAE;MACrC,MAAM,IAAIE,KAAK,CAAC,0CAA0C,CAAC;;IAG5DN,MAAM,IAAII,SAAS;IACnBH,eAAe,IAAIG,SAAS;IAE5B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA,OAAOX,YAAA,CAAAc,EAAE,CAACE,WAAW,CAAC;EACvB,CAAC;EAED,MAAME,eAAe,GAAGA,CAAA,KAAc;IACrC,IAAIV,eAAe,GAAG,CAAC,EAAE;MACxB,MAAM,IAAIK,KAAK,CAAC,gDAAgD,CAAC;;IAElE,OAAOL,eAAe,KAAK,CAAC;EAC7B,CAAC;EAED,OAAO;IACNE,cAAc;IACdQ,eAAe;IACfC,cAAc,EAAEA,CAAA,KAAa;MAC5B,IAAID,eAAe,EAAE,EAAE,OAAOd,MAAM,CAACW,KAAK,CAAC,CAAC,CAAC;MAC7C,MAAMK,OAAO,GAAGhB,MAAM,CAACW,KAAK,CAACP,eAAe,CAAC;MAC7CL,GAAG,CAACc,IAAI,CAACG,OAAO,EAAE,CAAC,EAAEb,MAAM,CAAC;MAC5B,OAAOa,OAAO;IACf;GACA;AACF,CAAC;AACYC,OAAA,CAAAC,YAAY,GAAG;EAC3BC,MAAM,EAAErB;CACR;AAEM,MAAMsB,UAAU,GACtBC,MAAc,IACqC;EACnD,MAAMC,YAAY,GAAkBxB,kBAAkB,CAACuB,MAAM,CAAC;EAC9D,OAAOC,YAAY,CAAChB,cAAc;AACnC,CAAC;AALYW,OAAA,CAAAG,UAAU,GAAAA,UAAA;AAOvB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}