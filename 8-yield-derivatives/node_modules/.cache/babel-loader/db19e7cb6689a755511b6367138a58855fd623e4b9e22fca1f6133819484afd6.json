{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HDPathRadix = exports.BIP44 = exports.bip44Purpose = exports.RADIX_COIN_TYPE = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\nconst bip32_1 = require(\"../bip32\");\nconst bip32PathComponent_1 = require(\"../bip32PathComponent\");\nconst util_1 = require(\"@radixdlt/util\");\nexports.RADIX_COIN_TYPE = 1022;\nconst bip44Component = input => {\n  const componentResult = bip32PathComponent_1.BIP32PathComponent.create(input);\n  if (componentResult.isErr()) {\n    throw new Error(`Incorrect implementation, should always be able to create BIP44 component. Underlying error: '${(0, util_1.msgFromError)(componentResult.error)}'.`);\n  }\n  return Object.assign(Object.assign({}, componentResult.value), {\n    name: input.name\n  });\n};\nexports.bip44Purpose = bip44Component({\n  index: 44,\n  isHardened: true,\n  level: 1,\n  name: 'purpose'\n});\nconst bip44CoinType = index => bip44Component({\n  index: index,\n  isHardened: true,\n  level: 2,\n  name: 'coin type'\n});\nconst bip44Account = index => bip44Component({\n  index: index,\n  isHardened: true,\n  level: 3,\n  name: 'account'\n});\nconst bip44Change = index => bip44Component({\n  index: index,\n  isHardened: false,\n  level: 4,\n  name: 'change'\n});\nconst create = input => {\n  var _a, _b, _c, _d;\n  const purpose = exports.bip44Purpose;\n  const coinType = bip44CoinType((_a = input.coinType) !== null && _a !== void 0 ? _a : exports.RADIX_COIN_TYPE);\n  const account = bip44Account((_b = input.account) !== null && _b !== void 0 ? _b : 0);\n  const change = bip44Change((_c = input.change) !== null && _c !== void 0 ? _c : 0);\n  const addressIndex = bip44Component({\n    index: input.address.index,\n    isHardened: (_d = input.address.isHardened) !== null && _d !== void 0 ? _d : true,\n    level: 5,\n    name: 'address index'\n  });\n  const pathComponents = [purpose, coinType, account, change, addressIndex];\n  const bip32 = bip32_1.BIP32.unsafeCreate(pathComponents);\n  return Object.assign(Object.assign({}, bip32), {\n    purpose,\n    coinType,\n    account,\n    change,\n    addressIndex,\n    pathComponents\n  });\n};\nconst fromComponents = bip32Components => bip32_1.BIP32.create(bip32Components).andThen(bip32 => radixPathFromString(bip32.toString()));\nconst createRadixPath = input => create(input);\nconst validateBIP44Component = (expected, component) => {\n  if (component.level !== expected.level) return (0, neverthrow_1.err)(new Error('Wrong level in BIP44 path'));\n  if (component.isHardened !== expected.isHardened) return (0, neverthrow_1.err)(new Error(`Wrong hardened value, expected component at level ${component.level} to${expected.isHardened ? '' : ' NOT'} be hardened, but it is${component.isHardened ? '' : ' NOT'}.`));\n  if (expected.name) {\n    if (component.name !== expected.name) return (0, neverthrow_1.err)(new Error('Wrong name'));\n  }\n  if (expected.index) {\n    if (component.index !== expected.index) {\n      return (0, neverthrow_1.err)(new Error(`Wrong index, component.index: ${component.index}, expected.index: ${expected.index}, whole expected: ${JSON.stringify(expected, null, 4)}, component: ${JSON.stringify(component, null, 4)}`));\n    }\n  }\n  return (0, neverthrow_1.ok)(component);\n};\nconst validateBIP44Purpose = validateBIP44Component.bind(null, exports.bip44Purpose);\nconst validateBIP44CoinType = validateBIP44Component.bind(null, Object.assign(Object.assign({}, bip44CoinType(0)), {\n  index: undefined\n}));\nconst validateBIP44Account = validateBIP44Component.bind(null, Object.assign(Object.assign({}, bip44Account(0)), {\n  index: undefined\n}));\nconst validateBIP44Change = validateBIP44Component.bind(null, Object.assign(Object.assign({}, bip44Change(0)), {\n  index: undefined\n}));\nconst fromString = path => bip32_1.BIP32.fromString(path).andThen(bip32 => {\n  const components = bip32.pathComponents;\n  if (components.length !== 5) return (0, neverthrow_1.err)(new Error(`We require BIP44 to have five components: purpose / cointype / account / change / address`));\n  return (0, neverthrow_1.combine)([validateBIP44Purpose(Object.assign(Object.assign({}, components[0]), {\n    name: 'purpose'\n  })), validateBIP44CoinType(Object.assign(Object.assign({}, components[1]), {\n    name: 'coin type'\n  })), validateBIP44Account(Object.assign(Object.assign({}, components[2]), {\n    name: 'account'\n  })), validateBIP44Change(Object.assign(Object.assign({}, components[3]), {\n    name: 'change'\n  })), (0, neverthrow_1.ok)(Object.assign(Object.assign({}, components[4]), {\n    name: 'address index'\n  }))]).map(bip44Components => Object.assign(Object.assign({}, bip32), {\n    purpose: bip44Components[0],\n    coinType: bip44Components[1],\n    account: bip44Components[2],\n    change: bip44Components[3],\n    addressIndex: bip44Components[4],\n    pathComponents: bip44Components\n  }));\n});\nconst extractValueFromIndex = pathComponent => {\n  const {\n    index,\n    isHardened\n  } = pathComponent;\n  if (index >= bip32PathComponent_1.hardenedIncrement && !isHardened) return (0, neverthrow_1.err)(new Error(`Incorrect values passed, index is hardened, but you believed it to not be. Index: ${index}`));\n  if (index < bip32PathComponent_1.hardenedIncrement && isHardened) return (0, neverthrow_1.err)(new Error('Incorrect values passed, index is not hardened, but you believed it to be. Index: ${index}'));\n  return (0, neverthrow_1.ok)(isHardened ? index - bip32PathComponent_1.hardenedIncrement : index);\n};\nconst radixPathFromString = path => fromString(path).andThen(bip44 => extractValueFromIndex(bip44.coinType).andThen(coinType => coinType === exports.RADIX_COIN_TYPE ? (0, neverthrow_1.ok)(bip44) : (0, neverthrow_1.err)(new Error(`Incorrect coin type, expected Radix coin type: ${exports.RADIX_COIN_TYPE}, but got: ${coinType}`))));\nexports.BIP44 = {\n  create,\n  fromString\n};\nexports.HDPathRadix = {\n  create: createRadixPath,\n  fromString: radixPathFromString,\n  fromComponents\n};","map":{"version":3,"names":["neverthrow_1","require","bip32_1","bip32PathComponent_1","util_1","exports","RADIX_COIN_TYPE","bip44Component","input","componentResult","BIP32PathComponent","create","isErr","Error","msgFromError","error","Object","assign","value","name","bip44Purpose","index","isHardened","level","bip44CoinType","bip44Account","bip44Change","purpose","coinType","_a","account","_b","change","_c","addressIndex","address","_d","pathComponents","bip32","BIP32","unsafeCreate","fromComponents","bip32Components","andThen","radixPathFromString","toString","createRadixPath","validateBIP44Component","expected","component","err","JSON","stringify","ok","validateBIP44Purpose","bind","validateBIP44CoinType","undefined","validateBIP44Account","validateBIP44Change","fromString","path","components","length","combine","map","bip44Components","extractValueFromIndex","pathComponent","hardenedIncrement","bip44","BIP44","HDPathRadix"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/src/elliptic-curve/hd/bip32/bip44/bip44.ts"],"sourcesContent":["import { combine, err, ok, Result } from 'neverthrow'\nimport { BIP32 } from '../bip32'\nimport { BIP32PathComponent, hardenedIncrement } from '../bip32PathComponent'\n\nimport { BIP32PathComponentT, BIP32PathSimpleT, BIP32T, Int32 } from '../_types'\nimport { BIP44T, BIP44ChangeIndex, HDPathRadixT } from './_types'\nimport { msgFromError } from '@radixdlt/util'\n\nexport const RADIX_COIN_TYPE: Int32 = 1022\n\nconst bip44Component = (\n\tinput: Readonly<{\n\t\tindex: Int32\n\t\tisHardened: boolean\n\t\tlevel: number\n\t\tname: string\n\t}>,\n): BIP32PathComponentT => {\n\tconst componentResult = BIP32PathComponent.create(input)\n\tif (componentResult.isErr()) {\n\t\tthrow new Error(\n\t\t\t`Incorrect implementation, should always be able to create BIP44 component. Underlying error: '${msgFromError(\n\t\t\t\tcomponentResult.error,\n\t\t\t)}'.`,\n\t\t)\n\t}\n\treturn {\n\t\t...componentResult.value,\n\t\tname: input.name,\n\t}\n}\n\nexport const bip44Purpose = bip44Component({\n\tindex: 44,\n\tisHardened: true,\n\tlevel: 1,\n\tname: 'purpose',\n})\n\nconst bip44CoinType = (index: Int32): BIP32PathComponentT =>\n\tbip44Component({\n\t\tindex: index,\n\t\tisHardened: true,\n\t\tlevel: 2,\n\t\tname: 'coin type',\n\t})\n\nconst bip44Account = (index: Int32): BIP32PathComponentT =>\n\tbip44Component({\n\t\tindex: index,\n\t\tisHardened: true,\n\t\tlevel: 3,\n\t\tname: 'account',\n\t})\n\nconst bip44Change = (index: BIP44ChangeIndex): BIP32PathComponentT =>\n\tbip44Component({\n\t\tindex: index as Int32,\n\t\tisHardened: false,\n\t\tlevel: 4,\n\t\tname: 'change',\n\t})\n\nconst create = (\n\tinput: Readonly<{\n\t\tcoinType?: Int32 // defauts to `1022'` (Radix)\n\t\taccount?: Int32 // defaults to `0'`\n\t\tchange?: BIP44ChangeIndex // defaults to `0`\n\t\taddress: Readonly<{\n\t\t\tindex: Int32\n\t\t\tisHardened?: boolean // defaults to true\n\t\t}>\n\t}>,\n): BIP44T => {\n\tconst purpose = bip44Purpose\n\tconst coinType = bip44CoinType(input.coinType ?? RADIX_COIN_TYPE)\n\tconst account = bip44Account(input.account ?? 0)\n\tconst change = bip44Change(input.change ?? 0)\n\tconst addressIndex = bip44Component({\n\t\tindex: input.address.index,\n\t\tisHardened: input.address.isHardened ?? true,\n\t\tlevel: 5,\n\t\tname: 'address index',\n\t})\n\tconst pathComponents = [purpose, coinType, account, change, addressIndex]\n\n\tconst bip32 = BIP32.unsafeCreate(pathComponents)\n\treturn {\n\t\t...bip32,\n\t\tpurpose,\n\t\tcoinType,\n\t\taccount,\n\t\tchange,\n\t\taddressIndex,\n\t\tpathComponents,\n\t}\n}\n\nconst fromComponents = (\n\tbip32Components: BIP32PathComponentT[],\n): Result<HDPathRadixT, Error> =>\n\tBIP32.create(bip32Components).andThen(bip32 =>\n\t\tradixPathFromString(bip32.toString()),\n\t)\n\nconst createRadixPath = (\n\tinput: Readonly<{\n\t\taccount?: Int32 // defaults to `0'`\n\t\tchange?: BIP44ChangeIndex // defaults to `0`\n\t\taddress: Readonly<{\n\t\t\tindex: Int32\n\t\t\tisHardened?: boolean // defaults to true\n\t\t}>\n\t}>,\n): HDPathRadixT => create(input) as HDPathRadixT\n\nconst validateBIP44Component = (\n\texpected: Readonly<{\n\t\tindex?: Int32\n\t\tisHardened: boolean\n\t\tlevel: number\n\t\tname?: string\n\t}>,\n\tcomponent: BIP32PathComponentT,\n): Result<BIP32PathComponentT, Error> => {\n\tif (component.level !== expected.level)\n\t\treturn err(new Error('Wrong level in BIP44 path'))\n\tif (component.isHardened !== expected.isHardened)\n\t\treturn err(\n\t\t\tnew Error(\n\t\t\t\t`Wrong hardened value, expected component at level ${\n\t\t\t\t\tcomponent.level\n\t\t\t\t} to${\n\t\t\t\t\texpected.isHardened ? '' : ' NOT'\n\t\t\t\t} be hardened, but it is${component.isHardened ? '' : ' NOT'}.`,\n\t\t\t),\n\t\t)\n\tif (expected.name) {\n\t\tif (component.name !== expected.name)\n\t\t\treturn err(new Error('Wrong name'))\n\t}\n\tif (expected.index) {\n\t\tif (component.index !== expected.index) {\n\t\t\treturn err(\n\t\t\t\tnew Error(\n\t\t\t\t\t`Wrong index, component.index: ${\n\t\t\t\t\t\tcomponent.index\n\t\t\t\t\t}, expected.index: ${\n\t\t\t\t\t\texpected.index\n\t\t\t\t\t}, whole expected: ${JSON.stringify(\n\t\t\t\t\t\texpected,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t4,\n\t\t\t\t\t)}, component: ${JSON.stringify(component, null, 4)}`,\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\t}\n\treturn ok(component)\n}\n\nconst validateBIP44Purpose = validateBIP44Component.bind(null, bip44Purpose)\nconst validateBIP44CoinType = validateBIP44Component.bind(null, {\n\t...bip44CoinType(0),\n\tindex: undefined,\n})\nconst validateBIP44Account = validateBIP44Component.bind(null, {\n\t...bip44Account(0),\n\tindex: undefined,\n})\nconst validateBIP44Change = validateBIP44Component.bind(null, {\n\t...bip44Change(0),\n\tindex: undefined,\n})\n\nconst fromString = (path: string): Result<BIP44T, Error> =>\n\tBIP32.fromString(path).andThen(\n\t\t(bip32: BIP32T): Result<BIP44T, Error> => {\n\t\t\tconst components = bip32.pathComponents\n\t\t\tif (components.length !== 5)\n\t\t\t\treturn err(\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t`We require BIP44 to have five components: purpose / cointype / account / change / address`,\n\t\t\t\t\t),\n\t\t\t\t)\n\n\t\t\treturn combine([\n\t\t\t\tvalidateBIP44Purpose({ ...components[0], name: 'purpose' }),\n\t\t\t\tvalidateBIP44CoinType({ ...components[1], name: 'coin type' }),\n\t\t\t\tvalidateBIP44Account({ ...components[2], name: 'account' }),\n\t\t\t\tvalidateBIP44Change({ ...components[3], name: 'change' }),\n\t\t\t\tok({ ...components[4], name: 'address index' }) as Result<\n\t\t\t\t\tBIP32PathComponentT,\n\t\t\t\t\tError\n\t\t\t\t>,\n\t\t\t]).map(\n\t\t\t\t(bip44Components: BIP32PathComponentT[]): BIP44T => ({\n\t\t\t\t\t...bip32,\n\t\t\t\t\tpurpose: bip44Components[0],\n\t\t\t\t\tcoinType: bip44Components[1],\n\t\t\t\t\taccount: bip44Components[2],\n\t\t\t\t\tchange: bip44Components[3],\n\t\t\t\t\taddressIndex: bip44Components[4],\n\t\t\t\t\tpathComponents: bip44Components,\n\t\t\t\t}),\n\t\t\t)\n\t\t},\n\t)\n\nconst extractValueFromIndex = (\n\tpathComponent: BIP32PathSimpleT,\n): Result<Int32, Error> => {\n\tconst { index, isHardened } = pathComponent\n\tif (index >= hardenedIncrement && !isHardened)\n\t\treturn err(\n\t\t\tnew Error(\n\t\t\t\t`Incorrect values passed, index is hardened, but you believed it to not be. Index: ${index}`,\n\t\t\t),\n\t\t)\n\tif (index < hardenedIncrement && isHardened)\n\t\treturn err(\n\t\t\tnew Error(\n\t\t\t\t'Incorrect values passed, index is not hardened, but you believed it to be. Index: ${index}',\n\t\t\t),\n\t\t)\n\treturn ok(isHardened ? index - hardenedIncrement : index)\n}\n\nconst radixPathFromString = (path: string): Result<HDPathRadixT, Error> =>\n\tfromString(path).andThen(bip44 =>\n\t\textractValueFromIndex(bip44.coinType).andThen(coinType =>\n\t\t\tcoinType === RADIX_COIN_TYPE\n\t\t\t\t? ok(bip44 as HDPathRadixT)\n\t\t\t\t: err(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Incorrect coin type, expected Radix coin type: ${RADIX_COIN_TYPE}, but got: ${coinType}`,\n\t\t\t\t\t\t),\n\t\t\t\t  ),\n\t\t),\n\t)\n\nexport const BIP44 = {\n\tcreate,\n\tfromString,\n}\n\nexport const HDPathRadix = {\n\tcreate: createRadixPath,\n\tfromString: radixPathFromString,\n\tfromComponents,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}