{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function retry(count) {\n  if (count === void 0) {\n    count = -1;\n  }\n  return function (source) {\n    return source.lift(new RetryOperator(count, source));\n  };\n}\nvar RetryOperator = /*@__PURE__*/function () {\n  function RetryOperator(count, source) {\n    this.count = count;\n    this.source = source;\n  }\n  RetryOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n  };\n  return RetryOperator;\n}();\nvar RetrySubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(RetrySubscriber, _super);\n  function RetrySubscriber(destination, count, source) {\n    var _this = _super.call(this, destination) || this;\n    _this.count = count;\n    _this.source = source;\n    return _this;\n  }\n  RetrySubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var _a = this,\n        source = _a.source,\n        count = _a.count;\n      if (count === 0) {\n        return _super.prototype.error.call(this, err);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  };\n  return RetrySubscriber;\n}(Subscriber);","map":{"version":3,"names":["tslib_1","Subscriber","retry","count","source","lift","RetryOperator","prototype","call","subscriber","subscribe","RetrySubscriber","_super","__extends","destination","_this","error","err","isStopped","_a","_unsubscribeAndRecycle"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/radixdlt/node_modules/rxjs/src/internal/operators/retry.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * ![](retry.png)\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n *\n * ## Example\n * ```ts\n * import { interval, of, throwError } from 'rxjs';\n * import { mergeMap, retry } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   mergeMap(val => {\n *     if(val > 5){\n *       return throwError('Error!');\n *     }\n *     return of(val);\n *   }),\n *   //retry 2 times on error\n *   retry(2)\n * );\n *\n * const subscribe = example.subscribe({\n *   next: val => console.log(val),\n *   error: val => console.log(`${val}: Retried 2 times then quit!`)\n * });\n *\n * // Output:\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // \"Error!: Retried 2 times then quit!\"\n * ```\n *\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nexport function retry<T>(count: number = -1): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RetryOperator(count, source));\n}\n\nclass RetryOperator<T> implements Operator<T, T> {\n  constructor(private count: number,\n              private source: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RetrySubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>,\n              private count: number,\n              private source: Observable<T>) {\n    super(destination);\n  }\n  error(err: any) {\n    if (!this.isStopped) {\n      const { source, count } = this;\n      if (count === 0) {\n        return super.error(err);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  }\n}\n"],"mappings":";AACA,OAAO,KAAEA,OAAU,MAAE,OAAM;AAmD3B,SAAMC,UAAU,QAA2B;OAAlB,SAAAC,MAAAC,KAAA;EACvB,IAAAA,KAAO,UAAC;IACTA,KAAA;EAED;EACE,iBAAAC,MAAoB;IAAA,OACAA,MAAqB,CAAAC,IAAA,KAAAC,aAAA,CAAAH,KAAA,EAAAC,MAAA;EAAA;;iBAArB,GAAM,aAAe;EACzC,SAACE,cAAAH,KAAA,EAAAC,MAAA;IAED,KAAAD,KAAA,GAAAA,KAAA;IACE,KAAAC,MAAO,GAAOA,MAAA;EAChB;EACFE,aAAA,CAAAC,SAAC,CAAAC,IAAA,aAAAC,UAAA,EAAAL,MAAA;IAAA,OAAAA,MAAA,CAAAM,SAAA,KAAAC,eAAA,CAAAF,UAAA,OAAAN,KAAA,OAAAC,MAAA;EAOD;EAAiC,OAAAE,aAAA;GAC/B;mBAAA,GAGE,uBAAMM,MAAY;SAFA,CAAAC,SAAK,CAALF,eAAa,EAAAC,MAAA;WACbD,gBAAMG,WAAe,EAAAX,KAAA,EAAAC,MAAA;;IAExCW,KAAA,CAAAZ,KAAA,GAAAA,KAAA;IACDY,KAAA,CAAAX,MAAA,GAAAA,MAAA;IACE,OAAKW,KAAK;;iBAEJ,CAAAR,SAAa,CAAAS,KAAA,aAAAC,GAAA;aACf,CAAAC,SAAO;UACRC,EAAA;QAAAf,MAAA,GAAAe,EAAA,CAAAf,MAAA;QAAAD,KAAA,GAAAgB,EAAA,CAAAhB,KAAA;eAAU,KAAK,GAAG;QACjB,OAAKS,MAAQ,CAAAL,SAAU,CAAAS,KAAA,CAAAR,IAAA,OAAAS,GAAA;OACxB,MACD,IAAOd,KAAA,GAAU,IAAI;QACtB,KAAAA,KAAA,GAAAA,KAAA;MACF;MACHC,MAAA,CAAAM,SAAC,MAAAU,sBAAA;IAjBgC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}