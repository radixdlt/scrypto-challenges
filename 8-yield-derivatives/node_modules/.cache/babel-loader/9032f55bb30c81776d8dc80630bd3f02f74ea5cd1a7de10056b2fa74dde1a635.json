{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nexports.__esModule = true;\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\nvar Contract_1 = require(\"./Contract\");\nvar Option_1 = require(\"./Option\");\nvar HashSet_1 = require(\"./HashSet\");\nvar Vector_1 = require(\"./Vector\");\nvar LinkedList_1 = require(\"./LinkedList\");\nvar SeqHelpers = require(\"./SeqHelpers\");\nvar Value_1 = require(\"./Value\");\nvar hamt = require(\"hamt_plus\");\n// HashMap could extend Collection, conceptually. But I'm\n// not super happy of having the callbacks get a pair, for instance\n// 'HashMap.filter' takes two parameters in the current HashMap;\n// if HashMap did implement Collection, it would have to take a k,v\n// pair. There's also another trick with 'contains'. The Collection signature\n// says T&WithEquality, but here we get [K&WithEquality,V&WithEquality],\n// but arrays don't have equality so that doesn't type-check :-(\n/**\n * A dictionary, mapping keys to values.\n * @param K the key type\n * @param V the value type\n */\nvar HashMap = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function HashMap(hamt) {\n    this.hamt = hamt;\n  }\n  /**\n   * The empty map.\n   * @param K the key type\n   * @param V the value type\n   */\n  HashMap.empty = function () {\n    return emptyHashMap;\n  };\n  /**\n   * Build a HashMap from key-value pairs.\n   *\n   *     HashMap.of([1,\"a\"],[2,\"b\"])\n   *\n   */\n  HashMap.of = function () {\n    var entries = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      entries[_i] = arguments[_i];\n    }\n    return HashMap.ofIterable(entries);\n  };\n  /**\n   * Build a HashMap from an iterable containing key-value pairs.\n   *\n   *    HashMap.ofIterable(Vector.of<[number,string]>([1,\"a\"],[2,\"b\"]));\n   */\n  HashMap.ofIterable = function (entries) {\n    // remember we must set up the hamt with the custom equality\n    var iterator = entries[Symbol.iterator]();\n    var curItem = iterator.next();\n    if (curItem.done) {\n      return new EmptyHashMap();\n    }\n    // emptyhashmap.put sets up the custom equality+hashcode\n    var startH = new EmptyHashMap().put(curItem.value[0], curItem.value[1]).hamt;\n    curItem = iterator.next();\n    return new HashMap(startH.mutate(function (h) {\n      while (!curItem.done) {\n        h.set(curItem.value[0], curItem.value[1]);\n        curItem = iterator.next();\n      }\n    }));\n  };\n  /**\n   * Build a HashMap from a javascript object literal representing\n   * a dictionary. Note that the key type must always be string,\n   * as that's the way it works in javascript.\n   * Also note that entries with undefined values will be stripped\n   * from the map.\n   *\n   *     HashMap.ofObjectDictionary<number>({a:1,b:2})\n   *     => HashMap.of([\"a\",1],[\"b\",2])\n   */\n  HashMap.ofObjectDictionary = function (object) {\n    // no need to bother with the proper equals & hashcode\n    // as I know the key type supports ===\n    var h = hamt.make().beginMutation();\n    for (var property in object) {\n      // the reason we strip entries with undefined values on\n      // import from object dictionaries are: sanity, and also\n      // partial object definitions like {[TKey in MyEnum]?:number}\n      // where typescript sees the value type as 'number|undefined'\n      // (there is a test covering that)\n      if (object.hasOwnProperty(property) && typeof object[property] !== \"undefined\") {\n        h.set(property, object[property]);\n      }\n    }\n    return new HashMap(h.endMutation());\n  };\n  /**\n   * Curried predicate to find out whether the HashMap is empty.\n   *\n   *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())\n   *         .filter(HashMap.isEmpty)\n   *     => Vector.of(HashMap.empty<number,number>())\n   */\n  HashMap.isEmpty = function (v) {\n    return v.isEmpty();\n  };\n  /**\n   * Curried predicate to find out whether the HashMap is empty.\n   *\n   *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())\n   *         .filter(HashMap.isNotEmpty)\n   *     => Vector.of(HashMap.of([1,2]))\n   */\n  HashMap.isNotEmpty = function (v) {\n    return !v.isEmpty();\n  };\n  /**\n   * Get the value for the key you give, if the key is present.\n   */\n  HashMap.prototype.get = function (k) {\n    return Option_1.Option.of(this.hamt.get(k));\n  };\n  /**\n   * Implementation of the Iterator interface.\n   */\n  HashMap.prototype[Symbol.iterator] = function () {\n    return this.hamt.entries();\n  };\n  /**\n   * @hidden\n   */\n  HashMap.prototype.hasTrueEquality = function () {\n    // for true equality, need both key & value to have true\n    // equality. but i can't check when they're in an array,\n    // as array doesn't have true equality => extract them\n    // and check them separately.\n    return Option_1.Option.of(this.hamt.entries().next().value).map(function (x) {\n      return x[0];\n    }).hasTrueEquality() && Option_1.Option.of(this.hamt.entries().next().value).map(function (x) {\n      return x[1];\n    }).hasTrueEquality();\n  };\n  /**\n   * Add a new entry in the map. If there was entry with the same\n   * key, it will be overwritten.\n   * @param k the key\n   * @param v the value\n   */\n  HashMap.prototype.put = function (k, v) {\n    return new HashMap(this.hamt.set(k, v));\n  };\n  /**\n   * Return a new map with the key you give removed.\n   */\n  HashMap.prototype.remove = function (k) {\n    return new HashMap(this.hamt.remove(k));\n  };\n  /**\n   * Add a new entry in the map; in case there was already an\n   * entry with the same key, the merge function will be invoked\n   * with the old and the new value to produce the value to take\n   * into account.\n   *\n   * It is guaranteed that the merge function first parameter\n   * will be the entry from this map, and the second parameter\n   * from the map you give.\n   * @param k the key\n   * @param v the value\n   * @param merge a function to merge old and new values in case of conflict.\n   */\n  HashMap.prototype.putWithMerge = function (k, v, merge) {\n    return new HashMap(this.hamt.modify(k, function (curV) {\n      if (curV === undefined) {\n        return v;\n      }\n      return merge(curV, v);\n    }));\n  };\n  /**\n   * number of items in the map\n   */\n  HashMap.prototype.length = function () {\n    return this.hamt.size;\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  HashMap.prototype.single = function () {\n    return this.hamt.size === 1 ? Option_1.Option.of(this.hamt.entries().next().value) : Option_1.Option.none();\n  };\n  /**\n   * true if the map is empty, false otherwise.\n   */\n  HashMap.prototype.isEmpty = function () {\n    return this.hamt.size === 0;\n  };\n  /**\n   * Get a Set containing all the keys in the map\n   */\n  HashMap.prototype.keySet = function () {\n    return HashSet_1.HashSet.ofIterable(this.hamt.keys());\n  };\n  /**\n   * Get an iterable containing all the values in the map\n   * (can't return a set as we don't constrain map values\n   * to have equality in the generics type)\n   */\n  HashMap.prototype.valueIterable = function () {\n    var _a;\n    var hamt = this.hamt;\n    return _a = {}, _a[Symbol.iterator] = function () {\n      return hamt.values();\n    }, _a;\n  };\n  /**\n   * Create a new map combining the entries of this map, and\n   * the other map you give. In case an entry from this map\n   * and the other map have the same key, the merge function\n   * will be invoked to get a combined value.\n   *\n   * It is guaranteed that the merge function first parameter\n   * will be the entry from this map, and the second parameter\n   * from the map you give.\n   * @param other another map to merge with this one\n   * @param merge a merge function to combine two values\n   *        in case two entries share the same key.\n   */\n  HashMap.prototype.mergeWith = function (elts, merge) {\n    var iterator = elts[Symbol.iterator]();\n    var map = this;\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      map = map.putWithMerge(curItem.value[0], curItem.value[1], merge);\n      curItem = iterator.next();\n    }\n    return map;\n  };\n  /**\n   * Return a new map where each entry was transformed\n   * by the mapper function you give. You return key,value\n   * as pairs.\n   */\n  HashMap.prototype.map = function (fn) {\n    return this.hamt.fold(function (acc, value, key) {\n      var _a = fn(key, value),\n        newk = _a[0],\n        newv = _a[1];\n      return acc.put(newk, newv);\n    }, HashMap.empty());\n  };\n  /**\n   * Return a new map where keys are the same as in this one,\n   * but values are transformed\n   * by the mapper function you give. You return key,value\n   * as pairs.\n   */\n  HashMap.prototype.mapValues = function (fn) {\n    return this.hamt.fold(function (acc, value, key) {\n      return acc.put(key, fn(value));\n    }, HashMap.empty());\n  };\n  /**\n   * Call a function for element in the collection.\n   */\n  HashMap.prototype.forEach = function (fun) {\n    var iterator = this.hamt.entries();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      fun(curItem.value);\n      curItem = iterator.next();\n    }\n    return this;\n  };\n  /**\n   * Calls the function you give for each item in the map,\n   * your function returns a map, all the maps are\n   * merged.\n   */\n  HashMap.prototype.flatMap = function (fn) {\n    return this.foldLeft(HashMap.empty(), function (soFar, cur) {\n      return soFar.mergeWith(fn(cur[0], cur[1]), function (a, b) {\n        return b;\n      });\n    });\n  };\n  /**\n   * Returns true if the predicate returns true for all the\n   * elements in the collection.\n   */\n  HashMap.prototype.allMatch = function (predicate) {\n    var iterator = this.hamt.entries();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (!predicate(curItem.value[0], curItem.value[1])) {\n        return false;\n      }\n      curItem = iterator.next();\n    }\n    return true;\n  };\n  /**\n   * Returns true if there the predicate returns true for any\n   * element in the collection.\n   */\n  HashMap.prototype.anyMatch = function (predicate) {\n    var iterator = this.hamt.entries();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (predicate(curItem.value[0], curItem.value[1])) {\n        return true;\n      }\n      curItem = iterator.next();\n    }\n    return false;\n  };\n  /**\n   * Returns true if the item is in the collection,\n   * false otherwise.\n   */\n  HashMap.prototype.contains = function (val) {\n    return Comparison_1.areEqual(this.hamt.get(val[0]), val[1]);\n  };\n  /**\n   * Returns true if there is item with that key in the collection,\n   * false otherwise.\n   *\n   *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"]).containsKey(1);\n   *     => true\n   *\n   *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"]).containsKey(3);\n   *     => false\n   */\n  HashMap.prototype.containsKey = function (key) {\n    return this.hamt.has(key);\n  };\n  /**\n   * Call a predicate for each element in the collection,\n   * build a new collection holding only the elements\n   * for which the predicate returned true.\n   */\n  HashMap.prototype.filter = function (predicate) {\n    var _this = this;\n    return new HashMap(hamt.make({\n      hash: this.hamt._config.hash,\n      keyEq: this.hamt._config.keyEq\n    }).mutate(function (h) {\n      var iterator = _this.hamt.entries();\n      var curItem = iterator.next();\n      while (!curItem.done) {\n        if (predicate(curItem.value[0], curItem.value[1])) {\n          h.set(curItem.value[0], curItem.value[1]);\n        }\n        curItem = iterator.next();\n      }\n    }));\n  };\n  /**\n   * Search for an item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   * We name the method findAny instead of find to emphasize\n   * that there is not ordering in a hashset.\n   *\n   *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])\n   *         .findAny((k,v) => k>=2 && v === \"c\")\n   *     => Option.of([3,'c'])\n   *\n   *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])\n   *         .findAny((k,v) => k>=3 && v === \"b\")\n   *     => Option.none<[number,string]>()\n   */\n  HashMap.prototype.findAny = function (predicate) {\n    var iterator = this.hamt.entries();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (predicate(curItem.value[0], curItem.value[1])) {\n        return Option_1.Option.of(curItem.value);\n      }\n      curItem = iterator.next();\n    }\n    return Option_1.Option.none();\n  };\n  HashMap.prototype.filterKeys = function (predicate) {\n    return this.filter(function (k, v) {\n      return predicate(k);\n    });\n  };\n  HashMap.prototype.filterValues = function (predicate) {\n    return this.filter(function (k, v) {\n      return predicate(v);\n    });\n  };\n  /**\n   * Reduces the collection to a single value using the\n   * associative binary function you give. Since the function\n   * is associative, order of application doesn't matter.\n   *\n   * Example:\n   *\n   *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"],[3,\"c\"])\n   *      .fold([0,\"\"], ([a,b],[c,d])=>[a+c, b>d?b:d])\n   *     => [6,\"c\"]\n   */\n  HashMap.prototype.fold = function (zero, fn) {\n    return this.foldLeft(zero, fn);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Left-associative.\n   * No guarantees for the order of items in a hashset!\n   *\n   * Example:\n   *\n   *     HashMap.of([1,\"a\"], [2,\"bb\"], [3,\"ccc\"])\n   *     .foldLeft(0, (soFar,[item,val])=>soFar+val.length);\n   *     => 6\n   *\n   * @param zero The initial value\n   * @param fn A function taking the previous value and\n   *           the current collection item, and returning\n   *           an updated value.\n   */\n  HashMap.prototype.foldLeft = function (zero, fn) {\n    return this.hamt.fold(function (acc, v, k) {\n      return fn(acc, [k, v]);\n    }, zero);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Right-associative.\n   * No guarantees for the order of items in a hashset!\n   *\n   * Example:\n   *\n   *     HashMap.of([1,\"a\"], [2,\"bb\"], [3,\"ccc\"])\n   *     .foldRight(0, ([item,value],soFar)=>soFar+value.length);\n   *     => 6\n   *\n   * @param zero The initial value\n   * @param fn A function taking the current collection item and\n   *           the previous value , and returning\n   *           an updated value.\n   */\n  HashMap.prototype.foldRight = function (zero, fn) {\n    return this.foldLeft(zero, function (cur, soFar) {\n      return fn(soFar, cur);\n    });\n  };\n  /**\n   * Reduces the collection to a single value by repeatedly\n   * calling the combine function.\n   * No starting value. The order in which the elements are\n   * passed to the combining function is undetermined.\n   */\n  HashMap.prototype.reduce = function (combine) {\n    // not really glorious with any...\n    return SeqHelpers.reduce(this, combine);\n  };\n  /**\n   * Convert to array.\n   */\n  HashMap.prototype.toArray = function () {\n    return this.hamt.fold(function (acc, value, key) {\n      acc.push([key, value]);\n      return acc;\n    }, []);\n  };\n  /**\n   * Convert this map to a vector of key,value pairs.\n   * Note that Map is already an iterable of key,value pairs!\n   */\n  HashMap.prototype.toVector = function () {\n    return this.hamt.fold(function (acc, value, key) {\n      return acc.append([key, value]);\n    }, Vector_1.Vector.empty());\n  };\n  /**\n   * Convert this map to a list of key,value pairs.\n   * Note that Map is already an iterable of key,value pairs!\n   */\n  HashMap.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.ofIterable(this);\n  };\n  /**\n   * Convert to a javascript object dictionary\n   * You must provide a function to convert the\n   * key to a string.\n   *\n   *     HashMap.of<string,number>([\"a\",1],[\"b\",2])\n   *         .toObjectDictionary(x=>x);\n   *     => {a:1,b:2}\n   */\n  HashMap.prototype.toObjectDictionary = function (keyConvert) {\n    return this.foldLeft({}, function (soFar, cur) {\n      soFar[keyConvert(cur[0])] = cur[1];\n      return soFar;\n    });\n  };\n  HashMap.prototype.toJsMap = function (keyConvert) {\n    return this.foldLeft(new Map(), function (soFar, cur) {\n      return soFar.set(keyConvert(cur[0]), cur[1]);\n    });\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  HashMap.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  HashMap.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || !other.valueIterable) {\n      return false;\n    }\n    Contract_1.contractTrueEquality(\"HashMap.equals\", this, other);\n    var sz = this.hamt.size;\n    if (other.length() === 0 && sz === 0) {\n      // we could get that i'm not the empty map\n      // but my size is zero, after some filtering and such.\n      return true;\n    }\n    if (sz !== other.length()) {\n      return false;\n    }\n    var keys = Array.from(this.hamt.keys());\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var k = keys_1[_i];\n      var myVal = this.hamt.get(k);\n      var hisVal = other.get(k).getOrUndefined();\n      if (myVal === undefined || hisVal === undefined) {\n        return false;\n      }\n      if (!Comparison_1.areEqual(myVal, hisVal)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  HashMap.prototype.hashCode = function () {\n    // references:\n    // https://github.com/clojure/clojure/blob/5ffe3833508495ca7c635d47ad7a1c8b820eab76/src/jvm/clojure/lang/APersistentMap.java#L98\n    // https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/19fb8f93c59dfd791f62d41f332db9e306bc1422/src/java.base/share/classes/java/util/HashMap.java#L296\n    // Both the Clojure and AdoptOpenJDK references calculate the bitwise XOR\n    // of the key/value pairs. The significance of the bitwise XOR is that,\n    // unlike just adding the hashcode of the key and value pair, they become\n    // intertwined, which prevents collisions when identical values are swapped\n    // between keys.\n    // This algorithm only intertwines the keys and the values. The calculations\n    // for the pairs are summed up, to make sure that we get the same result\n    // if the pairs are in a different order.\n    // The Clojure implementation also caches the result of the calculation, but\n    // we've decided not to do that yet, see the discussion on the PR for context:\n    // https://github.com/emmanueltouzery/prelude-ts/pull/67\n    return this.hamt.fold(function (acc, value, key) {\n      return acc + (Comparison_1.getHashCode(key) ^ Comparison_1.getHashCode(value));\n    }, 0);\n  };\n  /*\n   * Get a human-friendly string representation of that value.\n   */\n  HashMap.prototype.toString = function () {\n    return \"HashMap(\" + this.hamt.fold(function (acc, value, key) {\n      acc.push(SeqHelpers_1.toStringHelper(key, {\n        quoteStrings: false\n      }) + \": \" + SeqHelpers_1.toStringHelper(value));\n      return acc;\n    }, []).join(\", \") + \")\";\n  };\n  HashMap.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return HashMap;\n}();\nexports.HashMap = HashMap;\n// we need to override the empty hashmap\n// because i don't know how to get the hash & keyset\n// functions for the keys without a key value to get\n// the functions from\nvar EmptyHashMap = /** @class */function (_super) {\n  __extends(EmptyHashMap, _super);\n  function EmptyHashMap() {\n    return _super.call(this, {}) || this;\n  }\n  EmptyHashMap.prototype.get = function (k) {\n    return Option_1.none;\n  };\n  EmptyHashMap.prototype[Symbol.iterator] = function () {\n    return {\n      next: function () {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  };\n  EmptyHashMap.prototype.put = function (k, v) {\n    Contract_1.contractTrueEquality(\"Error building a HashMap\", k);\n    if (Comparison_1.hasEquals(k)) {\n      return new HashMap(hamt.make({\n        hash: function (v) {\n          return v.hashCode();\n        },\n        keyEq: function (a, b) {\n          return a.equals(b);\n        }\n      }).set(k, v));\n    }\n    return new HashMap(hamt.make().set(k, v));\n  };\n  EmptyHashMap.prototype.remove = function (k) {\n    return this;\n  };\n  EmptyHashMap.prototype.hasTrueEquality = function () {\n    return true;\n  };\n  EmptyHashMap.prototype.putWithMerge = function (k, v, merge) {\n    return this.put(k, v);\n  };\n  EmptyHashMap.prototype.length = function () {\n    return 0;\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  EmptyHashMap.prototype.single = function () {\n    return Option_1.Option.none();\n  };\n  EmptyHashMap.prototype.isEmpty = function () {\n    return true;\n  };\n  EmptyHashMap.prototype.keySet = function () {\n    return HashSet_1.HashSet.empty();\n  };\n  EmptyHashMap.prototype.valueIterable = function () {\n    var _a;\n    return _a = {}, _a[Symbol.iterator] = function () {\n      return {\n        next: function () {\n          return {\n            done: true,\n            value: undefined\n          };\n        }\n      };\n    }, _a;\n  };\n  EmptyHashMap.prototype.mergeWith = function (other, merge) {\n    return HashMap.ofIterable(other);\n  };\n  EmptyHashMap.prototype.map = function (fn) {\n    return HashMap.empty();\n  };\n  EmptyHashMap.prototype.mapValues = function (fn) {\n    return HashMap.empty();\n  };\n  EmptyHashMap.prototype.forEach = function (fun) {\n    return this;\n  };\n  EmptyHashMap.prototype.allMatch = function (predicate) {\n    return true;\n  };\n  EmptyHashMap.prototype.anyMatch = function (predicate) {\n    return false;\n  };\n  EmptyHashMap.prototype.contains = function (val) {\n    return false;\n  };\n  EmptyHashMap.prototype.containsKey = function (key) {\n    return false;\n  };\n  EmptyHashMap.prototype.filter = function (predicate) {\n    return this;\n  };\n  EmptyHashMap.prototype.findAny = function (predicate) {\n    return Option_1.Option.none();\n  };\n  EmptyHashMap.prototype.foldLeft = function (zero, fn) {\n    return zero;\n  };\n  EmptyHashMap.prototype.toArray = function () {\n    return [];\n  };\n  EmptyHashMap.prototype.toVector = function () {\n    return Vector_1.Vector.empty();\n  };\n  EmptyHashMap.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.empty();\n  };\n  EmptyHashMap.prototype.equals = function (other) {\n    if (!other || !other.valueIterable) {\n      return false;\n    }\n    return other === emptyHashMap || other.length() === 0;\n  };\n  EmptyHashMap.prototype.hashCode = function () {\n    return 0;\n  };\n  EmptyHashMap.prototype.toString = function () {\n    return \"HashMap()\";\n  };\n  return EmptyHashMap;\n}(HashMap);\nvar emptyHashMap = new EmptyHashMap();","map":{"version":3,"names":["Comparison_1","require","SeqHelpers_1","Contract_1","Option_1","HashSet_1","Vector_1","LinkedList_1","SeqHelpers","Value_1","hamt","HashMap","empty","emptyHashMap","of","entries","_i","arguments","length","ofIterable","iterator","Symbol","curItem","next","done","EmptyHashMap","startH","put","value","mutate","h","set","ofObjectDictionary","object","make","beginMutation","property","hasOwnProperty","endMutation","isEmpty","v","isNotEmpty","prototype","get","k","Option","hasTrueEquality","map","x","remove","putWithMerge","merge","modify","curV","undefined","size","single","none","keySet","HashSet","keys","valueIterable","_a","values","mergeWith","elts","fn","fold","acc","key","newk","newv","mapValues","forEach","fun","flatMap","foldLeft","soFar","cur","a","b","allMatch","predicate","anyMatch","contains","val","areEqual","containsKey","has","filter","_this","hash","_config","keyEq","findAny","filterKeys","filterValues","zero","foldRight","reduce","combine","toArray","push","toVector","append","Vector","toLinkedList","LinkedList","toObjectDictionary","keyConvert","toJsMap","Map","transform","converter","equals","other","contractTrueEquality","sz","Array","from","keys_1","myVal","hisVal","getOrUndefined","hashCode","getHashCode","toString","toStringHelper","quoteStrings","join","inspect","exports","_super","__extends","call","hasEquals"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/HashMap.ts"],"sourcesContent":["import { IMap } from \"./IMap\";\nimport { hasEquals, HasEquals, WithEquality,\n         getHashCode, areEqual, fieldsHashCode } from \"./Comparison\";\nimport { toStringHelper } from \"./SeqHelpers\";\nimport { contractTrueEquality } from \"./Contract\"\nimport { Option, none, None } from \"./Option\";\nimport { HashSet } from \"./HashSet\";\nimport { Vector } from \"./Vector\";\nimport { LinkedList } from \"./LinkedList\";\nimport * as SeqHelpers from \"./SeqHelpers\";\nimport { inspect } from \"./Value\";\nconst hamt: any = require(\"hamt_plus\");\n\n// HashMap could extend Collection, conceptually. But I'm\n// not super happy of having the callbacks get a pair, for instance\n// 'HashMap.filter' takes two parameters in the current HashMap;\n// if HashMap did implement Collection, it would have to take a k,v\n// pair. There's also another trick with 'contains'. The Collection signature\n// says T&WithEquality, but here we get [K&WithEquality,V&WithEquality],\n// but arrays don't have equality so that doesn't type-check :-(\n\n/**\n * A dictionary, mapping keys to values.\n * @param K the key type\n * @param V the value type\n */\nexport class HashMap<K,V> implements IMap<K,V> {\n\n    /**\n     * @hidden\n     */\n    protected constructor(private hamt: any) {}\n\n    /**\n     * The empty map.\n     * @param K the key type\n     * @param V the value type\n     */\n    static empty<K,V>(): HashMap<K,V> {\n        return <EmptyHashMap<K,V>>emptyHashMap;\n    }\n\n    /**\n     * Build a HashMap from key-value pairs.\n     *\n     *     HashMap.of([1,\"a\"],[2,\"b\"])\n     *\n     */\n    static of<K,V>(...entries: Array<[K&WithEquality, V]>): HashMap<K,V> {\n        return HashMap.ofIterable<K,V>(entries);\n    }\n\n    /**\n     * Build a HashMap from an iterable containing key-value pairs.\n     *\n     *    HashMap.ofIterable(Vector.of<[number,string]>([1,\"a\"],[2,\"b\"]));\n     */\n    static ofIterable<K,V>(entries: Iterable<[K&WithEquality, V]>): HashMap<K,V> {\n        // remember we must set up the hamt with the custom equality\n        const iterator = entries[Symbol.iterator]();\n        let curItem = iterator.next();\n        if (curItem.done) {\n            return new EmptyHashMap<K,V>();\n        }\n        // emptyhashmap.put sets up the custom equality+hashcode\n        let startH = (new EmptyHashMap<K,V>()).put(curItem.value[0], curItem.value[1]).hamt;\n        curItem = iterator.next();\n        return new HashMap<K,V>(startH.mutate((h:any) => {\n            while (!curItem.done) {\n                h.set(curItem.value[0], curItem.value[1]);\n                curItem = iterator.next();\n            }\n        }));\n    }\n\n    /**\n     * Build a HashMap from a javascript object literal representing\n     * a dictionary. Note that the key type must always be string,\n     * as that's the way it works in javascript.\n     * Also note that entries with undefined values will be stripped\n     * from the map.\n     *\n     *     HashMap.ofObjectDictionary<number>({a:1,b:2})\n     *     => HashMap.of([\"a\",1],[\"b\",2])\n     */\n    static ofObjectDictionary<V>(object: {[index:string]: V|undefined}): HashMap<string,V> {\n        // no need to bother with the proper equals & hashcode\n        // as I know the key type supports ===\n        const h: any = hamt.make().beginMutation();\n        for (let property in object) {\n            // the reason we strip entries with undefined values on\n            // import from object dictionaries are: sanity, and also\n            // partial object definitions like {[TKey in MyEnum]?:number}\n            // where typescript sees the value type as 'number|undefined'\n            // (there is a test covering that)\n            if (object.hasOwnProperty(property) &&\n                (typeof object[property] !== \"undefined\")) {\n                h.set(property, object[property]);\n            }\n        }\n        return new HashMap<string,V>(h.endMutation());\n    }\n\n    /**\n     * Curried predicate to find out whether the HashMap is empty.\n     *\n     *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())\n     *         .filter(HashMap.isEmpty)\n     *     => Vector.of(HashMap.empty<number,number>())\n     */\n    static isEmpty<K,V>(v: HashMap<K,V>): boolean {\n        return v.isEmpty();\n    }\n\n    /**\n     * Curried predicate to find out whether the HashMap is empty.\n     *\n     *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())\n     *         .filter(HashMap.isNotEmpty)\n     *     => Vector.of(HashMap.of([1,2]))\n     */\n    static isNotEmpty<K,V>(v: HashMap<K,V>): boolean {\n        return !v.isEmpty();\n    }\n\n    /**\n     * Get the value for the key you give, if the key is present.\n     */\n    get(k: K & WithEquality): Option<V> {\n        return Option.of<V>(this.hamt.get(k));\n    }\n\n    /**\n     * Implementation of the Iterator interface.\n     */\n    [Symbol.iterator](): Iterator<[K,V]> {\n        return this.hamt.entries();\n    }\n\n    /**\n     * @hidden\n     */\n    hasTrueEquality(): boolean {\n        // for true equality, need both key & value to have true\n        // equality. but i can't check when they're in an array,\n        // as array doesn't have true equality => extract them\n        // and check them separately.\n        return Option.of(this.hamt.entries().next().value)\n            .map(x => x[0]).hasTrueEquality() &&\n            Option.of(this.hamt.entries().next().value)\n            .map(x => x[1]).hasTrueEquality()\n    }\n\n    /**\n     * Add a new entry in the map. If there was entry with the same\n     * key, it will be overwritten.\n     * @param k the key\n     * @param v the value\n     */\n    put(k: K & WithEquality, v: V): HashMap<K,V> {\n        return new HashMap<K,V>(this.hamt.set(k,v));\n    }\n\n    /**\n     * Return a new map with the key you give removed.\n     */\n    remove(k: K&WithEquality): HashMap<K,V> {\n        return new HashMap<K,V>(this.hamt.remove(k));\n    }\n\n    /**\n     * Add a new entry in the map; in case there was already an\n     * entry with the same key, the merge function will be invoked\n     * with the old and the new value to produce the value to take\n     * into account.\n     *\n     * It is guaranteed that the merge function first parameter\n     * will be the entry from this map, and the second parameter\n     * from the map you give.\n     * @param k the key\n     * @param v the value\n     * @param merge a function to merge old and new values in case of conflict.\n     */\n    putWithMerge(k: K & WithEquality, v: V, merge: (v1: V, v2: V) => V): HashMap<K,V> {\n        return new HashMap<K,V>(this.hamt.modify(k, (curV?: V) => {\n            if (curV === undefined) {\n                return v;\n            }\n            return merge(curV, v);\n        }))\n    }\n\n    /**\n     * number of items in the map\n     */\n    length(): number {\n        return this.hamt.size;\n    }\n\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    single(): Option<[K,V]> {\n        return this.hamt.size === 1\n            ? Option.of(this.hamt.entries().next().value)\n            : Option.none();\n    }\n\n    /**\n     * true if the map is empty, false otherwise.\n     */\n    isEmpty(): boolean {\n        return this.hamt.size === 0;\n    }\n\n    /**\n     * Get a Set containing all the keys in the map\n     */\n    keySet(): HashSet<K> {\n        return HashSet.ofIterable<K>(this.hamt.keys());\n    }\n\n    /**\n     * Get an iterable containing all the values in the map\n     * (can't return a set as we don't constrain map values\n     * to have equality in the generics type)\n     */\n    valueIterable(): Iterable<V> {\n        const hamt = this.hamt;\n        return {\n            [Symbol.iterator]() { return hamt.values(); }\n        };\n    }\n\n    /**\n     * Create a new map combining the entries of this map, and\n     * the other map you give. In case an entry from this map\n     * and the other map have the same key, the merge function\n     * will be invoked to get a combined value.\n     *\n     * It is guaranteed that the merge function first parameter\n     * will be the entry from this map, and the second parameter\n     * from the map you give.\n     * @param other another map to merge with this one\n     * @param merge a merge function to combine two values\n     *        in case two entries share the same key.\n     */\n    mergeWith(elts: Iterable<[K & WithEquality,V]>, merge:(v1: V, v2: V) => V): HashMap<K,V> {\n        const iterator = elts[Symbol.iterator]();\n        let map: HashMap<K,V> = this;\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            map = map.putWithMerge(curItem.value[0], curItem.value[1], merge);\n            curItem = iterator.next();\n        }\n        return map;\n    }\n\n    /**\n     * Return a new map where each entry was transformed\n     * by the mapper function you give. You return key,value\n     * as pairs.\n     */\n    map<K2,V2>(fn:(k:K&WithEquality, v:V)=>[K2&WithEquality,V2]): HashMap<K2,V2> {\n        return this.hamt.fold(\n            (acc: HashMap<K2,V2>, value: V, key: K&WithEquality) => {\n                const [newk,newv] = fn(key, value);\n                return acc.put(newk,newv);\n            }, HashMap.empty());\n    }\n\n    /**\n     * Return a new map where keys are the same as in this one,\n     * but values are transformed\n     * by the mapper function you give. You return key,value\n     * as pairs.\n     */\n    mapValues<V2>(fn:(v:V)=>V2): HashMap<K,V2> {\n        return this.hamt.fold(\n            (acc: HashMap<K,V2>, value: V, key: K&WithEquality) =>\n                acc.put(key,fn(value)), HashMap.empty());\n    }\n\n    /**\n     * Call a function for element in the collection.\n     */\n    forEach(fun:(x:[K,V])=>void): HashMap<K,V> {\n        const iterator: Iterator<[K,V]> = this.hamt.entries();\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            fun(curItem.value);\n            curItem = iterator.next();\n        }\n        return this;\n    }\n\n    /**\n     * Calls the function you give for each item in the map,\n     * your function returns a map, all the maps are\n     * merged.\n     */\n    flatMap<K2,V2>(fn:(k:K, v:V)=>Iterable<[K2&WithEquality,V2]>): HashMap<K2,V2> {\n        return this.foldLeft(HashMap.empty<K2,V2>(),\n                             (soFar,cur) => soFar.mergeWith(fn(cur[0],cur[1]), (a,b)=>b));\n    }\n\n    /**\n     * Returns true if the predicate returns true for all the\n     * elements in the collection.\n     */\n    allMatch(predicate:(k:K,v:V)=>boolean): boolean {\n        const iterator: Iterator<[K,V]> = this.hamt.entries();\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            if (!predicate(curItem.value[0], curItem.value[1])) {\n                return false;\n            }\n            curItem = iterator.next();\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    anyMatch(predicate:(k:K,v:V)=>boolean): boolean {\n        const iterator: Iterator<[K,V]> = this.hamt.entries();\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            if (predicate(curItem.value[0], curItem.value[1])) {\n                return true;\n            }\n            curItem = iterator.next();\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the item is in the collection,\n     * false otherwise.\n     */\n    contains(val: [K&WithEquality,V&WithEquality]): boolean {\n        return areEqual(this.hamt.get(val[0]), val[1]);\n    }\n\n    /**\n     * Returns true if there is item with that key in the collection,\n     * false otherwise.\n     *\n     *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"]).containsKey(1);\n     *     => true\n     *\n     *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"]).containsKey(3);\n     *     => false\n     */\n    containsKey(key: K&WithEquality): boolean {\n        return this.hamt.has(key);\n    }\n\n    /**\n     * Call a predicate for each element in the collection,\n     * build a new collection holding only the elements\n     * for which the predicate returned true.\n     */\n    filter(predicate:(k:K,v:V)=>boolean): HashMap<K,V> {\n        return new HashMap<K,V>(\n            hamt.make({hash:this.hamt._config.hash, keyEq:this.hamt._config.keyEq}).mutate((h:any) => {\n                const iterator: Iterator<[K,V]> = this.hamt.entries();\n                let curItem = iterator.next();\n                while (!curItem.done) {\n                    if (predicate(curItem.value[0], curItem.value[1])) {\n                        h.set(curItem.value[0], curItem.value[1]);\n                    }\n                    curItem = iterator.next();\n                }\n            }));\n    }\n\n    /**\n     * Search for an item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     * We name the method findAny instead of find to emphasize\n     * that there is not ordering in a hashset.\n     *\n     *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])\n     *         .findAny((k,v) => k>=2 && v === \"c\")\n     *     => Option.of([3,'c'])\n     *\n     *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])\n     *         .findAny((k,v) => k>=3 && v === \"b\")\n     *     => Option.none<[number,string]>()\n     */\n    findAny(predicate:(k:K,v:V)=>boolean): Option<[K,V]> {\n        const iterator: Iterator<[K,V]> = this.hamt.entries();\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            if (predicate(curItem.value[0], curItem.value[1])) {\n                return Option.of(curItem.value);\n            }\n            curItem = iterator.next();\n        }\n        return Option.none<[K,V]>();\n    }\n\n    /**\n     * Call a predicate for each key in the collection,\n     * build a new collection holding only the elements\n     * for which the predicate returned true.\n     *\n     *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"]).filterKeys(k=>k%2===0)\n     *     => HashMap.of<number,string>([2,\"b\"])\n     */\n    filterKeys<U extends K>(fn:(v:K)=>v is U): HashMap<U,V>;\n    filterKeys(predicate:(k:K)=>boolean): HashMap<K,V>;\n    filterKeys(predicate:(k:K)=>boolean): HashMap<K,V> {\n        return this.filter((k,v)=>predicate(k));\n    }\n\n    /**\n     * Call a predicate for each value in the collection,\n     * build a new collection holding only the elements\n     * for which the predicate returned true.\n     *\n     *     HashMap.of<number,string>([1,\"a\"],[2,\"ab\"]).filterValues(v=>v.length>1)\n     *     => HashMap.of<number,string>([2,\"ab\"])\n     */\n    filterValues<U extends V>(fn:(v:V)=>v is U): HashMap<K,U>;\n    filterValues(predicate:(k:V)=>boolean): HashMap<K,V>;\n    filterValues(predicate:(k:V)=>boolean): HashMap<K,V> {\n        return this.filter((k,v)=>predicate(v));\n    }\n\n    /**\n     * Reduces the collection to a single value using the\n     * associative binary function you give. Since the function\n     * is associative, order of application doesn't matter.\n     *\n     * Example:\n     *\n     *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"],[3,\"c\"])\n     *      .fold([0,\"\"], ([a,b],[c,d])=>[a+c, b>d?b:d])\n     *     => [6,\"c\"]\n     */\n    fold(zero:[K,V], fn:(v1:[K,V],v2:[K,V])=>[K,V]): [K,V] {\n        return this.foldLeft(zero, fn);\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Left-associative.\n     * No guarantees for the order of items in a hashset!\n     *\n     * Example:\n     *\n     *     HashMap.of([1,\"a\"], [2,\"bb\"], [3,\"ccc\"])\n     *     .foldLeft(0, (soFar,[item,val])=>soFar+val.length);\n     *     => 6\n     *\n     * @param zero The initial value\n     * @param fn A function taking the previous value and\n     *           the current collection item, and returning\n     *           an updated value.\n     */\n    foldLeft<U>(zero: U, fn:(soFar:U,cur:[K,V])=>U): U {\n        return this.hamt.fold(\n            (acc: U, v: V, k: K&WithEquality) =>\n                fn(acc, [k,v]), zero);\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Right-associative.\n     * No guarantees for the order of items in a hashset!\n     *\n     * Example:\n     *\n     *     HashMap.of([1,\"a\"], [2,\"bb\"], [3,\"ccc\"])\n     *     .foldRight(0, ([item,value],soFar)=>soFar+value.length);\n     *     => 6\n     *\n     * @param zero The initial value\n     * @param fn A function taking the current collection item and\n     *           the previous value , and returning\n     *           an updated value.\n     */\n    foldRight<U>(zero: U, fn:(cur:[K,V], soFar:U)=>U): U {\n        return this.foldLeft(zero, (cur, soFar) => fn(soFar, cur));\n    }\n\n    /**\n     * Reduces the collection to a single value by repeatedly\n     * calling the combine function.\n     * No starting value. The order in which the elements are\n     * passed to the combining function is undetermined.\n     */\n    reduce(combine: (v1:[K,V],v2:[K,V])=>[K,V]): Option<[K,V]> {\n        // not really glorious with any...\n        return <Option<[K,V]>>SeqHelpers.reduce<any>(<any>this, combine);\n    }\n\n    /**\n     * Convert to array.\n     */\n    toArray(): Array<[K,V]> {\n        return this.hamt.fold(\n            (acc: [[K,V]], value: V, key: K&WithEquality) =>\n                {acc.push([key,value]); return acc; }, []);\n    }\n\n    /**\n     * Convert this map to a vector of key,value pairs.\n     * Note that Map is already an iterable of key,value pairs!\n     */\n    toVector(): Vector<[K,V]> {\n        return this.hamt.fold(\n            (acc: Vector<[K,V]>, value: V, key: K&WithEquality) =>\n                acc.append([key,value]), Vector.empty());\n    }\n\n    /**\n     * Convert this map to a list of key,value pairs.\n     * Note that Map is already an iterable of key,value pairs!\n     */\n    toLinkedList(): LinkedList<[K,V]> {\n        return LinkedList.ofIterable(this);\n    }\n\n    /**\n     * Convert to a javascript object dictionary\n     * You must provide a function to convert the\n     * key to a string.\n     *\n     *     HashMap.of<string,number>([\"a\",1],[\"b\",2])\n     *         .toObjectDictionary(x=>x);\n     *     => {a:1,b:2}\n     */\n    toObjectDictionary(keyConvert:(k:K)=>string): {[index:string]:V} {\n        return this.foldLeft<{[index:string]:V}>({}, (soFar,cur)=> {\n            soFar[keyConvert(cur[0])] = cur[1];\n            return soFar;\n        });\n    }\n\n    /**\n     * Convert to an ES6 Map.\n     * You must provide a function to convert the\n     * key to a string, number or boolean, because\n     * with other types equality is not correctly\n     * managed by JS.\n     * https://stackoverflow.com/questions/29759480/how-to-customize-object-equality-for-javascript-set\n     * https://esdiscuss.org/topic/maps-with-object-keys\n     *\n     *     HashMap.of<string,number>([\"a\",1],[\"b\",2])\n     *         .toJsMap(x=>x);\n     *     => new Map([[\"a\",1], [\"b\",2]])\n     */\n    toJsMap(keyConvert:(k:K)=>string): Map<string,V>;\n    toJsMap(keyConvert:(k:K)=>number): Map<number,V>;\n    toJsMap(keyConvert:(k:K)=>boolean): Map<boolean,V>;\n    toJsMap<K2 extends number|string|boolean>(keyConvert:(k:K)=>K2): Map<K2,V> {\n        return this.foldLeft(\n            new Map<K2,V>(),\n            (soFar,cur)=> soFar.set(keyConvert(cur[0]), cur[1]));\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:HashMap<K,V>)=>U): U {\n        return converter(this);\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other: IMap<K&WithEquality,V&WithEquality>): boolean {\n        if (<any>other === this) {\n            return true;\n        }\n        if (!other || !other.valueIterable) {\n            return false;\n        }\n        contractTrueEquality(\"HashMap.equals\", this, other);\n        const sz = this.hamt.size;\n        if (other.length() === 0 && sz === 0) {\n            // we could get that i'm not the empty map\n            // but my size is zero, after some filtering and such.\n            return true;\n        }\n        if (sz !== other.length()) {\n            return false;\n        }\n        const keys: Array<K & WithEquality> = Array.from<K & WithEquality>(this.hamt.keys());\n        for (let k of keys) {\n            const myVal: V|null|undefined = this.hamt.get(k);\n            const hisVal: V|null|undefined = other.get(k).getOrUndefined();\n            if (myVal === undefined || hisVal === undefined) {\n                return false;\n            }\n            if (!areEqual(myVal, hisVal)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        // references:\n        // https://github.com/clojure/clojure/blob/5ffe3833508495ca7c635d47ad7a1c8b820eab76/src/jvm/clojure/lang/APersistentMap.java#L98\n        // https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/19fb8f93c59dfd791f62d41f332db9e306bc1422/src/java.base/share/classes/java/util/HashMap.java#L296\n\n        // Both the Clojure and AdoptOpenJDK references calculate the bitwise XOR\n        // of the key/value pairs. The significance of the bitwise XOR is that,\n        // unlike just adding the hashcode of the key and value pair, they become\n        // intertwined, which prevents collisions when identical values are swapped\n        // between keys.\n\n        // This algorithm only intertwines the keys and the values. The calculations\n        // for the pairs are summed up, to make sure that we get the same result\n        // if the pairs are in a different order.\n\n        // The Clojure implementation also caches the result of the calculation, but\n        // we've decided not to do that yet, see the discussion on the PR for context:\n        // https://github.com/emmanueltouzery/prelude-ts/pull/67\n        return this.hamt.fold(\n            (acc: number, value: V, key: K & WithEquality) =>\n                acc + (getHashCode(key) ^ getHashCode(value)), 0);\n    }\n\n    /*\n     * Get a human-friendly string representation of that value.\n     */\n    toString(): string {\n        return \"HashMap(\" +\n            this.hamt.fold(\n                (acc: string[], value: V, key: K) =>\n                    {acc.push(\n                        toStringHelper(key, {quoteStrings:false}) +\n                            \": \" + toStringHelper(value)); return acc;}, [])\n            .join(\", \") + \")\";\n    }\n\n    [inspect](): string {\n        return this.toString();\n    }\n}\n\n// we need to override the empty hashmap\n// because i don't know how to get the hash & keyset\n// functions for the keys without a key value to get\n// the functions from\nclass EmptyHashMap<K,V> extends HashMap<K,V> {\n\n    constructor() {\n        super({}); // we must override all the functions\n    }\n\n    get(k: K & WithEquality): Option<V> {\n        return <None<V>>none;\n    }\n\n    [Symbol.iterator](): Iterator<[K,V]> {\n        return { next: () => ({ done: true, value: <any>undefined }) };\n    }\n\n    put(k: K & WithEquality, v: V): HashMap<K,V> {\n        contractTrueEquality(\"Error building a HashMap\", k);\n        if (hasEquals(k)) {\n            return new HashMap<K,V>(hamt.make({\n                hash: (v: K & HasEquals) => v.hashCode(),\n                keyEq: (a: K & HasEquals, b: K & HasEquals) => a.equals(b)\n            }).set(k,v));\n        }\n        return new HashMap<K,V>(hamt.make().set(k,v));\n    }\n\n    remove(k: K&WithEquality): HashMap<K,V> {\n        return this;\n    }\n\n    hasTrueEquality(): boolean {\n        return true;\n    }\n\n    putWithMerge(k: K & WithEquality, v: V, merge: (v1: V, v2: V) => V): HashMap<K,V> {\n        return this.put(k,v);\n    }\n\n    length(): number {\n        return 0;\n    }\n\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    single(): Option<[K,V]> {\n        return Option.none<[K,V]>();\n    }\n\n    isEmpty(): boolean {\n        return true;\n    }\n\n    keySet(): HashSet<K> {\n        return HashSet.empty<K>();\n    }\n\n    valueIterable(): Iterable<V> {\n        return {\n            [Symbol.iterator](): Iterator<V> {\n                return {\n                    next(): IteratorResult<V> {\n                        return {\n                            done: true,\n                            value: <any>undefined\n                        };\n                    }\n                };\n            }\n        };\n    }\n\n    mergeWith(other: Iterable<[K & WithEquality,V]>, merge:(v1: V, v2: V) => V): HashMap<K,V> {\n        return HashMap.ofIterable(other);\n    }\n\n    map<K2,V2>(fn:(k:K&WithEquality, v:V)=>[K2&WithEquality,V2]): HashMap<K2,V2> {\n        return HashMap.empty<K2,V2>();\n    }\n\n    mapValues<V2>(fn:(v:V)=>V2): HashMap<K,V2> {\n        return HashMap.empty<K,V2>();\n    }\n\n    forEach(fun:(x:[K,V])=>void): HashMap<K,V> {\n        return this;\n    }\n\n    allMatch(predicate:(k:K,v:V)=>boolean): boolean {\n        return true;\n    }\n\n    anyMatch(predicate:(k:K,v:V)=>boolean): boolean {\n        return false;\n    }\n\n    contains(val: [K&WithEquality,V&WithEquality]): boolean {\n        return false;\n    }\n\n    containsKey(key: K&WithEquality) : boolean {\n        return false;\n    }\n\n    filter(predicate:(k:K,v:V)=>boolean): HashMap<K,V> {\n        return this;\n    }\n\n    findAny(predicate:(k:K,v:V)=>boolean): Option<[K,V]> {\n        return Option.none<[K,V]>();\n    }\n\n    foldLeft<U>(zero: U, fn:(soFar:U,cur:[K,V])=>U): U {\n        return zero;\n    }\n\n    toArray(): Array<[K,V]> {\n        return [];\n    }\n\n    toVector(): Vector<[K,V]> {\n        return Vector.empty<[K,V]>();\n    }\n\n    toLinkedList(): LinkedList<[K,V]> {\n        return LinkedList.empty<[K,V]>();\n    }\n\n    equals(other: IMap<K&WithEquality,V&WithEquality>): boolean {\n        if (!other || !other.valueIterable) {\n            return false;\n        }\n        return <any>other === emptyHashMap || other.length() === 0;\n    }\n\n    hashCode(): number {\n        return 0;\n    }\n\n    toString(): string {\n        return \"HashMap()\";\n    }\n}\n\nconst emptyHashMap = new EmptyHashMap<any,any>();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}