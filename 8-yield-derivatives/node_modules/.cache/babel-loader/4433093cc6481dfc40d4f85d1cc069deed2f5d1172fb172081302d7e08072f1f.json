{"ast":null,"code":"import { operate } from '../util/lift';\nimport { OperatorSubscriber } from './OperatorSubscriber';\nexport function mapTo(value) {\n  return operate(function (source, subscriber) {\n    source.subscribe(new OperatorSubscriber(subscriber, function () {\n      return subscriber.next(value);\n    }));\n  });\n}","map":{"version":3,"names":["operate","OperatorSubscriber","mapTo","value","source","subscriber","subscribe","next"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/rxjs/src/internal/operators/mapTo.ts"],"sourcesContent":["import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { OperatorSubscriber } from './OperatorSubscriber';\n\nexport function mapTo<R>(value: R): OperatorFunction<any, R>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R>;\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n * Map every click to the string 'Hi'\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { mapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return A function that returns an Observable that emits the given `value`\n * every time the source Observable emits.\n */\nexport function mapTo<R>(value: R): OperatorFunction<any, R> {\n  return operate((source, subscriber) => {\n    // Subscribe to the source. All errors and completions are forwarded to the consumer\n    source.subscribe(\n      new OperatorSubscriber(\n        subscriber,\n        // On every value from the source, send the `mapTo` value to the consumer.\n        () => subscriber.next(value)\n      )\n    );\n  });\n}\n"],"mappings":"AACA,SAASA,OAAO,QAAQ,cAAc;AACtC,SAASC,kBAAkB,QAAQ,sBAAsB;AAoCzD,OAAM,SAAUC,KAAKA,CAAIC,KAAQ;EAC/B,OAAOH,OAAO,CAAC,UAACI,MAAM,EAAEC,UAAU;IAEhCD,MAAM,CAACE,SAAS,CACd,IAAIL,kBAAkB,CACpBI,UAAU,EAEV;MAAM,OAAAA,UAAU,CAACE,IAAI,CAACJ,KAAK,CAAC;IAAtB,CAAsB,CAC7B,CACF;EACH,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}