{"ast":null,"code":"/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { from } from './from';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\nexport function onErrorResumeNext() {\n  var sources = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    sources[_i] = arguments[_i];\n  }\n  if (sources.length === 0) {\n    return EMPTY;\n  }\n  var first = sources[0],\n    remainder = sources.slice(1);\n  if (sources.length === 1 && isArray(first)) {\n    return onErrorResumeNext.apply(void 0, first);\n  }\n  return new Observable(function (subscriber) {\n    var subNext = function () {\n      return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber));\n    };\n    return from(first).subscribe({\n      next: function (value) {\n        subscriber.next(value);\n      },\n      error: subNext,\n      complete: subNext\n    });\n  });\n}","map":{"version":3,"names":["Observable","from","isArray","EMPTY","onErrorResumeNext","_i","arguments","length","sources","first","remainder","slice","apply","subscriber","subNext","add","subscribe","next","value","error","complete"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/radixdlt/node_modules/rxjs/src/internal/observable/onErrorResumeNext.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\nimport { from } from './from';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNext<R>(v: ObservableInput<R>): Observable<R>;\nexport function onErrorResumeNext<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\nexport function onErrorResumeNext<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\nexport function onErrorResumeNext<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\nexport function onErrorResumeNext<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\n\nexport function onErrorResumeNext<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport function onErrorResumeNext<R>(array: ObservableInput<any>[]): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` Will subscribe to each observable source it is provided, in order.\n * If the source it's subscribed to emits an error or completes, it will move to the next source\n * without error.\n *\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link index/EMPTY}.\n *\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\n * sources emits an error.\n *\n * Note that there is no way to handle any errors thrown by sources via the result of\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\n *\n * ## Example\n * Subscribe to the next Observable after map fails</caption>\n * ```ts\n * import { onErrorResumeNext, of } from 'rxjs';\n * import { map } from 'rxjs/operators';\n *\n * onErrorResumeNext(\n *  of(1, 2, 3, 0).pipe(\n *    map(x => {\n *      if (x === 0) throw Error();\n *      return 10 / x;\n *    })\n *  ),\n *  of(1, 2, 3),\n * )\n * .subscribe(\n *   val => console.log(val),\n *   err => console.log(err),          // Will never be called.\n *   () => console.log('done'),\n * );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"done\"\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.\n * @return {Observable} An Observable that concatenates all sources, one after the other,\n * ignoring all errors, such that any error causes it to move on to the next source.\n */\nexport function onErrorResumeNext<T, R>(...sources: Array<ObservableInput<any> |\n                                                              Array<ObservableInput<any>> |\n                                                              ((...values: Array<any>) => R)>): Observable<R> {\n\n  if (sources.length === 0) {\n    return EMPTY;\n  }\n\n  const [ first, ...remainder ] = sources;\n\n  if (sources.length === 1 && isArray(first)) {\n    return onErrorResumeNext(...first);\n  }\n\n  return new Observable(subscriber => {\n    const subNext = () => subscriber.add(\n      onErrorResumeNext(...remainder).subscribe(subscriber)\n    );\n\n    return from(first).subscribe({\n      next(value) { subscriber.next(value); },\n      error: subNext,\n      complete: subNext,\n    });\n  });\n}\n"],"mappings":"AAAA;AAEA,SAASA,UAAM,QAAM,eAAS;AAC9B,SAASC,IAAA,QAAS,QAAM;AACxB,SAASC,OAAO,QAAM,iBAAU;AAwEhC,SAAMC,KAAA,QAAU;OAAwB,SAAAC,iBAEqDA,CAAA;aAFrD,KAEqD;OAFrD,IAAAC,EAAA,MAAAA,EAAA,GAAAC,SAAA,CAEqDC,MAAA,EAAAF,EAAA;;EAE3F;MACEG,OAAO,CAAAD,MAAM;IACd,OAAAJ,KAAA;EAEO;EAER,IAAIM,KAAA,GAAQD,OAAM;IAAME,SAAI,GAAQF,OAAM,CAAEG,KAAA;MAC1CH,OAAO,CAAAD,MAAA,UAAiBL,OAAA,CAAAO,KAAA,GAAI;IAC7B,OAAAL,iBAAA,CAAAQ,KAAA,SAAAH,KAAA;EAED;SACE,IAAMT,UAAU,WAAMa,UAAA;IAItB,IAAAC,OAAW,GAAC,SAAAA,CAAA,EAAO;MAAS,OAACD,UAAA,CAAAE,GAAA,CAAAX,iBAAA,CAAAQ,KAAA,SAAAF,SAAA,EAAAM,SAAA,CAAAH,UAAA;IAAA;WAC3BZ,IAAI,CAAAQ,KAAA,EAAAO,SAAM,CAAI;MACdC,IAAA,EAAK,SAAAA,CAASC,KAAA;QAAAL,UAAA,CAAAI,IAAA,CAAAC,KAAA;MAAA;MACdC,KAAA,EAAAL,OAAU;MACTM,QAAA,EAAAN;IACF;EACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}