{"ast":null,"code":"\"use strict\";\n\n/**\n * The [[Either]] type represents an alternative between two value types.\n * A \"left\" value which is also conceptually tied to a failure,\n * or a \"right\" value which is conceptually tied to success.\n *\n * The code is organized through the class [[Left]], the class [[Right]],\n * and the type alias [[Either]] (Left or Right).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[EitherStatic]] and are accessed through the global constant Either.\n *\n * Examples:\n *\n *     Either.right<number,number>(5);\n *     Either.left<number,number>(2);\n *     Either.right<number,number>(5).map(x => x*2);\n *\n * Left has the extra [[Left.getLeft]] method that [[Right]] doesn't have.\n * Right has the extra [[Right.get]] method that [[Left]] doesn't have.\n */\nexports.__esModule = true;\nvar Value_1 = require(\"./Value\");\nvar Option_1 = require(\"./Option\");\nvar LinkedList_1 = require(\"./LinkedList\");\nvar Vector_1 = require(\"./Vector\");\nvar Comparison_1 = require(\"./Comparison\");\nvar Contract_1 = require(\"./Contract\");\n/**\n * Holds the \"static methods\" for [[Either]]\n */\nvar EitherStatic = /** @class */function () {\n  function EitherStatic() {}\n  /**\n   * Constructs an Either containing a left value which you give.\n   */\n  EitherStatic.prototype.left = function (val) {\n    return new Left(val);\n  };\n  /**\n   * Constructs an Either containing a right value which you give.\n   */\n  EitherStatic.prototype.right = function (val) {\n    return new Right(val);\n  };\n  /**\n   * Curried type guard for Either\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))\n   *         .filter(Either.isLeft)\n   *         .map(o => o.getLeft())\n   *     => Vector.of(1)\n   */\n  EitherStatic.prototype.isLeft = function (e) {\n    return e.isLeft();\n  };\n  /**\n   * Curried type guard for Either\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))\n   *         .filter(Either.isRight)\n   *         .map(o => o.get())\n   *     => Vector.of(2)\n   */\n  EitherStatic.prototype.isRight = function (e) {\n    return e.isRight();\n  };\n  /**\n   * Turns a list of eithers in an either containing a list of items.\n   * Useful in many contexts.\n   *\n   *     Either.sequence(Vector.of(\n   *         Either.right<number,number>(1),\n   *         Either.right<number,number>(2)));\n   *     => Either.right(Vector.of(1,2))\n   *\n   * But if a single element is Left, everything is discarded:\n   *\n   *     Either.sequence(Vector.of(\n   *           Either.right<number,number>(1),\n   *           Either.left<number,number>(2),\n   *           Either.left<number,number>(3)));\n   *     => Either.left(2)\n   *\n   * Also see [[EitherStatic.traverse]]\n   */\n  EitherStatic.prototype.sequence = function (elts) {\n    return exports.Either.traverse(elts, function (x) {\n      return x;\n    });\n  };\n  /**\n   * Takes a list, a function that can transform list elements\n   * to eithers, then return an either containing a list of\n   * the transformed elements.\n   *\n   *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?\n   *         Either.right(\"user\" + x.toString()) : Either.left(\"invalid id!\");\n   *     Either.traverse([4, 3, 2], getUserById);\n   *     => Either.right(Vector.of(\"user4\", \"user3\", \"user2\"))\n   *\n   * But if a single element results in Left, everything is discarded:\n   *\n   *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?\n   *         Either.right(\"user\" + x.toString()) : Either.left(\"invalid id!\");\n   *     Either.traverse([4, -3, 2], getUserById);\n   *     => Either.left(\"invalid id!\")\n   *\n   * Also see [[EitherStatic.sequence]]\n   */\n  EitherStatic.prototype.traverse = function (elts, fn) {\n    var r = Vector_1.Vector.empty();\n    var iterator = elts[Symbol.iterator]();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      var v = fn(curItem.value);\n      if (v.isLeft()) {\n        return v;\n      }\n      r = r.append(v.get());\n      curItem = iterator.next();\n    }\n    return exports.Either.right(r);\n  };\n  /**\n   * Turns a list of eithers in an either containing a list of items.\n   * Compared to [[EitherStatic.sequence]], sequenceAcc 'accumulates'\n   * the errors, instead of short-circuiting on the first error.\n   *\n   *     Either.sequenceAcc(Vector.of(\n   *         Either.right<number,number>(1),\n   *         Either.right<number,number>(2)));\n   *     => Either.right(Vector.of(1,2))\n   *\n   * But if a single element is Left, you get all the lefts:\n   *\n   *     Either.sequenceAcc(Vector.of(\n   *           Either.right<number,number>(1),\n   *           Either.left<number,number>(2),\n   *           Either.left<number,number>(3)));\n   *     => Either.left(Vector.of(2,3))\n   */\n  EitherStatic.prototype.sequenceAcc = function (elts) {\n    var _a = Vector_1.Vector.ofIterable(elts).partition(exports.Either.isLeft),\n      lefts = _a[0],\n      rights = _a[1];\n    if (lefts.isEmpty()) {\n      return exports.Either.right(rights.map(function (r) {\n        return r.getOrThrow();\n      }));\n    }\n    return exports.Either.left(lefts.map(function (l) {\n      return l.getLeft();\n    }));\n  };\n  /**\n   * Applicative lifting for Either.\n   * Takes a function which operates on basic values, and turns it\n   * in a function that operates on eithers of these values ('lifts'\n   * the function). The 2 is because it works on functions taking two\n   * parameters.\n   *\n   *     const lifted = Either.liftA2(\n   *         (x:number,y:number) => x+y, {} as string);\n   *     lifted(\n   *         Either.right<string,number>(5),\n   *         Either.right<string,number>(6));\n   *     => Either.right(11)\n   *\n   *     const lifted = Either.liftA2(\n   *         (x:number,y:number) => x+y, {} as string);\n   *     lifted(\n   *         Either.right<string,number>(5),\n   *         Either.left<string,number>(\"bad\"));\n   *     => Either.left(\"bad\")\n   *\n   * @param R1 the first right type\n   * @param R2 the second right type\n   * @param L the left type\n   * @param V the new right type as returned by the combining function.\n   */\n  EitherStatic.prototype.liftA2 = function (fn, leftWitness) {\n    return function (p1, p2) {\n      return p1.flatMap(function (a1) {\n        return p2.map(function (a2) {\n          return fn(a1, a2);\n        });\n      });\n    };\n  };\n  /**\n   * Applicative lifting for Either. 'p' stands for 'properties'.\n   *\n   * Takes a function which operates on a simple JS object, and turns it\n   * in a function that operates on the same JS object type except which each field\n   * wrapped in an Either ('lifts' the function).\n   * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters\n   * is not two.\n   *\n   *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n   *     const lifted = Either.liftAp(fn, {} as number);\n   *     lifted({\n   *         a: Either.right<number,number>(5),\n   *         b: Either.right<number,number>(6),\n   *         c: Either.right<number,number>(3)});\n   *     => Either.right(14)\n   *\n   *     const lifted = Either.liftAp<number,{a:number,b:number},number>(\n   *         x => x.a+x.b);\n   *     lifted({\n   *         a: Either.right<number,number>(5),\n   *         b: Either.left<number,number>(2)});\n   *     => Either.left(2)\n   *\n   * @param L the left type\n   * @param A the object property type specifying the parameters for your function\n   * @param B the type returned by your function, returned wrapped in an either by liftAp.\n   */\n  EitherStatic.prototype.liftAp = function (fn, leftWitness) {\n    return function (x) {\n      var copy = {};\n      for (var p in x) {\n        if (x[p].isLeft()) {\n          return x[p];\n        }\n        copy[p] = x[p].getOrThrow();\n      }\n      return exports.Either.right(fn(copy));\n    };\n  };\n  /**\n   * Applicative lifting for Either. 'p' stands for 'properties'.\n   * Compared to [[EitherStatic.liftAp]], liftApAcc 'accumulates'\n   * the errors, instead of short-circuiting on the first error.\n   *\n   * Takes a function which operates on a simple JS object, and turns it\n   * in a function that operates on the same JS object type except which each field\n   * wrapped in an Either ('lifts' the function).\n   * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters\n   * is not two.\n   *\n   *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n   *     const lifted = Either.liftApAcc(fn, {} as number);\n   *     lifted({\n   *         a: Either.right<number,number>(5),\n   *         b: Either.right<number,number>(6),\n   *         c:Either.right<number,number>(3)});\n   *     => Either.right(14)\n   *\n   *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n   *     const lifted = Either.liftApAcc(fn, {} as number);\n   *     lifted({\n   *         a: Either.right<number,number>(5),\n   *         b: Either.left<number,number>(2),\n   *         c: Either.left<number,number>(6)});\n   *     => Either.left(Vector.of(2, 6))\n   *\n   * @param L the left type\n   * @param A the object property type specifying the parameters for your function\n   * @param B the type returned by your function, returned wrapped in an either by liftAp.\n   */\n  EitherStatic.prototype.liftApAcc = function (fn, leftWitness) {\n    var leftErrs = [];\n    return function (x) {\n      var copy = {};\n      for (var p in x) {\n        var field = x[p];\n        if (field.isLeft()) {\n          leftErrs.push(field.getLeft());\n        } else {\n          copy[p] = x[p].getOrThrow();\n        }\n      }\n      if (leftErrs.length === 0) {\n        return exports.Either.right(fn(copy));\n      } else {\n        return exports.Either.left(Vector_1.Vector.ofIterable(leftErrs));\n      }\n    };\n  };\n  /**\n   * Take a partial function (may return undefined or throw),\n   * and lift it to return an [[Either]] instead.\n   *\n   * Note that unlike the [[OptionStatic.lift]] version, if\n   * the function returns undefined, the Either.lift version will throw\n   * (the Option.lift version returns None()): if you want to do\n   * pure side-effects which may throw, you're better off just using\n   * javascript try blocks.\n   *\n   * When using typescript, to help the compiler infer the left type,\n   * you can either pass a second parameter like `{} as <type>`, or\n   * call with `lift<L,R>(...)`.\n   *\n   *     const add = Either.lift((x:number,y:number) => x+y, {} as string);\n   *     add(1,2);\n   *     => Either.right(3)\n   *\n   *     const undef = Either.lift((x:number,y:number,z:number) => undefined);\n   *     undef(1,2,3);\n   *     => throws\n   *\n   *     const throws = Either.lift(() => {throw \"x\"});\n   *     throws();\n   *     => Either.left(\"x\")\n   */\n  EitherStatic.prototype.lift = function (fn, witness) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      try {\n        var r = fn.apply(void 0, args);\n        if (r !== undefined) {\n          return exports.Either.right(r);\n        }\n      } catch (err) {\n        return exports.Either.left(err);\n      }\n      throw new Error(\"liftEither got undefined!\");\n    };\n  };\n  /**\n   * Take a no-parameter partial function (may return undefined or throw),\n   * call it, and return an [[Either]] instead.\n   *\n   * Note that unlike the [[OptionStatic.try_]] version, if\n   * the function returns undefined, this function will throw\n   * (the Option.try_ version returns None()): if you want to do\n   * pure side-effects which may throw, you're better off just using\n   * javascript try blocks.\n   *\n   * When using typescript, to help the compiler infer the left type,\n   * you can either pass a second parameter like `{} as <type>`, or\n   * call with `try_<L,R>(...)`.\n   *\n   *     Either.try_(Math.random, {} as string);\n   *     => Either.right(0.49884723907769635)\n   *\n   *     Either.try_(() => undefined);\n   *     => throws\n   *\n   *     Either.try_(() => {throw \"x\"});\n   *     => Either.left(\"x\")\n   *\n   * Also see [[EitherStatic.lift]], [[OptionStatic.try_]],\n   * [[OptionStatic.tryNullable]]\n   */\n  EitherStatic.prototype.try_ = function (fn, witness) {\n    return exports.Either.lift(fn)();\n  };\n  return EitherStatic;\n}();\nexports.EitherStatic = EitherStatic;\n/**\n * The Either constant allows to call the either \"static\" methods\n */\nexports.Either = new EitherStatic();\n/**\n * Represents an [[Either]] containing a left value,\n * conceptually tied to a failure.\n * \"static methods\" available through [[EitherStatic]]\n * @param L the \"left\" item type 'failure'\n * @param R the \"right\" item type 'success'\n */\nvar Left = /** @class */function () {\n  function Left(value) {\n    this.value = value;\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * Returns true since this is a Left\n   */\n  Left.prototype.isLeft = function () {\n    return true;\n  };\n  /**\n   * Returns false since this is a Left\n   */\n  Left.prototype.isRight = function () {\n    return false;\n  };\n  /**\n   * Returns true if this is either is a right and contains the value you give.\n   */\n  Left.prototype.contains = function (val) {\n    return false;\n  };\n  /**\n   * If this either is a right, applies the function you give\n   * to its contents and build a new right either, otherwise return this.\n   */\n  Left.prototype.map = function (fn) {\n    return this;\n  };\n  /**\n   * If this either is a right, call the function you give with\n   * the contents, and return what the function returns, else\n   * returns this.\n   * This is the monadic bind.\n   */\n  Left.prototype.flatMap = function (fn) {\n    return this;\n  };\n  /**\n   * If this either is a left, call the function you give with\n   * the left value and return a new either left with the result\n   * of the function, else return this.\n   */\n  Left.prototype.mapLeft = function (fn) {\n    return new Left(fn(this.value));\n  };\n  /**\n   * Map the either: you give a function to apply to the value,\n   * a function in case it's a left, a function in case it's a right.\n   */\n  Left.prototype.bimap = function (fnL, fnR) {\n    return new Left(fnL(this.value));\n  };\n  /**\n   * \"filter\" the either. If it was a Left, it stays a Left.\n   * If it was a Right and the predicate you pass returns\n   * true for its value, return the either unchanged.\n   * But if it was a left and the predicate returns false,\n   * return a Left with the value returned by the function\n   * passed as second parameter.\n   *\n   *     Either.right<string,number>(-3)\n   *         .filter(x => x >= 0, v => \"got negative value: \" + v);\n   *     => Either.left<string,number>(\"got negative value: -3\")\n   */\n  Left.prototype.filter = function (p, filterVal) {\n    return this;\n  };\n  /**\n   * Combines two eithers. If this either is a right, returns it.\n   * If it's a left, returns the other one.\n   */\n  Left.prototype.orElse = function (other) {\n    return other;\n  };\n  /**\n   * Has no effect if this Either is a right. If it's a left however,\n   * the function you give will be called, receiving as parameter\n   * the left contents, and an Either equivalent to the one your\n   * function returns will be returned.\n   */\n  Left.prototype.recoverWith = function (recoveryFn) {\n    return recoveryFn(this.value);\n  };\n  /**\n   * Execute a side-effecting function if the either\n   * is a right; returns the either.\n   */\n  Left.prototype.ifRight = function (fn) {\n    return this;\n  };\n  /**\n   * Execute a side-effecting function if the either\n   * is a left; returns the either.\n   */\n  Left.prototype.ifLeft = function (fn) {\n    fn(this.value);\n    return this;\n  };\n  /**\n   * Handle both branches of the either and return a value\n   * (can also be used for side-effects).\n   * This is the catamorphism for either.\n   *\n   *     Either.right<string,number>(5).match({\n   *         Left:  x => \"left \" + x,\n   *         Right: x => \"right \" + x\n   *     });\n   *     => \"right 5\"\n   */\n  Left.prototype.match = function (cases) {\n    return cases.Left(this.value);\n  };\n  /**\n   * If this either is a right, return its value, else throw\n   * an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message, or an Error object.\n   */\n  Left.prototype.getOrThrow = function (errorInfo) {\n    if (typeof errorInfo === 'string') {\n      throw new Error(errorInfo || \"Left.getOrThrow called!\");\n    }\n    throw errorInfo || new Error(\"Left.getOrThrow called!\");\n  };\n  /**\n   * If this either is a right, return its value, else return\n   * the value you give.\n   */\n  Left.prototype.getOrElse = function (other) {\n    return other;\n  };\n  /**\n   * Get the value contained in this left.\n   * NOTE: we know it's there, since this method\n   * belongs to Left, not Either.\n   */\n  Left.prototype.getLeft = function () {\n    return this.value;\n  };\n  /**\n   * If this either is a left, return its value, else throw\n   * an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message.\n   */\n  Left.prototype.getLeftOrThrow = function (message) {\n    return this.value;\n  };\n  /**\n   * If this either is a left, return its value, else return\n   * the value you give.\n   */\n  Left.prototype.getLeftOrElse = function (other) {\n    return this.value;\n  };\n  /**\n   * Convert this either to an option, conceptually dropping\n   * the left (failing) value.\n   */\n  Left.prototype.toOption = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * Convert to a vector. If it's a left, it's the empty\n   * vector, if it's a right, it's a one-element vector with\n   * the contents of the either.\n   */\n  Left.prototype.toVector = function () {\n    return Vector_1.Vector.empty();\n  };\n  /**\n   * Convert to a list. If it's a left, it's the empty\n   * list, if it's a right, it's a one-element list with\n   * the contents of the either.\n   */\n  Left.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.empty();\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  Left.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  Left.prototype.hasTrueEquality = function () {\n    return this.value && this.value.hasTrueEquality ? this.value.hasTrueEquality() : Comparison_1.hasTrueEquality(this.value);\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  Left.prototype.hashCode = function () {\n    return Comparison_1.getHashCode(this.value);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  Left.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || !other.isRight || other.isRight()) {\n      return false;\n    }\n    var leftOther = other;\n    Contract_1.contractTrueEquality(\"Either.equals\", this, leftOther);\n    return Comparison_1.areEqual(this.value, leftOther.value);\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   */\n  Left.prototype.toString = function () {\n    return \"Left(\" + this.value + \")\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   */\n  Left.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return Left;\n}();\nexports.Left = Left;\n/**\n * Represents an [[Either]] containing a success value,\n * conceptually tied to a success.\n * \"static methods\" available through [[EitherStatic]]\n * @param L the \"left\" item type 'failure'\n * @param R the \"right\" item type 'success'\n */\nvar Right = /** @class */function () {\n  function Right(value) {\n    this.value = value;\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * Returns false since this is a Right\n   */\n  Right.prototype.isLeft = function () {\n    return false;\n  };\n  /**\n   * Returns true since this is a Right\n   */\n  Right.prototype.isRight = function () {\n    return true;\n  };\n  /**\n   * Returns true if this is either is a right and contains the value you give.\n   */\n  Right.prototype.contains = function (val) {\n    return Comparison_1.areEqual(this.value, val);\n  };\n  /**\n   * If this either is a right, applies the function you give\n   * to its contents and build a new right either, otherwise return this.\n   */\n  Right.prototype.map = function (fn) {\n    return new Right(fn(this.value));\n  };\n  /**\n   * If this either is a right, call the function you give with\n   * the contents, and return what the function returns, else\n   * returns this.\n   * This is the monadic bind.\n   */\n  Right.prototype.flatMap = function (fn) {\n    return fn(this.value);\n  };\n  /**\n   * If this either is a left, call the function you give with\n   * the left value and return a new either left with the result\n   * of the function, else return this.\n   */\n  Right.prototype.mapLeft = function (fn) {\n    return this;\n  };\n  /**\n   * Map the either: you give a function to apply to the value,\n   * a function in case it's a left, a function in case it's a right.\n   */\n  Right.prototype.bimap = function (fnL, fnR) {\n    return new Right(fnR(this.value));\n  };\n  /**\n   * \"filter\" the either. If it was a Left, it stays a Left.\n   * If it was a Right and the predicate you pass returns\n   * true for its value, return the either unchanged.\n   * But if it was a left and the predicate returns false,\n   * return a Left with the value returned by the function\n   * passed as second parameter.\n   *\n   *     Either.right<string,number>(-3)\n   *         .filter(x => x >= 0, v => \"got negative value: \" + v);\n   *     => Either.left<string,number>(\"got negative value: -3\")\n   */\n  Right.prototype.filter = function (p, filterVal) {\n    if (p(this.value)) {\n      return this;\n    }\n    return new Left(filterVal(this.value));\n  };\n  /**\n   * Combines two eithers. If this either is a right, returns it.\n   * If it's a left, returns the other one.\n   */\n  Right.prototype.orElse = function (other) {\n    return this;\n  };\n  /**\n   * Has no effect if this Either is a right. If it's a left however,\n   * the function you give will be called, receiving as parameter\n   * the left contents, and an Either equivalent to the one your\n   * function returns will be returned.\n   */\n  Right.prototype.recoverWith = function (recoveryFn) {\n    return this;\n  };\n  /**\n   * Execute a side-effecting function if the either\n   * is a right; returns the either.\n   */\n  Right.prototype.ifRight = function (fn) {\n    fn(this.value);\n    return this;\n  };\n  /**\n   * Execute a side-effecting function if the either\n   * is a left; returns the either.\n   */\n  Right.prototype.ifLeft = function (fn) {\n    return this;\n  };\n  /**\n   * Handle both branches of the either and return a value\n   * (can also be used for side-effects).\n   * This is the catamorphism for either.\n   *\n   *     Either.right<string,number>(5).match({\n   *         Left:  x => \"left \" + x,\n   *         Right: x => \"right \" + x\n   *     });\n   *     => \"right 5\"\n   */\n  Right.prototype.match = function (cases) {\n    return cases.Right(this.value);\n  };\n  /**\n   * Get the value contained in this right.\n   * NOTE: we know it's there, since this method\n   * belongs to Right, not Either.\n   */\n  Right.prototype.get = function () {\n    return this.value;\n  };\n  /**\n   * If this either is a right, return its value, else throw\n   * an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message, or an Error object.\n   */\n  Right.prototype.getOrThrow = function (errorInfo) {\n    return this.value;\n  };\n  /**\n   * If this either is a right, return its value, else return\n   * the value you give.\n   */\n  Right.prototype.getOrElse = function (other) {\n    return this.value;\n  };\n  /**\n   * If this either is a left, return its value, else throw\n   * an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message.\n   */\n  Right.prototype.getLeftOrThrow = function (message) {\n    throw message || \"Left.getOrThrow called!\";\n  };\n  /**\n   * If this either is a left, return its value, else return\n   * the value you give.\n   */\n  Right.prototype.getLeftOrElse = function (other) {\n    return other;\n  };\n  /**\n   * Convert this either to an option, conceptually dropping\n   * the left (failing) value.\n   */\n  Right.prototype.toOption = function () {\n    return Option_1.Option.of(this.value);\n  };\n  /**\n   * Convert to a vector. If it's a left, it's the empty\n   * vector, if it's a right, it's a one-element vector with\n   * the contents of the either.\n   */\n  Right.prototype.toVector = function () {\n    return Vector_1.Vector.of(this.value);\n  };\n  /**\n   * Convert to a list. If it's a left, it's the empty\n   * list, if it's a right, it's a one-element list with\n   * the contents of the either.\n   */\n  Right.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.of(this.value);\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  Right.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  Right.prototype.hasTrueEquality = function () {\n    return this.value && this.value.hasTrueEquality ? this.value.hasTrueEquality() : Comparison_1.hasTrueEquality(this.value);\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  Right.prototype.hashCode = function () {\n    return Comparison_1.getHashCode(this.value);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  Right.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || !other.isRight || !other.isRight()) {\n      return false;\n    }\n    var rightOther = other;\n    Contract_1.contractTrueEquality(\"Either.equals\", this, rightOther);\n    return Comparison_1.areEqual(this.value, rightOther.value);\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   */\n  Right.prototype.toString = function () {\n    return \"Right(\" + this.value + \")\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   */\n  Right.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return Right;\n}();\nexports.Right = Right;","map":{"version":3,"names":["Value_1","require","Option_1","LinkedList_1","Vector_1","Comparison_1","Contract_1","EitherStatic","prototype","left","val","Left","right","Right","isLeft","e","isRight","sequence","elts","exports","Either","traverse","x","fn","r","Vector","empty","iterator","Symbol","curItem","next","done","v","value","append","get","sequenceAcc","_a","ofIterable","partition","lefts","rights","isEmpty","map","getOrThrow","l","getLeft","liftA2","leftWitness","p1","p2","flatMap","a1","a2","liftAp","copy","p","liftApAcc","leftErrs","field","push","length","lift","witness","args","_i","arguments","apply","undefined","err","Error","try_","className","contains","mapLeft","bimap","fnL","fnR","filter","filterVal","orElse","other","recoverWith","recoveryFn","ifRight","ifLeft","match","cases","errorInfo","getOrElse","getLeftOrThrow","message","getLeftOrElse","toOption","Option","none","toVector","toLinkedList","LinkedList","transform","converter","hasTrueEquality","hashCode","getHashCode","equals","leftOther","contractTrueEquality","areEqual","toString","inspect","of","rightOther"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/Either.ts"],"sourcesContent":["/**\n * The [[Either]] type represents an alternative between two value types.\n * A \"left\" value which is also conceptually tied to a failure,\n * or a \"right\" value which is conceptually tied to success.\n *\n * The code is organized through the class [[Left]], the class [[Right]],\n * and the type alias [[Either]] (Left or Right).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[EitherStatic]] and are accessed through the global constant Either.\n *\n * Examples:\n *\n *     Either.right<number,number>(5);\n *     Either.left<number,number>(2);\n *     Either.right<number,number>(5).map(x => x*2);\n *\n * Left has the extra [[Left.getLeft]] method that [[Right]] doesn't have.\n * Right has the extra [[Right.get]] method that [[Left]] doesn't have.\n */\n\nimport { Value, inspect } from \"./Value\";\nimport { Option } from \"./Option\";\nimport { LinkedList } from \"./LinkedList\";\nimport { Vector } from \"./Vector\";\nimport { WithEquality, areEqual,\n         hasTrueEquality, getHashCode } from \"./Comparison\";\nimport { contractTrueEquality} from \"./Contract\";\n\n/**\n * Holds the \"static methods\" for [[Either]]\n */\nexport class EitherStatic {\n    /**\n     * Constructs an Either containing a left value which you give.\n     */\n    left<L,R>(val: L): Either<L,R> {\n        return new Left<L,R>(val);\n    }\n\n    /**\n     * Constructs an Either containing a right value which you give.\n     */\n    right<L,R>(val: R): Either<L,R> {\n        return new Right<L,R>(val);\n    }\n\n    /**\n     * Curried type guard for Either\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))\n     *         .filter(Either.isLeft)\n     *         .map(o => o.getLeft())\n     *     => Vector.of(1)\n     */\n    isLeft<L,R>(e: Either<L,R>): e is Left<L,R> {\n        return e.isLeft();\n    }\n\n    /**\n     * Curried type guard for Either\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))\n     *         .filter(Either.isRight)\n     *         .map(o => o.get())\n     *     => Vector.of(2)\n     */\n    isRight<L,R>(e: Either<L,R>): e is Right<L,R> {\n        return e.isRight();\n    }\n\n    /**\n     * Turns a list of eithers in an either containing a list of items.\n     * Useful in many contexts.\n     *\n     *     Either.sequence(Vector.of(\n     *         Either.right<number,number>(1),\n     *         Either.right<number,number>(2)));\n     *     => Either.right(Vector.of(1,2))\n     *\n     * But if a single element is Left, everything is discarded:\n     *\n     *     Either.sequence(Vector.of(\n     *           Either.right<number,number>(1),\n     *           Either.left<number,number>(2),\n     *           Either.left<number,number>(3)));\n     *     => Either.left(2)\n     *\n     * Also see [[EitherStatic.traverse]]\n     */\n    sequence<L,R>(elts:Iterable<Either<L,R>>): Either<L,Vector<R>> {\n        return Either.traverse(elts, x=>x);\n    }\n\n    /**\n     * Takes a list, a function that can transform list elements\n     * to eithers, then return an either containing a list of\n     * the transformed elements.\n     *\n     *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?\n     *         Either.right(\"user\" + x.toString()) : Either.left(\"invalid id!\");\n     *     Either.traverse([4, 3, 2], getUserById);\n     *     => Either.right(Vector.of(\"user4\", \"user3\", \"user2\"))\n     *\n     * But if a single element results in Left, everything is discarded:\n     *\n     *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?\n     *         Either.right(\"user\" + x.toString()) : Either.left(\"invalid id!\");\n     *     Either.traverse([4, -3, 2], getUserById);\n     *     => Either.left(\"invalid id!\")\n     *\n     * Also see [[EitherStatic.sequence]]\n     */\n    traverse<T,L,R>(elts:Iterable<T>, fn: (x:T)=>Either<L,R>): Either<L,Vector<R>> {\n        let r = Vector.empty<R>();\n        const iterator = elts[Symbol.iterator]();\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            const v = fn(curItem.value);\n            if (v.isLeft()) {\n                return <any>v;\n            }\n            r = r.append(v.get());\n            curItem = iterator.next();\n        }\n        return Either.right<L,Vector<R>>(r);\n    }\n\n    /**\n     * Turns a list of eithers in an either containing a list of items.\n     * Compared to [[EitherStatic.sequence]], sequenceAcc 'accumulates'\n     * the errors, instead of short-circuiting on the first error.\n     *\n     *     Either.sequenceAcc(Vector.of(\n     *         Either.right<number,number>(1),\n     *         Either.right<number,number>(2)));\n     *     => Either.right(Vector.of(1,2))\n     *\n     * But if a single element is Left, you get all the lefts:\n     *\n     *     Either.sequenceAcc(Vector.of(\n     *           Either.right<number,number>(1),\n     *           Either.left<number,number>(2),\n     *           Either.left<number,number>(3)));\n     *     => Either.left(Vector.of(2,3))\n     */\n    sequenceAcc<L,R>(elts:Iterable<Either<L,R>>): Either<Vector<L>,Vector<R>> {\n        const [lefts,rights] = Vector.ofIterable(elts).partition(Either.isLeft);\n        if (lefts.isEmpty()) {\n            return Either.right<Vector<L>,Vector<R>>(rights.map(r => r.getOrThrow()));\n        }\n        return Either.left<Vector<L>,Vector<R>>(lefts.map(l => l.getLeft()));\n    }\n\n    /**\n     * Applicative lifting for Either.\n     * Takes a function which operates on basic values, and turns it\n     * in a function that operates on eithers of these values ('lifts'\n     * the function). The 2 is because it works on functions taking two\n     * parameters.\n     *\n     *     const lifted = Either.liftA2(\n     *         (x:number,y:number) => x+y, {} as string);\n     *     lifted(\n     *         Either.right<string,number>(5),\n     *         Either.right<string,number>(6));\n     *     => Either.right(11)\n     *\n     *     const lifted = Either.liftA2(\n     *         (x:number,y:number) => x+y, {} as string);\n     *     lifted(\n     *         Either.right<string,number>(5),\n     *         Either.left<string,number>(\"bad\"));\n     *     => Either.left(\"bad\")\n     *\n     * @param R1 the first right type\n     * @param R2 the second right type\n     * @param L the left type\n     * @param V the new right type as returned by the combining function.\n     */\n    liftA2<R1,R2,L,V>(fn:(v1:R1,v2:R2)=>V, leftWitness?: L) : (p1:Either<L,R1>, p2:Either<L,R2>) => Either<L,V> {\n        return (p1,p2) => p1.flatMap(a1 => p2.map(a2 => fn(a1,a2)));\n    }\n\n    /**\n     * Applicative lifting for Either. 'p' stands for 'properties'.\n     *\n     * Takes a function which operates on a simple JS object, and turns it\n     * in a function that operates on the same JS object type except which each field\n     * wrapped in an Either ('lifts' the function).\n     * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters\n     * is not two.\n     *\n     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n     *     const lifted = Either.liftAp(fn, {} as number);\n     *     lifted({\n     *         a: Either.right<number,number>(5),\n     *         b: Either.right<number,number>(6),\n     *         c: Either.right<number,number>(3)});\n     *     => Either.right(14)\n     *\n     *     const lifted = Either.liftAp<number,{a:number,b:number},number>(\n     *         x => x.a+x.b);\n     *     lifted({\n     *         a: Either.right<number,number>(5),\n     *         b: Either.left<number,number>(2)});\n     *     => Either.left(2)\n     *\n     * @param L the left type\n     * @param A the object property type specifying the parameters for your function\n     * @param B the type returned by your function, returned wrapped in an either by liftAp.\n     */\n    liftAp<L,A,B>(fn:(x:A)=>B, leftWitness?: L): (x: {[K in keyof A]: Either<L,A[K]>;}) => Either<L,B> {\n        return x => {\n            const copy:A = <any>{};\n            for (let p in x) {\n                if (x[p].isLeft()) {\n                    return <Either<L,B>><any>x[p];\n                }\n                copy[p] = x[p].getOrThrow();\n            }\n            return Either.right<L,B>(fn(copy));\n        }\n    }\n\n    /**\n     * Applicative lifting for Either. 'p' stands for 'properties'.\n     * Compared to [[EitherStatic.liftAp]], liftApAcc 'accumulates'\n     * the errors, instead of short-circuiting on the first error.\n     *\n     * Takes a function which operates on a simple JS object, and turns it\n     * in a function that operates on the same JS object type except which each field\n     * wrapped in an Either ('lifts' the function).\n     * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters\n     * is not two.\n     *\n     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n     *     const lifted = Either.liftApAcc(fn, {} as number);\n     *     lifted({\n     *         a: Either.right<number,number>(5),\n     *         b: Either.right<number,number>(6),\n     *         c:Either.right<number,number>(3)});\n     *     => Either.right(14)\n     *\n     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n     *     const lifted = Either.liftApAcc(fn, {} as number);\n     *     lifted({\n     *         a: Either.right<number,number>(5),\n     *         b: Either.left<number,number>(2),\n     *         c: Either.left<number,number>(6)});\n     *     => Either.left(Vector.of(2, 6))\n     *\n     * @param L the left type\n     * @param A the object property type specifying the parameters for your function\n     * @param B the type returned by your function, returned wrapped in an either by liftAp.\n     */\n    liftApAcc<L,A,B>(fn:(x:A)=>B, leftWitness?: L): (x: {[K in keyof A]: Either<L,A[K]>;}) => Either<Vector<L>,B> {\n        const leftErrs: L[] = [];\n        return x => {\n            const copy:A = <any>{};\n            for (let p in x) {\n                const field = x[p];\n                if (field.isLeft()) {\n                    leftErrs.push(field.getLeft());\n                } else {\n                    copy[p] = x[p].getOrThrow();\n                }\n            }\n            if (leftErrs.length === 0) {\n                return Either.right<Vector<L>,B>(fn(copy));\n            } else {\n                return Either.left<Vector<L>,B>(Vector.ofIterable(leftErrs));\n            }\n        }\n    }\n\n    /**\n     * Take a partial function (may return undefined or throw),\n     * and lift it to return an [[Either]] instead.\n     *\n     * Note that unlike the [[OptionStatic.lift]] version, if\n     * the function returns undefined, the Either.lift version will throw\n     * (the Option.lift version returns None()): if you want to do\n     * pure side-effects which may throw, you're better off just using\n     * javascript try blocks.\n     *\n     * When using typescript, to help the compiler infer the left type,\n     * you can either pass a second parameter like `{} as <type>`, or\n     * call with `lift<L,R>(...)`.\n     *\n     *     const add = Either.lift((x:number,y:number) => x+y, {} as string);\n     *     add(1,2);\n     *     => Either.right(3)\n     *\n     *     const undef = Either.lift((x:number,y:number,z:number) => undefined);\n     *     undef(1,2,3);\n     *     => throws\n     *\n     *     const throws = Either.lift(() => {throw \"x\"});\n     *     throws();\n     *     => Either.left(\"x\")\n     */\n    lift<T extends any[],L,U>(fn: (...args: T)=>U, witness?: L): (...args:T)=>Either<L,U> {\n        return (...args:T) => {\n            try {\n                const r = fn(...args);\n                if (r !== undefined) {\n                    return Either.right(r);\n                }\n            } catch (err) {\n                return Either.left(err);\n            }\n            throw new Error(\"liftEither got undefined!\");\n        };\n    }\n\n    /**\n     * Take a no-parameter partial function (may return undefined or throw),\n     * call it, and return an [[Either]] instead.\n     *\n     * Note that unlike the [[OptionStatic.try_]] version, if\n     * the function returns undefined, this function will throw\n     * (the Option.try_ version returns None()): if you want to do\n     * pure side-effects which may throw, you're better off just using\n     * javascript try blocks.\n     *\n     * When using typescript, to help the compiler infer the left type,\n     * you can either pass a second parameter like `{} as <type>`, or\n     * call with `try_<L,R>(...)`.\n     *\n     *     Either.try_(Math.random, {} as string);\n     *     => Either.right(0.49884723907769635)\n     *\n     *     Either.try_(() => undefined);\n     *     => throws\n     *\n     *     Either.try_(() => {throw \"x\"});\n     *     => Either.left(\"x\")\n     *\n     * Also see [[EitherStatic.lift]], [[OptionStatic.try_]],\n     * [[OptionStatic.tryNullable]]\n     */\n    try_<L,T>(fn:()=>T, witness?: L): Either<L,T> {\n        return Either.lift<[],L,T>(fn)();\n    }\n}\n\n/**\n * The Either constant allows to call the either \"static\" methods\n */\nexport const Either = new EitherStatic();\n\n/**\n * Either represents an alternative between two value types.\n * A \"left\" value which is also conceptually tied to a failure,\n * or a \"right\" value which is conceptually tied to success.\n * \"static methods\" available through [[EitherStatic]]\n */\nexport type Either<L,R> = Left<L,R> | Right<L,R>;\n\n/**\n * Represents an [[Either]] containing a left value,\n * conceptually tied to a failure.\n * \"static methods\" available through [[EitherStatic]]\n * @param L the \"left\" item type 'failure'\n * @param R the \"right\" item type 'success'\n */\nexport class Left<L,R> implements Value {\n    constructor(private value: L) {}\n\n    /**\n     * @hidden\n     */\n    readonly className: \"Left\" = <any>undefined;  // https://stackoverflow.com/a/47841595/516188\n\n    /**\n     * Returns true since this is a Left\n     */\n    isLeft(): this is Left<L,R> {\n        return true;\n    }\n\n    /**\n     * Returns false since this is a Left\n     */\n    isRight(): this is Right<L,R> {\n        return false;\n    }\n\n    /**\n     * Returns true if this is either is a right and contains the value you give.\n     */\n    contains(val: R&WithEquality): boolean {\n        return false;\n    }\n\n    /**\n     * If this either is a right, applies the function you give\n     * to its contents and build a new right either, otherwise return this.\n     */\n    map<U>(fn: (x:R)=>U): Either<L,U> {\n        return <any>this;\n    }\n\n    /**\n     * If this either is a right, call the function you give with\n     * the contents, and return what the function returns, else\n     * returns this.\n     * This is the monadic bind.\n     */\n    flatMap<U>(fn: (x:R)=>Either<L,U>): Either<L,U> {\n        return <any>this;\n    }\n\n    /**\n     * If this either is a left, call the function you give with\n     * the left value and return a new either left with the result\n     * of the function, else return this.\n     */\n    mapLeft<U>(fn: (x:L)=>U): Either<U,R> {\n        return new Left<U,R>(fn(this.value));\n    }\n\n    /**\n     * Map the either: you give a function to apply to the value,\n     * a function in case it's a left, a function in case it's a right.\n     */\n    bimap<S,T>(fnL: (x:L)=>S,fnR: (x:R)=>T): Either<S,T> {\n        return new Left<S,T>(fnL(this.value));\n    }\n\n    /**\n     * \"filter\" the either. If it was a Left, it stays a Left.\n     * If it was a Right and the predicate you pass returns\n     * true for its value, return the either unchanged.\n     * But if it was a left and the predicate returns false,\n     * return a Left with the value returned by the function\n     * passed as second parameter.\n     *\n     *     Either.right<string,number>(-3)\n     *         .filter(x => x >= 0, v => \"got negative value: \" + v);\n     *     => Either.left<string,number>(\"got negative value: -3\")\n     */\n    filter(p: (x:R)=>boolean, filterVal: (x:R)=>L): Either<L,R> {\n        return this;\n    }\n\n    /**\n     * Combines two eithers. If this either is a right, returns it.\n     * If it's a left, returns the other one.\n     */\n    orElse(other: Either<L,R>): Either<L,R> {\n        return other;\n    }\n\n    /**\n     * Has no effect if this Either is a right. If it's a left however,\n     * the function you give will be called, receiving as parameter\n     * the left contents, and an Either equivalent to the one your\n     * function returns will be returned.\n     */\n    recoverWith(recoveryFn: (left:L)=>Either<L, R>): Either<L, R> {\n        return recoveryFn(this.value);\n    }\n\n    /**\n     * Execute a side-effecting function if the either\n     * is a right; returns the either.\n     */\n    ifRight(fn: (x:R)=>void): Either<L,R> {\n        return this;\n    }\n\n    /**\n     * Execute a side-effecting function if the either\n     * is a left; returns the either.\n     */\n    ifLeft(fn: (x:L)=>void): Either<L,R> {\n        fn(this.value);\n        return this;\n    }\n\n    /**\n     * Handle both branches of the either and return a value\n     * (can also be used for side-effects).\n     * This is the catamorphism for either.\n     *\n     *     Either.right<string,number>(5).match({\n     *         Left:  x => \"left \" + x,\n     *         Right: x => \"right \" + x\n     *     });\n     *     => \"right 5\"\n     */\n    match<U>(cases: {Left: (v:L)=>U, Right: (v:R)=>U}): U {\n        return cases.Left(this.value);\n    }\n\n    /**\n     * If this either is a right, return its value, else throw\n     * an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message, or an Error object.\n     */\n    getOrThrow(errorInfo?: Error|string): R {\n        if (typeof errorInfo === 'string') {\n            throw new Error(errorInfo || \"Left.getOrThrow called!\");\n        }\n        throw errorInfo || new Error(\"Left.getOrThrow called!\");\n    }\n\n    /**\n     * If this either is a right, return its value, else return\n     * the value you give.\n     */\n    getOrElse(other: R): R {\n        return other;\n    }\n\n    /**\n     * Get the value contained in this left.\n     * NOTE: we know it's there, since this method\n     * belongs to Left, not Either.\n     */\n    getLeft(): L {\n        return this.value;\n    }\n\n    /**\n     * If this either is a left, return its value, else throw\n     * an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message.\n     */\n    getLeftOrThrow(message?: string): L {\n        return this.value;\n    }\n\n    /**\n     * If this either is a left, return its value, else return\n     * the value you give.\n     */\n    getLeftOrElse(other: L): L {\n        return this.value;\n    }\n\n    /**\n     * Convert this either to an option, conceptually dropping\n     * the left (failing) value.\n     */\n    toOption(): Option<R> {\n        return Option.none<R>();\n    }\n\n    /**\n     * Convert to a vector. If it's a left, it's the empty\n     * vector, if it's a right, it's a one-element vector with\n     * the contents of the either.\n     */\n    toVector(): Vector<R> {\n        return Vector.empty<R>();\n    }\n\n    /**\n     * Convert to a list. If it's a left, it's the empty\n     * list, if it's a right, it's a one-element list with\n     * the contents of the either.\n     */\n    toLinkedList(): LinkedList<R> {\n        return LinkedList.empty<R>();\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:Either<L,R>)=>U): U {\n        return converter(this);\n    }\n\n    hasTrueEquality(): boolean {\n        return (this.value && (<any>this.value).hasTrueEquality) ?\n            (<any>this.value).hasTrueEquality() :\n            hasTrueEquality(this.value);\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        return getHashCode(this.value);\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other: Either<L&WithEquality,R&WithEquality>): boolean {\n        if (<any>other === this) {\n            return true;\n        }\n        if ((!other) || (!other.isRight) || other.isRight()) {\n            return false;\n        }\n        const leftOther = <Left<L&WithEquality,R&WithEquality>>other;\n        contractTrueEquality(\"Either.equals\", this, leftOther);\n        return areEqual(this.value, leftOther.value);\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     */\n    toString(): string {\n        return \"Left(\" + this.value + \")\";\n    }\n\n    /**\n     * Used by the node REPL to display values.\n     */\n    [inspect](): string {\n        return this.toString();\n    }\n}\n\n/**\n * Represents an [[Either]] containing a success value,\n * conceptually tied to a success.\n * \"static methods\" available through [[EitherStatic]]\n * @param L the \"left\" item type 'failure'\n * @param R the \"right\" item type 'success'\n */\nexport class Right<L,R> implements Value {\n    constructor(private value: R) {}\n\n    /**\n     * @hidden\n     */\n    readonly className: \"Right\" = <any>undefined;  // https://stackoverflow.com/a/47841595/516188\n\n    /**\n     * Returns false since this is a Right\n     */\n    isLeft(): this is Left<L,R> {\n        return false;\n    }\n\n    /**\n     * Returns true since this is a Right\n     */\n    isRight(): this is Right<L,R> {\n        return true;\n    }\n\n    /**\n     * Returns true if this is either is a right and contains the value you give.\n     */\n    contains(val: R&WithEquality): boolean {\n        return areEqual(this.value, val);\n    }\n\n    /**\n     * If this either is a right, applies the function you give\n     * to its contents and build a new right either, otherwise return this.\n     */\n    map<U>(fn: (x:R)=>U): Either<L,U> {\n        return new Right<L,U>(fn(this.value));\n    }\n\n    /**\n     * If this either is a right, call the function you give with\n     * the contents, and return what the function returns, else\n     * returns this.\n     * This is the monadic bind.\n     */\n    flatMap<U>(fn: (x:R)=>Either<L,U>): Either<L,U> {\n        return fn(this.value);\n    }\n\n    /**\n     * If this either is a left, call the function you give with\n     * the left value and return a new either left with the result\n     * of the function, else return this.\n     */\n    mapLeft<U>(fn: (x:L)=>U): Either<U,R> {\n        return <any>this;\n    }\n\n    /**\n     * Map the either: you give a function to apply to the value,\n     * a function in case it's a left, a function in case it's a right.\n     */\n    bimap<S,T>(fnL: (x:L)=>S,fnR: (x:R)=>T): Either<S,T> {\n        return new Right<S,T>(fnR(this.value));\n    }\n\n    /**\n     * \"filter\" the either. If it was a Left, it stays a Left.\n     * If it was a Right and the predicate you pass returns\n     * true for its value, return the either unchanged.\n     * But if it was a left and the predicate returns false,\n     * return a Left with the value returned by the function\n     * passed as second parameter.\n     *\n     *     Either.right<string,number>(-3)\n     *         .filter(x => x >= 0, v => \"got negative value: \" + v);\n     *     => Either.left<string,number>(\"got negative value: -3\")\n     */\n    filter(p: (x:R)=>boolean, filterVal: (x:R)=>L): Either<L,R> {\n        if (p(this.value)) {\n            return this;\n        }\n        return new Left(filterVal(this.value));\n    }\n\n    /**\n     * Combines two eithers. If this either is a right, returns it.\n     * If it's a left, returns the other one.\n     */\n    orElse(other: Either<L,R>): Either<L,R> {\n        return this;\n    }\n    \n    /**\n     * Has no effect if this Either is a right. If it's a left however,\n     * the function you give will be called, receiving as parameter\n     * the left contents, and an Either equivalent to the one your\n     * function returns will be returned.\n     */\n    recoverWith(recoveryFn: (left:L)=>Either<L, R>): Either<L, R> {\n        return this;\n    }\n\n    /**\n     * Execute a side-effecting function if the either\n     * is a right; returns the either.\n     */\n    ifRight(fn: (x:R)=>void): Either<L,R> {\n        fn(this.value);\n        return this;\n    }\n\n    /**\n     * Execute a side-effecting function if the either\n     * is a left; returns the either.\n     */\n    ifLeft(fn: (x:L)=>void): Either<L,R> {\n        return this;\n    }\n\n    /**\n     * Handle both branches of the either and return a value\n     * (can also be used for side-effects).\n     * This is the catamorphism for either.\n     *\n     *     Either.right<string,number>(5).match({\n     *         Left:  x => \"left \" + x,\n     *         Right: x => \"right \" + x\n     *     });\n     *     => \"right 5\"\n     */\n    match<U>(cases: {Left: (v:L)=>U, Right: (v:R)=>U}): U {\n        return cases.Right(this.value);\n    }\n\n    /**\n     * Get the value contained in this right.\n     * NOTE: we know it's there, since this method\n     * belongs to Right, not Either.\n     */\n    get(): R {\n        return this.value;\n    }\n\n    /**\n     * If this either is a right, return its value, else throw\n     * an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message, or an Error object.\n     */\n    getOrThrow(errorInfo?: Error|string): R {\n        return this.value;\n    }\n\n    /**\n     * If this either is a right, return its value, else return\n     * the value you give.\n     */\n    getOrElse(other: R): R {\n        return this.value;\n    }\n\n    /**\n     * If this either is a left, return its value, else throw\n     * an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message.\n     */\n    getLeftOrThrow(message?: string): L {\n        throw message || \"Left.getOrThrow called!\";\n    }\n\n    /**\n     * If this either is a left, return its value, else return\n     * the value you give.\n     */\n    getLeftOrElse(other: L): L {\n        return other;\n    }\n\n    /**\n     * Convert this either to an option, conceptually dropping\n     * the left (failing) value.\n     */\n    toOption(): Option<R> {\n        return Option.of(this.value);\n    }\n\n    /**\n     * Convert to a vector. If it's a left, it's the empty\n     * vector, if it's a right, it's a one-element vector with\n     * the contents of the either.\n     */\n    toVector(): Vector<R> {\n        return Vector.of(this.value);\n    }\n\n    /**\n     * Convert to a list. If it's a left, it's the empty\n     * list, if it's a right, it's a one-element list with\n     * the contents of the either.\n     */\n    toLinkedList(): LinkedList<R> {\n        return LinkedList.of(this.value);\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:Either<L,R>)=>U): U {\n        return converter(this);\n    }\n\n    hasTrueEquality(): boolean {\n        return (this.value && (<any>this.value).hasTrueEquality) ?\n            (<any>this.value).hasTrueEquality() :\n            hasTrueEquality(this.value);\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        return getHashCode(this.value);\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other: Either<L&WithEquality,R&WithEquality>): boolean {\n        if (<any>other === this) {\n            return true;\n        }\n        if ((!other) || (!other.isRight) || (!other.isRight())) {\n            return false;\n        }\n        const rightOther = <Right<L&WithEquality,R&WithEquality>>other;\n        contractTrueEquality(\"Either.equals\", this, rightOther);\n        return areEqual(this.value, rightOther.value);\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     */\n    toString(): string {\n        return \"Right(\" + this.value + \")\";\n    }\n\n    /**\n     * Used by the node REPL to display values.\n     */\n    [inspect](): string {\n        return this.toString();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}