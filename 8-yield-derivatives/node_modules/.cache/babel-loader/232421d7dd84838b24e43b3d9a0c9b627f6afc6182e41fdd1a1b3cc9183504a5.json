{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nvar ReplaySubject = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ReplaySubject, _super);\n  function ReplaySubject(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) {\n      bufferSize = Number.POSITIVE_INFINITY;\n    }\n    if (windowTime === void 0) {\n      windowTime = Number.POSITIVE_INFINITY;\n    }\n    var _this = _super.call(this) || this;\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n    return _this;\n  }\n  ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n    if (!this.isStopped) {\n      var _events = this._events;\n      _events.push(value);\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n    _super.prototype.next.call(this, value);\n  };\n  ReplaySubject.prototype.nextTimeWindow = function (value) {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n      this._trimBufferThenGetEvents();\n    }\n    _super.prototype.next.call(this, value);\n  };\n  ReplaySubject.prototype._subscribe = function (subscriber) {\n    var _infiniteTimeWindow = this._infiniteTimeWindow;\n    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    var scheduler = this.scheduler;\n    var len = _events.length;\n    var subscription;\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n    }\n    if (_infiniteTimeWindow) {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i]);\n      }\n    } else {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i].value);\n      }\n    }\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n    return subscription;\n  };\n  ReplaySubject.prototype._getNow = function () {\n    return (this.scheduler || queue).now();\n  };\n  ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n    var now = this._getNow();\n    var _bufferSize = this._bufferSize;\n    var _windowTime = this._windowTime;\n    var _events = this._events;\n    var eventsCount = _events.length;\n    var spliceCount = 0;\n    while (spliceCount < eventsCount) {\n      if (now - _events[spliceCount].time < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n    return _events;\n  };\n  return ReplaySubject;\n}(Subject);\nexport { ReplaySubject };\nvar ReplayEvent = /*@__PURE__*/function () {\n  function ReplayEvent(time, value) {\n    this.time = time;\n    this.value = value;\n  }\n  return ReplayEvent;\n}();","map":{"version":3,"names":["tslib_1","Subject","queue","Subscription","ObserveOnSubscriber","ObjectUnsubscribedError","SubjectSubscription","ReplaySubject","_super","__extends","bufferSize","windowTime","scheduler","Number","POSITIVE_INFINITY","_this","call","_events","_infiniteTimeWindow","_bufferSize","_windowTime","next","nextTimeWindow","prototype","nextInfiniteTimeWindow","value","isStopped","push","length","shift","ReplayEvent","_getNow","_trimBufferThenGetEvents","_subscribe","subscriber","subscription","closed","hasError","EMPTY","observers","add","i","len","error","thrownError","complete","now","spliceCount","eventsCount","time","Math","max","splice"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/radixdlt/node_modules/rxjs/src/internal/ReplaySubject.ts"],"sourcesContent":["import { Subject } from './Subject';\nimport { SchedulerLike } from './types';\nimport { queue } from './scheduler/queue';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n/**\n * A variant of Subject that \"replays\" or emits old values to new subscribers.\n * It buffers a set number of values and will emit those values immediately to\n * any new subscribers in addition to emitting new values to existing subscribers.\n *\n * @class ReplaySubject<T>\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _events: (ReplayEvent<T> | T)[] = [];\n  private _bufferSize: number;\n  private _windowTime: number;\n  private _infiniteTimeWindow: boolean = false;\n\n  constructor(bufferSize: number = Number.POSITIVE_INFINITY,\n              windowTime: number = Number.POSITIVE_INFINITY,\n              private scheduler?: SchedulerLike) {\n    super();\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      this._infiniteTimeWindow = true;\n      this.next = this.nextInfiniteTimeWindow;\n    } else {\n      this.next = this.nextTimeWindow;\n    }\n  }\n\n  private nextInfiniteTimeWindow(value: T): void {\n    if (!this.isStopped) {\n      const _events = this._events;\n      _events.push(value);\n      // Since this method is invoked in every next() call than the buffer\n      // can overgrow the max size only by one item\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n    super.next(value);\n  }\n\n  private nextTimeWindow(value: T): void {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n      this._trimBufferThenGetEvents();\n    }\n    super.next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    // When `_infiniteTimeWindow === true` then the buffer is already trimmed\n    const _infiniteTimeWindow = this._infiniteTimeWindow;\n    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    const scheduler = this.scheduler;\n    const len = _events.length;\n    let subscription: Subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber<T>(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(<T>_events[i]);\n      }\n    } else {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next((<ReplayEvent<T>>_events[i]).value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  }\n\n  _getNow(): number {\n    return (this.scheduler || queue).now();\n  }\n\n  private _trimBufferThenGetEvents(): ReplayEvent<T>[] {\n    const now = this._getNow();\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = <ReplayEvent<T>[]>this._events;\n\n    const eventsCount = _events.length;\n    let spliceCount = 0;\n\n    // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n    while (spliceCount < eventsCount) {\n      if ((now - _events[spliceCount].time) < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  }\n\n}\n\nclass ReplayEvent<T> {\n  constructor(public time: number, public value: T) {\n  }\n}\n"],"mappings":";AAAA,OAAO,KAAEA,OAAS,MAAM;AAExB,SAASC,OAAO,QAAM;AAEtB,SAASC,KAAA,QAAY,mBAAQ;AAC7B,SAASC,YAAA,QAAmB,gBAAQ;AACpC,SAASC,mBAAA,QAAyB,uBAAM;AACxC,SAASC,uBAAqB,QAAM,gCAAwB;AAQ5D,SAAAC,mBAAA;IAAsCC,aAAA,0BAAUC,MAAA;EAM9CR,OAAA,CAAAS,SAAA,CAAAF,aAAY,EAA6CC,MAC7C;WADAD,cAAAG,UAAA,EAAAC,UAAA,EAAqBC,SAAO;IAC5B,IAAAF,UAAA;MADZA,UAGE,GAAAG,MAAA,CAAAC,iBAUD;IAXmB;IAPZ,IAAAH,UAAO,KAA8B;MAGrCA,UAAA,GAAAE,MAAA,CAAAC,iBAAqC;IAM3C;IACA,IAAAC,KAAK,GAAAP,MAAW,CAAAQ,IAAG,UAAa,IAAI;IAEpCD,KAAI,CAAAH,SAAU,GAAAA,SAAY;SACxB,CAAAK,OAAK;SACL,CAAAC,mBAAiB;SAClB,CAAAC,WAAA,GAAAT,UAAA,WAAAA,UAAA;SAAM,CAAAU,WAAA,GAAAT,UAAA,WAAAA,UAAA;QACLA,UAAS,KAAGE,MAAK,CAAAC,iBAAe;MACjCC,KAAA,CAAAG,mBAAA;;IACF,OAEO;MACFH,KAAK,CAACM,IAAA,GAAAN,KAAW,CAAAO,cAAA;;WAEnBP,KAAQ;;eAIN,CAAAQ,SAAQ,CAAAC,sBAAQ,aAAAC,KAAA;SACjB,KAAAC,SAAA;MACF,IAAAT,OAAA,QAAAA,OAAA;MACDA,OAAA,CAAAU,IAAA,CAAMF,KAAI;MACX,IAAAR,OAAA,CAAAW,MAAA,QAAAT,WAAA;QAEOF,OAAA,CAAAY,KAAA;MACF;;UAEF,CAAAN,SAAK,CAAAF,IAAA,CAAAL,IAAA,OAAwBS,KAAG;;eAElC,CAAAF,SAAM,CAAAD,cAAK,aAAOG,KAAA;IACnB,UAAAC,SAAA;MAGD,KAAAT,OAAA,CAAAU,IAAA,KAAAG,WAAA,MAAWC,OAAA,IAAyBN,KAAA;MAE5B,KAAAO,wBAA2B;IACjC;IACAxB,MAAM,CAAAe,SAAY,CAAAF,IAAK,CAAAL,IAAA,KAAU,EAAAS,KAAA;;eAE7B,CAAAF,SAA2B,CAAAU,UAAA,aAAAC,UAAA;IAE/B,IAAIhB,mBAAa,QAAAA,mBAAA;QACfD,OAAM,GAAIC,mBAAA,OAA0B,CAAAD,OAAA,QAAAe,wBAAA;QACrCpB,SAAA,QAAAA,SAAA;WAAM,GAAIK,OAAK,CAAAW,MAAS;QACvBO,YAAY;QACb,KAAAC,MAAA;YAAM,IAAA/B,uBAAA;WAEL,SAAAqB,SAAmB,SAAAW,QAAA,EAAmB;MACvCF,YAAA,GAAAhC,YAAA,CAAAmC,KAAA;IAED,OACE;MACD,KAAAC,SAAA,CAAAZ,IAAA,CAAAO,UAAA;MAEGC,YAAA,OAAmB7B,mBAAE,OAAA4B,UAAA;;iBAErB;gBACD,CAAAM,GAAA,CAAAN,UAAA,OAAA9B,mBAAA,CAAA8B,UAAA,EAAAtB,SAAA;;2BACI;MACL,KAAK,IAAI6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,GAAG,IAAI,CAACR,UAAU,CAACE,MAAM,EAAEK,CAAC,EAAE,EAAE;QAClDP,UAAU,CAACb,IAAI,CAAkBJ,OAAO,CAACwB,CAAC,CAAE,CAAC;;KAEhD,MAEG;MACF,SAAAA,CAAU,GAAC,GAAKA,CAAC,GAAAC,GAAK,KAAAR,UAAa,CAAAE,MAAA,EAAAK,CAAA;QACpCP,UAAA,CAAAb,IAAA,CAAAJ,OAAA,CAAAwB,CAAA,EAAAhB,KAAA;;;QAEA,KAAAY,QAAA;MAEDH,UAAO,CAAAS,KAAa,MAAAC,WAAA;IACrB,OAED,SAAAlB,SAAA;MACEQ,UAAa,CAAAW,QAAS;IACvB;IAEO,OAAAV,YAAA;;eAEA,CAAAZ,SAAc,CAAAQ,OAAK,eAAY;IACrC,OAAM,MAAAnB,SAAkB,IAACV,KAAA,EAAA4C,GAAY;;eAG/B,CAAAvB,SAAc,CAAAS,wBAAe;IACnC,IAAIc,GAAA,QAAWf,OAAK;IAKpB,IAAAZ,WAAO,GAAW,IAAG,CAAAA,WAAa;QAChCC,WAAW,OAAO,CAACA,WAAW;eAC5B,GAAM,KAAAH,OAAA;mBACP,GAAAA,OAAA,CAAAW,MAAA;QACDmB,WAAW,GAAG;WACfA,WAAA,GAAAC,WAAA;MAEG,IAAAF,GAAA,GAAW7B,OAAG,CAAA8B,WAAa,EAAAE,IAAA,GAAA7B,WAAA;QAC7B;MACD;MAEG2B,WAAW;;QAEdC,WAAA,GAAA7B,WAAA;MAED4B,WAAe,GAAAG,IAAA,CAAAC,GAAA,CAAAJ,WAAA,EAAAC,WAAA,GAAA7B,WAAA;IAChB;IAEH,IAAA4B,WAAA,GAAC;MAAA9B,OAAA,CAAAmC,MAAA,IAAAL,WAAA;;IAED,OAAA9B,OAAA;EACE;SAAmBV,aAAI;SAAiB;SACvCA,aAAA;IACHuB,WAAA,gBAAC;EAHD,SAGCA,YAAAmB,IAAA,EAAAxB,KAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}