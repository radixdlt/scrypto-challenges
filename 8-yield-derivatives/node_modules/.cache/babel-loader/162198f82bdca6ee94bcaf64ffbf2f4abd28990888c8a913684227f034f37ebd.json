{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n/**\n * A predicate is a function taking one parameter and returning a boolean.\n * In other words the predicate checks whether some proposition holds for the parameter.\n *\n * The Predicate interface offers normal function-calling, to make sure that the\n * predicate holds (just call predicate(x)), but also some helper methods to\n * deal with logical operations between propositions.\n *\n * You can build predicates using [[PredicateStatic]] through the\n * 'Predicate' global constant.\n *\n * Examples:\n *\n *     const check = Predicate.of((x: number) => x > 10).and(x => x < 20);\n *     check(12); // => true\n *     check(21);\n *     => false\n *\n *     Vector.of(1,2,3,4,5).filter(\n *         Predicate.isIn([2,3]).negate())\n *     => Vector.of(1, 4, 5)\n */\nvar Comparison_1 = require(\"./Comparison\");\nvar Vector_1 = require(\"./Vector\");\n/**\n * The Predicates class offers some helper functions to deal\n * with [[Predicate]] including the ability to build [[Predicate]]\n * from functions using [[PredicateStatic.of]], some builtin predicates\n * like [[PredicateStatic.isIn]], and the ability to combine to combine\n * Predicates like with [[PredicateStatic.allOf]].\n */\nvar PredicateStatic = /** @class */function () {\n  function PredicateStatic() {}\n  /**\n   * Take a predicate function and of it to become a [[Predicate]]\n   * (enabling you to call [[Predicate.and]], and other logic operations on it)\n   */\n  PredicateStatic.prototype.of = function (fn) {\n    var r = fn;\n    r.and = function (other) {\n      return exports.Predicate.of(function (x) {\n        return r(x) && other(x);\n      });\n    };\n    r.or = function (other) {\n      return exports.Predicate.of(function (x) {\n        return r(x) || other(x);\n      });\n    };\n    r.negate = function () {\n      return exports.Predicate.of(function (x) {\n        return !fn(x);\n      });\n    };\n    return r;\n  };\n  /**\n   * Return a [[Predicate]] checking whether a value is equal to the\n   * value you give as parameter.\n   */\n  PredicateStatic.prototype.equals = function (other) {\n    return exports.Predicate.of(function (x) {\n      return Comparison_1.areEqual(other, x);\n    });\n  };\n  /**\n   * Return a [[Predicate]] checking whether a value is contained in the\n   * list of values you give as parameter.\n   */\n  PredicateStatic.prototype.isIn = function (others) {\n    return exports.Predicate.of(function (x) {\n      return Vector_1.Vector.ofIterable(others).contains(x);\n    });\n  };\n  /**\n   * Return a [[Predicate]] checking whether all of the predicate functions given hold\n   */\n  PredicateStatic.prototype.allOf = function () {\n    var predicates = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      predicates[_i] = arguments[_i];\n    }\n    return exports.Predicate.of(function (x) {\n      return Vector_1.Vector.ofIterable(predicates).allMatch(function (p) {\n        return p(x);\n      });\n    });\n  };\n  /**\n   * Return a [[Predicate]] checking whether any of the predicate functions given hold\n   */\n  PredicateStatic.prototype.anyOf = function () {\n    var predicates = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      predicates[_i] = arguments[_i];\n    }\n    return exports.Predicate.of(function (x) {\n      return Vector_1.Vector.ofIterable(predicates).anyMatch(function (p) {\n        return p(x);\n      });\n    });\n  };\n  /**\n   * Return a [[Predicate]] checking whether none of the predicate functions given hold\n   */\n  PredicateStatic.prototype.noneOf = function () {\n    var predicates = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      predicates[_i] = arguments[_i];\n    }\n    return exports.Predicate.of(function (x) {\n      return !Vector_1.Vector.ofIterable(predicates).anyMatch(function (p) {\n        return p(x);\n      });\n    });\n  };\n  return PredicateStatic;\n}();\nexports.PredicateStatic = PredicateStatic;\n/**\n * The Predicate constant allows to call the [[Predicate]] \"static\" methods.\n */\nexports.Predicate = new PredicateStatic();","map":{"version":3,"names":["Comparison_1","require","Vector_1","PredicateStatic","prototype","of","fn","r","and","other","exports","Predicate","x","or","negate","equals","areEqual","isIn","others","Vector","ofIterable","contains","allOf","predicates","_i","arguments","length","allMatch","p","anyOf","anyMatch","noneOf"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/Predicate.ts"],"sourcesContent":["/**\n * A predicate is a function taking one parameter and returning a boolean.\n * In other words the predicate checks whether some proposition holds for the parameter.\n *\n * The Predicate interface offers normal function-calling, to make sure that the\n * predicate holds (just call predicate(x)), but also some helper methods to\n * deal with logical operations between propositions.\n *\n * You can build predicates using [[PredicateStatic]] through the\n * 'Predicate' global constant.\n *\n * Examples:\n *\n *     const check = Predicate.of((x: number) => x > 10).and(x => x < 20);\n *     check(12); // => true\n *     check(21);\n *     => false\n *\n *     Vector.of(1,2,3,4,5).filter(\n *         Predicate.isIn([2,3]).negate())\n *     => Vector.of(1, 4, 5)\n */\nimport { WithEquality, areEqual } from \"./Comparison\";\nimport { Vector } from \"./Vector\";\n\n/**\n * A predicate is a function taking one parameter and returning a boolean.\n * In other words the predicate checks whether some proposition holds for the parameter.\n *\n * The Predicate interface offers normal function-calling, to make sure that the\n * predicate holds (just call predicate(x)), but also some helper methods to\n * deal with logical operations between propositions.\n *\n * You can build predicates using [[PredicateStatic]] through the\n * 'Predicate' global constant.\n */\nexport interface Predicate<T> {\n\n    /**\n     * Does the predicate hold for the value you give?\n     * Returns true or false\n     */\n    (x:T): boolean;\n\n    /**\n     * Combines two predicates with the 'and' logical operation.\n     * For instance:\n     *\n     *     Predicate.of((x: number) => x > 10).and(x => x < 20)\n     */\n    and(fn:(x:T)=>boolean): Predicate<T>;\n\n    /**\n     * Combines two predicates with the 'or' logical operation.\n     * For instance:\n     *\n     *     Predicate.of((x: number) => x < 5).or(x => x > 10)\n     */\n    or(fn:(x:T)=>boolean): Predicate<T>;\n\n    /**\n     * Unary operation to negate the predicate.\n     */\n    negate(): Predicate<T>;\n}\n\n/**\n * The Predicates class offers some helper functions to deal\n * with [[Predicate]] including the ability to build [[Predicate]]\n * from functions using [[PredicateStatic.of]], some builtin predicates\n * like [[PredicateStatic.isIn]], and the ability to combine to combine\n * Predicates like with [[PredicateStatic.allOf]].\n */\nexport class PredicateStatic {\n\n    /**\n     * Take a predicate function and of it to become a [[Predicate]]\n     * (enabling you to call [[Predicate.and]], and other logic operations on it)\n     */\n    of<T>(fn: (x:T)=>boolean): Predicate<T> {\n        const r = <Predicate<T>>fn;\n        r.and = (other:(x:T)=>boolean) => Predicate.of((x:T) => r(x) && other(x));\n        r.or = (other:(x:T)=>boolean) => Predicate.of((x:T) => r(x) || other(x));\n        r.negate = () => Predicate.of((x:T) => !fn(x));\n        return r;\n    }\n\n    /**\n     * Return a [[Predicate]] checking whether a value is equal to the\n     * value you give as parameter.\n     */\n    equals<T>(other: T&WithEquality): Predicate<T&WithEquality> {\n        return Predicate.of(x => areEqual(other, x));\n    }\n\n    /**\n     * Return a [[Predicate]] checking whether a value is contained in the\n     * list of values you give as parameter.\n     */\n    isIn<T>(others: Iterable<T&WithEquality>): Predicate<T&WithEquality> {\n        return Predicate.of<T&WithEquality>(x => Vector.ofIterable(others).contains(x));\n    }\n\n    /**\n     * Return a [[Predicate]] checking whether all of the predicate functions given hold\n     */\n    allOf<T>(...predicates: Array<(x:T)=>boolean>): Predicate<T> {\n        return Predicate.of<T>(x => Vector.ofIterable(predicates).allMatch(p=>p(x)));\n    }\n\n    /**\n     * Return a [[Predicate]] checking whether any of the predicate functions given hold\n     */\n    anyOf<T>(...predicates: Array<(x:T)=>boolean>): Predicate<T> {\n        return Predicate.of<T>(x => Vector.ofIterable(predicates).anyMatch(p=>p(x)));\n    }\n\n    /**\n     * Return a [[Predicate]] checking whether none of the predicate functions given hold\n     */\n    noneOf<T>(...predicates: Array<(x:T)=>boolean>): Predicate<T> {\n        return Predicate.of<T>(x => !Vector.ofIterable(predicates).anyMatch(p=>p(x)));\n    }\n}\n\n/**\n * The Predicate constant allows to call the [[Predicate]] \"static\" methods.\n */\nexport const Predicate = new PredicateStatic();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}