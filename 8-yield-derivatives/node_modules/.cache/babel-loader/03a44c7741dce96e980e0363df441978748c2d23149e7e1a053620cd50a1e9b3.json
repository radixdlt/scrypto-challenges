{"ast":null,"code":"\"use strict\";\n\n/**\n * The [[Option]] type expresses that a value may be present or not.\n * The code is organized through the class [[None]] (value not\n * present), the class [[Some]] (value present), and the type alias\n * [[Option]] (Some or None).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[OptionStatic]] and are accessed through the global constant Option.\n *\n * Examples:\n *\n *     Option.of(5);\n *     Option.none<number>();\n *     Option.of(5).map(x => x*2);\n *\n * To get the value out of an option, you can use [[Some.getOrThrow]],\n * or [[Some.get]]. The latter is available if you've checked that you\n * indeed have a some, for example:\n *\n *     const opt = Option.of(5);\n *     if (opt.isSome()) {\n *         opt.get();\n *     }\n *\n * You also have other options like [[Some.getOrElse]], [[Some.getOrUndefined]]\n * and so on. [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n */\nexports.__esModule = true;\nvar Value_1 = require(\"./Value\");\nvar Vector_1 = require(\"./Vector\");\nvar Either_1 = require(\"./Either\");\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\nvar Contract_1 = require(\"./Contract\");\n/**\n * Holds the \"static methods\" for [[Option]]\n */\nvar OptionStatic = /** @class */function () {\n  function OptionStatic() {}\n  /**\n   * Builds an optional value.\n   * * T is wrapped in a [[Some]]\n   * * undefined becomes a [[None]]\n   * * null becomes a [[Some]].\n   *\n   *     Option.of(5).isSome()\n   *     => true\n   *\n   *     Option.of(undefined).isSome()\n   *     => false\n   *\n   *     Option.of(null).isSome()\n   *     => true\n   *\n   * Also see [[OptionStatic.some]], [[OptionStatic.ofNullable]]\n   */\n  OptionStatic.prototype.of = function (v) {\n    return v === undefined ? exports.none : new Some(v);\n  };\n  /**\n   * Build an optional value from a nullable.\n   * * T is wrapped in a [[Some]]\n   * * undefined becomes a [[None]]\n   * * null becomes a [[None]].\n   *\n   *     Option.ofNullable(5).isSome()\n   *     => true\n   *\n   *     Option.ofNullable(undefined).isSome()\n   *     => false\n   *\n   *     Option.ofNullable(null).isSome()\n   *     => false\n   *\n   * Also see [[OptionStatic.some]], [[OptionStatic.of]]\n   */\n  OptionStatic.prototype.ofNullable = function (v) {\n    return v !== undefined && v !== null ? new Some(v) : exports.none;\n  };\n  /**\n   * Build a [[Some]], unlike [[OptionStatic.of]], which may build a [[Some]]\n   * or a [[None]].\n   * Will throw if given undefined.\n   *\n   *     Option.some(5).isSome()\n   *     => true\n   *\n   *     Option.some(undefined).isSome()\n   *     => throws\n   *\n   *     Option.some(null).isSome()\n   *     => true\n   *\n   * Also see [[OptionStatic.of]], [[OptionStatic.ofNullable]]\n   */\n  OptionStatic.prototype.some = function (v) {\n    // the reason I decided to add a some in addition to 'of'\n    // instead of making 'of' smarter (which is possible in\n    // typescript, see https://github.com/bcherny/tsoption)\n    // is that sometimes you really want an Option, not a Some.\n    // for instance you can't mix an a Some and an Option in a list\n    // if you put the Some first, without calling asOption().\n    if (typeof v === \"undefined\") {\n      throw \"Option.some got undefined!\";\n    }\n    return new Some(v);\n  };\n  /**\n   * The optional value expressing a missing value.\n   */\n  OptionStatic.prototype.none = function () {\n    return exports.none;\n  };\n  /**\n   * Curried type guard for Option\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Option.of(2), Option.none<number>())\n   *         .filter(Option.isSome)\n   *         .map(o => o.get())\n   *     => Vector.of(2)\n   */\n  OptionStatic.prototype.isSome = function (o) {\n    return o.isSome();\n  };\n  /**\n   * Curried type guard for Option\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Option.of(2), Option.none<number>())\n   *         .filter(Option.isNone)\n   *     => Vector.of(Option.none<number>())\n   */\n  OptionStatic.prototype.isNone = function (o) {\n    return o.isNone();\n  };\n  /**\n   * Turns a list of options in an option containing a list of items.\n   * Useful in many contexts.\n   *\n   *     Option.sequence(Vector.of(Option.of(1),Option.of(2)))\n   *     => Option.of(Vector.of(1,2))\n   *\n   * But if a single element is None, everything is discarded:\n   *\n   *     Option.sequence(Vector.of(Option.of(1), Option.none()))\n   *     => Option.none()\n   *\n   * Also see [[OptionStatic.traverse]]\n   */\n  OptionStatic.prototype.sequence = function (elts) {\n    return exports.Option.traverse(elts, function (x) {\n      return x;\n    });\n  };\n  /**\n   * Takes a list, a function that can transform list elements\n   * to options, then return an option containing a list of\n   * the transformed elements.\n   *\n   *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?\n   *         Option.of(\"user\" + x.toString()) : Option.none();\n   *     Option.traverse([4, 3, 2], getUserById);\n   *     => Option.of(Vector.of(\"user4\", \"user3\", \"user2\"))\n   *\n   * But if a single element results in None, everything is discarded:\n   *\n   *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?\n   *         Option.of(\"user\" + x.toString()) : Option.none();\n   *     Option.traverse([4, -3, 2], getUserById);\n   *     => Option.none()\n   *\n   * Also see [[OptionStatic.sequence]]\n   */\n  OptionStatic.prototype.traverse = function (elts, fn) {\n    var r = Vector_1.Vector.empty();\n    var iterator = elts[Symbol.iterator]();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      var v = fn(curItem.value);\n      if (v.isNone()) {\n        return exports.none;\n      }\n      r = r.append(v.get());\n      curItem = iterator.next();\n    }\n    return exports.Option.of(r);\n  };\n  /**\n   * Applicative lifting for Option.\n   * Takes a function which operates on basic values, and turns it\n   * in a function that operates on options of these values ('lifts'\n   * the function). The 2 is because it works on functions taking two\n   * parameters.\n   *\n   *     const lifted = Option.liftA2((x:number,y:number) => x+y);\n   *     lifted(Option.of(5), Option.of(6));\n   *     => Option.of(11)\n   *\n   *     const lifted2 = Option.liftA2((x:number,y:number) => x+y);\n   *     lifted2(Option.of(5), Option.none<number>());\n   *     => Option.none()\n   *\n   * @param T the first option type\n   * @param U the second option type\n   * @param V the new type as returned by the combining function.\n   */\n  OptionStatic.prototype.liftA2 = function (fn) {\n    return function (p1, p2) {\n      return p1.flatMap(function (a1) {\n        return p2.map(function (a2) {\n          return fn(a1, a2);\n        });\n      });\n    };\n  };\n  /**\n   * Applicative lifting for Option. 'p' stands for 'properties'.\n   *\n   * Takes a function which operates on a simple JS object, and turns it\n   * in a function that operates on the same JS object type except which each field\n   * wrapped in an Option ('lifts' the function).\n   * It's an alternative to [[OptionStatic.liftA2]] when the number of parameters\n   * is not two.\n   *\n   *     const lifted = Option.liftAp((x:{a:number,b:number,c:number}) => x.a+x.b+x.c);\n   *     lifted({a:Option.of(5), b:Option.of(6), c:Option.of(3)});\n   *     => Option.of(14)\n   *\n   *     const lifted = Option.liftAp((x:{a:number,b:number}) => x.a+x.b);\n   *     lifted({a:Option.of(5), b:Option.none<number>()});\n   *     => Option.none()\n   *\n   * @param A the object property type specifying the parameters for your function\n   * @param B the type returned by your function, returned wrapped in an option by liftAp.\n   */\n  OptionStatic.prototype.liftAp = function (fn) {\n    return function (x) {\n      var copy = {};\n      for (var p in x) {\n        if (x[p].isNone()) {\n          return exports.Option.none();\n        }\n        copy[p] = x[p].getOrThrow();\n      }\n      return exports.Option.of(fn(copy));\n    };\n  };\n  /**\n   * Take a partial function (may return undefined or throw),\n   * and lift it to return an [[Option]] instead.\n   * undefined becomes a [[None]], everything else a [[Some]]\n   *\n   *     const plus = Option.lift((x:number,y:number)=>x+y);\n   *     plus(1,2);\n   *     => Option.of(3)\n   *\n   *     const undef = Option.lift((x:number)=>undefined);\n   *     undef(1);\n   *     => Option.none()\n   *\n   *     const nl = Option.lift((x:number,y:number,z:number)=>null);\n   *     nl(1,2,3);\n   *     => Option.some(null)\n   *\n   *     const throws = Option.lift((x:number,y:number)=>{throw \"x\"});\n   *     throws(1,2);\n   *     => Option.none()\n   */\n  OptionStatic.prototype.lift = function (fn) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      try {\n        return exports.Option.of(fn.apply(void 0, args));\n      } catch (_a) {\n        return exports.Option.none();\n      }\n    };\n  };\n  /**\n   * Take a partial function (may return undefined or throw),\n   * and lift it to return an [[Option]] instead.\n   * null and undefined become a [[None]], everything else a [[Some]]\n   *\n   *     const plus = Option.liftNullable((x:number,y:number)=>x+y);\n   *     plus(1,2);\n   *     => Option.of(3)\n   *\n   *     const undef = Option.liftNullable((x:number,y:number,z:string)=>undefined);\n   *     undef(1,2,\"\");\n   *     => Option.none()\n   *\n   *     const nl = Option.liftNullable((x:number)=>null);\n   *     nl(1);\n   *     => Option.none()\n   *\n   *     const throws = Option.liftNullable((x:number,y:number)=>{throw \"x\"});\n   *     throws(1,2);\n   *     => Option.none()\n   */\n  OptionStatic.prototype.liftNullable = function (fn) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      try {\n        return exports.Option.ofNullable(fn.apply(void 0, args));\n      } catch (_a) {\n        return exports.Option.none();\n      }\n    };\n  };\n  /**\n   * Take a no-parameter partial function (may return undefined or throw),\n   * and call it, return an [[Option]] instead.\n   * undefined becomes a [[None]], everything else a [[Some]]\n   *\n   *     Option.try_(Math.random);\n   *     => Option.of(0.49884723907769635)\n   *\n   *     Option.try_(()=>undefined);\n   *     => Option.none()\n   *\n   *     Option.try_(()=>null);\n   *     => Option.of(null)\n   *\n   *     Option.try_(()=>{throw \"x\"});\n   *     => Option.none()\n   *\n   * Also see [[OptionStatic.tryNullable]], [[OptionStatic.lift]],\n   * [[OptionStatic.liftNullable]], [[EitherStatic.try_]].\n   */\n  OptionStatic.prototype.try_ = function (fn) {\n    return exports.Option.lift(fn)();\n  };\n  /**\n   * Take a no-parameter partial function (may return null, undefined or throw),\n   * and call it, return an [[Option]] instead.\n   * null and undefined become a [[None]], everything else a [[Some]]\n   *\n   *     Option.tryNullable(Math.random);\n   *     => Option.of(0.49884723907769635)\n   *\n   *     Option.tryNullable(()=>undefined);\n   *     => Option.none()\n   *\n   *     Option.tryNullable(()=>null);\n   *     => Option.none()\n   *\n   *     Option.tryNullable(()=>{throw \"x\"});\n   *     => Option.none()\n   *\n   * Also see [[OptionStatic.try_]], [[OptionStatic.liftNullable]],\n   * [[OptionStatic.lift]], [[EitherStatic.try_]].\n   */\n  OptionStatic.prototype.tryNullable = function (fn) {\n    return exports.Option.liftNullable(fn)();\n  };\n  return OptionStatic;\n}();\nexports.OptionStatic = OptionStatic;\n/**\n * The Option constant allows to call the option \"static\" methods\n */\nexports.Option = new OptionStatic();\nfunction optionHasTrueEquality(opt) {\n  return opt.flatMap(function (x) {\n    return x && x.hasTrueEquality ? exports.Option.of(x.hasTrueEquality()) : Comparison_1.hasTrueEquality(x);\n  }).getOrElse(true);\n}\n/**\n * Some represents an [[Option]] with a value.\n * \"static methods\" available through [[OptionStatic]]\n *\n * [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n * @param T the item type\n */\nvar Some = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function Some(value) {\n    this.value = value;\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * Returns true since this is a Some (contains a value)\n   */\n  Some.prototype.isSome = function () {\n    return true;\n  };\n  /**\n   * Returns false since this is a Some (contains a value)\n   */\n  Some.prototype.isNone = function () {\n    return false;\n  };\n  /**\n   * View this Some a as Option. Useful to help typescript type\n   * inference sometimes.\n   */\n  Some.prototype.asOption = function () {\n    return this;\n  };\n  /**\n   * Get the value contained in this option.\n   * NOTE: we know it's there, since this method\n   * belongs to Some, not Option.\n   */\n  Some.prototype.get = function () {\n    return this.value;\n  };\n  /**\n   * Combines two options. If this option is a Some, returns it.\n   * If it's a None, returns the other one.\n   */\n  Some.prototype.orElse = function (other) {\n    return this;\n  };\n  /**\n   * Get the value from this option if it's a Some, otherwise\n   * throw an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message.\n   */\n  Some.prototype.getOrThrow = function (errorInfo) {\n    return this.value;\n  };\n  /**\n   * Returns true if the option is a Some and contains the\n   * value you give, false otherwise.\n   */\n  Some.prototype.contains = function (v) {\n    return v === this.value;\n  };\n  /**\n   * Get the value contained in the option if it's a Some,\n   * return undefined if it's a None.\n   *\n   *     Option.of(5).getOrUndefined()\n   *     => 5\n   *\n   *     Option.none<number>().getOrUndefined()\n   *     => undefined\n   */\n  Some.prototype.getOrUndefined = function () {\n    return this.value;\n  };\n  /**\n   * Get the value contained in the option if it's a Some,\n   * return null if it's a None.\n   *\n   *     Option.of(5).getOrNull()\n   *     => 5\n   *\n   *     Option.none<number>().getOrNull()\n   *     => null\n   */\n  Some.prototype.getOrNull = function () {\n    return this.value;\n  };\n  /**\n   * Get the value from this option; if it's a None (no value\n   * present), then return the default value that you give.\n   */\n  Some.prototype.getOrElse = function (alt) {\n    return this.value;\n  };\n  /**\n   * Get the value from this option; if it's a None (no value\n   * present), then return the value returned by the function that you give.\n   *\n   *     Option.of(5).getOrCall(() => 6)\n   *     => 5\n   *\n   *     Option.none<number>().getOrCall(() => 6)\n   *     => 6\n   */\n  Some.prototype.getOrCall = function (fn) {\n    return this.value;\n  };\n  /**\n   * Return a new option where the element (if present) was transformed\n   * by the mapper function you give. If the option was None it'll stay None.\n   *\n   *     Option.of(5).map(x => x*2)\n   *     => Option.of(10)\n   *\n   *     Option.of(5).map(x => null)\n   *     => Option.of(null)\n   *\n   * Also see [[Some.mapNullable]], [[Some.flatMap]]\n   */\n  Some.prototype.map = function (fn) {\n    return exports.Option.of(fn(this.value));\n  };\n  /**\n   * Return a new option where the element (if present) was transformed\n   * by the mapper function you give. If the mapped value is `null` or\n   * `undefined`, then a Some will turn into a None.\n   * If the option was None it'll stay None.\n   *\n   *     Option.of(5).mapNullable(x => x*2)\n   *     => Option.of(10)\n   *\n   *     Option.of(5).mapNullable(x => null)\n   *     => Option.none()\n   *\n   * Also see [[Some.map]], [[Some.flatMap]]\n   */\n  Some.prototype.mapNullable = function (fn) {\n    return exports.Option.ofNullable(fn(this.value));\n  };\n  /**\n   * If this is a Some, calls the function you give on\n   * the item in the option and return its result.\n   * If the option is a None, return none.\n   * This is the monadic bind.\n   */\n  Some.prototype.flatMap = function (mapper) {\n    return mapper(this.value);\n  };\n  Some.prototype.filter = function (fn) {\n    return fn(this.value) ? this : exports.Option.none();\n  };\n  /**\n   * Execute a side-effecting function if the option\n   * is a Some; returns the option.\n   */\n  Some.prototype.ifSome = function (fn) {\n    fn(this.value);\n    return this;\n  };\n  /**\n   * Execute a side-effecting function if the option\n   * is a None; returns the option.\n   */\n  Some.prototype.ifNone = function (fn) {\n    return this;\n  };\n  /**\n   * Handle both branches of the option and return a value\n   * (can also be used for side-effects).\n   * This is the catamorphism for option.\n   *\n   *     Option.of(5).match({\n   *         Some: x  => \"got \" + x,\n   *         None: () => \"got nothing!\"\n   *     });\n   *     => \"got 5\"\n   */\n  Some.prototype.match = function (cases) {\n    return cases.Some(this.value);\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  Some.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Convert to a vector. If it's a None, it's the empty\n   * vector, if it's a Some, it's a one-element vector with\n   * the contents of the option.\n   */\n  Some.prototype.toVector = function () {\n    return Vector_1.Vector.of(this.value);\n  };\n  /**\n   * Convert to an either. You must provide a left value\n   * in case this is a None.\n   */\n  Some.prototype.toEither = function (left) {\n    return Either_1.Either.right(this.value);\n  };\n  /**\n   * If this is a Some, return this object.\n   * If this is a None, return the result of the function.\n   */\n  Some.prototype.orCall = function (_) {\n    return this;\n  };\n  Some.prototype.hasTrueEquality = function () {\n    return optionHasTrueEquality(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  Some.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    // the .isSome doesn't test if it's a Some, but\n    // if the object has a field called isSome.\n    if (other === exports.none || !other || !other.isSome) {\n      return false;\n    }\n    var someOther = other;\n    Contract_1.contractTrueEquality(\"Option.equals\", this, someOther);\n    return Comparison_1.areEqual(this.value, someOther.value);\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  Some.prototype.hashCode = function () {\n    return Comparison_1.getHashCode(this.value);\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   */\n  Some.prototype.toString = function () {\n    return \"Some(\" + SeqHelpers_1.toStringHelper(this.value) + \")\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   */\n  Some.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return Some;\n}();\nexports.Some = Some;\n/**\n * None represents an [[Option]] without value.\n * \"static methods\" available through [[OptionStatic]]\n *\n * [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n * @param T the item type\n */\nvar None = /** @class */function () {\n  function None() {\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * Returns false since this is a None (doesn'tcontains a value)\n   */\n  None.prototype.isSome = function () {\n    return false;\n  };\n  /**\n   * Returns true since this is a None (doesn'tcontains a value)\n   */\n  None.prototype.isNone = function () {\n    return true;\n  };\n  /**\n   * View this Some a as Option. Useful to help typescript type\n   * inference sometimes.\n   */\n  None.prototype.asOption = function () {\n    return this;\n  };\n  /**\n   * Combines two options. If this option is a Some, returns it.\n   * If it's a None, returns the other one.\n   */\n  None.prototype.orElse = function (other) {\n    return other;\n  };\n  /**\n   * Get the value from this option if it's a Some, otherwise\n   * throw an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message, or an Error object.\n   */\n  None.prototype.getOrThrow = function (errorInfo) {\n    if (typeof errorInfo === 'string') {\n      throw new Error(errorInfo || \"getOrThrow called on none!\");\n    }\n    throw errorInfo || new Error(\"getOrThrow called on none!\");\n  };\n  /**\n   * Returns true if the option is a Some and contains the\n   * value you give, false otherwise.\n   */\n  None.prototype.contains = function (v) {\n    return false;\n  };\n  /**\n   * Get the value contained in the option if it's a Some,\n   * return undefined if it's a None.\n   *\n   *     Option.of(5).getOrUndefined()\n   *     => 5\n   *\n   *     Option.none<number>().getOrUndefined()\n   *     => undefined\n   */\n  None.prototype.getOrUndefined = function () {\n    return undefined;\n  };\n  /**\n   * Get the value contained in the option if it's a Some,\n   * return null if it's a None.\n   *\n   *     Option.of(5).getOrNull()\n   *     => 5\n   *\n   *     Option.none<number>().getOrNull()\n   *     => null\n   */\n  None.prototype.getOrNull = function () {\n    return null;\n  };\n  /**\n   * Get the value from this option; if it's a None (no value\n   * present), then return the default value that you give.\n   */\n  None.prototype.getOrElse = function (alt) {\n    return alt;\n  };\n  /**\n   * Get the value from this option; if it's a None (no value\n   * present), then return the value returned by the function that you give.\n   *\n   *     Option.of(5).getOrCall(() => 6)\n   *     => 5\n   *\n   *     Option.none<number>().getOrCall(() => 6)\n   *     => 6\n   */\n  None.prototype.getOrCall = function (fn) {\n    return fn();\n  };\n  /**\n   * Return a new option where the element (if present) was transformed\n   * by the mapper function you give. If the option was None it'll stay None.\n   *\n   *     Option.of(5).map(x => x*2)\n   *     => Option.of(10)\n   *\n   *     Option.of(5).map(x => null)\n   *     => Option.of(null)\n   *\n   * Also see [[None.mapNullable]], [[None.flatMap]]\n   */\n  None.prototype.map = function (fn) {\n    return exports.none;\n  };\n  /**\n   * Return a new option where the element (if present) was transformed\n   * by the mapper function you give. If the mapped value is `null` or\n   * `undefined`, then a Some will turn into a None.\n   * If the option was None it'll stay None.\n   *\n   *     Option.of(5).mapNullable(x => x*2)\n   *     => Option.of(10)\n   *\n   *     Option.of(5).mapNullable(x => null)\n   *     => Option.none()\n   *\n   * Also see [[None.map]], [[None.flatMap]]\n   */\n  None.prototype.mapNullable = function (fn) {\n    return exports.none;\n  };\n  /**\n   * If this is a Some, calls the function you give on\n   * the item in the option and return its result.\n   * If the option is a None, return none.\n   * This is the monadic bind.\n   */\n  None.prototype.flatMap = function (mapper) {\n    return exports.none;\n  };\n  None.prototype.filter = function (fn) {\n    return exports.none;\n  };\n  /**\n   * Execute a side-effecting function if the option\n   * is a Some; returns the option.\n   */\n  None.prototype.ifSome = function (fn) {\n    return this;\n  };\n  /**\n   * Execute a side-effecting function if the option\n   * is a Some; returns the option.\n   */\n  None.prototype.ifNone = function (fn) {\n    fn();\n    return this;\n  };\n  /**\n   * Handle both branches of the option and return a value\n   * (can also be used for side-effects).\n   * This is the catamorphism for option.\n   *\n   *     Option.of(5).match({\n   *         Some: x  => \"got \" + x,\n   *         None: () => \"got nothing!\"\n   *     });\n   *     => \"got 5\"\n   */\n  None.prototype.match = function (cases) {\n    return cases.None();\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  None.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Convert to a vector. If it's a None, it's the empty\n   * vector, if it's a Some, it's a one-element vector with\n   * the contents of the option.\n   */\n  None.prototype.toVector = function () {\n    return Vector_1.Vector.empty();\n  };\n  /**\n   * Convert to an either. You must provide a left value\n   * in case this is a None.\n   */\n  None.prototype.toEither = function (left) {\n    return Either_1.Either.left(left);\n  };\n  /**\n   * If this is a Some, return this object.\n   * If this is a None, return the result of the function.\n   */\n  None.prototype.orCall = function (fn) {\n    return fn();\n  };\n  None.prototype.hasTrueEquality = function () {\n    return optionHasTrueEquality(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  None.prototype.equals = function (other) {\n    return other === exports.none;\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  None.prototype.hashCode = function () {\n    return 1;\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   */\n  None.prototype.toString = function () {\n    return \"None()\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   */\n  None.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return None;\n}();\nexports.None = None;\n/**\n * @hidden\n */\nexports.none = new None();","map":{"version":3,"names":["Value_1","require","Vector_1","Either_1","Comparison_1","SeqHelpers_1","Contract_1","OptionStatic","prototype","of","v","undefined","exports","none","Some","ofNullable","some","isSome","o","isNone","sequence","elts","Option","traverse","x","fn","r","Vector","empty","iterator","Symbol","curItem","next","done","value","append","get","liftA2","p1","p2","flatMap","a1","map","a2","liftAp","copy","p","getOrThrow","lift","args","_i","arguments","length","apply","_a","liftNullable","try_","tryNullable","optionHasTrueEquality","opt","hasTrueEquality","getOrElse","className","asOption","orElse","other","errorInfo","contains","getOrUndefined","getOrNull","alt","getOrCall","mapNullable","mapper","filter","ifSome","ifNone","match","cases","transform","converter","toVector","toEither","left","Either","right","orCall","_","equals","someOther","contractTrueEquality","areEqual","hashCode","getHashCode","toString","toStringHelper","inspect","None","Error"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/Option.ts"],"sourcesContent":["/**\n * The [[Option]] type expresses that a value may be present or not.\n * The code is organized through the class [[None]] (value not\n * present), the class [[Some]] (value present), and the type alias\n * [[Option]] (Some or None).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[OptionStatic]] and are accessed through the global constant Option.\n *\n * Examples:\n *\n *     Option.of(5);\n *     Option.none<number>();\n *     Option.of(5).map(x => x*2);\n *\n * To get the value out of an option, you can use [[Some.getOrThrow]],\n * or [[Some.get]]. The latter is available if you've checked that you\n * indeed have a some, for example:\n *\n *     const opt = Option.of(5);\n *     if (opt.isSome()) {\n *         opt.get();\n *     }\n *\n * You also have other options like [[Some.getOrElse]], [[Some.getOrUndefined]]\n * and so on. [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n */\n\nimport { Value, inspect } from \"./Value\";\nimport { Vector } from \"./Vector\";\nimport { Either } from \"./Either\";\nimport { WithEquality, areEqual, hasTrueEquality,\n         getHashCode, } from \"./Comparison\";\nimport { toStringHelper } from \"./SeqHelpers\";\nimport { contractTrueEquality} from \"./Contract\";\n\n/**\n * An Option is either [[Some]] or [[None]]\n * \"static methods\" available through [[OptionStatic]]\n * @param T the item type\n */\nexport type Option<T> = Some<T> | None<T>;\n\n/**\n * Holds the \"static methods\" for [[Option]]\n */\nexport class OptionStatic {\n\n    /**\n     * Builds an optional value.\n     * * T is wrapped in a [[Some]]\n     * * undefined becomes a [[None]]\n     * * null becomes a [[Some]].\n     *\n     *     Option.of(5).isSome()\n     *     => true\n     *\n     *     Option.of(undefined).isSome()\n     *     => false\n     *\n     *     Option.of(null).isSome()\n     *     => true\n     *\n     * Also see [[OptionStatic.some]], [[OptionStatic.ofNullable]]\n     */\n    of<T>(v: T|undefined): Option<T> {\n        return (v === undefined) ? <None<T>>none : new Some(v);\n    }\n\n    /**\n     * Build an optional value from a nullable.\n     * * T is wrapped in a [[Some]]\n     * * undefined becomes a [[None]]\n     * * null becomes a [[None]].\n     *\n     *     Option.ofNullable(5).isSome()\n     *     => true\n     *\n     *     Option.ofNullable(undefined).isSome()\n     *     => false\n     *\n     *     Option.ofNullable(null).isSome()\n     *     => false\n     *\n     * Also see [[OptionStatic.some]], [[OptionStatic.of]]\n     */\n    ofNullable<T>(v:T|undefined|null): Option<T> {\n        return (v !== undefined && v !== null) ? new Some(v) : <None<T>>none;\n    }\n\n    /**\n     * Build a [[Some]], unlike [[OptionStatic.of]], which may build a [[Some]]\n     * or a [[None]].\n     * Will throw if given undefined.\n     *\n     *     Option.some(5).isSome()\n     *     => true\n     *\n     *     Option.some(undefined).isSome()\n     *     => throws\n     *\n     *     Option.some(null).isSome()\n     *     => true\n     *\n     * Also see [[OptionStatic.of]], [[OptionStatic.ofNullable]]\n     */\n    some<T>(v: T): Some<T> {\n        // the reason I decided to add a some in addition to 'of'\n        // instead of making 'of' smarter (which is possible in\n        // typescript, see https://github.com/bcherny/tsoption)\n        // is that sometimes you really want an Option, not a Some.\n        // for instance you can't mix an a Some and an Option in a list\n        // if you put the Some first, without calling asOption().\n        if (typeof v === \"undefined\") {\n            throw \"Option.some got undefined!\";\n        }\n        return new Some(v);\n    }\n\n    /**\n     * The optional value expressing a missing value.\n     */\n    none<T>(): Option<T> {\n        return <None<T>>none;\n    }\n\n    /**\n     * Curried type guard for Option\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Option.of(2), Option.none<number>())\n     *         .filter(Option.isSome)\n     *         .map(o => o.get())\n     *     => Vector.of(2)\n     */\n    isSome<T>(o: Option<T>): o is Some<T> {\n        return o.isSome();\n    }\n\n    /**\n     * Curried type guard for Option\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Option.of(2), Option.none<number>())\n     *         .filter(Option.isNone)\n     *     => Vector.of(Option.none<number>())\n     */\n    isNone<T>(o: Option<T>): o is None<T> {\n        return o.isNone();\n    }\n\n    /**\n     * Turns a list of options in an option containing a list of items.\n     * Useful in many contexts.\n     *\n     *     Option.sequence(Vector.of(Option.of(1),Option.of(2)))\n     *     => Option.of(Vector.of(1,2))\n     *\n     * But if a single element is None, everything is discarded:\n     *\n     *     Option.sequence(Vector.of(Option.of(1), Option.none()))\n     *     => Option.none()\n     *\n     * Also see [[OptionStatic.traverse]]\n     */\n    sequence<T>(elts:Iterable<Option<T>>): Option<Vector<T>> {\n        return Option.traverse(elts, x=>x);\n    }\n\n    /**\n     * Takes a list, a function that can transform list elements\n     * to options, then return an option containing a list of\n     * the transformed elements.\n     *\n     *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?\n     *         Option.of(\"user\" + x.toString()) : Option.none();\n     *     Option.traverse([4, 3, 2], getUserById);\n     *     => Option.of(Vector.of(\"user4\", \"user3\", \"user2\"))\n     *\n     * But if a single element results in None, everything is discarded:\n     *\n     *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?\n     *         Option.of(\"user\" + x.toString()) : Option.none();\n     *     Option.traverse([4, -3, 2], getUserById);\n     *     => Option.none()\n     *\n     * Also see [[OptionStatic.sequence]]\n     */\n    traverse<T,U>(elts:Iterable<T>, fn: (x:T)=>Option<U>): Option<Vector<U>> {\n        let r = Vector.empty<U>();\n        const iterator = elts[Symbol.iterator]();\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            const v = fn(curItem.value);\n            if (v.isNone()) {\n                return <None<Vector<U>>>none;\n            }\n            r = r.append(v.get());\n            curItem = iterator.next();\n        }\n        return Option.of(r);\n    }\n\n    /**\n     * Applicative lifting for Option.\n     * Takes a function which operates on basic values, and turns it\n     * in a function that operates on options of these values ('lifts'\n     * the function). The 2 is because it works on functions taking two\n     * parameters.\n     *\n     *     const lifted = Option.liftA2((x:number,y:number) => x+y);\n     *     lifted(Option.of(5), Option.of(6));\n     *     => Option.of(11)\n     *\n     *     const lifted2 = Option.liftA2((x:number,y:number) => x+y);\n     *     lifted2(Option.of(5), Option.none<number>());\n     *     => Option.none()\n     *\n     * @param T the first option type\n     * @param U the second option type\n     * @param V the new type as returned by the combining function.\n     */\n    liftA2<T,U,V>(fn:(v1:T,v2:U)=>V): (p1:Option<T>, p2:Option<U>) => Option<V> {\n        return (p1,p2) => p1.flatMap(a1 => p2.map(a2 => fn(a1,a2)));\n    }\n\n    /**\n     * Applicative lifting for Option. 'p' stands for 'properties'.\n     *\n     * Takes a function which operates on a simple JS object, and turns it\n     * in a function that operates on the same JS object type except which each field\n     * wrapped in an Option ('lifts' the function).\n     * It's an alternative to [[OptionStatic.liftA2]] when the number of parameters\n     * is not two.\n     *\n     *     const lifted = Option.liftAp((x:{a:number,b:number,c:number}) => x.a+x.b+x.c);\n     *     lifted({a:Option.of(5), b:Option.of(6), c:Option.of(3)});\n     *     => Option.of(14)\n     *\n     *     const lifted = Option.liftAp((x:{a:number,b:number}) => x.a+x.b);\n     *     lifted({a:Option.of(5), b:Option.none<number>()});\n     *     => Option.none()\n     *\n     * @param A the object property type specifying the parameters for your function\n     * @param B the type returned by your function, returned wrapped in an option by liftAp.\n     */\n    liftAp<A,B>(fn:(x:A)=>B): (x: {[K in keyof A]: Option<A[K]>;}) => Option<B> {\n        return x => {\n            const copy:A = <any>{};\n            for (let p in x) {\n                if (x[p].isNone()) {\n                    return Option.none<B>();\n                }\n                copy[p] = x[p].getOrThrow();\n            }\n            return Option.of(fn(copy));\n        }\n    }\n\n    /**\n     * Take a partial function (may return undefined or throw),\n     * and lift it to return an [[Option]] instead.\n     * undefined becomes a [[None]], everything else a [[Some]]\n     *\n     *     const plus = Option.lift((x:number,y:number)=>x+y);\n     *     plus(1,2);\n     *     => Option.of(3)\n     *\n     *     const undef = Option.lift((x:number)=>undefined);\n     *     undef(1);\n     *     => Option.none()\n     *\n     *     const nl = Option.lift((x:number,y:number,z:number)=>null);\n     *     nl(1,2,3);\n     *     => Option.some(null)\n     *\n     *     const throws = Option.lift((x:number,y:number)=>{throw \"x\"});\n     *     throws(1,2);\n     *     => Option.none()\n     */\n    lift<T extends any[],U>(fn: (...args: T)=>U|undefined): (...args:T)=>Option<U> {\n        return (...args:T) => {\n            try {\n                return Option.of(fn(...args));\n            } catch {\n                return Option.none<U>();\n            }\n        };\n    }\n\n    /**\n     * Take a partial function (may return undefined or throw),\n     * and lift it to return an [[Option]] instead.\n     * null and undefined become a [[None]], everything else a [[Some]]\n     *\n     *     const plus = Option.liftNullable((x:number,y:number)=>x+y);\n     *     plus(1,2);\n     *     => Option.of(3)\n     *\n     *     const undef = Option.liftNullable((x:number,y:number,z:string)=>undefined);\n     *     undef(1,2,\"\");\n     *     => Option.none()\n     *\n     *     const nl = Option.liftNullable((x:number)=>null);\n     *     nl(1);\n     *     => Option.none()\n     *\n     *     const throws = Option.liftNullable((x:number,y:number)=>{throw \"x\"});\n     *     throws(1,2);\n     *     => Option.none()\n     */\n    liftNullable<T extends any[],U>(fn: (...args: T)=>U|null|undefined): (...args:T)=>Option<U> {\n        return (...args:T) => {\n            try {\n                return Option.ofNullable(fn(...args));\n            } catch {\n                return Option.none<U>();\n            }\n        };\n    }\n\n    /**\n     * Take a no-parameter partial function (may return undefined or throw),\n     * and call it, return an [[Option]] instead.\n     * undefined becomes a [[None]], everything else a [[Some]]\n     *\n     *     Option.try_(Math.random);\n     *     => Option.of(0.49884723907769635)\n     *\n     *     Option.try_(()=>undefined);\n     *     => Option.none()\n     *\n     *     Option.try_(()=>null);\n     *     => Option.of(null)\n     *\n     *     Option.try_(()=>{throw \"x\"});\n     *     => Option.none()\n     *\n     * Also see [[OptionStatic.tryNullable]], [[OptionStatic.lift]],\n     * [[OptionStatic.liftNullable]], [[EitherStatic.try_]].\n     */\n    try_<T>(fn:()=>T|undefined): Option<T> {\n        return Option.lift(fn)();\n    }\n\n    /**\n     * Take a no-parameter partial function (may return null, undefined or throw),\n     * and call it, return an [[Option]] instead.\n     * null and undefined become a [[None]], everything else a [[Some]]\n     *\n     *     Option.tryNullable(Math.random);\n     *     => Option.of(0.49884723907769635)\n     *\n     *     Option.tryNullable(()=>undefined);\n     *     => Option.none()\n     *\n     *     Option.tryNullable(()=>null);\n     *     => Option.none()\n     *\n     *     Option.tryNullable(()=>{throw \"x\"});\n     *     => Option.none()\n     *\n     * Also see [[OptionStatic.try_]], [[OptionStatic.liftNullable]],\n     * [[OptionStatic.lift]], [[EitherStatic.try_]].\n     */\n    tryNullable<T>(fn:()=>T|null|undefined): Option<T> {\n        return Option.liftNullable(fn)();\n    }\n}\n\n/**\n * The Option constant allows to call the option \"static\" methods\n */\nexport const Option = new OptionStatic();\n\nfunction optionHasTrueEquality<T>(opt: Option<T>): boolean {\n    return opt.flatMap(\n        x => (x && (<any>x).hasTrueEquality) ?\n            Option.of((<any>x).hasTrueEquality()) :\n            hasTrueEquality(x))\n        .getOrElse(true);\n}\n\n/**\n * Some represents an [[Option]] with a value.\n * \"static methods\" available through [[OptionStatic]]\n *\n * [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n * @param T the item type\n */\nexport class Some<T> implements Value {\n    /**\n     * @hidden\n     */\n    constructor(private value: T) {}\n\n    /**\n     * @hidden\n     */\n    readonly className: \"Some\" = <any>undefined;  // https://stackoverflow.com/a/47841595/516188\n\n    /**\n     * Returns true since this is a Some (contains a value)\n     */\n    isSome(): this is Some<T> {\n        return true;\n    }\n\n    /**\n     * Returns false since this is a Some (contains a value)\n     */\n    isNone(): this is None<T> {\n        return false;\n    }\n\n    /**\n     * View this Some a as Option. Useful to help typescript type\n     * inference sometimes.\n     */\n    asOption(): Option<T> {\n        return this;\n    }\n\n    /**\n     * Get the value contained in this option.\n     * NOTE: we know it's there, since this method\n     * belongs to Some, not Option.\n     */\n    get(): T {\n        return this.value;\n    }\n\n    /**\n     * Combines two options. If this option is a Some, returns it.\n     * If it's a None, returns the other one.\n     */\n    orElse(other: Option<T>): Option<T> {\n        return this;\n    }\n\n    /**\n     * Get the value from this option if it's a Some, otherwise\n     * throw an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message.\n     */\n    getOrThrow(errorInfo?: Error|string): T {\n        return this.value;\n    }\n\n    /**\n     * Returns true if the option is a Some and contains the\n     * value you give, false otherwise.\n     */\n    contains(v: T&WithEquality): boolean {\n        return v === this.value;\n    }\n\n    /**\n     * Get the value contained in the option if it's a Some,\n     * return undefined if it's a None.\n     *\n     *     Option.of(5).getOrUndefined()\n     *     => 5\n     *\n     *     Option.none<number>().getOrUndefined()\n     *     => undefined\n     */\n    getOrUndefined(): T | undefined {\n        return this.value;\n    }\n\n    /**\n     * Get the value contained in the option if it's a Some,\n     * return null if it's a None.\n     *\n     *     Option.of(5).getOrNull()\n     *     => 5\n     *\n     *     Option.none<number>().getOrNull()\n     *     => null\n     */\n    getOrNull(): T | null {\n        return this.value;\n    }\n\n    /**\n     * Get the value from this option; if it's a None (no value\n     * present), then return the default value that you give.\n     */\n    getOrElse(alt: T): T {\n        return this.value;\n    }\n\n    /**\n     * Get the value from this option; if it's a None (no value\n     * present), then return the value returned by the function that you give.\n     *\n     *     Option.of(5).getOrCall(() => 6)\n     *     => 5\n     *\n     *     Option.none<number>().getOrCall(() => 6)\n     *     => 6\n     */\n    getOrCall(fn: ()=>T): T {\n        return this.value;\n    }\n\n    /**\n     * Return a new option where the element (if present) was transformed\n     * by the mapper function you give. If the option was None it'll stay None.\n     *\n     *     Option.of(5).map(x => x*2)\n     *     => Option.of(10)\n     *\n     *     Option.of(5).map(x => null)\n     *     => Option.of(null)\n     *\n     * Also see [[Some.mapNullable]], [[Some.flatMap]]\n     */\n    map<U>(fn: (v:T)=>U): Option<U> {\n        return Option.of(fn(this.value));\n    }\n\n    /**\n     * Return a new option where the element (if present) was transformed\n     * by the mapper function you give. If the mapped value is `null` or\n     * `undefined`, then a Some will turn into a None.\n     * If the option was None it'll stay None.\n     *\n     *     Option.of(5).mapNullable(x => x*2)\n     *     => Option.of(10)\n     *\n     *     Option.of(5).mapNullable(x => null)\n     *     => Option.none()\n     *\n     * Also see [[Some.map]], [[Some.flatMap]]\n     */\n    mapNullable<U>(fn: (v:T)=>U|null|undefined): Option<U> {\n        return Option.ofNullable(fn(this.value));\n    }\n\n    /**\n     * If this is a Some, calls the function you give on\n     * the item in the option and return its result.\n     * If the option is a None, return none.\n     * This is the monadic bind.\n     */\n    flatMap<U>(mapper:(v:T)=>Option<U>): Option<U> {\n        return mapper(this.value);\n    }\n\n    /**\n     * If this is None, will return None. If it's a Some,\n     * and the contents match your predicate, return the option.\n     * If the contents don't match the predicate, return None.\n     */\n    filter<U extends T>(fn:(v:T)=>v is U): Option<U>;\n    filter(fn: (v:T)=>boolean): Option<T>;\n    filter(fn: (v:T)=>boolean): Option<T> {\n        return fn(this.value) ? this : Option.none<T>();\n    }\n\n    /**\n     * Execute a side-effecting function if the option\n     * is a Some; returns the option.\n     */\n    ifSome(fn:(v:T)=>void): Option<T> {\n        fn(this.value);\n        return this;\n    }\n\n    /**\n     * Execute a side-effecting function if the option\n     * is a None; returns the option.\n     */\n    ifNone(fn:()=>void): Option<T> {\n        return this;\n    }\n\n    /**\n     * Handle both branches of the option and return a value\n     * (can also be used for side-effects).\n     * This is the catamorphism for option.\n     *\n     *     Option.of(5).match({\n     *         Some: x  => \"got \" + x,\n     *         None: () => \"got nothing!\"\n     *     });\n     *     => \"got 5\"\n     */\n    match<U>(cases: {Some: (v:T)=>U, None: ()=>U}): U {\n        return cases.Some(this.value);\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:Option<T>)=>U): U {\n        return converter(this);\n    }\n\n    /**\n     * Convert to a vector. If it's a None, it's the empty\n     * vector, if it's a Some, it's a one-element vector with\n     * the contents of the option.\n     */\n    toVector(): Vector<T> {\n        return Vector.of(this.value);\n    }\n\n    /**\n     * Convert to an either. You must provide a left value\n     * in case this is a None.\n     */\n    toEither<L>(left: L): Either<L,T> {\n        return Either.right<L,T>(this.value);\n    }\n\n    /**\n     * If this is a Some, return this object.\n     * If this is a None, return the result of the function.\n     */\n    orCall(_: () => Option<T>): Option<T> {\n      return this;\n    }\n\n    hasTrueEquality<T>(): boolean {\n        return optionHasTrueEquality(this);\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other: Option<T&WithEquality>): boolean {\n        if (<any>other === this) {\n            return true;\n        }\n        // the .isSome doesn't test if it's a Some, but\n        // if the object has a field called isSome.\n        if (other === <None<T>>none || !other || !(<any>other).isSome) {\n            return false;\n        }\n\n        const someOther = <Some<T&WithEquality>>other;\n        contractTrueEquality(\"Option.equals\", this, someOther);\n        return areEqual(this.value, someOther.value);\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        return getHashCode(this.value);\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     */\n    toString(): string {\n        return \"Some(\" + toStringHelper(this.value) + \")\";\n    }\n\n    /**\n     * Used by the node REPL to display values.\n     */\n    [inspect](): string {\n        return this.toString();\n    }\n}\n\n/**\n * None represents an [[Option]] without value.\n * \"static methods\" available through [[OptionStatic]]\n *\n * [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n * @param T the item type\n */\nexport class None<T> implements Value {\n\n    /**\n     * @hidden\n     */\n    readonly className: \"None\" = <any>undefined;  // https://stackoverflow.com/a/47841595/516188\n\n    /**\n     * Returns false since this is a None (doesn'tcontains a value)\n     */\n    isSome(): this is Some<T> {\n        return false;\n    }\n\n    /**\n     * Returns true since this is a None (doesn'tcontains a value)\n     */\n    isNone(): this is None<T> {\n        return true;\n    }\n\n    /**\n     * View this Some a as Option. Useful to help typescript type\n     * inference sometimes.\n     */\n    asOption(): Option<T> {\n        return this;\n    }\n\n    /**\n     * Combines two options. If this option is a Some, returns it.\n     * If it's a None, returns the other one.\n     */\n    orElse(other: Option<T>): Option<T> {\n        return other;\n    }\n\n    /**\n     * Get the value from this option if it's a Some, otherwise\n     * throw an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message, or an Error object.\n     */\n    getOrThrow(errorInfo?: Error|string): T & WithEquality {\n        if (typeof errorInfo === 'string') {\n            throw new Error(errorInfo || \"getOrThrow called on none!\");\n        }\n        throw errorInfo || new Error(\"getOrThrow called on none!\");\n    }\n\n    /**\n     * Returns true if the option is a Some and contains the\n     * value you give, false otherwise.\n     */\n    contains(v: T&WithEquality): boolean {\n        return false;\n    }\n\n    /**\n     * Get the value contained in the option if it's a Some,\n     * return undefined if it's a None.\n     *\n     *     Option.of(5).getOrUndefined()\n     *     => 5\n     *\n     *     Option.none<number>().getOrUndefined()\n     *     => undefined\n     */\n    getOrUndefined(): T|undefined {\n        return undefined;\n    }\n\n    /**\n     * Get the value contained in the option if it's a Some,\n     * return null if it's a None.\n     *\n     *     Option.of(5).getOrNull()\n     *     => 5\n     *\n     *     Option.none<number>().getOrNull()\n     *     => null\n     */\n    getOrNull(): T|null {\n        return null;\n    }\n\n    /**\n     * Get the value from this option; if it's a None (no value\n     * present), then return the default value that you give.\n     */\n    getOrElse(alt: T): T {\n        return alt;\n    }\n\n    /**\n     * Get the value from this option; if it's a None (no value\n     * present), then return the value returned by the function that you give.\n     *\n     *     Option.of(5).getOrCall(() => 6)\n     *     => 5\n     *\n     *     Option.none<number>().getOrCall(() => 6)\n     *     => 6\n     */\n    getOrCall(fn: ()=>T): T {\n        return fn();\n    }\n\n    /**\n     * Return a new option where the element (if present) was transformed\n     * by the mapper function you give. If the option was None it'll stay None.\n     *\n     *     Option.of(5).map(x => x*2)\n     *     => Option.of(10)\n     *\n     *     Option.of(5).map(x => null)\n     *     => Option.of(null)\n     *\n     * Also see [[None.mapNullable]], [[None.flatMap]]\n     */\n    map<U>(fn: (v:T)=>U): Option<U> {\n        return <None<U>>none;\n    }\n\n    /**\n     * Return a new option where the element (if present) was transformed\n     * by the mapper function you give. If the mapped value is `null` or\n     * `undefined`, then a Some will turn into a None.\n     * If the option was None it'll stay None.\n     *\n     *     Option.of(5).mapNullable(x => x*2)\n     *     => Option.of(10)\n     *\n     *     Option.of(5).mapNullable(x => null)\n     *     => Option.none()\n     *\n     * Also see [[None.map]], [[None.flatMap]]\n     */\n    mapNullable<U>(fn: (v:T)=>U|null|undefined): Option<U> {\n        return <None<U>>none;\n    }\n\n    /**\n     * If this is a Some, calls the function you give on\n     * the item in the option and return its result.\n     * If the option is a None, return none.\n     * This is the monadic bind.\n     */\n    flatMap<U>(mapper:(v:T)=>Option<U>): Option<U> {\n        return <None<U>>none;\n    }\n\n    /**\n     * If this is None, will return None. If it's a Some,\n     * and the contents match your predicate, return the option.\n     * If the contents don't match the predicate, return None.\n     */\n    filter<U extends T>(fn:(v:T)=>v is U): Option<U>;\n    filter(fn: (v:T)=>boolean): Option<T>;\n    filter(fn: (v:T)=>boolean): Option<T> {\n        return <None<T>>none;\n    }\n\n    /**\n     * Execute a side-effecting function if the option\n     * is a Some; returns the option.\n     */\n    ifSome(fn:(v:T)=>void): Option<T> {\n        return this;\n    }\n\n    /**\n     * Execute a side-effecting function if the option\n     * is a Some; returns the option.\n     */\n    ifNone(fn:()=>void): Option<T> {\n        fn();\n        return this;\n    }\n\n    /**\n     * Handle both branches of the option and return a value\n     * (can also be used for side-effects).\n     * This is the catamorphism for option.\n     *\n     *     Option.of(5).match({\n     *         Some: x  => \"got \" + x,\n     *         None: () => \"got nothing!\"\n     *     });\n     *     => \"got 5\"\n     */\n    match<U>(cases: {Some: (v:T)=>U, None: ()=>U}): U {\n        return cases.None();\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:Option<T>)=>U): U {\n        return converter(this);\n    }\n\n    /**\n     * Convert to a vector. If it's a None, it's the empty\n     * vector, if it's a Some, it's a one-element vector with\n     * the contents of the option.\n     */\n    toVector(): Vector<T> {\n        return Vector.empty<T>();\n    }\n\n    /**\n     * Convert to an either. You must provide a left value\n     * in case this is a None.\n     */\n    toEither<L>(left: L): Either<L,T> {\n        return Either.left<L,T>(left);\n    }\n\n    /**\n     * If this is a Some, return this object.\n     * If this is a None, return the result of the function.\n     */\n    orCall(fn: () => Option<T>): Option<T> {\n      return fn();\n    }\n\n    hasTrueEquality<T>(): boolean {\n        return optionHasTrueEquality(this);\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other: Option<T&WithEquality>): boolean {\n        return other === <None<T>>none;\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        return 1;\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     */\n    toString(): string {\n        return \"None()\";\n    }\n\n    /**\n     * Used by the node REPL to display values.\n     */\n    [inspect](): string {\n        return this.toString();\n    }\n}\n\n/**\n * @hidden\n */\nexport const none = new None<any>();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}