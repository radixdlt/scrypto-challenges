{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bech32 = exports.defaultEncoding = exports.Encoding = void 0;\nconst bech32_1 = require(\"bech32\");\nconst util_1 = require(\"@radixdlt/util\");\nconst neverthrow_1 = require(\"neverthrow\");\nvar Encoding;\n(function (Encoding) {\n  Encoding[\"BECH32\"] = \"bech32\";\n  Encoding[\"BECH32m\"] = \"bech32m\";\n})(Encoding = exports.Encoding || (exports.Encoding = {}));\nexports.defaultEncoding = Encoding.BECH32;\nconst convertDataFromBech32 = bech32Data => {\n  try {\n    const data = bech32_1.bech32.fromWords(bech32Data);\n    return (0, neverthrow_1.ok)(Buffer.from(data));\n  } catch (e) {\n    const underlyingError = (0, util_1.msgFromError)(e);\n    const errMsg = `Failed to converted bech32 data to Buffer, underlying error: '${underlyingError}'`;\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n};\nconst convertDataToBech32 = data => {\n  try {\n    const bech32Data = bech32_1.bech32.toWords(data);\n    return (0, neverthrow_1.ok)(Buffer.from(bech32Data));\n  } catch (e) {\n    const underlyingError = (0, util_1.msgFromError)(e);\n    const errMsg = `Failed to converted buffer to bech32 data, underlying error: '${underlyingError}'`;\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n};\nconst __unsafeCreate = input => {\n  const toString = () => input.bech32String;\n  const equals = other => toString() === other.toString();\n  return {\n    hrp: input.hrp,\n    data: input.data,\n    equals,\n    toString\n  };\n};\nconst encode = input => {\n  var _a;\n  const {\n    hrp,\n    data,\n    maxLength\n  } = input;\n  const encoding = (_a = input.encoding) !== null && _a !== void 0 ? _a : exports.defaultEncoding;\n  const impl = encoding === Encoding.BECH32 ? bech32_1.bech32 : bech32_1.bech32m;\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access\n    const bech32String = impl.encode(hrp, data, maxLength);\n    return (0, neverthrow_1.ok)(__unsafeCreate({\n      bech32String: bech32String.toLowerCase(),\n      hrp,\n      data\n    }));\n  } catch (e) {\n    const errMsg = (0, util_1.msgFromError)(e);\n    util_1.log.error(errMsg);\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n};\nconst decode = input => {\n  var _a;\n  const {\n    bechString,\n    maxLength\n  } = input;\n  const encoding = (_a = input.encoding) !== null && _a !== void 0 ? _a : exports.defaultEncoding;\n  const impl = encoding === Encoding.BECH32 ? bech32_1.bech32 : bech32_1.bech32m;\n  try {\n    const decoded = impl.decode(bechString, maxLength);\n    return (0, neverthrow_1.ok)(__unsafeCreate({\n      bech32String: bechString,\n      hrp: decoded.prefix,\n      data: Buffer.from(decoded.words)\n    }));\n  } catch (e) {\n    const errMsg = (0, util_1.msgFromError)(e);\n    util_1.log.error(errMsg);\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n};\nexports.Bech32 = {\n  convertDataToBech32,\n  convertDataFromBech32,\n  decode,\n  encode\n};","map":{"version":3,"names":["bech32_1","require","util_1","neverthrow_1","Encoding","exports","defaultEncoding","BECH32","convertDataFromBech32","bech32Data","data","bech32","fromWords","ok","Buffer","from","e","underlyingError","msgFromError","errMsg","err","Error","convertDataToBech32","toWords","__unsafeCreate","input","toString","bech32String","equals","other","hrp","encode","maxLength","encoding","_a","impl","bech32m","toLowerCase","log","error","decode","bechString","decoded","prefix","words","Bech32"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/account/src/bech32/bech32.ts"],"sourcesContent":["import { bech32, bech32m, BechLib, Decoded } from 'bech32'\nimport { log, msgFromError } from '@radixdlt/util'\nimport { err, ok, Result } from 'neverthrow'\nimport { Bech32T } from './_types'\n\nexport enum Encoding {\n\tBECH32 = 'bech32',\n\tBECH32m = 'bech32m',\n}\n\nexport const defaultEncoding = Encoding.BECH32\n\nconst convertDataFromBech32 = (bech32Data: Buffer): Result<Buffer, Error> => {\n\ttry {\n\t\tconst data = bech32.fromWords(bech32Data)\n\t\treturn ok(Buffer.from(data))\n\t} catch (e) {\n\t\tconst underlyingError = msgFromError(e)\n\t\tconst errMsg = `Failed to converted bech32 data to Buffer, underlying error: '${underlyingError}'`\n\t\treturn err(new Error(errMsg))\n\t}\n}\n\nconst convertDataToBech32 = (data: Buffer): Result<Buffer, Error> => {\n\ttry {\n\t\tconst bech32Data = bech32.toWords(data)\n\t\treturn ok(Buffer.from(bech32Data))\n\t} catch (e) {\n\t\tconst underlyingError = msgFromError(e)\n\t\tconst errMsg = `Failed to converted buffer to bech32 data, underlying error: '${underlyingError}'`\n\t\treturn err(new Error(errMsg))\n\t}\n}\n\nconst __unsafeCreate = (\n\tinput: Readonly<{\n\t\tbech32String: string\n\t\thrp: string\n\t\tdata: Buffer\n\t}>,\n): Bech32T => {\n\tconst toString = (): string => input.bech32String\n\tconst equals = (other: Bech32T): boolean => toString() === other.toString()\n\treturn { hrp: input.hrp, data: input.data, equals, toString }\n}\n\nexport type Bech32EncodeInput = Readonly<{\n\thrp: string\n\tdata: Buffer\n\tencoding?: Encoding\n\tmaxLength?: number\n}>\n\nconst encode = (input: Bech32EncodeInput): Result<Bech32T, Error> => {\n\tconst { hrp, data, maxLength } = input\n\tconst encoding = input.encoding ?? defaultEncoding\n\n\tconst impl: BechLib = encoding === Encoding.BECH32 ? bech32 : bech32m\n\n\ttry {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access\n\t\tconst bech32String: string = impl.encode(hrp, data, maxLength)\n\t\treturn ok(\n\t\t\t__unsafeCreate({\n\t\t\t\tbech32String: bech32String.toLowerCase(),\n\t\t\t\thrp,\n\t\t\t\tdata,\n\t\t\t}),\n\t\t)\n\t} catch (e) {\n\t\tconst errMsg = msgFromError(e)\n\t\tlog.error(errMsg)\n\t\treturn err(new Error(errMsg))\n\t}\n}\n\nexport type Bech32DecodeInput = Readonly<{\n\tbechString: string\n\tencoding?: Encoding\n\tmaxLength?: number\n}>\n\nconst decode = (input: Bech32DecodeInput): Result<Bech32T, Error> => {\n\tconst { bechString, maxLength } = input\n\tconst encoding = input.encoding ?? defaultEncoding\n\n\tconst impl: BechLib = encoding === Encoding.BECH32 ? bech32 : bech32m\n\n\ttry {\n\t\tconst decoded: Decoded = impl.decode(bechString, maxLength)\n\t\treturn ok(\n\t\t\t__unsafeCreate({\n\t\t\t\tbech32String: bechString,\n\t\t\t\thrp: decoded.prefix,\n\t\t\t\tdata: Buffer.from(decoded.words),\n\t\t\t}),\n\t\t)\n\t} catch (e) {\n\t\tconst errMsg = msgFromError(e)\n\t\tlog.error(errMsg)\n\t\treturn err(new Error(errMsg))\n\t}\n}\n\nexport const Bech32 = {\n\tconvertDataToBech32,\n\tconvertDataFromBech32,\n\tdecode,\n\tencode,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}