{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { OperatorSubscriber } from './OperatorSubscriber';\nexport function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n  return operate(function (source, subscriber) {\n    var groups = new Map();\n    var notify = function (cb) {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n    var handleError = function (err) {\n      return notify(function (consumer) {\n        return consumer.error(err);\n      });\n    };\n    var groupBySourceSubscriber = new GroupBySubscriber(subscriber, function (value) {\n      try {\n        var key_1 = keySelector(value);\n        var group_1 = groups.get(key_1);\n        if (!group_1) {\n          groups.set(key_1, group_1 = subjectSelector ? subjectSelector() : new Subject());\n          var grouped = createGroupedObservable(key_1, group_1);\n          subscriber.next(grouped);\n          if (durationSelector) {\n            var durationSubscriber_1 = new OperatorSubscriber(group_1, function () {\n              group_1.complete();\n              durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();\n            }, undefined, undefined, function () {\n              return groups.delete(key_1);\n            });\n            groupBySourceSubscriber.add(durationSelector(grouped).subscribe(durationSubscriber_1));\n          }\n        }\n        group_1.next(elementSelector ? elementSelector(value) : value);\n      } catch (err) {\n        handleError(err);\n      }\n    }, function () {\n      return notify(function (consumer) {\n        return consumer.complete();\n      });\n    }, handleError, function () {\n      return groups.clear();\n    });\n    source.subscribe(groupBySourceSubscriber);\n    function createGroupedObservable(key, groupSubject) {\n      var result = new Observable(function (groupSubscriber) {\n        groupBySourceSubscriber.activeGroups++;\n        var innerSub = groupSubject.subscribe(groupSubscriber);\n        return function () {\n          innerSub.unsubscribe();\n          --groupBySourceSubscriber.activeGroups === 0 && groupBySourceSubscriber.teardownAttempted && groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}\nvar GroupBySubscriber = function (_super) {\n  __extends(GroupBySubscriber, _super);\n  function GroupBySubscriber() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.activeGroups = 0;\n    _this.teardownAttempted = false;\n    return _this;\n  }\n  GroupBySubscriber.prototype.unsubscribe = function () {\n    this.teardownAttempted = true;\n    this.activeGroups === 0 && _super.prototype.unsubscribe.call(this);\n  };\n  return GroupBySubscriber;\n}(OperatorSubscriber);","map":{"version":3,"names":["Observable","Subject","operate","OperatorSubscriber","groupBy","keySelector","elementSelector","durationSelector","subjectSelector","source","subscriber","groups","Map","notify","cb","forEach","handleError","err","consumer","error","groupBySourceSubscriber","GroupBySubscriber","value","key_1","group_1","get","set","grouped","createGroupedObservable","next","durationSubscriber_1","complete","unsubscribe","undefined","delete","add","subscribe","clear","key","groupSubject","result","groupSubscriber","activeGroups","innerSub","teardownAttempted","_super","__extends","_this","apply","arguments","prototype","call"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/rxjs/src/internal/operators/groupBy.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Observer, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { OperatorSubscriber } from './OperatorSubscriber';\n\nexport function groupBy<T, K extends T>(\n  keySelector: (value: T) => value is K\n): OperatorFunction<T, GroupedObservable<true, K> | GroupedObservable<false, Exclude<T, K>>>;\nexport function groupBy<T, K>(keySelector: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\nexport function groupBy<T, K>(\n  keySelector: (value: T) => K,\n  elementSelector: void,\n  durationSelector: (grouped: GroupedObservable<K, T>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, T>>;\nexport function groupBy<T, K, R>(\n  keySelector: (value: T) => K,\n  elementSelector?: (value: T) => R,\n  durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, R>>;\nexport function groupBy<T, K, R>(\n  keySelector: (value: T) => K,\n  elementSelector?: (value: T) => R,\n  durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n  subjectSelector?: () => Subject<R>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * ![](groupBy.png)\n *\n * When the Observable emits an item, a key is computed for this item with the keySelector function.\n *\n * If a {@link GroupedObservable} for this key exists, this {@link GroupedObservable} emits. Otherwise, a new\n * {@link GroupedObservable} for this key is created and emits.\n *\n * A {@link GroupedObservable} represents values belonging to the same group represented by a common key. The common\n * key is available as the `key` field of a {@link GroupedObservable} instance.\n *\n * The elements emitted by {@link GroupedObservable}s are by default the items emitted by the Observable, or elements\n * returned by the elementSelector function.\n *\n * ## Examples\n *\n * ### Group objects by id and return as array\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { mergeMap, groupBy, reduce } from 'rxjs/operators';\n *\n * of(\n *   {id: 1, name: 'JavaScript'},\n *   {id: 2, name: 'Parcel'},\n *   {id: 2, name: 'webpack'},\n *   {id: 1, name: 'TypeScript'},\n *   {id: 3, name: 'TSLint'}\n * ).pipe(\n *   groupBy(p => p.id),\n *   mergeMap((group$) => group$.pipe(reduce((acc, cur) => [...acc, cur], [])))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'JavaScript'},\n * //   { id: 1, name: 'TypeScript'} ]\n * //\n * // [ { id: 2, name: 'Parcel'},\n * //   { id: 2, name: 'webpack'} ]\n * //\n * // [ { id: 3, name: 'TSLint'} ]\n * ```\n *\n * ### Pivot data on the id field\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { groupBy, map, mergeMap, reduce } from 'rxjs/operators';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * )\n *   .pipe(\n *     groupBy(p => p.id, p => p.name),\n *     mergeMap(group$ =>\n *       group$.pipe(reduce((acc, cur) => [...acc, cur], [`${group$.key}`]))\n *     ),\n *     map(arr => ({ id: parseInt(arr[0], 10), values: arr.slice(1) }))\n *  )\n *  .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'JavaScript', 'TypeScript' ] }\n * // { id: 2, values: [ 'Parcel', 'webpack' ] }\n * // { id: 3, values: [ 'TSLint' ] }\n * ```\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @param {function(): Subject<R>} [subjectSelector] Factory function to create an\n * intermediate Subject through which grouped elements are emitted.\n * @return A function that returns an Observable that emits GroupedObservables,\n * each of which corresponds to a unique key value and each of which emits\n * those items from the source Observable that share that key value.\n */\nexport function groupBy<T, K, R>(\n  keySelector: (value: T) => K,\n  elementSelector?: ((value: T) => R) | void,\n  durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n  subjectSelector?: () => Subject<R>\n): OperatorFunction<T, GroupedObservable<K, R>> {\n  return operate((source, subscriber) => {\n    // A lookup for the groups that we have so far.\n    const groups = new Map<K, Subject<any>>();\n\n    // Used for notifying all groups and the subscriber in the same way.\n    const notify = (cb: (group: Observer<any>) => void) => {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n\n    // Used to handle errors from the source, AND errors that occur during the\n    // next call from the source.\n    const handleError = (err: any) => notify((consumer) => consumer.error(err));\n\n    // Capturing a reference to this, because we need a handle to it\n    // in `createGroupedObservable` below. This is what we use to\n    // subscribe to our source observable. This sometimes needs to be unsubscribed\n    // out-of-band with our `subscriber` which is the downstream subscriber, or destination,\n    // in cases where a user unsubscribes from the main resulting subscription, but\n    // still has groups from this subscription subscribed and would expect values from it\n    // Consider:  `source.pipe(groupBy(fn), take(2))`.\n    const groupBySourceSubscriber = new GroupBySubscriber(\n      subscriber,\n      (value: T) => {\n        // Because we have to notify all groups of any errors that occur in here,\n        // we have to add our own try/catch to ensure that those errors are propagated.\n        // OperatorSubscriber will only send the error to the main subscriber.\n        try {\n          const key = keySelector(value);\n\n          let group = groups.get(key);\n          if (!group) {\n            // Create our group subject\n            groups.set(key, (group = subjectSelector ? subjectSelector() : new Subject<any>()));\n\n            // Emit the grouped observable. Note that we can't do a simple `asObservable()` here,\n            // because the grouped observable has special semantics around reference counting\n            // to ensure we don't sever our connection to the source prematurely.\n            const grouped = createGroupedObservable(key, group);\n            subscriber.next(grouped);\n\n            if (durationSelector) {\n              const durationSubscriber = new OperatorSubscriber(\n                // Providing the group here ensures that it is disposed of -- via `unsubscribe` --\n                // wnen the duration subscription is torn down. That is important, because then\n                // if someone holds a handle to the grouped observable and tries to subscribe to it\n                // after the connection to the source has been severed, they will get an\n                // `ObjectUnsubscribedError` and know they can't possibly get any notifications.\n                group as any,\n                () => {\n                  // Our duration notified! We can complete the group.\n                  // The group will be removed from the map in the teardown phase.\n                  group!.complete();\n                  durationSubscriber?.unsubscribe();\n                },\n                // Completions are also sent to the group, but just the group.\n                undefined,\n                // Errors on the duration subscriber are sent to the group\n                // but only the group. They are not sent to the main subscription.\n                undefined,\n                // Teardown: Remove this group from our map.\n                () => groups.delete(key)\n              );\n\n              // Start our duration notifier.\n              groupBySourceSubscriber.add(durationSelector(grouped).subscribe(durationSubscriber));\n            }\n          }\n\n          // Send the value to our group.\n          group.next(elementSelector ? elementSelector(value) : value);\n        } catch (err) {\n          handleError(err);\n        }\n      },\n      // Source completes.\n      () => notify((consumer) => consumer.complete()),\n      // Error from the source.\n      handleError,\n      // Free up memory.\n      // When the source subscription is _finally_ torn down, release the subjects and keys\n      // in our groups Map, they may be quite large and we don't want to keep them around if we\n      // don't have to.\n      () => groups.clear()\n    );\n\n    // Subscribe to the source\n    source.subscribe(groupBySourceSubscriber);\n\n    /**\n     * Creates the actual grouped observable returned.\n     * @param key The key of the group\n     * @param groupSubject The subject that fuels the group\n     */\n    function createGroupedObservable(key: K, groupSubject: Subject<any>) {\n      const result: any = new Observable<T>((groupSubscriber) => {\n        groupBySourceSubscriber.activeGroups++;\n        const innerSub = groupSubject.subscribe(groupSubscriber);\n        return () => {\n          innerSub.unsubscribe();\n          // We can kill the subscription to our source if we now have no more\n          // active groups subscribed, and a teardown was already attempted on\n          // the source.\n          --groupBySourceSubscriber.activeGroups === 0 &&\n            groupBySourceSubscriber.teardownAttempted &&\n            groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}\n\n/**\n * This was created because groupBy is a bit unique, in that emitted groups that have\n * subscriptions have to keep the subscription to the source alive until they\n * are torn down.\n */\nclass GroupBySubscriber<T> extends OperatorSubscriber<T> {\n  /**\n   * The number of actively subscribed groups\n   */\n  activeGroups = 0;\n  /**\n   * Whether or not teardown was attempted on this subscription.\n   */\n  teardownAttempted = false;\n\n  unsubscribe() {\n    this.teardownAttempted = true;\n    // We only kill our subscription to the source if we have\n    // no active groups. As stated above, consider this scenario:\n    // source$.pipe(groupBy(fn), take(2)).\n    this.activeGroups === 0 && super.unsubscribe();\n  }\n}\n\n/**\n * An observable of values that is the emitted by the result of a {@link groupBy} operator,\n * contains a `key` property for the grouping.\n */\nexport interface GroupedObservable<K, T> extends Observable<T> {\n  /**\n   * The key value for the grouped notifications.\n   */\n  readonly key: K;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}