{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\nconst util = require('util');\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source</caption>\n * const n = new NoFilter('Zm9v', 'base64');\n * n.pipe(process.stdout);\n *\n * @example <caption>sink</caption>\n * const n = new Nofilter();\n * // NOTE: 'finish' fires when the input is done writing\n * n.on('finish', function() { console.log(n.toString('base64')); });\n * process.stdin.pipe(n);\n */\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer} [input] - Source data\n   * @param {string} [inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {Object} [options={}] - Other options\n   * @param {string|Buffer} [options.input=null] - Input source data\n   * @param {string} [options.inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {number} [options.highWaterMark=16384] - The maximum number of bytes\n   *   to store in the internal buffer before ceasing to read from the\n   *   underlying resource. Default=16kb, or 16 for objectMode streams\n   * @param {string} [options.encoding=null] - If specified, then buffers will\n   *   be decoded to strings using the specified encoding\n   * @param {boolean} [options.objectMode=false] - Whether this stream should\n   *   behave as a stream of objects. Meaning that stream.read(n) returns a\n   *   single value instead of a Buffer of size n\n   * @param {boolean} [options.decodeStrings=true] - Whether or not to decode\n   *   strings into Buffers before passing them to _write()\n   * @param {boolean} [options.watchPipe=true] - Whether to watch for 'pipe'\n   *   events, setting this stream's objectMode based on the objectMode of the\n   *   input stream\n   * @param {boolean} [options.readError=false] - If true, when a read()\n   *   underflows, throw an error.\n   */\n  constructor(input, inputEncoding, options) {\n    if (options == null) {\n      options = {};\n    }\n    let inp;\n    let inpE;\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input;\n          if (inputEncoding != null && typeof inputEncoding === 'object') {\n            options = inputEncoding;\n          }\n        } else {\n          options = input;\n        }\n        break;\n      case 'string':\n        inp = input;\n        if (inputEncoding != null && typeof inputEncoding === 'object') {\n          options = inputEncoding;\n        } else {\n          inpE = inputEncoding;\n        }\n        break;\n    }\n    if (options == null) {\n      options = {};\n    }\n    if (inp == null) {\n      inp = options.input;\n    }\n    if (inpE == null) {\n      inpE = options.inputEncoding;\n    }\n    delete options.input;\n    delete options.inputEncoding;\n    const watchPipe = options.watchPipe != null ? options.watchPipe : true;\n    delete options.watchPipe;\n    const readError = !!options.readError;\n    delete options.readError;\n    super(options);\n    this.readError = readError;\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        const om = readable._readableState.objectMode;\n        if (this.length > 0 && om !== this._readableState.objectMode) {\n          throw new Error('Do not switch objectMode in the middle of the stream');\n        }\n        this._readableState.objectMode = om;\n        return this._writableState.objectMode = om;\n      });\n    }\n    if (inp != null) {\n      this.end(inp, inpE);\n    }\n  }\n\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {Object} obj The object to test.\n   * @returns {boolean} true if obj is a NoFilter\n   */\n  static isNoFilter(obj) {\n    return obj instanceof this;\n  }\n\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 - The first object to compare\n   * @param {NoFilter} nf2 - The second object to compare\n   * @returns {number} -1, 0, 1 for less, equal, greater\n   *\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')];\n   * arr.sort(NoFilter.compare);\n   */\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters');\n    }\n    if (nf1 === nf2) {\n      return 0;\n    } else {\n      return nf1.compare(nf2);\n    }\n  }\n\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer\n   */\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters');\n    }\n    if (list.length === 0 || length === 0) {\n      return Buffer.alloc(0);\n    }\n    if (length == null) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters');\n        }\n        return tot + nf.length;\n      }, 0);\n    }\n    let allBufs = true;\n    let allObjs = true;\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters');\n      }\n      const buf = nf.slice();\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false;\n      } else {\n        allBufs = false;\n      }\n      return buf;\n    });\n    if (allBufs) {\n      return Buffer.concat(bufs, length);\n    }\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length);\n    }\n    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n    throw new Error('Concatenating mixed object and byte streams not supported');\n  }\n\n  /**\n   * @private\n   */\n  _transform(chunk, encoding, callback) {\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n    this.push(chunk);\n    callback();\n  }\n\n  /**\n   * @private\n   */\n  _bufArray() {\n    let bufs = this._readableState.buffer;\n    // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head;\n      bufs = [];\n      while (b != null) {\n        bufs.push(b.data);\n        b = b.next;\n      }\n    }\n    return bufs;\n  }\n\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] - Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer\n   * @throws Error - if readError is true and there was underflow\n   * @fires NoFilter#read\n   */\n  read(size) {\n    const buf = super.read(size);\n    if (buf != null) {\n      /*\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @type {Buffer|string|Object}\n       *\n       */\n      this.emit('read', buf);\n      if (this.readError && buf.length < size) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`);\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`);\n    }\n    return buf;\n  }\n\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {function} [cb=null] - finished/error callback used in *addition*\n   *   to the promise\n   * @returns {Promise<Buffer|String>} fulfilled when complete\n   */\n  promise(cb) {\n    let done = false;\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read();\n        if (cb != null && !done) {\n          done = true;\n          cb(null, data);\n        }\n        resolve(data);\n      });\n      this.on('error', er => {\n        if (cb != null && !done) {\n          done = true;\n          cb(er);\n        }\n        reject(er);\n      });\n    });\n  }\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other - The other object to compare\n   * @returns {Number} -1, 0, 1 for less, equal, greater\n   */\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters');\n    }\n    if (this === other) {\n      return 0;\n    } else {\n      const buf1 = this.slice();\n      const buf2 = other.slice();\n      // these will both be buffers because of the check above.\n      if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n        return buf1.compare(buf2);\n      }\n      throw new Error('Cannot compare streams in object mode');\n    }\n  }\n\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other\n   * @returns {boolean} Equal?\n   */\n  equals(other) {\n    return this.compare(other) === 0;\n  }\n\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {Number} [start=0] - beginning offset\n   * @param {Number} [end=length] - ending offset\n   * @returns {Buffer|Array} if in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n  slice(start, end) {\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end);\n    }\n    const bufs = this._bufArray();\n    switch (bufs.length) {\n      case 0:\n        return Buffer.alloc(0);\n      case 1:\n        return bufs[0].slice(start, end);\n      default:\n        const b = Buffer.concat(bufs);\n        // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n        return b.slice(start, end);\n    }\n  }\n\n  /**\n    * Get a byte by offset.  I didn't want to get into metaprogramming\n    * to give you the `NoFilter[0]` syntax.\n    *\n    * @param {Number} index - The byte to retrieve\n    * @returns {Number} 0-255\n    */\n  get(index) {\n    return this.slice()[index];\n  }\n\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so\n   * that round-tripping will produce a Buffer.\n   *\n   * @returns {Object}\n   *\n   * @example output for 'foo'\n   *   { type: 'Buffer', data: [ 102, 111, 111 ] }\n   */\n  toJSON() {\n    const b = this.slice();\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON();\n    } else {\n      return b;\n    }\n  }\n\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {String} [encoding='utf8'] - Which to use for decoding?\n   * @param {Number} [start=0] - Start offset\n   * @param {Number} [end=length] - End offset\n   * @returns {String}\n   */\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end);\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf);\n    }\n    if ((!encoding || encoding === 'utf8') && util.TextDecoder) {\n      const td = new util.TextDecoder('utf8', {\n        fatal: true,\n        ignoreBOM: true\n      });\n      return td.decode(buf);\n    }\n    return buf.toString(encoding, start, end);\n  }\n\n  /**\n   * @private\n   * @deprecated\n   */\n  inspect(depth, options) {\n    return this[util.inspect.custom](depth, options);\n  }\n\n  /**\n   * @private\n   */\n  [util.inspect.custom](depth, options) {\n    const bufs = this._bufArray();\n    const hex = bufs.map(b => {\n      if (Buffer.isBuffer(b)) {\n        if (options != null ? options.stylize : undefined) {\n          return options.stylize(b.toString('hex'), 'string');\n        } else {\n          return b.toString('hex');\n        }\n      } else {\n        return util.inspect(b, options);\n      }\n    }).join(', ');\n    return `${this.constructor.name} [${hex}]`;\n  }\n\n  /**\n   * Current readable length, in bytes.\n   *\n   * @member {number}\n   * @readonly\n   */\n  get length() {\n    return this._readableState.length;\n  }\n\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val - The value to write\n   * @returns {boolean} true on success\n   */\n  writeBigInt(val) {\n    let str = val.toString(16);\n    if (val < 0) {\n      // two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2));\n      const mask = BigInt(1) << sz * BigInt(8);\n      val = mask + val;\n      str = val.toString(16);\n    }\n    if (str.length % 2) {\n      str = '0' + str;\n    }\n    return this.push(Buffer.from(str, 'hex'));\n  }\n\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number}  [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n  readUBigInt(len) {\n    const b = this.read(len);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return BigInt('0x' + b.toString('hex'));\n  }\n\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n  readBigInt(len) {\n    const b = this.read(len);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    let ret = BigInt('0x' + b.toString('hex'));\n    // negative?\n    if (b[0] & 0x80) {\n      // two's complement\n      const mask = BigInt(1) << BigInt(b.length) * BigInt(8);\n      ret = ret - mask;\n    }\n    return ret;\n  }\n}\n\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\nfunction _read_gen(meth, len) {\n  return function (val) {\n    const b = this.read(len);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b[meth].call(b, 0, true);\n  };\n}\n\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\nfunction _write_gen(meth, len) {\n  return function (val) {\n    const b = Buffer.alloc(len);\n    b[meth].call(b, val, 0, true);\n    return this.push(b);\n  };\n}\nObject.assign(NoFilter.prototype, {\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @function writeUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value - 0-255\n   * @returns {boolean} true on success\n   */\n  writeUInt8: _write_gen('writeUInt8', 1),\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16LE: _write_gen('writeUInt16LE', 2),\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16BE: _write_gen('writeUInt16BE', 2),\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32LE: _write_gen('writeUInt32LE', 4),\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32BE: _write_gen('writeUInt32BE', 4),\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @function writeInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt8: _write_gen('writeInt8', 1),\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16LE: _write_gen('writeInt16LE', 2),\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16BE: _write_gen('writeInt16BE', 2),\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32LE: _write_gen('writeInt32LE', 4),\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32BE: _write_gen('writeInt32BE', 4),\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatLE: _write_gen('writeFloatLE', 4),\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatBE: _write_gen('writeFloatBE', 4),\n  /**\n   * Write a little-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleLE: _write_gen('writeDoubleLE', 8),\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleBE: _write_gen('writeDoubleBE', 8),\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @function readUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt8: _read_gen('readUInt8', 1),\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16LE: _read_gen('readUInt16LE', 2),\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16BE: _read_gen('readUInt16BE', 2),\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32LE: _read_gen('readUInt32LE', 4),\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32BE: _read_gen('readUInt32BE', 4),\n  /**\n   * Read a signed 8-bit integer from the stream.\n   * Consumes 1 byte.\n   *\n   * @function readInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt8: _read_gen('readInt8', 1),\n  /**\n   * Read a signed 16-bit little-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16LE: _read_gen('readInt16LE', 2),\n  /**\n   * Read a signed 16-bit big-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16BE: _read_gen('readInt16BE', 2),\n  /**\n   * Read a signed 32-bit little-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32LE: _read_gen('readInt32LE', 4),\n  /**\n   * Read a signed 32-bit big-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32BE: _read_gen('readInt32BE', 4),\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatLE: _read_gen('readFloatLE', 4),\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatBE: _read_gen('readFloatBE', 4),\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleLE: _read_gen('readDoubleLE', 8),\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleBE: _read_gen('readDoubleBE', 8)\n});\nmodule.exports = NoFilter;","map":{"version":3,"names":["stream","require","util","NoFilter","Transform","constructor","input","inputEncoding","options","inp","inpE","Buffer","isBuffer","watchPipe","readError","on","readable","om","_readableState","objectMode","length","Error","_writableState","end","isNoFilter","obj","compare","nf1","nf2","TypeError","concat","list","Array","isArray","alloc","reduce","tot","nf","allBufs","allObjs","bufs","map","buf","slice","_transform","chunk","encoding","callback","from","push","_bufArray","buffer","b","head","data","next","read","size","emit","promise","cb","done","Promise","resolve","reject","er","other","buf1","buf2","equals","start","get","index","toJSON","toString","JSON","stringify","TextDecoder","td","fatal","ignoreBOM","decode","inspect","depth","custom","hex","stylize","undefined","join","name","writeBigInt","val","str","sz","BigInt","Math","floor","mask","readUBigInt","len","readBigInt","ret","_read_gen","meth","call","_write_gen","Object","assign","prototype","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","readUInt8","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/nofilter/lib/index.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst util = require('util')\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source</caption>\n * const n = new NoFilter('Zm9v', 'base64');\n * n.pipe(process.stdout);\n *\n * @example <caption>sink</caption>\n * const n = new Nofilter();\n * // NOTE: 'finish' fires when the input is done writing\n * n.on('finish', function() { console.log(n.toString('base64')); });\n * process.stdin.pipe(n);\n */\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer} [input] - Source data\n   * @param {string} [inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {Object} [options={}] - Other options\n   * @param {string|Buffer} [options.input=null] - Input source data\n   * @param {string} [options.inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {number} [options.highWaterMark=16384] - The maximum number of bytes\n   *   to store in the internal buffer before ceasing to read from the\n   *   underlying resource. Default=16kb, or 16 for objectMode streams\n   * @param {string} [options.encoding=null] - If specified, then buffers will\n   *   be decoded to strings using the specified encoding\n   * @param {boolean} [options.objectMode=false] - Whether this stream should\n   *   behave as a stream of objects. Meaning that stream.read(n) returns a\n   *   single value instead of a Buffer of size n\n   * @param {boolean} [options.decodeStrings=true] - Whether or not to decode\n   *   strings into Buffers before passing them to _write()\n   * @param {boolean} [options.watchPipe=true] - Whether to watch for 'pipe'\n   *   events, setting this stream's objectMode based on the objectMode of the\n   *   input stream\n   * @param {boolean} [options.readError=false] - If true, when a read()\n   *   underflows, throw an error.\n   */\n  constructor(input, inputEncoding, options) {\n    if (options == null) {\n      options = {}\n    }\n    let inp\n    let inpE\n    switch (typeof(input)) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input\n          if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {\n            options = inputEncoding\n          }\n        } else {\n          options = input\n        }\n        break\n      case 'string':\n        inp = input\n        if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {\n          options = inputEncoding\n        } else {\n          inpE = inputEncoding\n        }\n        break\n    }\n\n    if ((options == null)) {\n      options = {}\n    }\n    if (inp == null) {\n      inp = options.input\n    }\n    if (inpE == null) {\n      inpE = options.inputEncoding\n    }\n    delete options.input\n    delete options.inputEncoding\n    const watchPipe = options.watchPipe != null ? options.watchPipe : true\n    delete options.watchPipe\n    const readError = !! options.readError\n    delete options.readError\n    super(options)\n\n    this.readError = readError\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        const om = readable._readableState.objectMode\n        if ((this.length > 0) && (om !== this._readableState.objectMode)) {\n          throw new Error(\n            'Do not switch objectMode in the middle of the stream')\n        }\n\n        this._readableState.objectMode = om\n        return this._writableState.objectMode = om\n      })\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE)\n    }\n  }\n\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {Object} obj The object to test.\n   * @returns {boolean} true if obj is a NoFilter\n   */\n  static isNoFilter(obj) {\n    return obj instanceof this\n  }\n\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 - The first object to compare\n   * @param {NoFilter} nf2 - The second object to compare\n   * @returns {number} -1, 0, 1 for less, equal, greater\n   *\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')];\n   * arr.sort(NoFilter.compare);\n   */\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (nf1 === nf2) {\n      return 0\n    } else {\n      return nf1.compare(nf2)\n    }\n  }\n\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer\n   */\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters')\n    }\n    if ((list.length === 0) || (length === 0)) {\n      return Buffer.alloc(0)\n    }\n    if ((length == null)) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters')\n        }\n        return tot + nf.length\n      }, 0)\n    }\n    let allBufs = true\n    let allObjs = true\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters')\n      }\n      const buf = nf.slice()\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false\n      } else {\n        allBufs = false\n      }\n      return buf\n    })\n    if (allBufs) {\n      return Buffer.concat(bufs, length)\n    }\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length)\n    }\n    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n    throw new Error('Concatenating mixed object and byte streams not supported')\n  }\n\n  /**\n   * @private\n   */\n  _transform(chunk, encoding, callback) {\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n    this.push(chunk)\n    callback()\n  }\n\n  /**\n   * @private\n   */\n  _bufArray() {\n    let bufs = this._readableState.buffer\n    // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head\n      bufs = []\n      while (b != null) {\n        bufs.push(b.data)\n        b = b.next\n      }\n    }\n    return bufs\n  }\n\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] - Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer\n   * @throws Error - if readError is true and there was underflow\n   * @fires NoFilter#read\n   */\n  read(size) {\n    const buf = super.read(size)\n    if (buf != null) {\n      /*\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @type {Buffer|string|Object}\n       *\n       */\n      this.emit('read', buf)\n      if (this.readError && (buf.length < size)) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`)\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`)\n    }\n    return buf\n  }\n\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {function} [cb=null] - finished/error callback used in *addition*\n   *   to the promise\n   * @returns {Promise<Buffer|String>} fulfilled when complete\n   */\n  promise(cb) {\n    let done = false\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read()\n        if ((cb != null) && !done) {\n          done = true\n          cb(null, data)\n        }\n        resolve(data)\n      })\n      this.on('error', (er) => {\n        if ((cb != null) && !done) {\n          done = true\n          cb(er)\n        }\n        reject(er)\n      })\n    })\n  }\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other - The other object to compare\n   * @returns {Number} -1, 0, 1 for less, equal, greater\n   */\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (this === other) {\n      return 0\n    } else {\n      const buf1 = this.slice()\n      const buf2 = other.slice()\n      // these will both be buffers because of the check above.\n      if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n        return buf1.compare(buf2)\n      }\n      throw new Error('Cannot compare streams in object mode')\n    }\n  }\n\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other\n   * @returns {boolean} Equal?\n   */\n  equals(other) {\n    return this.compare(other) === 0\n  }\n\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {Number} [start=0] - beginning offset\n   * @param {Number} [end=length] - ending offset\n   * @returns {Buffer|Array} if in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n  slice(start, end) {\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end)\n    }\n    const bufs = this._bufArray()\n    switch (bufs.length) {\n      case 0: return Buffer.alloc(0)\n      case 1: return bufs[0].slice(start, end)\n      default:\n        const b = Buffer.concat(bufs)\n        // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n        return b.slice(start, end)\n    }\n  }\n\n  /**\n    * Get a byte by offset.  I didn't want to get into metaprogramming\n    * to give you the `NoFilter[0]` syntax.\n    *\n    * @param {Number} index - The byte to retrieve\n    * @returns {Number} 0-255\n    */\n  get(index) {\n    return this.slice()[index]\n  }\n\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so\n   * that round-tripping will produce a Buffer.\n   *\n   * @returns {Object}\n   *\n   * @example output for 'foo'\n   *   { type: 'Buffer', data: [ 102, 111, 111 ] }\n   */\n  toJSON() {\n    const b = this.slice()\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON()\n    } else {\n      return b\n    }\n  }\n\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {String} [encoding='utf8'] - Which to use for decoding?\n   * @param {Number} [start=0] - Start offset\n   * @param {Number} [end=length] - End offset\n   * @returns {String}\n   */\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end)\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf)\n    }\n    if ((!encoding || (encoding === 'utf8')) && util.TextDecoder) {\n      const td = new util.TextDecoder('utf8', {\n        fatal: true,\n        ignoreBOM: true\n      })\n      return td.decode(buf)\n    }\n    return buf.toString(encoding, start, end)\n  }\n\n  /**\n   * @private\n   * @deprecated\n   */\n  inspect(depth, options) {\n    return this[util.inspect.custom](depth, options)\n  }\n\n  /**\n   * @private\n   */\n  [util.inspect.custom](depth, options) {\n    const bufs = this._bufArray()\n    const hex = bufs.map((b) => {\n      if (Buffer.isBuffer(b)) {\n        if ((options != null ? options.stylize : undefined)) {\n          return options.stylize(b.toString('hex'), 'string')\n        } else {\n          return b.toString('hex')\n        }\n      } else {\n        return util.inspect(b, options)\n      }\n    }).join(', ')\n    return `${this.constructor.name} [${hex}]`\n  }\n\n  /**\n   * Current readable length, in bytes.\n   *\n   * @member {number}\n   * @readonly\n   */\n  get length() {\n    return this._readableState.length\n  }\n\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val - The value to write\n   * @returns {boolean} true on success\n   */\n  writeBigInt(val) {\n    let str = val.toString(16)\n    if (val < 0) {\n      // two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2))\n      const mask = BigInt(1) << (sz * BigInt(8))\n      val = mask + val\n      str = val.toString(16)\n    }\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    return this.push(Buffer.from(str, 'hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number}  [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n  readUBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return BigInt('0x' + b.toString('hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n  readBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    let ret = BigInt('0x' + b.toString('hex'))\n    // negative?\n    if (b[0] & 0x80) {\n      // two's complement\n      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))\n      ret = ret - mask\n    }\n    return ret\n  }\n}\n\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\nfunction _read_gen(meth, len) {\n  return function(val) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b[meth].call(b, 0, true)\n  }\n}\n\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\nfunction _write_gen(meth, len) {\n  return function(val) {\n    const b = Buffer.alloc(len)\n    b[meth].call(b, val, 0, true)\n    return this.push(b)\n  }\n}\n\nObject.assign(NoFilter.prototype, {\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @function writeUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value - 0-255\n   * @returns {boolean} true on success\n   */\n  writeUInt8: _write_gen('writeUInt8', 1),\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16LE: _write_gen('writeUInt16LE', 2),\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16BE: _write_gen('writeUInt16BE', 2),\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32LE: _write_gen('writeUInt32LE', 4),\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32BE: _write_gen('writeUInt32BE', 4),\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @function writeInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt8: _write_gen('writeInt8', 1),\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16LE: _write_gen('writeInt16LE', 2),\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16BE: _write_gen('writeInt16BE', 2),\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32LE: _write_gen('writeInt32LE', 4),\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32BE: _write_gen('writeInt32BE', 4),\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatLE: _write_gen('writeFloatLE', 4),\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatBE: _write_gen('writeFloatBE', 4),\n\n  /**\n   * Write a little-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleLE: _write_gen('writeDoubleLE', 8),\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleBE: _write_gen('writeDoubleBE', 8),\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @function readUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt8: _read_gen('readUInt8', 1),\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16LE: _read_gen('readUInt16LE', 2),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16BE: _read_gen('readUInt16BE', 2),\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32LE: _read_gen('readUInt32LE', 4),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32BE: _read_gen('readUInt32BE', 4),\n\n  /**\n   * Read a signed 8-bit integer from the stream.\n   * Consumes 1 byte.\n   *\n   * @function readInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt8: _read_gen('readInt8', 1),\n\n  /**\n   * Read a signed 16-bit little-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16LE: _read_gen('readInt16LE', 2),\n\n  /**\n   * Read a signed 16-bit big-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16BE: _read_gen('readInt16BE', 2),\n\n  /**\n   * Read a signed 32-bit little-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32LE: _read_gen('readInt32LE', 4),\n\n  /**\n   * Read a signed 32-bit big-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32BE: _read_gen('readInt32BE', 4),\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatLE: _read_gen('readFloatLE', 4),\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatBE: _read_gen('readFloatBE', 4),\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleLE: _read_gen('readDoubleLE', 8),\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleBE: _read_gen('readDoubleBE', 8)\n})\n\nmodule.exports = NoFilter\n"],"mappings":"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F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEO,aAAa,EAAEP,UAAU,CAAC,eAAe,EAAE,CAAC,CAAC;EAE7C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEQ,aAAa,EAAER,UAAU,CAAC,eAAe,EAAE,CAAC,CAAC;EAE7C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACES,SAAS,EAAET,UAAU,CAAC,WAAW,EAAE,CAAC,CAAC;EAErC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEU,YAAY,EAAEV,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;EAE3C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEW,YAAY,EAAEX,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;EAE3C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEY,YAAY,EAAEZ,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;EAE3C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEa,YAAY,EAAEb,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;EAE3C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEc,YAAY,EAAEd,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;EAE3C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEe,YAAY,EAAEf,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;EAE3C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEgB,aAAa,EAAEhB,UAAU,CAAC,eAAe,EAAE,CAAC,CAAC;EAE7C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEiB,aAAa,EAAEjB,UAAU,CAAC,eAAe,EAAE,CAAC,CAAC;EAE7C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEkB,SAAS,EAAErB,SAAS,CAAC,WAAW,EAAE,CAAC,CAAC;EAEpC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEsB,YAAY,EAAEtB,SAAS,CAAC,cAAc,EAAE,CAAC,CAAC;EAE1C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEuB,YAAY,EAAEvB,SAAS,CAAC,cAAc,EAAE,CAAC,CAAC;EAE1C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEwB,YAAY,EAAExB,SAAS,CAAC,cAAc,EAAE,CAAC,CAAC;EAE1C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEyB,YAAY,EAAEzB,SAAS,CAAC,cAAc,EAAE,CAAC,CAAC;EAE1C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE0B,QAAQ,EAAE1B,SAAS,CAAC,UAAU,EAAE,CAAC,CAAC;EAElC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE2B,WAAW,EAAE3B,SAAS,CAAC,aAAa,EAAE,CAAC,CAAC;EAExC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE4B,WAAW,EAAE5B,SAAS,CAAC,aAAa,EAAE,CAAC,CAAC;EAExC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE6B,WAAW,EAAE7B,SAAS,CAAC,aAAa,EAAE,CAAC,CAAC;EAExC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE8B,WAAW,EAAE9B,SAAS,CAAC,aAAa,EAAE,CAAC,CAAC;EAExC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE+B,WAAW,EAAE/B,SAAS,CAAC,aAAa,EAAE,CAAC,CAAC;EAExC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEgC,WAAW,EAAEhC,SAAS,CAAC,aAAa,EAAE,CAAC,CAAC;EAExC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEiC,YAAY,EAAEjC,SAAS,CAAC,cAAc,EAAE,CAAC,CAAC;EAE1C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEkC,YAAY,EAAElC,SAAS,CAAC,cAAc,EAAE,CAAC;AAC3C,CAAC,CAAC;AAEFmC,MAAM,CAACC,OAAO,GAAGvI,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}