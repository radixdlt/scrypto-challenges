{"ast":null,"code":"/**\n * Javascript implementation of RSA-KEM.\n *\n * @author Lautaro Cozzani Rodriguez\n * @author Dave Longley\n *\n * Copyright (c) 2014 Lautaro Cozzani <lautaro.cozzani@scytl.com>\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\nrequire('./random');\nrequire('./jsbn');\nmodule.exports = forge.kem = forge.kem || {};\nvar BigInteger = forge.jsbn.BigInteger;\n\n/**\n * The API for the RSA Key Encapsulation Mechanism (RSA-KEM) from ISO 18033-2.\n */\nforge.kem.rsa = {};\n\n/**\n * Creates an RSA KEM API object for generating a secret asymmetric key.\n *\n * The symmetric key may be generated via a call to 'encrypt', which will\n * produce a ciphertext to be transmitted to the recipient and a key to be\n * kept secret. The ciphertext is a parameter to be passed to 'decrypt' which\n * will produce the same secret key for the recipient to use to decrypt a\n * message that was encrypted with the secret key.\n *\n * @param kdf the KDF API to use (eg: new forge.kem.kdf1()).\n * @param options the options to use.\n *          [prng] a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n */\nforge.kem.rsa.create = function (kdf, options) {\n  options = options || {};\n  var prng = options.prng || forge.random;\n  var kem = {};\n\n  /**\n   * Generates a secret key and its encapsulation.\n   *\n   * @param publicKey the RSA public key to encrypt with.\n   * @param keyLength the length, in bytes, of the secret key to generate.\n   *\n   * @return an object with:\n   *   encapsulation: the ciphertext for generating the secret key, as a\n   *     binary-encoded string of bytes.\n   *   key: the secret key to use for encrypting a message.\n   */\n  kem.encrypt = function (publicKey, keyLength) {\n    // generate a random r where 1 < r < n\n    var byteLength = Math.ceil(publicKey.n.bitLength() / 8);\n    var r;\n    do {\n      r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n);\n    } while (r.compareTo(BigInteger.ONE) <= 0);\n\n    // prepend r with zeros\n    r = forge.util.hexToBytes(r.toString(16));\n    var zeros = byteLength - r.length;\n    if (zeros > 0) {\n      r = forge.util.fillString(String.fromCharCode(0), zeros) + r;\n    }\n\n    // encrypt the random\n    var encapsulation = publicKey.encrypt(r, 'NONE');\n\n    // generate the secret key\n    var key = kdf.generate(r, keyLength);\n    return {\n      encapsulation: encapsulation,\n      key: key\n    };\n  };\n\n  /**\n   * Decrypts an encapsulated secret key.\n   *\n   * @param privateKey the RSA private key to decrypt with.\n   * @param encapsulation the ciphertext for generating the secret key, as\n   *          a binary-encoded string of bytes.\n   * @param keyLength the length, in bytes, of the secret key to generate.\n   *\n   * @return the secret key as a binary-encoded string of bytes.\n   */\n  kem.decrypt = function (privateKey, encapsulation, keyLength) {\n    // decrypt the encapsulation and generate the secret key\n    var r = privateKey.decrypt(encapsulation, 'NONE');\n    return kdf.generate(r, keyLength);\n  };\n  return kem;\n};\n\n// TODO: add forge.kem.kdf.create('KDF1', {md: ..., ...}) API?\n\n/**\n * Creates a key derivation API object that implements KDF1 per ISO 18033-2.\n *\n * @param md the hash API to use.\n * @param [digestLength] an optional digest length that must be positive and\n *          less than or equal to md.digestLength.\n *\n * @return a KDF1 API object.\n */\nforge.kem.kdf1 = function (md, digestLength) {\n  _createKDF(this, md, 0, digestLength || md.digestLength);\n};\n\n/**\n * Creates a key derivation API object that implements KDF2 per ISO 18033-2.\n *\n * @param md the hash API to use.\n * @param [digestLength] an optional digest length that must be positive and\n *          less than or equal to md.digestLength.\n *\n * @return a KDF2 API object.\n */\nforge.kem.kdf2 = function (md, digestLength) {\n  _createKDF(this, md, 1, digestLength || md.digestLength);\n};\n\n/**\n * Creates a KDF1 or KDF2 API object.\n *\n * @param md the hash API to use.\n * @param counterStart the starting index for the counter.\n * @param digestLength the digest length to use.\n *\n * @return the KDF API object.\n */\nfunction _createKDF(kdf, md, counterStart, digestLength) {\n  /**\n   * Generate a key of the specified length.\n   *\n   * @param x the binary-encoded byte string to generate a key from.\n   * @param length the number of bytes to generate (the size of the key).\n   *\n   * @return the key as a binary-encoded string.\n   */\n  kdf.generate = function (x, length) {\n    var key = new forge.util.ByteBuffer();\n\n    // run counter from counterStart to ceil(length / Hash.len)\n    var k = Math.ceil(length / digestLength) + counterStart;\n    var c = new forge.util.ByteBuffer();\n    for (var i = counterStart; i < k; ++i) {\n      // I2OSP(i, 4): convert counter to an octet string of 4 octets\n      c.putInt32(i);\n\n      // digest 'x' and the counter and add the result to the key\n      md.start();\n      md.update(x + c.getBytes());\n      var hash = md.digest();\n      key.putBytes(hash.getBytes(digestLength));\n    }\n\n    // truncate to the correct key length\n    key.truncate(key.length() - length);\n    return key.getBytes();\n  };\n}","map":{"version":3,"names":["forge","require","module","exports","kem","BigInteger","jsbn","rsa","create","kdf","options","prng","random","encrypt","publicKey","keyLength","byteLength","Math","ceil","n","bitLength","r","util","bytesToHex","getBytesSync","mod","compareTo","ONE","hexToBytes","toString","zeros","length","fillString","String","fromCharCode","encapsulation","key","generate","decrypt","privateKey","kdf1","md","digestLength","_createKDF","kdf2","counterStart","x","ByteBuffer","k","c","i","putInt32","start","update","getBytes","hash","digest","putBytes","truncate"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/node-forge/lib/kem.js"],"sourcesContent":["/**\n * Javascript implementation of RSA-KEM.\n *\n * @author Lautaro Cozzani Rodriguez\n * @author Dave Longley\n *\n * Copyright (c) 2014 Lautaro Cozzani <lautaro.cozzani@scytl.com>\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\nrequire('./random');\nrequire('./jsbn');\n\nmodule.exports = forge.kem = forge.kem || {};\n\nvar BigInteger = forge.jsbn.BigInteger;\n\n/**\n * The API for the RSA Key Encapsulation Mechanism (RSA-KEM) from ISO 18033-2.\n */\nforge.kem.rsa = {};\n\n/**\n * Creates an RSA KEM API object for generating a secret asymmetric key.\n *\n * The symmetric key may be generated via a call to 'encrypt', which will\n * produce a ciphertext to be transmitted to the recipient and a key to be\n * kept secret. The ciphertext is a parameter to be passed to 'decrypt' which\n * will produce the same secret key for the recipient to use to decrypt a\n * message that was encrypted with the secret key.\n *\n * @param kdf the KDF API to use (eg: new forge.kem.kdf1()).\n * @param options the options to use.\n *          [prng] a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n */\nforge.kem.rsa.create = function(kdf, options) {\n  options = options || {};\n  var prng = options.prng || forge.random;\n\n  var kem = {};\n\n  /**\n   * Generates a secret key and its encapsulation.\n   *\n   * @param publicKey the RSA public key to encrypt with.\n   * @param keyLength the length, in bytes, of the secret key to generate.\n   *\n   * @return an object with:\n   *   encapsulation: the ciphertext for generating the secret key, as a\n   *     binary-encoded string of bytes.\n   *   key: the secret key to use for encrypting a message.\n   */\n  kem.encrypt = function(publicKey, keyLength) {\n    // generate a random r where 1 < r < n\n    var byteLength = Math.ceil(publicKey.n.bitLength() / 8);\n    var r;\n    do {\n      r = new BigInteger(\n        forge.util.bytesToHex(prng.getBytesSync(byteLength)),\n        16).mod(publicKey.n);\n    } while(r.compareTo(BigInteger.ONE) <= 0);\n\n    // prepend r with zeros\n    r = forge.util.hexToBytes(r.toString(16));\n    var zeros = byteLength - r.length;\n    if(zeros > 0) {\n      r = forge.util.fillString(String.fromCharCode(0), zeros) + r;\n    }\n\n    // encrypt the random\n    var encapsulation = publicKey.encrypt(r, 'NONE');\n\n    // generate the secret key\n    var key = kdf.generate(r, keyLength);\n\n    return {encapsulation: encapsulation, key: key};\n  };\n\n  /**\n   * Decrypts an encapsulated secret key.\n   *\n   * @param privateKey the RSA private key to decrypt with.\n   * @param encapsulation the ciphertext for generating the secret key, as\n   *          a binary-encoded string of bytes.\n   * @param keyLength the length, in bytes, of the secret key to generate.\n   *\n   * @return the secret key as a binary-encoded string of bytes.\n   */\n  kem.decrypt = function(privateKey, encapsulation, keyLength) {\n    // decrypt the encapsulation and generate the secret key\n    var r = privateKey.decrypt(encapsulation, 'NONE');\n    return kdf.generate(r, keyLength);\n  };\n\n  return kem;\n};\n\n// TODO: add forge.kem.kdf.create('KDF1', {md: ..., ...}) API?\n\n/**\n * Creates a key derivation API object that implements KDF1 per ISO 18033-2.\n *\n * @param md the hash API to use.\n * @param [digestLength] an optional digest length that must be positive and\n *          less than or equal to md.digestLength.\n *\n * @return a KDF1 API object.\n */\nforge.kem.kdf1 = function(md, digestLength) {\n  _createKDF(this, md, 0, digestLength || md.digestLength);\n};\n\n/**\n * Creates a key derivation API object that implements KDF2 per ISO 18033-2.\n *\n * @param md the hash API to use.\n * @param [digestLength] an optional digest length that must be positive and\n *          less than or equal to md.digestLength.\n *\n * @return a KDF2 API object.\n */\nforge.kem.kdf2 = function(md, digestLength) {\n  _createKDF(this, md, 1, digestLength || md.digestLength);\n};\n\n/**\n * Creates a KDF1 or KDF2 API object.\n *\n * @param md the hash API to use.\n * @param counterStart the starting index for the counter.\n * @param digestLength the digest length to use.\n *\n * @return the KDF API object.\n */\nfunction _createKDF(kdf, md, counterStart, digestLength) {\n  /**\n   * Generate a key of the specified length.\n   *\n   * @param x the binary-encoded byte string to generate a key from.\n   * @param length the number of bytes to generate (the size of the key).\n   *\n   * @return the key as a binary-encoded string.\n   */\n  kdf.generate = function(x, length) {\n    var key = new forge.util.ByteBuffer();\n\n    // run counter from counterStart to ceil(length / Hash.len)\n    var k = Math.ceil(length / digestLength) + counterStart;\n\n    var c = new forge.util.ByteBuffer();\n    for(var i = counterStart; i < k; ++i) {\n      // I2OSP(i, 4): convert counter to an octet string of 4 octets\n      c.putInt32(i);\n\n      // digest 'x' and the counter and add the result to the key\n      md.start();\n      md.update(x + c.getBytes());\n      var hash = md.digest();\n      key.putBytes(hash.getBytes(digestLength));\n    }\n\n    // truncate to the correct key length\n    key.truncate(key.length() - length);\n    return key.getBytes();\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}