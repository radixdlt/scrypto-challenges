{"ast":null,"code":"\"use strict\";\n\n/**\n * The [[Option]] type expresses that a value may be present or not.\n * The code is organized through the class [[None]] (value not\n * present), the class [[Some]] (value present), and the type alias\n * [[Option]] (Some or None).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[OptionStatic]] and are accessed through the global constant Option.\n *\n * Examples:\n *\n *     Option.of(5);\n *     Option.none<number>();\n *     Option.of(5).map(x => x*2);\n *\n * To get the value out of an option, you can use [[Some.getOrThrow]],\n * or [[Some.get]]. The latter is available if you've checked that you\n * indeed have a some, for example:\n *\n *     const opt = Option.of(5);\n *     if (opt.isSome()) {\n *         opt.get();\n *     }\n *\n * You also have other options like [[Some.getOrElse]], [[Some.getOrUndefined]]\n * and so on. [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n */\nexports.__esModule = true;\nvar Value_1 = require(\"./Value\");\nvar Vector_1 = require(\"./Vector\");\nvar Either_1 = require(\"./Either\");\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\nvar Contract_1 = require(\"./Contract\");\n/**\n * Holds the \"static methods\" for [[Option]]\n */\nvar OptionStatic = /** @class */function () {\n  function OptionStatic() {}\n  /**\n   * Builds an optional value.\n   * * T is wrapped in a [[Some]]\n   * * undefined becomes a [[None]]\n   * * null becomes a [[Some]].\n   *\n   *     Option.of(5).isSome()\n   *     => true\n   *\n   *     Option.of(undefined).isSome()\n   *     => false\n   *\n   *     Option.of(null).isSome()\n   *     => true\n   *\n   * Also see [[OptionStatic.some]], [[OptionStatic.ofNullable]]\n   */\n  OptionStatic.prototype.of = function (v) {\n    return v === undefined ? exports.none : new Some(v);\n  };\n  /**\n   * Build an optional value from a nullable.\n   * * T is wrapped in a [[Some]]\n   * * undefined becomes a [[None]]\n   * * null becomes a [[None]].\n   *\n   *     Option.ofNullable(5).isSome()\n   *     => true\n   *\n   *     Option.ofNullable(undefined).isSome()\n   *     => false\n   *\n   *     Option.ofNullable(null).isSome()\n   *     => false\n   *\n   * Also see [[OptionStatic.some]], [[OptionStatic.of]]\n   */\n  OptionStatic.prototype.ofNullable = function (v) {\n    return v !== undefined && v !== null ? new Some(v) : exports.none;\n  };\n  /**\n   * Build a [[Some]], unlike [[OptionStatic.of]], which may build a [[Some]]\n   * or a [[None]].\n   * Will throw if given undefined.\n   *\n   *     Option.some(5).isSome()\n   *     => true\n   *\n   *     Option.some(undefined).isSome()\n   *     => throws\n   *\n   *     Option.some(null).isSome()\n   *     => true\n   *\n   * Also see [[OptionStatic.of]], [[OptionStatic.ofNullable]]\n   */\n  OptionStatic.prototype.some = function (v) {\n    // the reason I decided to add a some in addition to 'of'\n    // instead of making 'of' smarter (which is possible in\n    // typescript, see https://github.com/bcherny/tsoption)\n    // is that sometimes you really want an Option, not a Some.\n    // for instance you can't mix an a Some and an Option in a list\n    // if you put the Some first, without calling asOption().\n    if (typeof v === \"undefined\") {\n      throw \"Option.some got undefined!\";\n    }\n    return new Some(v);\n  };\n  /**\n   * The optional value expressing a missing value.\n   */\n  OptionStatic.prototype.none = function () {\n    return exports.none;\n  };\n  /**\n   * Curried type guard for Option\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Option.of(2), Option.none<number>())\n   *         .filter(Option.isSome)\n   *         .map(o => o.get())\n   *     => Vector.of(2)\n   */\n  OptionStatic.prototype.isSome = function (o) {\n    return o.isSome();\n  };\n  /**\n   * Curried type guard for Option\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Option.of(2), Option.none<number>())\n   *         .filter(Option.isNone)\n   *     => Vector.of(Option.none<number>())\n   */\n  OptionStatic.prototype.isNone = function (o) {\n    return o.isNone();\n  };\n  /**\n   * Turns a list of options in an option containing a list of items.\n   * Useful in many contexts.\n   *\n   *     Option.sequence(Vector.of(Option.of(1),Option.of(2)))\n   *     => Option.of(Vector.of(1,2))\n   *\n   * But if a single element is None, everything is discarded:\n   *\n   *     Option.sequence(Vector.of(Option.of(1), Option.none()))\n   *     => Option.none()\n   *\n   * Also see [[OptionStatic.traverse]]\n   */\n  OptionStatic.prototype.sequence = function (elts) {\n    return exports.Option.traverse(elts, function (x) {\n      return x;\n    });\n  };\n  /**\n   * Takes a list, a function that can transform list elements\n   * to options, then return an option containing a list of\n   * the transformed elements.\n   *\n   *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?\n   *         Option.of(\"user\" + x.toString()) : Option.none();\n   *     Option.traverse([4, 3, 2], getUserById);\n   *     => Option.of(Vector.of(\"user4\", \"user3\", \"user2\"))\n   *\n   * But if a single element results in None, everything is discarded:\n   *\n   *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?\n   *         Option.of(\"user\" + x.toString()) : Option.none();\n   *     Option.traverse([4, -3, 2], getUserById);\n   *     => Option.none()\n   *\n   * Also see [[OptionStatic.sequence]]\n   */\n  OptionStatic.prototype.traverse = function (elts, fn) {\n    var r = Vector_1.Vector.empty();\n    var iterator = elts[Symbol.iterator]();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      var v = fn(curItem.value);\n      if (v.isNone()) {\n        return exports.none;\n      }\n      r = r.append(v.get());\n      curItem = iterator.next();\n    }\n    return exports.Option.of(r);\n  };\n  /**\n   * Applicative lifting for Option.\n   * Takes a function which operates on basic values, and turns it\n   * in a function that operates on options of these values ('lifts'\n   * the function). The 2 is because it works on functions taking two\n   * parameters.\n   *\n   *     const lifted = Option.liftA2((x:number,y:number) => x+y);\n   *     lifted(Option.of(5), Option.of(6));\n   *     => Option.of(11)\n   *\n   *     const lifted2 = Option.liftA2((x:number,y:number) => x+y);\n   *     lifted2(Option.of(5), Option.none<number>());\n   *     => Option.none()\n   *\n   * @param T the first option type\n   * @param U the second option type\n   * @param V the new type as returned by the combining function.\n   */\n  OptionStatic.prototype.liftA2 = function (fn) {\n    return function (p1, p2) {\n      return p1.flatMap(function (a1) {\n        return p2.map(function (a2) {\n          return fn(a1, a2);\n        });\n      });\n    };\n  };\n  /**\n   * Applicative lifting for Option. 'p' stands for 'properties'.\n   *\n   * Takes a function which operates on a simple JS object, and turns it\n   * in a function that operates on the same JS object type except which each field\n   * wrapped in an Option ('lifts' the function).\n   * It's an alternative to [[OptionStatic.liftA2]] when the number of parameters\n   * is not two.\n   *\n   *     const lifted = Option.liftAp((x:{a:number,b:number,c:number}) => x.a+x.b+x.c);\n   *     lifted({a:Option.of(5), b:Option.of(6), c:Option.of(3)});\n   *     => Option.of(14)\n   *\n   *     const lifted = Option.liftAp((x:{a:number,b:number}) => x.a+x.b);\n   *     lifted({a:Option.of(5), b:Option.none<number>()});\n   *     => Option.none()\n   *\n   * @param A the object property type specifying the parameters for your function\n   * @param B the type returned by your function, returned wrapped in an option by liftAp.\n   */\n  OptionStatic.prototype.liftAp = function (fn) {\n    return function (x) {\n      var copy = {};\n      for (var p in x) {\n        if (x[p].isNone()) {\n          return exports.Option.none();\n        }\n        copy[p] = x[p].getOrThrow();\n      }\n      return exports.Option.of(fn(copy));\n    };\n  };\n  /**\n   * Take a partial function (may return undefined or throw),\n   * and lift it to return an [[Option]] instead.\n   * undefined becomes a [[None]], everything else a [[Some]]\n   *\n   *     const plus = Option.lift((x:number,y:number)=>x+y);\n   *     plus(1,2);\n   *     => Option.of(3)\n   *\n   *     const undef = Option.lift((x:number)=>undefined);\n   *     undef(1);\n   *     => Option.none()\n   *\n   *     const nl = Option.lift((x:number,y:number,z:number)=>null);\n   *     nl(1,2,3);\n   *     => Option.some(null)\n   *\n   *     const throws = Option.lift((x:number,y:number)=>{throw \"x\"});\n   *     throws(1,2);\n   *     => Option.none()\n   */\n  OptionStatic.prototype.lift = function (fn) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      try {\n        return exports.Option.of(fn.apply(void 0, args));\n      } catch (_a) {\n        return exports.Option.none();\n      }\n    };\n  };\n  /**\n   * Take a partial function (may return undefined or throw),\n   * and lift it to return an [[Option]] instead.\n   * null and undefined become a [[None]], everything else a [[Some]]\n   *\n   *     const plus = Option.liftNullable((x:number,y:number)=>x+y);\n   *     plus(1,2);\n   *     => Option.of(3)\n   *\n   *     const undef = Option.liftNullable((x:number,y:number,z:string)=>undefined);\n   *     undef(1,2,\"\");\n   *     => Option.none()\n   *\n   *     const nl = Option.liftNullable((x:number)=>null);\n   *     nl(1);\n   *     => Option.none()\n   *\n   *     const throws = Option.liftNullable((x:number,y:number)=>{throw \"x\"});\n   *     throws(1,2);\n   *     => Option.none()\n   */\n  OptionStatic.prototype.liftNullable = function (fn) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      try {\n        return exports.Option.ofNullable(fn.apply(void 0, args));\n      } catch (_a) {\n        return exports.Option.none();\n      }\n    };\n  };\n  /**\n   * Take a no-parameter partial function (may return undefined or throw),\n   * and call it, return an [[Option]] instead.\n   * undefined becomes a [[None]], everything else a [[Some]]\n   *\n   *     Option.try_(Math.random);\n   *     => Option.of(0.49884723907769635)\n   *\n   *     Option.try_(()=>undefined);\n   *     => Option.none()\n   *\n   *     Option.try_(()=>null);\n   *     => Option.of(null)\n   *\n   *     Option.try_(()=>{throw \"x\"});\n   *     => Option.none()\n   *\n   * Also see [[OptionStatic.tryNullable]], [[OptionStatic.lift]],\n   * [[OptionStatic.liftNullable]], [[EitherStatic.try_]].\n   */\n  OptionStatic.prototype.try_ = function (fn) {\n    return exports.Option.lift(fn)();\n  };\n  /**\n   * Take a no-parameter partial function (may return null, undefined or throw),\n   * and call it, return an [[Option]] instead.\n   * null and undefined become a [[None]], everything else a [[Some]]\n   *\n   *     Option.tryNullable(Math.random);\n   *     => Option.of(0.49884723907769635)\n   *\n   *     Option.tryNullable(()=>undefined);\n   *     => Option.none()\n   *\n   *     Option.tryNullable(()=>null);\n   *     => Option.none()\n   *\n   *     Option.tryNullable(()=>{throw \"x\"});\n   *     => Option.none()\n   *\n   * Also see [[OptionStatic.try_]], [[OptionStatic.liftNullable]],\n   * [[OptionStatic.lift]], [[EitherStatic.try_]].\n   */\n  OptionStatic.prototype.tryNullable = function (fn) {\n    return exports.Option.liftNullable(fn)();\n  };\n  return OptionStatic;\n}();\nexports.OptionStatic = OptionStatic;\n/**\n * The Option constant allows to call the option \"static\" methods\n */\nexports.Option = new OptionStatic();\nfunction optionHasTrueEquality(opt) {\n  return opt.flatMap(function (x) {\n    return x && x.hasTrueEquality ? exports.Option.of(x.hasTrueEquality()) : Comparison_1.hasTrueEquality(x);\n  }).getOrElse(true);\n}\n/**\n * Some represents an [[Option]] with a value.\n * \"static methods\" available through [[OptionStatic]]\n *\n * [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n * @param T the item type\n */\nvar Some = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function Some(value) {\n    this.value = value;\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * Returns true since this is a Some (contains a value)\n   */\n  Some.prototype.isSome = function () {\n    return true;\n  };\n  /**\n   * Returns false since this is a Some (contains a value)\n   */\n  Some.prototype.isNone = function () {\n    return false;\n  };\n  /**\n   * View this Some a as Option. Useful to help typescript type\n   * inference sometimes.\n   */\n  Some.prototype.asOption = function () {\n    return this;\n  };\n  /**\n   * Get the value contained in this option.\n   * NOTE: we know it's there, since this method\n   * belongs to Some, not Option.\n   */\n  Some.prototype.get = function () {\n    return this.value;\n  };\n  /**\n   * Combines two options. If this option is a Some, returns it.\n   * If it's a None, returns the other one.\n   */\n  Some.prototype.orElse = function (other) {\n    return this;\n  };\n  /**\n   * Get the value from this option if it's a Some, otherwise\n   * throw an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message.\n   */\n  Some.prototype.getOrThrow = function (errorInfo) {\n    return this.value;\n  };\n  /**\n   * Returns true if the option is a Some and contains the\n   * value you give, false otherwise.\n   */\n  Some.prototype.contains = function (v) {\n    return v === this.value;\n  };\n  /**\n   * Get the value contained in the option if it's a Some,\n   * return undefined if it's a None.\n   *\n   *     Option.of(5).getOrUndefined()\n   *     => 5\n   *\n   *     Option.none<number>().getOrUndefined()\n   *     => undefined\n   */\n  Some.prototype.getOrUndefined = function () {\n    return this.value;\n  };\n  /**\n   * Get the value contained in the option if it's a Some,\n   * return null if it's a None.\n   *\n   *     Option.of(5).getOrNull()\n   *     => 5\n   *\n   *     Option.none<number>().getOrNull()\n   *     => null\n   */\n  Some.prototype.getOrNull = function () {\n    return this.value;\n  };\n  /**\n   * Get the value from this option; if it's a None (no value\n   * present), then return the default value that you give.\n   */\n  Some.prototype.getOrElse = function (alt) {\n    return this.value;\n  };\n  /**\n   * Get the value from this option; if it's a None (no value\n   * present), then return the value returned by the function that you give.\n   *\n   *     Option.of(5).getOrCall(() => 6)\n   *     => 5\n   *\n   *     Option.none<number>().getOrCall(() => 6)\n   *     => 6\n   */\n  Some.prototype.getOrCall = function (fn) {\n    return this.value;\n  };\n  /**\n   * Return a new option where the element (if present) was transformed\n   * by the mapper function you give. If the option was None it'll stay None.\n   *\n   *     Option.of(5).map(x => x*2)\n   *     => Option.of(10)\n   *\n   *     Option.of(5).map(x => null)\n   *     => Option.of(null)\n   *\n   * Also see [[Some.mapNullable]], [[Some.flatMap]]\n   */\n  Some.prototype.map = function (fn) {\n    return exports.Option.of(fn(this.value));\n  };\n  /**\n   * Return a new option where the element (if present) was transformed\n   * by the mapper function you give. If the mapped value is `null` or\n   * `undefined`, then a Some will turn into a None.\n   * If the option was None it'll stay None.\n   *\n   *     Option.of(5).mapNullable(x => x*2)\n   *     => Option.of(10)\n   *\n   *     Option.of(5).mapNullable(x => null)\n   *     => Option.none()\n   *\n   * Also see [[Some.map]], [[Some.flatMap]]\n   */\n  Some.prototype.mapNullable = function (fn) {\n    return exports.Option.ofNullable(fn(this.value));\n  };\n  /**\n   * If this is a Some, calls the function you give on\n   * the item in the option and return its result.\n   * If the option is a None, return none.\n   * This is the monadic bind.\n   */\n  Some.prototype.flatMap = function (mapper) {\n    return mapper(this.value);\n  };\n  Some.prototype.filter = function (fn) {\n    return fn(this.value) ? this : exports.Option.none();\n  };\n  /**\n   * Execute a side-effecting function if the option\n   * is a Some; returns the option.\n   */\n  Some.prototype.ifSome = function (fn) {\n    fn(this.value);\n    return this;\n  };\n  /**\n   * Execute a side-effecting function if the option\n   * is a None; returns the option.\n   */\n  Some.prototype.ifNone = function (fn) {\n    return this;\n  };\n  /**\n   * Handle both branches of the option and return a value\n   * (can also be used for side-effects).\n   * This is the catamorphism for option.\n   *\n   *     Option.of(5).match({\n   *         Some: x  => \"got \" + x,\n   *         None: () => \"got nothing!\"\n   *     });\n   *     => \"got 5\"\n   */\n  Some.prototype.match = function (cases) {\n    return cases.Some(this.value);\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  Some.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Convert to a vector. If it's a None, it's the empty\n   * vector, if it's a Some, it's a one-element vector with\n   * the contents of the option.\n   */\n  Some.prototype.toVector = function () {\n    return Vector_1.Vector.of(this.value);\n  };\n  /**\n   * Convert to an either. You must provide a left value\n   * in case this is a None.\n   */\n  Some.prototype.toEither = function (left) {\n    return Either_1.Either.right(this.value);\n  };\n  /**\n   * If this is a Some, return this object.\n   * If this is a None, return the result of the function.\n   */\n  Some.prototype.orCall = function (_) {\n    return this;\n  };\n  Some.prototype.hasTrueEquality = function () {\n    return optionHasTrueEquality(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  Some.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    // the .isSome doesn't test if it's a Some, but\n    // if the object has a field called isSome.\n    if (other === exports.none || !other || !other.isSome) {\n      return false;\n    }\n    var someOther = other;\n    Contract_1.contractTrueEquality(\"Option.equals\", this, someOther);\n    return Comparison_1.areEqual(this.value, someOther.value);\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  Some.prototype.hashCode = function () {\n    return Comparison_1.getHashCode(this.value);\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   */\n  Some.prototype.toString = function () {\n    return \"Some(\" + SeqHelpers_1.toStringHelper(this.value) + \")\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   */\n  Some.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return Some;\n}();\nexports.Some = Some;\n/**\n * None represents an [[Option]] without value.\n * \"static methods\" available through [[OptionStatic]]\n *\n * [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n * @param T the item type\n */\nvar None = /** @class */function () {\n  function None() {\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * Returns false since this is a None (doesn'tcontains a value)\n   */\n  None.prototype.isSome = function () {\n    return false;\n  };\n  /**\n   * Returns true since this is a None (doesn'tcontains a value)\n   */\n  None.prototype.isNone = function () {\n    return true;\n  };\n  /**\n   * View this Some a as Option. Useful to help typescript type\n   * inference sometimes.\n   */\n  None.prototype.asOption = function () {\n    return this;\n  };\n  /**\n   * Combines two options. If this option is a Some, returns it.\n   * If it's a None, returns the other one.\n   */\n  None.prototype.orElse = function (other) {\n    return other;\n  };\n  /**\n   * Get the value from this option if it's a Some, otherwise\n   * throw an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message, or an Error object.\n   */\n  None.prototype.getOrThrow = function (errorInfo) {\n    if (typeof errorInfo === 'string') {\n      throw new Error(errorInfo || \"getOrThrow called on none!\");\n    }\n    throw errorInfo || new Error(\"getOrThrow called on none!\");\n  };\n  /**\n   * Returns true if the option is a Some and contains the\n   * value you give, false otherwise.\n   */\n  None.prototype.contains = function (v) {\n    return false;\n  };\n  /**\n   * Get the value contained in the option if it's a Some,\n   * return undefined if it's a None.\n   *\n   *     Option.of(5).getOrUndefined()\n   *     => 5\n   *\n   *     Option.none<number>().getOrUndefined()\n   *     => undefined\n   */\n  None.prototype.getOrUndefined = function () {\n    return undefined;\n  };\n  /**\n   * Get the value contained in the option if it's a Some,\n   * return null if it's a None.\n   *\n   *     Option.of(5).getOrNull()\n   *     => 5\n   *\n   *     Option.none<number>().getOrNull()\n   *     => null\n   */\n  None.prototype.getOrNull = function () {\n    return null;\n  };\n  /**\n   * Get the value from this option; if it's a None (no value\n   * present), then return the default value that you give.\n   */\n  None.prototype.getOrElse = function (alt) {\n    return alt;\n  };\n  /**\n   * Get the value from this option; if it's a None (no value\n   * present), then return the value returned by the function that you give.\n   *\n   *     Option.of(5).getOrCall(() => 6)\n   *     => 5\n   *\n   *     Option.none<number>().getOrCall(() => 6)\n   *     => 6\n   */\n  None.prototype.getOrCall = function (fn) {\n    return fn();\n  };\n  /**\n   * Return a new option where the element (if present) was transformed\n   * by the mapper function you give. If the option was None it'll stay None.\n   *\n   *     Option.of(5).map(x => x*2)\n   *     => Option.of(10)\n   *\n   *     Option.of(5).map(x => null)\n   *     => Option.of(null)\n   *\n   * Also see [[None.mapNullable]], [[None.flatMap]]\n   */\n  None.prototype.map = function (fn) {\n    return exports.none;\n  };\n  /**\n   * Return a new option where the element (if present) was transformed\n   * by the mapper function you give. If the mapped value is `null` or\n   * `undefined`, then a Some will turn into a None.\n   * If the option was None it'll stay None.\n   *\n   *     Option.of(5).mapNullable(x => x*2)\n   *     => Option.of(10)\n   *\n   *     Option.of(5).mapNullable(x => null)\n   *     => Option.none()\n   *\n   * Also see [[None.map]], [[None.flatMap]]\n   */\n  None.prototype.mapNullable = function (fn) {\n    return exports.none;\n  };\n  /**\n   * If this is a Some, calls the function you give on\n   * the item in the option and return its result.\n   * If the option is a None, return none.\n   * This is the monadic bind.\n   */\n  None.prototype.flatMap = function (mapper) {\n    return exports.none;\n  };\n  None.prototype.filter = function (fn) {\n    return exports.none;\n  };\n  /**\n   * Execute a side-effecting function if the option\n   * is a Some; returns the option.\n   */\n  None.prototype.ifSome = function (fn) {\n    return this;\n  };\n  /**\n   * Execute a side-effecting function if the option\n   * is a Some; returns the option.\n   */\n  None.prototype.ifNone = function (fn) {\n    fn();\n    return this;\n  };\n  /**\n   * Handle both branches of the option and return a value\n   * (can also be used for side-effects).\n   * This is the catamorphism for option.\n   *\n   *     Option.of(5).match({\n   *         Some: x  => \"got \" + x,\n   *         None: () => \"got nothing!\"\n   *     });\n   *     => \"got 5\"\n   */\n  None.prototype.match = function (cases) {\n    return cases.None();\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  None.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Convert to a vector. If it's a None, it's the empty\n   * vector, if it's a Some, it's a one-element vector with\n   * the contents of the option.\n   */\n  None.prototype.toVector = function () {\n    return Vector_1.Vector.empty();\n  };\n  /**\n   * Convert to an either. You must provide a left value\n   * in case this is a None.\n   */\n  None.prototype.toEither = function (left) {\n    return Either_1.Either.left(left);\n  };\n  /**\n   * If this is a Some, return this object.\n   * If this is a None, return the result of the function.\n   */\n  None.prototype.orCall = function (fn) {\n    return fn();\n  };\n  None.prototype.hasTrueEquality = function () {\n    return optionHasTrueEquality(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  None.prototype.equals = function (other) {\n    return other === exports.none;\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  None.prototype.hashCode = function () {\n    return 1;\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   */\n  None.prototype.toString = function () {\n    return \"None()\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   */\n  None.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return None;\n}();\nexports.None = None;\n/**\n * @hidden\n */\nexports.none = new None();","map":{"version":3,"names":["exports","__esModule","Value_1","require","Vector_1","Either_1","Comparison_1","SeqHelpers_1","Contract_1","OptionStatic","prototype","of","v","undefined","none","Some","ofNullable","some","isSome","o","isNone","sequence","elts","Option","traverse","x","fn","r","Vector","empty","iterator","Symbol","curItem","next","done","value","append","get","liftA2","p1","p2","flatMap","a1","map","a2","liftAp","copy","p","getOrThrow","lift","args","_i","arguments","length","apply","_a","liftNullable","try_","tryNullable","optionHasTrueEquality","opt","hasTrueEquality","getOrElse","className","asOption","orElse","other","errorInfo","contains","getOrUndefined","getOrNull","alt","getOrCall","mapNullable","mapper","filter","ifSome","ifNone","match","cases","transform","converter","toVector","toEither","left","Either","right","orCall","_","equals","someOther","contractTrueEquality","areEqual","hashCode","getHashCode","toString","toStringHelper","inspect","None","Error"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/dist/src/Option.js"],"sourcesContent":["\"use strict\";\n/**\n * The [[Option]] type expresses that a value may be present or not.\n * The code is organized through the class [[None]] (value not\n * present), the class [[Some]] (value present), and the type alias\n * [[Option]] (Some or None).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[OptionStatic]] and are accessed through the global constant Option.\n *\n * Examples:\n *\n *     Option.of(5);\n *     Option.none<number>();\n *     Option.of(5).map(x => x*2);\n *\n * To get the value out of an option, you can use [[Some.getOrThrow]],\n * or [[Some.get]]. The latter is available if you've checked that you\n * indeed have a some, for example:\n *\n *     const opt = Option.of(5);\n *     if (opt.isSome()) {\n *         opt.get();\n *     }\n *\n * You also have other options like [[Some.getOrElse]], [[Some.getOrUndefined]]\n * and so on. [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n */\nexports.__esModule = true;\nvar Value_1 = require(\"./Value\");\nvar Vector_1 = require(\"./Vector\");\nvar Either_1 = require(\"./Either\");\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\nvar Contract_1 = require(\"./Contract\");\n/**\n * Holds the \"static methods\" for [[Option]]\n */\nvar OptionStatic = /** @class */ (function () {\n    function OptionStatic() {\n    }\n    /**\n     * Builds an optional value.\n     * * T is wrapped in a [[Some]]\n     * * undefined becomes a [[None]]\n     * * null becomes a [[Some]].\n     *\n     *     Option.of(5).isSome()\n     *     => true\n     *\n     *     Option.of(undefined).isSome()\n     *     => false\n     *\n     *     Option.of(null).isSome()\n     *     => true\n     *\n     * Also see [[OptionStatic.some]], [[OptionStatic.ofNullable]]\n     */\n    OptionStatic.prototype.of = function (v) {\n        return (v === undefined) ? exports.none : new Some(v);\n    };\n    /**\n     * Build an optional value from a nullable.\n     * * T is wrapped in a [[Some]]\n     * * undefined becomes a [[None]]\n     * * null becomes a [[None]].\n     *\n     *     Option.ofNullable(5).isSome()\n     *     => true\n     *\n     *     Option.ofNullable(undefined).isSome()\n     *     => false\n     *\n     *     Option.ofNullable(null).isSome()\n     *     => false\n     *\n     * Also see [[OptionStatic.some]], [[OptionStatic.of]]\n     */\n    OptionStatic.prototype.ofNullable = function (v) {\n        return (v !== undefined && v !== null) ? new Some(v) : exports.none;\n    };\n    /**\n     * Build a [[Some]], unlike [[OptionStatic.of]], which may build a [[Some]]\n     * or a [[None]].\n     * Will throw if given undefined.\n     *\n     *     Option.some(5).isSome()\n     *     => true\n     *\n     *     Option.some(undefined).isSome()\n     *     => throws\n     *\n     *     Option.some(null).isSome()\n     *     => true\n     *\n     * Also see [[OptionStatic.of]], [[OptionStatic.ofNullable]]\n     */\n    OptionStatic.prototype.some = function (v) {\n        // the reason I decided to add a some in addition to 'of'\n        // instead of making 'of' smarter (which is possible in\n        // typescript, see https://github.com/bcherny/tsoption)\n        // is that sometimes you really want an Option, not a Some.\n        // for instance you can't mix an a Some and an Option in a list\n        // if you put the Some first, without calling asOption().\n        if (typeof v === \"undefined\") {\n            throw \"Option.some got undefined!\";\n        }\n        return new Some(v);\n    };\n    /**\n     * The optional value expressing a missing value.\n     */\n    OptionStatic.prototype.none = function () {\n        return exports.none;\n    };\n    /**\n     * Curried type guard for Option\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Option.of(2), Option.none<number>())\n     *         .filter(Option.isSome)\n     *         .map(o => o.get())\n     *     => Vector.of(2)\n     */\n    OptionStatic.prototype.isSome = function (o) {\n        return o.isSome();\n    };\n    /**\n     * Curried type guard for Option\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Option.of(2), Option.none<number>())\n     *         .filter(Option.isNone)\n     *     => Vector.of(Option.none<number>())\n     */\n    OptionStatic.prototype.isNone = function (o) {\n        return o.isNone();\n    };\n    /**\n     * Turns a list of options in an option containing a list of items.\n     * Useful in many contexts.\n     *\n     *     Option.sequence(Vector.of(Option.of(1),Option.of(2)))\n     *     => Option.of(Vector.of(1,2))\n     *\n     * But if a single element is None, everything is discarded:\n     *\n     *     Option.sequence(Vector.of(Option.of(1), Option.none()))\n     *     => Option.none()\n     *\n     * Also see [[OptionStatic.traverse]]\n     */\n    OptionStatic.prototype.sequence = function (elts) {\n        return exports.Option.traverse(elts, function (x) { return x; });\n    };\n    /**\n     * Takes a list, a function that can transform list elements\n     * to options, then return an option containing a list of\n     * the transformed elements.\n     *\n     *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?\n     *         Option.of(\"user\" + x.toString()) : Option.none();\n     *     Option.traverse([4, 3, 2], getUserById);\n     *     => Option.of(Vector.of(\"user4\", \"user3\", \"user2\"))\n     *\n     * But if a single element results in None, everything is discarded:\n     *\n     *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?\n     *         Option.of(\"user\" + x.toString()) : Option.none();\n     *     Option.traverse([4, -3, 2], getUserById);\n     *     => Option.none()\n     *\n     * Also see [[OptionStatic.sequence]]\n     */\n    OptionStatic.prototype.traverse = function (elts, fn) {\n        var r = Vector_1.Vector.empty();\n        var iterator = elts[Symbol.iterator]();\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            var v = fn(curItem.value);\n            if (v.isNone()) {\n                return exports.none;\n            }\n            r = r.append(v.get());\n            curItem = iterator.next();\n        }\n        return exports.Option.of(r);\n    };\n    /**\n     * Applicative lifting for Option.\n     * Takes a function which operates on basic values, and turns it\n     * in a function that operates on options of these values ('lifts'\n     * the function). The 2 is because it works on functions taking two\n     * parameters.\n     *\n     *     const lifted = Option.liftA2((x:number,y:number) => x+y);\n     *     lifted(Option.of(5), Option.of(6));\n     *     => Option.of(11)\n     *\n     *     const lifted2 = Option.liftA2((x:number,y:number) => x+y);\n     *     lifted2(Option.of(5), Option.none<number>());\n     *     => Option.none()\n     *\n     * @param T the first option type\n     * @param U the second option type\n     * @param V the new type as returned by the combining function.\n     */\n    OptionStatic.prototype.liftA2 = function (fn) {\n        return function (p1, p2) { return p1.flatMap(function (a1) { return p2.map(function (a2) { return fn(a1, a2); }); }); };\n    };\n    /**\n     * Applicative lifting for Option. 'p' stands for 'properties'.\n     *\n     * Takes a function which operates on a simple JS object, and turns it\n     * in a function that operates on the same JS object type except which each field\n     * wrapped in an Option ('lifts' the function).\n     * It's an alternative to [[OptionStatic.liftA2]] when the number of parameters\n     * is not two.\n     *\n     *     const lifted = Option.liftAp((x:{a:number,b:number,c:number}) => x.a+x.b+x.c);\n     *     lifted({a:Option.of(5), b:Option.of(6), c:Option.of(3)});\n     *     => Option.of(14)\n     *\n     *     const lifted = Option.liftAp((x:{a:number,b:number}) => x.a+x.b);\n     *     lifted({a:Option.of(5), b:Option.none<number>()});\n     *     => Option.none()\n     *\n     * @param A the object property type specifying the parameters for your function\n     * @param B the type returned by your function, returned wrapped in an option by liftAp.\n     */\n    OptionStatic.prototype.liftAp = function (fn) {\n        return function (x) {\n            var copy = {};\n            for (var p in x) {\n                if (x[p].isNone()) {\n                    return exports.Option.none();\n                }\n                copy[p] = x[p].getOrThrow();\n            }\n            return exports.Option.of(fn(copy));\n        };\n    };\n    /**\n     * Take a partial function (may return undefined or throw),\n     * and lift it to return an [[Option]] instead.\n     * undefined becomes a [[None]], everything else a [[Some]]\n     *\n     *     const plus = Option.lift((x:number,y:number)=>x+y);\n     *     plus(1,2);\n     *     => Option.of(3)\n     *\n     *     const undef = Option.lift((x:number)=>undefined);\n     *     undef(1);\n     *     => Option.none()\n     *\n     *     const nl = Option.lift((x:number,y:number,z:number)=>null);\n     *     nl(1,2,3);\n     *     => Option.some(null)\n     *\n     *     const throws = Option.lift((x:number,y:number)=>{throw \"x\"});\n     *     throws(1,2);\n     *     => Option.none()\n     */\n    OptionStatic.prototype.lift = function (fn) {\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            try {\n                return exports.Option.of(fn.apply(void 0, args));\n            }\n            catch (_a) {\n                return exports.Option.none();\n            }\n        };\n    };\n    /**\n     * Take a partial function (may return undefined or throw),\n     * and lift it to return an [[Option]] instead.\n     * null and undefined become a [[None]], everything else a [[Some]]\n     *\n     *     const plus = Option.liftNullable((x:number,y:number)=>x+y);\n     *     plus(1,2);\n     *     => Option.of(3)\n     *\n     *     const undef = Option.liftNullable((x:number,y:number,z:string)=>undefined);\n     *     undef(1,2,\"\");\n     *     => Option.none()\n     *\n     *     const nl = Option.liftNullable((x:number)=>null);\n     *     nl(1);\n     *     => Option.none()\n     *\n     *     const throws = Option.liftNullable((x:number,y:number)=>{throw \"x\"});\n     *     throws(1,2);\n     *     => Option.none()\n     */\n    OptionStatic.prototype.liftNullable = function (fn) {\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            try {\n                return exports.Option.ofNullable(fn.apply(void 0, args));\n            }\n            catch (_a) {\n                return exports.Option.none();\n            }\n        };\n    };\n    /**\n     * Take a no-parameter partial function (may return undefined or throw),\n     * and call it, return an [[Option]] instead.\n     * undefined becomes a [[None]], everything else a [[Some]]\n     *\n     *     Option.try_(Math.random);\n     *     => Option.of(0.49884723907769635)\n     *\n     *     Option.try_(()=>undefined);\n     *     => Option.none()\n     *\n     *     Option.try_(()=>null);\n     *     => Option.of(null)\n     *\n     *     Option.try_(()=>{throw \"x\"});\n     *     => Option.none()\n     *\n     * Also see [[OptionStatic.tryNullable]], [[OptionStatic.lift]],\n     * [[OptionStatic.liftNullable]], [[EitherStatic.try_]].\n     */\n    OptionStatic.prototype.try_ = function (fn) {\n        return exports.Option.lift(fn)();\n    };\n    /**\n     * Take a no-parameter partial function (may return null, undefined or throw),\n     * and call it, return an [[Option]] instead.\n     * null and undefined become a [[None]], everything else a [[Some]]\n     *\n     *     Option.tryNullable(Math.random);\n     *     => Option.of(0.49884723907769635)\n     *\n     *     Option.tryNullable(()=>undefined);\n     *     => Option.none()\n     *\n     *     Option.tryNullable(()=>null);\n     *     => Option.none()\n     *\n     *     Option.tryNullable(()=>{throw \"x\"});\n     *     => Option.none()\n     *\n     * Also see [[OptionStatic.try_]], [[OptionStatic.liftNullable]],\n     * [[OptionStatic.lift]], [[EitherStatic.try_]].\n     */\n    OptionStatic.prototype.tryNullable = function (fn) {\n        return exports.Option.liftNullable(fn)();\n    };\n    return OptionStatic;\n}());\nexports.OptionStatic = OptionStatic;\n/**\n * The Option constant allows to call the option \"static\" methods\n */\nexports.Option = new OptionStatic();\nfunction optionHasTrueEquality(opt) {\n    return opt.flatMap(function (x) { return (x && x.hasTrueEquality) ?\n        exports.Option.of(x.hasTrueEquality()) :\n        Comparison_1.hasTrueEquality(x); })\n        .getOrElse(true);\n}\n/**\n * Some represents an [[Option]] with a value.\n * \"static methods\" available through [[OptionStatic]]\n *\n * [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n * @param T the item type\n */\nvar Some = /** @class */ (function () {\n    /**\n     * @hidden\n     */\n    function Some(value) {\n        this.value = value;\n        /**\n         * @hidden\n         */\n        this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n    }\n    /**\n     * Returns true since this is a Some (contains a value)\n     */\n    Some.prototype.isSome = function () {\n        return true;\n    };\n    /**\n     * Returns false since this is a Some (contains a value)\n     */\n    Some.prototype.isNone = function () {\n        return false;\n    };\n    /**\n     * View this Some a as Option. Useful to help typescript type\n     * inference sometimes.\n     */\n    Some.prototype.asOption = function () {\n        return this;\n    };\n    /**\n     * Get the value contained in this option.\n     * NOTE: we know it's there, since this method\n     * belongs to Some, not Option.\n     */\n    Some.prototype.get = function () {\n        return this.value;\n    };\n    /**\n     * Combines two options. If this option is a Some, returns it.\n     * If it's a None, returns the other one.\n     */\n    Some.prototype.orElse = function (other) {\n        return this;\n    };\n    /**\n     * Get the value from this option if it's a Some, otherwise\n     * throw an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message.\n     */\n    Some.prototype.getOrThrow = function (errorInfo) {\n        return this.value;\n    };\n    /**\n     * Returns true if the option is a Some and contains the\n     * value you give, false otherwise.\n     */\n    Some.prototype.contains = function (v) {\n        return v === this.value;\n    };\n    /**\n     * Get the value contained in the option if it's a Some,\n     * return undefined if it's a None.\n     *\n     *     Option.of(5).getOrUndefined()\n     *     => 5\n     *\n     *     Option.none<number>().getOrUndefined()\n     *     => undefined\n     */\n    Some.prototype.getOrUndefined = function () {\n        return this.value;\n    };\n    /**\n     * Get the value contained in the option if it's a Some,\n     * return null if it's a None.\n     *\n     *     Option.of(5).getOrNull()\n     *     => 5\n     *\n     *     Option.none<number>().getOrNull()\n     *     => null\n     */\n    Some.prototype.getOrNull = function () {\n        return this.value;\n    };\n    /**\n     * Get the value from this option; if it's a None (no value\n     * present), then return the default value that you give.\n     */\n    Some.prototype.getOrElse = function (alt) {\n        return this.value;\n    };\n    /**\n     * Get the value from this option; if it's a None (no value\n     * present), then return the value returned by the function that you give.\n     *\n     *     Option.of(5).getOrCall(() => 6)\n     *     => 5\n     *\n     *     Option.none<number>().getOrCall(() => 6)\n     *     => 6\n     */\n    Some.prototype.getOrCall = function (fn) {\n        return this.value;\n    };\n    /**\n     * Return a new option where the element (if present) was transformed\n     * by the mapper function you give. If the option was None it'll stay None.\n     *\n     *     Option.of(5).map(x => x*2)\n     *     => Option.of(10)\n     *\n     *     Option.of(5).map(x => null)\n     *     => Option.of(null)\n     *\n     * Also see [[Some.mapNullable]], [[Some.flatMap]]\n     */\n    Some.prototype.map = function (fn) {\n        return exports.Option.of(fn(this.value));\n    };\n    /**\n     * Return a new option where the element (if present) was transformed\n     * by the mapper function you give. If the mapped value is `null` or\n     * `undefined`, then a Some will turn into a None.\n     * If the option was None it'll stay None.\n     *\n     *     Option.of(5).mapNullable(x => x*2)\n     *     => Option.of(10)\n     *\n     *     Option.of(5).mapNullable(x => null)\n     *     => Option.none()\n     *\n     * Also see [[Some.map]], [[Some.flatMap]]\n     */\n    Some.prototype.mapNullable = function (fn) {\n        return exports.Option.ofNullable(fn(this.value));\n    };\n    /**\n     * If this is a Some, calls the function you give on\n     * the item in the option and return its result.\n     * If the option is a None, return none.\n     * This is the monadic bind.\n     */\n    Some.prototype.flatMap = function (mapper) {\n        return mapper(this.value);\n    };\n    Some.prototype.filter = function (fn) {\n        return fn(this.value) ? this : exports.Option.none();\n    };\n    /**\n     * Execute a side-effecting function if the option\n     * is a Some; returns the option.\n     */\n    Some.prototype.ifSome = function (fn) {\n        fn(this.value);\n        return this;\n    };\n    /**\n     * Execute a side-effecting function if the option\n     * is a None; returns the option.\n     */\n    Some.prototype.ifNone = function (fn) {\n        return this;\n    };\n    /**\n     * Handle both branches of the option and return a value\n     * (can also be used for side-effects).\n     * This is the catamorphism for option.\n     *\n     *     Option.of(5).match({\n     *         Some: x  => \"got \" + x,\n     *         None: () => \"got nothing!\"\n     *     });\n     *     => \"got 5\"\n     */\n    Some.prototype.match = function (cases) {\n        return cases.Some(this.value);\n    };\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    Some.prototype.transform = function (converter) {\n        return converter(this);\n    };\n    /**\n     * Convert to a vector. If it's a None, it's the empty\n     * vector, if it's a Some, it's a one-element vector with\n     * the contents of the option.\n     */\n    Some.prototype.toVector = function () {\n        return Vector_1.Vector.of(this.value);\n    };\n    /**\n     * Convert to an either. You must provide a left value\n     * in case this is a None.\n     */\n    Some.prototype.toEither = function (left) {\n        return Either_1.Either.right(this.value);\n    };\n    /**\n     * If this is a Some, return this object.\n     * If this is a None, return the result of the function.\n     */\n    Some.prototype.orCall = function (_) {\n        return this;\n    };\n    Some.prototype.hasTrueEquality = function () {\n        return optionHasTrueEquality(this);\n    };\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    Some.prototype.equals = function (other) {\n        if (other === this) {\n            return true;\n        }\n        // the .isSome doesn't test if it's a Some, but\n        // if the object has a field called isSome.\n        if (other === exports.none || !other || !other.isSome) {\n            return false;\n        }\n        var someOther = other;\n        Contract_1.contractTrueEquality(\"Option.equals\", this, someOther);\n        return Comparison_1.areEqual(this.value, someOther.value);\n    };\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    Some.prototype.hashCode = function () {\n        return Comparison_1.getHashCode(this.value);\n    };\n    /**\n     * Get a human-friendly string representation of that value.\n     */\n    Some.prototype.toString = function () {\n        return \"Some(\" + SeqHelpers_1.toStringHelper(this.value) + \")\";\n    };\n    /**\n     * Used by the node REPL to display values.\n     */\n    Some.prototype[Value_1.inspect] = function () {\n        return this.toString();\n    };\n    return Some;\n}());\nexports.Some = Some;\n/**\n * None represents an [[Option]] without value.\n * \"static methods\" available through [[OptionStatic]]\n *\n * [[Some]] and [[None]] have the same methods, except that\n * Some has the extra [[Some.get]] method that [[None]] doesn't have.\n * @param T the item type\n */\nvar None = /** @class */ (function () {\n    function None() {\n        /**\n         * @hidden\n         */\n        this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n    }\n    /**\n     * Returns false since this is a None (doesn'tcontains a value)\n     */\n    None.prototype.isSome = function () {\n        return false;\n    };\n    /**\n     * Returns true since this is a None (doesn'tcontains a value)\n     */\n    None.prototype.isNone = function () {\n        return true;\n    };\n    /**\n     * View this Some a as Option. Useful to help typescript type\n     * inference sometimes.\n     */\n    None.prototype.asOption = function () {\n        return this;\n    };\n    /**\n     * Combines two options. If this option is a Some, returns it.\n     * If it's a None, returns the other one.\n     */\n    None.prototype.orElse = function (other) {\n        return other;\n    };\n    /**\n     * Get the value from this option if it's a Some, otherwise\n     * throw an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message, or an Error object.\n     */\n    None.prototype.getOrThrow = function (errorInfo) {\n        if (typeof errorInfo === 'string') {\n            throw new Error(errorInfo || \"getOrThrow called on none!\");\n        }\n        throw errorInfo || new Error(\"getOrThrow called on none!\");\n    };\n    /**\n     * Returns true if the option is a Some and contains the\n     * value you give, false otherwise.\n     */\n    None.prototype.contains = function (v) {\n        return false;\n    };\n    /**\n     * Get the value contained in the option if it's a Some,\n     * return undefined if it's a None.\n     *\n     *     Option.of(5).getOrUndefined()\n     *     => 5\n     *\n     *     Option.none<number>().getOrUndefined()\n     *     => undefined\n     */\n    None.prototype.getOrUndefined = function () {\n        return undefined;\n    };\n    /**\n     * Get the value contained in the option if it's a Some,\n     * return null if it's a None.\n     *\n     *     Option.of(5).getOrNull()\n     *     => 5\n     *\n     *     Option.none<number>().getOrNull()\n     *     => null\n     */\n    None.prototype.getOrNull = function () {\n        return null;\n    };\n    /**\n     * Get the value from this option; if it's a None (no value\n     * present), then return the default value that you give.\n     */\n    None.prototype.getOrElse = function (alt) {\n        return alt;\n    };\n    /**\n     * Get the value from this option; if it's a None (no value\n     * present), then return the value returned by the function that you give.\n     *\n     *     Option.of(5).getOrCall(() => 6)\n     *     => 5\n     *\n     *     Option.none<number>().getOrCall(() => 6)\n     *     => 6\n     */\n    None.prototype.getOrCall = function (fn) {\n        return fn();\n    };\n    /**\n     * Return a new option where the element (if present) was transformed\n     * by the mapper function you give. If the option was None it'll stay None.\n     *\n     *     Option.of(5).map(x => x*2)\n     *     => Option.of(10)\n     *\n     *     Option.of(5).map(x => null)\n     *     => Option.of(null)\n     *\n     * Also see [[None.mapNullable]], [[None.flatMap]]\n     */\n    None.prototype.map = function (fn) {\n        return exports.none;\n    };\n    /**\n     * Return a new option where the element (if present) was transformed\n     * by the mapper function you give. If the mapped value is `null` or\n     * `undefined`, then a Some will turn into a None.\n     * If the option was None it'll stay None.\n     *\n     *     Option.of(5).mapNullable(x => x*2)\n     *     => Option.of(10)\n     *\n     *     Option.of(5).mapNullable(x => null)\n     *     => Option.none()\n     *\n     * Also see [[None.map]], [[None.flatMap]]\n     */\n    None.prototype.mapNullable = function (fn) {\n        return exports.none;\n    };\n    /**\n     * If this is a Some, calls the function you give on\n     * the item in the option and return its result.\n     * If the option is a None, return none.\n     * This is the monadic bind.\n     */\n    None.prototype.flatMap = function (mapper) {\n        return exports.none;\n    };\n    None.prototype.filter = function (fn) {\n        return exports.none;\n    };\n    /**\n     * Execute a side-effecting function if the option\n     * is a Some; returns the option.\n     */\n    None.prototype.ifSome = function (fn) {\n        return this;\n    };\n    /**\n     * Execute a side-effecting function if the option\n     * is a Some; returns the option.\n     */\n    None.prototype.ifNone = function (fn) {\n        fn();\n        return this;\n    };\n    /**\n     * Handle both branches of the option and return a value\n     * (can also be used for side-effects).\n     * This is the catamorphism for option.\n     *\n     *     Option.of(5).match({\n     *         Some: x  => \"got \" + x,\n     *         None: () => \"got nothing!\"\n     *     });\n     *     => \"got 5\"\n     */\n    None.prototype.match = function (cases) {\n        return cases.None();\n    };\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    None.prototype.transform = function (converter) {\n        return converter(this);\n    };\n    /**\n     * Convert to a vector. If it's a None, it's the empty\n     * vector, if it's a Some, it's a one-element vector with\n     * the contents of the option.\n     */\n    None.prototype.toVector = function () {\n        return Vector_1.Vector.empty();\n    };\n    /**\n     * Convert to an either. You must provide a left value\n     * in case this is a None.\n     */\n    None.prototype.toEither = function (left) {\n        return Either_1.Either.left(left);\n    };\n    /**\n     * If this is a Some, return this object.\n     * If this is a None, return the result of the function.\n     */\n    None.prototype.orCall = function (fn) {\n        return fn();\n    };\n    None.prototype.hasTrueEquality = function () {\n        return optionHasTrueEquality(this);\n    };\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    None.prototype.equals = function (other) {\n        return other === exports.none;\n    };\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    None.prototype.hashCode = function () {\n        return 1;\n    };\n    /**\n     * Get a human-friendly string representation of that value.\n     */\n    None.prototype.toString = function () {\n        return \"None()\";\n    };\n    /**\n     * Used by the node REPL to display values.\n     */\n    None.prototype[Value_1.inspect] = function () {\n        return this.toString();\n    };\n    return None;\n}());\nexports.None = None;\n/**\n * @hidden\n */\nexports.none = new None();\n//# sourceMappingURL=Option.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}