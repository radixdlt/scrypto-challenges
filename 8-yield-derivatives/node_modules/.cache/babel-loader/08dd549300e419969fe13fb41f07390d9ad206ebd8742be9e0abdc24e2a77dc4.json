{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar Vector_1 = require(\"./Vector\");\nvar Option_1 = require(\"./Option\");\nvar Either_1 = require(\"./Either\");\nvar HashMap_1 = require(\"./HashMap\");\n/**\n * A Future is the equivalent, and ultimately wraps, a javascript Promise.\n * While Futures support the [[Future.then]] call (so that among others\n * you can use `await` on them), you should call [[Future.map]] and\n * [[Future.flatMap]].\n *\n * Futures represent an asynchronous computation. A Future will only ever\n * be computed once at most. Once it's computed, calling [[Future.map]] or\n * `await` will return instantly.\n */\nvar Future = /** @class */function () {\n  // careful cause i can't have my type be F<F<T>>\n  // while the code does F<T> as JS's then does!!!\n  // for that reason I wrap the value in an array\n  // to make sure JS will never turn a Promise<Promise<T>>\n  // in a Promise<T>\n  function Future(promise) {\n    this.promise = promise;\n  }\n  /**\n   * Build a Future in the same way as the 'new Promise'\n   * constructor.\n   * You get one callback to signal success (resolve),\n   * failure (reject), or you can throw to signal failure.\n   *\n   *     Future.ofPromiseCtor<string>((resolve,reject) => setTimeout(resolve, 10, \"hello!\"))\n   */\n  Future.ofPromiseCtor = function (executor) {\n    return new Future(new Promise(executor).then(function (v) {\n      return [v];\n    }));\n  };\n  /**\n   * Build a Future from an existing javascript Promise.\n   */\n  Future.of = function (promise) {\n    return new Future(promise.then(function (x) {\n      return [x];\n    }));\n  };\n  /**\n   * Build a Future from a node-style callback API, for instance:\n   *\n   *     Future.ofCallback<string>(cb => fs.readFile('/etc/passwd', 'utf-8', cb))\n   */\n  Future.ofCallback = function (fn) {\n    return Future.ofPromiseCtor(function (resolve, reject) {\n      return fn(function (err, data) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    });\n  };\n  /**\n   * Build a successful Future with the value you provide.\n   */\n  Future.ok = function (val) {\n    return new Future(Promise.resolve([val]));\n  };\n  /**\n   * Build a failed Future with the error data you provide.\n   */\n  Future.failed = function (reason) {\n    return new Future(Promise.reject(reason));\n  };\n  /**\n   * Creates a Future from a function returning a Promise,\n   * which can be inline in the call, for instance:\n   *\n   *     const f1 = Future.ok(1);\n   *     const f2 = Future.ok(2);\n   *     return Future.do(async () => {\n   *         const v1 = await f1;\n   *         const v2 = await f2;\n   *         return v1 + v2;\n   *     });\n   */\n  Future[\"do\"] = function (fn) {\n    return Future.of(fn());\n  };\n  /**\n   * The `then` call is not meant to be a part of the `Future` API,\n   * we need then so that `await` works directly.\n   *\n   * Please rather use [[Future.map]] or [[Future.flatMap]].\n   */\n  Future.prototype.then = function (onfulfilled, onrejected) {\n    return this.promise.then(function (_a) {\n      var x = _a[0];\n      return onfulfilled(x);\n    }, function (rejected) {\n      return onrejected ? onrejected(rejected) : Promise.reject(rejected);\n    });\n  };\n  /**\n   * Get a `Promise` from this `Future`.\n   */\n  Future.prototype.toPromise = function () {\n    return this.promise.then(function (_a) {\n      var x = _a[0];\n      return x;\n    });\n  };\n  /**\n   * Returns a `Future` that'll complete when the first `Future` of\n   * the iterable you give will complete, with the value of that first\n   * future. Be careful, completing doesn't necessarily mean completing\n   * successfully!\n   *\n   * Also see [[Future.firstSuccessfulOf]]\n   */\n  Future.firstCompletedOf = function (elts) {\n    return Future.of(Promise.race(Vector_1.Vector.ofIterable(elts).map(function (f) {\n      return f.toPromise();\n    })));\n  };\n  /**\n   * Returns a `Future` that'll complete when the first `Future` of\n   * the iterable you give will complete successfully, with the value of that first\n   * future.\n   *\n   * Also see [[Future.firstCompletedOf]]\n   */\n  Future.firstSuccessfulOf = function (elts) {\n    // https://stackoverflow.com/a/37235274/516188\n    return Future.of(Promise.all(Vector_1.Vector.ofIterable(elts).map(function (p) {\n      // If a request fails, count that as a resolution so it will keep\n      // waiting for other possible successes. If a request succeeds,\n      // treat it as a rejection so Promise.all immediately bails out.\n      return p.then(function (val) {\n        return Promise.reject(val);\n      }, function (err) {\n        return Promise.resolve(err);\n      });\n    })).then(\n    // If '.all' resolved, we've just got an array of errors.\n    function (errors) {\n      return Promise.reject(errors);\n    },\n    // If '.all' rejected, we've got the result we wanted.\n    function (val) {\n      return Promise.resolve(val);\n    }));\n  };\n  /**\n   * Turns a list of futures in a future containing a list of items.\n   * Useful in many contexts.\n   *\n   * But if a single future is failed, you get back a failed Future.\n   *\n   * Also see [[Future.traverse]]\n   */\n  Future.sequence = function (elts) {\n    return Future.traverse(elts, function (x) {\n      return x;\n    });\n  };\n  /**\n   * Takes a list, a function that can transform list elements\n   * to futures, then return a Future containing a list of\n   * the transformed elements.\n   *\n   * But if a single element results in failure, the result also\n   * resolves to a failure.\n   *\n   * There is an optional third parameter to specify options.\n   * You can specify `{maxConcurrent: number}` to request that\n   * the futures are not all triggered at the same time, but\n   * rather only 'number' at a time.\n   *\n   * Also see [[Future.sequence]]\n   */\n  Future.traverse = function (elts, fn, opts) {\n    if (!opts) {\n      return Future.of(Promise.all(Vector_1.Vector.ofIterable(elts).map(function (x) {\n        return fn(x).toPromise();\n      })).then(Vector_1.Vector.ofIterable));\n    }\n    // maxConcurrent algorithm inspired by https://stackoverflow.com/a/38778887/516188\n    var index = 0;\n    var active = [];\n    var results = {};\n    var it = elts[Symbol.iterator]();\n    var failed;\n    var addAsNeeded = function (_) {\n      if (failed) {\n        return failed;\n      }\n      var cur;\n      var _loop_1 = function () {\n        var p = fn(cur.value);\n        active.push(p);\n        var curIdx = index++;\n        p.onComplete(function (eitherRes) {\n          active.splice(active.indexOf(p), 1);\n          if (eitherRes.isLeft()) {\n            failed = p;\n          } else {\n            results[curIdx] = eitherRes.get();\n          }\n        });\n      };\n      while (active.length < opts.maxConcurrent && !(cur = it.next()).done) {\n        _loop_1();\n      }\n      if (!failed && active.length === 0 && cur && cur.done) {\n        return Future.ok(HashMap_1.HashMap.ofObjectDictionary(results).toVector().sortOn(function (kv) {\n          return parseInt(kv[0]);\n        }).map(function (kv) {\n          return kv[1];\n        }));\n      }\n      return Future.firstCompletedOf(active).flatMap(addAsNeeded);\n    };\n    return addAsNeeded();\n  };\n  /**\n   * From the list of Futures you give, will attempt to find a successful\n   * Future which value matches the predicate you give.\n   * We return a Future of an [[Option]], which will [[None]] in case\n   * no matching Future is found.\n   */\n  Future.find = function (elts, p) {\n    var origElts = Vector_1.Vector.ofIterable(elts);\n    if (origElts.isEmpty()) {\n      return Future.ok(Option_1.Option.none());\n    }\n    // map the failures to successes with option.none\n    // backup the original future object matching the new future\n    var velts = origElts.map(function (f) {\n      return f.map(function (item) {\n        return [f, Option_1.Option.of(item)];\n      }).recoverWith(function (_) {\n        return Future.ok([f, Option_1.Option.none()]);\n      });\n    });\n    // go for the first completed of the iterable\n    // remember after our map they're all successful now\n    var success = Future.firstCompletedOf(velts);\n    return success.flatMap(function (_a) {\n      var originalFuture = _a[0],\n        option = _a[1];\n      if (option.isSome() && p(option.get())) {\n        // this successful future matches our predicate, that's it.\n        return success.map(function (x) {\n          return x[1];\n        });\n      } else {\n        // this future failed or doesn't match our predicate.\n        // remove the future from the input list (we can do that\n        // because we \"backed up\" the original future in the future\n        // result), and try again only with the remaining candidates\n        return Future.find(origElts.removeFirst(function (future) {\n          return future === originalFuture;\n        }), p);\n      }\n    });\n  };\n  /**\n   * Applicative lifting for Future. 'p' stands for 'properties'.\n   *\n   * Takes a function which operates on a simple JS object, and turns it\n   * in a function that operates on the same JS object type except which each field\n   * wrapped in a Future ('lifts' the function).\n   * It's an alternative to [[Future.liftA2]] when the number of parameters\n   * is not two.\n   *\n   * @param A the object property type specifying the parameters for your function\n   * @param B the type returned by your function, returned wrapped in a future by liftAp.\n   */\n  Future.liftAp = function (fn) {\n    return function (x) {\n      var fieldNames = Object.keys(x);\n      var promisesAr = fieldNames.map(function (n) {\n        return x[n];\n      });\n      var i = 0;\n      return Future.of(Promise.all(promisesAr).then(function (resultAr) {\n        return resultAr.reduce(function (sofar, cur) {\n          sofar[fieldNames[i++]] = cur;\n          return sofar;\n        }, {});\n      })).map(fn);\n    };\n  };\n  /**\n   * Applicative lifting for Future.\n   * Takes a function which operates on basic values, and turns it\n   * in a function that operates on futures of these values ('lifts'\n   * the function). The 2 is because it works on functions taking two\n   * parameters.\n   *\n   * @param R1 the first future type\n   * @param R2 the second future type\n   * @param V the new future type as returned by the combining function.\n   */\n  Future.liftA2 = function (fn) {\n    return function (p1, p2) {\n      return p1.flatMap(function (a1) {\n        return p2.map(function (a2) {\n          return fn(a1, a2);\n        });\n      });\n    };\n  };\n  /**\n   * Take a function returning a Promise\n   * and lift it to return a [[Future]] instead.\n   */\n  Future.lift = function (fn) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return Future.of(fn.apply(void 0, args));\n    };\n  };\n  /**\n   * Transform the value contained in a successful Future. Has no effect\n   * if the Future was failed. Will turn a successful Future in a failed\n   * one if you throw an exception in the map callback (but please don't\n   * do it.. Rather use [[Future.filter]] or another mechanism).\n   */\n  Future.prototype.map = function (fn) {\n    return new Future(this.promise.then(function (_a) {\n      var x = _a[0];\n      return [fn(x)];\n    }));\n  };\n  /**\n   * Transform the value contained in a successful Future. You return a\n   * Future, but it is then \"flattened\" so we still return a Future<T>\n   * (and not a Future<Future<T>>).\n   * Has no effect if the Future was failed. Will turn a successful Future in a failed\n   * one if you throw an exception in the map callback (but please don't\n   * do it.. Rather use [[Future.filter]] or another mechanism).\n   * This is the monadic bind.\n   */\n  Future.prototype.flatMap = function (fn) {\n    return new Future(this.promise.then(function (_a) {\n      var x = _a[0];\n      return fn(x).promise;\n    }));\n  };\n  /**\n   * Transform the value contained in a failed Future. Has no effect\n   * if the Future was successful.\n   */\n  Future.prototype.mapFailure = function (fn) {\n    return new Future(this.promise[\"catch\"](function (x) {\n      throw fn(x);\n    }));\n  };\n  /**\n   * Execute the side-effecting function you give if the Future is a failure.\n   *\n   * The Future is unchanged by this call.\n   */\n  Future.prototype.onFailure = function (fn) {\n    this.promise[\"catch\"](function (x) {\n      return fn(x);\n    });\n    return this;\n  };\n  /**\n   * Execute the side-effecting function you give if the Future is a success.\n   *\n   * The Future is unchanged by this call.\n   */\n  Future.prototype.onSuccess = function (fn) {\n    // we create a new promise here, need to catch errors on it,\n    // to avoid node UnhandledPromiseRejectionWarning warnings\n    this.promise.then(function (x) {\n      fn(x[0]);\n      return x;\n    })[\"catch\"](function (_) {});\n    return this;\n  };\n  /**\n   * Execute the side-effecting function you give when the Future is\n   * completed. You get an [[Either]], a `Right` if the Future is a\n   * success, a `Left` if it's a failure.\n   *\n   * The Future is unchanged by this call.\n   */\n  Future.prototype.onComplete = function (fn) {\n    this.promise.then(function (x) {\n      fn(Either_1.Either.right(x[0]));\n      return x;\n    }, function (x) {\n      return fn(Either_1.Either.left(x));\n    });\n    return this;\n  };\n  /**\n   * Has no effect on a failed Future. If the Future was successful,\n   * will check whether its value matches the predicate you give as\n   * first parameter. If the value matches the predicate, an equivalent\n   * Future to the input one is returned.\n   *\n   * If the value doesn't match predicate however, the second parameter\n   * function is used to compute the contents of a failed Future that'll\n   * be returned.\n   */\n  Future.prototype.filter = function (p, ifFail) {\n    return this.flatMap(function (x) {\n      return p(x) ? Future.ok(x) : Future.failed(ifFail(x));\n    });\n  };\n  /**\n   * Has no effect if this Future is successful. If it's failed however,\n   * the function you give will be called, receiving as parameter\n   * the error contents, and a Future equivalent to the one your\n   * function returns will be returned.\n   */\n  Future.prototype.recoverWith = function (f) {\n    return new Future(this.promise[\"catch\"](function (err) {\n      return f(err).promise;\n    }));\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  Future.prototype.transform = function (fn) {\n    return fn(this);\n  };\n  return Future;\n}();\nexports.Future = Future;","map":{"version":3,"names":["exports","__esModule","Vector_1","require","Option_1","Either_1","HashMap_1","Future","promise","ofPromiseCtor","executor","Promise","then","v","of","x","ofCallback","fn","resolve","reject","err","data","ok","val","failed","reason","prototype","onfulfilled","onrejected","_a","rejected","toPromise","firstCompletedOf","elts","race","Vector","ofIterable","map","f","firstSuccessfulOf","all","p","errors","sequence","traverse","opts","index","active","results","it","Symbol","iterator","addAsNeeded","_","cur","_loop_1","value","push","curIdx","onComplete","eitherRes","splice","indexOf","isLeft","get","length","maxConcurrent","next","done","HashMap","ofObjectDictionary","toVector","sortOn","kv","parseInt","flatMap","find","origElts","isEmpty","Option","none","velts","item","recoverWith","success","originalFuture","option","isSome","removeFirst","future","liftAp","fieldNames","Object","keys","promisesAr","n","i","resultAr","reduce","sofar","liftA2","p1","p2","a1","a2","lift","args","_i","arguments","apply","mapFailure","onFailure","onSuccess","Either","right","left","filter","ifFail","transform"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/dist/src/Future.js"],"sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar Vector_1 = require(\"./Vector\");\nvar Option_1 = require(\"./Option\");\nvar Either_1 = require(\"./Either\");\nvar HashMap_1 = require(\"./HashMap\");\n/**\n * A Future is the equivalent, and ultimately wraps, a javascript Promise.\n * While Futures support the [[Future.then]] call (so that among others\n * you can use `await` on them), you should call [[Future.map]] and\n * [[Future.flatMap]].\n *\n * Futures represent an asynchronous computation. A Future will only ever\n * be computed once at most. Once it's computed, calling [[Future.map]] or\n * `await` will return instantly.\n */\nvar Future = /** @class */ (function () {\n    // careful cause i can't have my type be F<F<T>>\n    // while the code does F<T> as JS's then does!!!\n    // for that reason I wrap the value in an array\n    // to make sure JS will never turn a Promise<Promise<T>>\n    // in a Promise<T>\n    function Future(promise) {\n        this.promise = promise;\n    }\n    /**\n     * Build a Future in the same way as the 'new Promise'\n     * constructor.\n     * You get one callback to signal success (resolve),\n     * failure (reject), or you can throw to signal failure.\n     *\n     *     Future.ofPromiseCtor<string>((resolve,reject) => setTimeout(resolve, 10, \"hello!\"))\n     */\n    Future.ofPromiseCtor = function (executor) {\n        return new Future(new Promise(executor).then(function (v) { return [v]; }));\n    };\n    /**\n     * Build a Future from an existing javascript Promise.\n     */\n    Future.of = function (promise) {\n        return new Future(promise.then(function (x) { return [x]; }));\n    };\n    /**\n     * Build a Future from a node-style callback API, for instance:\n     *\n     *     Future.ofCallback<string>(cb => fs.readFile('/etc/passwd', 'utf-8', cb))\n     */\n    Future.ofCallback = function (fn) {\n        return Future.ofPromiseCtor(function (resolve, reject) { return fn(function (err, data) {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(data);\n            }\n        }); });\n    };\n    /**\n     * Build a successful Future with the value you provide.\n     */\n    Future.ok = function (val) {\n        return new Future(Promise.resolve([val]));\n    };\n    /**\n     * Build a failed Future with the error data you provide.\n     */\n    Future.failed = function (reason) {\n        return new Future(Promise.reject(reason));\n    };\n    /**\n     * Creates a Future from a function returning a Promise,\n     * which can be inline in the call, for instance:\n     *\n     *     const f1 = Future.ok(1);\n     *     const f2 = Future.ok(2);\n     *     return Future.do(async () => {\n     *         const v1 = await f1;\n     *         const v2 = await f2;\n     *         return v1 + v2;\n     *     });\n     */\n    Future[\"do\"] = function (fn) {\n        return Future.of(fn());\n    };\n    /**\n     * The `then` call is not meant to be a part of the `Future` API,\n     * we need then so that `await` works directly.\n     *\n     * Please rather use [[Future.map]] or [[Future.flatMap]].\n     */\n    Future.prototype.then = function (onfulfilled, onrejected) {\n        return this.promise.then(function (_a) {\n            var x = _a[0];\n            return onfulfilled(x);\n        }, function (rejected) { return onrejected ? onrejected(rejected) : Promise.reject(rejected); });\n    };\n    /**\n     * Get a `Promise` from this `Future`.\n     */\n    Future.prototype.toPromise = function () {\n        return this.promise.then(function (_a) {\n            var x = _a[0];\n            return x;\n        });\n    };\n    /**\n     * Returns a `Future` that'll complete when the first `Future` of\n     * the iterable you give will complete, with the value of that first\n     * future. Be careful, completing doesn't necessarily mean completing\n     * successfully!\n     *\n     * Also see [[Future.firstSuccessfulOf]]\n     */\n    Future.firstCompletedOf = function (elts) {\n        return Future.of(Promise.race(Vector_1.Vector.ofIterable(elts).map(function (f) { return f.toPromise(); })));\n    };\n    /**\n     * Returns a `Future` that'll complete when the first `Future` of\n     * the iterable you give will complete successfully, with the value of that first\n     * future.\n     *\n     * Also see [[Future.firstCompletedOf]]\n     */\n    Future.firstSuccessfulOf = function (elts) {\n        // https://stackoverflow.com/a/37235274/516188\n        return Future.of(Promise.all(Vector_1.Vector.ofIterable(elts).map(function (p) {\n            // If a request fails, count that as a resolution so it will keep\n            // waiting for other possible successes. If a request succeeds,\n            // treat it as a rejection so Promise.all immediately bails out.\n            return p.then(function (val) { return Promise.reject(val); }, function (err) { return Promise.resolve(err); });\n        })).then(\n        // If '.all' resolved, we've just got an array of errors.\n        function (errors) { return Promise.reject(errors); }, \n        // If '.all' rejected, we've got the result we wanted.\n        function (val) { return Promise.resolve(val); }));\n    };\n    /**\n     * Turns a list of futures in a future containing a list of items.\n     * Useful in many contexts.\n     *\n     * But if a single future is failed, you get back a failed Future.\n     *\n     * Also see [[Future.traverse]]\n     */\n    Future.sequence = function (elts) {\n        return Future.traverse(elts, function (x) { return x; });\n    };\n    /**\n     * Takes a list, a function that can transform list elements\n     * to futures, then return a Future containing a list of\n     * the transformed elements.\n     *\n     * But if a single element results in failure, the result also\n     * resolves to a failure.\n     *\n     * There is an optional third parameter to specify options.\n     * You can specify `{maxConcurrent: number}` to request that\n     * the futures are not all triggered at the same time, but\n     * rather only 'number' at a time.\n     *\n     * Also see [[Future.sequence]]\n     */\n    Future.traverse = function (elts, fn, opts) {\n        if (!opts) {\n            return Future.of(Promise.all(Vector_1.Vector.ofIterable(elts).map(function (x) { return fn(x).toPromise(); }))\n                .then(Vector_1.Vector.ofIterable));\n        }\n        // maxConcurrent algorithm inspired by https://stackoverflow.com/a/38778887/516188\n        var index = 0;\n        var active = [];\n        var results = {};\n        var it = elts[Symbol.iterator]();\n        var failed;\n        var addAsNeeded = function (_) {\n            if (failed) {\n                return failed;\n            }\n            var cur;\n            var _loop_1 = function () {\n                var p = fn(cur.value);\n                active.push(p);\n                var curIdx = index++;\n                p.onComplete(function (eitherRes) {\n                    active.splice(active.indexOf(p), 1);\n                    if (eitherRes.isLeft()) {\n                        failed = p;\n                    }\n                    else {\n                        results[curIdx] = eitherRes.get();\n                    }\n                });\n            };\n            while (active.length < opts.maxConcurrent &&\n                !(cur = it.next()).done) {\n                _loop_1();\n            }\n            if (!failed && active.length === 0 && cur && cur.done) {\n                return Future.ok(HashMap_1.HashMap.ofObjectDictionary(results)\n                    .toVector()\n                    .sortOn(function (kv) { return parseInt(kv[0]); })\n                    .map(function (kv) { return kv[1]; }));\n            }\n            return Future.firstCompletedOf(active).flatMap(addAsNeeded);\n        };\n        return addAsNeeded();\n    };\n    /**\n     * From the list of Futures you give, will attempt to find a successful\n     * Future which value matches the predicate you give.\n     * We return a Future of an [[Option]], which will [[None]] in case\n     * no matching Future is found.\n     */\n    Future.find = function (elts, p) {\n        var origElts = Vector_1.Vector.ofIterable(elts);\n        if (origElts.isEmpty()) {\n            return Future.ok(Option_1.Option.none());\n        }\n        // map the failures to successes with option.none\n        // backup the original future object matching the new future\n        var velts = origElts\n            .map(function (f) { return f\n            .map(function (item) { return [f, Option_1.Option.of(item)]; })\n            .recoverWith(function (_) { return Future.ok([f, Option_1.Option.none()]); }); });\n        // go for the first completed of the iterable\n        // remember after our map they're all successful now\n        var success = Future.firstCompletedOf(velts);\n        return success\n            .flatMap(function (_a) {\n            var originalFuture = _a[0], option = _a[1];\n            if (option.isSome() && p(option.get())) {\n                // this successful future matches our predicate, that's it.\n                return success.map(function (x) { return x[1]; });\n            }\n            else {\n                // this future failed or doesn't match our predicate.\n                // remove the future from the input list (we can do that\n                // because we \"backed up\" the original future in the future\n                // result), and try again only with the remaining candidates\n                return Future.find(origElts.removeFirst(function (future) { return future === originalFuture; }), p);\n            }\n        });\n    };\n    /**\n     * Applicative lifting for Future. 'p' stands for 'properties'.\n     *\n     * Takes a function which operates on a simple JS object, and turns it\n     * in a function that operates on the same JS object type except which each field\n     * wrapped in a Future ('lifts' the function).\n     * It's an alternative to [[Future.liftA2]] when the number of parameters\n     * is not two.\n     *\n     * @param A the object property type specifying the parameters for your function\n     * @param B the type returned by your function, returned wrapped in a future by liftAp.\n     */\n    Future.liftAp = function (fn) {\n        return function (x) {\n            var fieldNames = Object.keys(x);\n            var promisesAr = fieldNames.map(function (n) { return x[n]; });\n            var i = 0;\n            return Future.of(Promise.all(promisesAr)\n                .then(function (resultAr) { return resultAr.reduce(function (sofar, cur) {\n                sofar[fieldNames[i++]] = cur;\n                return sofar;\n            }, {}); })).map(fn);\n        };\n    };\n    /**\n     * Applicative lifting for Future.\n     * Takes a function which operates on basic values, and turns it\n     * in a function that operates on futures of these values ('lifts'\n     * the function). The 2 is because it works on functions taking two\n     * parameters.\n     *\n     * @param R1 the first future type\n     * @param R2 the second future type\n     * @param V the new future type as returned by the combining function.\n     */\n    Future.liftA2 = function (fn) {\n        return function (p1, p2) { return p1.flatMap(function (a1) { return p2.map(function (a2) { return fn(a1, a2); }); }); };\n    };\n    /**\n     * Take a function returning a Promise\n     * and lift it to return a [[Future]] instead.\n     */\n    Future.lift = function (fn) {\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return Future.of(fn.apply(void 0, args));\n        };\n    };\n    /**\n     * Transform the value contained in a successful Future. Has no effect\n     * if the Future was failed. Will turn a successful Future in a failed\n     * one if you throw an exception in the map callback (but please don't\n     * do it.. Rather use [[Future.filter]] or another mechanism).\n     */\n    Future.prototype.map = function (fn) {\n        return new Future(this.promise.then(function (_a) {\n            var x = _a[0];\n            return [fn(x)];\n        }));\n    };\n    /**\n     * Transform the value contained in a successful Future. You return a\n     * Future, but it is then \"flattened\" so we still return a Future<T>\n     * (and not a Future<Future<T>>).\n     * Has no effect if the Future was failed. Will turn a successful Future in a failed\n     * one if you throw an exception in the map callback (but please don't\n     * do it.. Rather use [[Future.filter]] or another mechanism).\n     * This is the monadic bind.\n     */\n    Future.prototype.flatMap = function (fn) {\n        return new Future(this.promise.then(function (_a) {\n            var x = _a[0];\n            return fn(x).promise;\n        }));\n    };\n    /**\n     * Transform the value contained in a failed Future. Has no effect\n     * if the Future was successful.\n     */\n    Future.prototype.mapFailure = function (fn) {\n        return new Future(this.promise[\"catch\"](function (x) { throw fn(x); }));\n    };\n    /**\n     * Execute the side-effecting function you give if the Future is a failure.\n     *\n     * The Future is unchanged by this call.\n     */\n    Future.prototype.onFailure = function (fn) {\n        this.promise[\"catch\"](function (x) { return fn(x); });\n        return this;\n    };\n    /**\n     * Execute the side-effecting function you give if the Future is a success.\n     *\n     * The Future is unchanged by this call.\n     */\n    Future.prototype.onSuccess = function (fn) {\n        // we create a new promise here, need to catch errors on it,\n        // to avoid node UnhandledPromiseRejectionWarning warnings\n        this.promise.then(function (x) { fn(x[0]); return x; })[\"catch\"](function (_) { });\n        return this;\n    };\n    /**\n     * Execute the side-effecting function you give when the Future is\n     * completed. You get an [[Either]], a `Right` if the Future is a\n     * success, a `Left` if it's a failure.\n     *\n     * The Future is unchanged by this call.\n     */\n    Future.prototype.onComplete = function (fn) {\n        this.promise.then(function (x) { fn(Either_1.Either.right(x[0])); return x; }, function (x) { return fn(Either_1.Either.left(x)); });\n        return this;\n    };\n    /**\n     * Has no effect on a failed Future. If the Future was successful,\n     * will check whether its value matches the predicate you give as\n     * first parameter. If the value matches the predicate, an equivalent\n     * Future to the input one is returned.\n     *\n     * If the value doesn't match predicate however, the second parameter\n     * function is used to compute the contents of a failed Future that'll\n     * be returned.\n     */\n    Future.prototype.filter = function (p, ifFail) {\n        return this.flatMap(function (x) { return p(x) ? Future.ok(x) : Future.failed(ifFail(x)); });\n    };\n    /**\n     * Has no effect if this Future is successful. If it's failed however,\n     * the function you give will be called, receiving as parameter\n     * the error contents, and a Future equivalent to the one your\n     * function returns will be returned.\n     */\n    Future.prototype.recoverWith = function (f) {\n        return new Future(this.promise[\"catch\"](function (err) { return f(err).promise; }));\n    };\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    Future.prototype.transform = function (fn) {\n        return fn(this);\n    };\n    return Future;\n}());\nexports.Future = Future;\n//# sourceMappingURL=Future.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}