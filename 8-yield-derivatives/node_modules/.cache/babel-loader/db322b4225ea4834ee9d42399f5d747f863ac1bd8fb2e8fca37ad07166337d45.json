{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BIP32 = exports.unsafeCreate = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\nconst bip32PathComponent_1 = require(\"./bip32PathComponent\");\nconst pathSeparator = '/';\nconst hardener = \"'\";\nconst isBIP32 = something => {\n  const inspection = something;\n  return inspection.pathComponents !== undefined && inspection.toString !== undefined;\n};\nconst unsafeCreate = pathComponents => {\n  const toString = () => 'm' + pathSeparator + pathComponents.map(pc => pc.toString()).join(pathSeparator);\n  return {\n    pathComponents,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    equals: other => {\n      if (!isBIP32(other)) return false;\n      return other.toString() === toString();\n    },\n    toString\n  };\n};\nexports.unsafeCreate = unsafeCreate;\nconst validateLevels = pathComponents => (0, neverthrow_1.combine)(pathComponents.map((component, i, components) => component.level !== (i > 0 ? components[i - 1].level + 1 : 1) ? (0, neverthrow_1.err)(new Error(\"Expected components with strictly increasing level with an increment of one.\")) : (0, neverthrow_1.ok)({\n  witness: 'component valid'\n}))).andThen(_a => (0, neverthrow_1.ok)({\n  witness: 'all components valid'\n}));\nconst create = pathComponents => validateLevels(pathComponents).map(() => (0, exports.unsafeCreate)(pathComponents));\nconst fromString = path => {\n  let bip32Path = path.trim();\n  if (bip32Path === '' || bip32Path === 'm' || bip32Path === pathSeparator) {\n    return (0, neverthrow_1.ok)({\n      pathComponents: [],\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      equals: other => {\n        if (!isBIP32(other)) return false;\n        return other.toString() === 'm';\n      },\n      toString: () => 'm'\n    });\n  }\n  if (bip32Path.startsWith('M/') || bip32Path.startsWith('m/')) {\n    bip32Path = bip32Path.slice(2);\n    if (bip32Path.length === 0) {\n      return (0, neverthrow_1.err)(new Error(\"Must start with just 'm/' or 'M/'\"));\n    }\n  }\n  if (bip32Path.length === 0) {\n    return (0, neverthrow_1.err)(new Error('Must not be empty'));\n  }\n  if (bip32Path.includes('//')) {\n    return (0, neverthrow_1.err)(new Error(\"Must not contain '//'\"));\n  }\n  const components = bip32Path.split(pathSeparator);\n  const pathComponents = [];\n  for (const {\n    index,\n    value\n  } of components.map((value, index) => ({\n    index,\n    value\n  }))) {\n    const pathComponentResult = bip32PathComponent_1.BIP32PathComponent.fromString(value, index + 1);\n    if (pathComponentResult.isErr()) return (0, neverthrow_1.err)(pathComponentResult.error);\n    pathComponents.push(pathComponentResult.value);\n  }\n  return create(pathComponents);\n};\nconst unsafeFromSimpleComponents = pathComponents => (0, neverthrow_1.combine)(pathComponents.map((e, i) => bip32PathComponent_1.BIP32PathComponent.create(Object.assign(Object.assign({}, e), {\n  level: i\n})))).map(exports.unsafeCreate);\nexports.BIP32 = {\n  create,\n  unsafeCreate: exports.unsafeCreate,\n  fromString,\n  unsafeFromSimpleComponents,\n  hardener,\n  pathSeparator\n};","map":{"version":3,"names":["neverthrow_1","require","bip32PathComponent_1","pathSeparator","hardener","isBIP32","something","inspection","pathComponents","undefined","toString","unsafeCreate","map","pc","join","equals","other","exports","validateLevels","combine","component","i","components","level","err","Error","ok","witness","andThen","_a","create","fromString","path","bip32Path","trim","startsWith","slice","length","includes","split","index","value","pathComponentResult","BIP32PathComponent","isErr","error","push","unsafeFromSimpleComponents","e","Object","assign","BIP32"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/src/elliptic-curve/hd/bip32/bip32.ts"],"sourcesContent":["import { combine, err, ok, Result } from 'neverthrow'\nimport { BIP32PathComponent } from './bip32PathComponent'\nimport { BIP32T, BIP32PathComponentT, Int32 } from './_types'\nimport { ValidationWitness } from '@radixdlt/util'\n\nconst pathSeparator = '/'\nconst hardener = `'`\n\nconst isBIP32 = (something: unknown): something is BIP32T => {\n\tconst inspection = something as BIP32T\n\treturn (\n\t\tinspection.pathComponents !== undefined &&\n\t\tinspection.toString !== undefined\n\t)\n}\n\nexport const unsafeCreate = (pathComponents: BIP32PathComponentT[]): BIP32T => {\n\tconst toString = (): string =>\n\t\t'm' +\n\t\tpathSeparator +\n\t\tpathComponents.map(pc => pc.toString()).join(pathSeparator)\n\n\treturn {\n\t\tpathComponents,\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tequals: (other: any): boolean => {\n\t\t\tif (!isBIP32(other)) return false\n\t\t\treturn other.toString() === toString()\n\t\t},\n\t\ttoString,\n\t}\n}\n\nconst validateLevels = (\n\tpathComponents: BIP32PathComponentT[],\n): Result<ValidationWitness, Error> =>\n\tcombine(\n\t\tpathComponents.map<Result<ValidationWitness, Error>>(\n\t\t\t(component, i, components) =>\n\t\t\t\tcomponent.level !== (i > 0 ? components[i - 1].level + 1 : 1)\n\t\t\t\t\t? err(\n\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t`Expected components with strictly increasing level with an increment of one.`,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t  )\n\t\t\t\t\t: ok({ witness: 'component valid' }),\n\t\t),\n\t).andThen(_a => ok({ witness: 'all components valid' }))\n\nconst create = (pathComponents: BIP32PathComponentT[]): Result<BIP32T, Error> =>\n\tvalidateLevels(pathComponents).map(() => unsafeCreate(pathComponents))\n\nconst fromString = (path: string): Result<BIP32T, Error> => {\n\tlet bip32Path = path.trim()\n\tif (bip32Path === '' || bip32Path === 'm' || bip32Path === pathSeparator) {\n\t\treturn ok({\n\t\t\tpathComponents: [],\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tequals: (other: any): boolean => {\n\t\t\t\tif (!isBIP32(other)) return false\n\t\t\t\treturn other.toString() === 'm'\n\t\t\t},\n\t\t\ttoString: (): string => 'm',\n\t\t})\n\t}\n\n\tif (bip32Path.startsWith('M/') || bip32Path.startsWith('m/')) {\n\t\tbip32Path = bip32Path.slice(2)\n\t\tif (bip32Path.length === 0) {\n\t\t\treturn err(new Error(`Must start with just 'm/' or 'M/'`))\n\t\t}\n\t}\n\tif (bip32Path.length === 0) {\n\t\treturn err(new Error('Must not be empty'))\n\t}\n\n\tif (bip32Path.includes('//')) {\n\t\treturn err(new Error(`Must not contain '//'`))\n\t}\n\n\tconst components = bip32Path.split(pathSeparator)\n\tconst pathComponents: BIP32PathComponentT[] = []\n\tfor (const { index, value } of components.map((value, index) => ({\n\t\tindex,\n\t\tvalue,\n\t}))) {\n\t\tconst pathComponentResult = BIP32PathComponent.fromString(\n\t\t\tvalue,\n\t\t\tindex + 1,\n\t\t)\n\t\tif (pathComponentResult.isErr()) return err(pathComponentResult.error)\n\t\tpathComponents.push(pathComponentResult.value)\n\t}\n\treturn create(pathComponents)\n}\nconst unsafeFromSimpleComponents = (\n\tpathComponents: Readonly<{\n\t\tindex: Int32\n\t\tisHardened: boolean\n\t}>[],\n): Result<BIP32T, Error> =>\n\tcombine(\n\t\tpathComponents.map((e, i) =>\n\t\t\tBIP32PathComponent.create({\n\t\t\t\t...e,\n\t\t\t\tlevel: i,\n\t\t\t}),\n\t\t),\n\t).map(unsafeCreate)\n\nexport const BIP32 = {\n\tcreate,\n\tunsafeCreate,\n\tfromString,\n\tunsafeFromSimpleComponents,\n\thardener,\n\tpathSeparator,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}