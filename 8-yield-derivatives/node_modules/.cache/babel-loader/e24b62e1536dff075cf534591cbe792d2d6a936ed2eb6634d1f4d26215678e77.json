{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar Option_1 = require(\"./Option\");\nvar Stream_1 = require(\"./Stream\");\nvar Lazy_1 = require(\"./Lazy\");\nvar HashSet_1 = require(\"./HashSet\");\n/**\n * @hidden\n */\nfunction shuffle(array) {\n  // https://stackoverflow.com/a/2450976/516188\n  var currentIndex = array.length,\n    temporaryValue,\n    randomIndex;\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n  return array;\n}\nexports.shuffle = shuffle;\n/**\n * @hidden\n */\nfunction arrangeBy(collection, getKey) {\n  return Option_1.Option.of(collection.groupBy(getKey).mapValues(function (v) {\n    return v.single();\n  })).filter(function (map) {\n    return !map.anyMatch(function (k, v) {\n      return v.isNone();\n    });\n  }).map(function (map) {\n    return map.mapValues(function (v) {\n      return v.getOrThrow();\n    });\n  });\n}\nexports.arrangeBy = arrangeBy;\n/**\n * @hidden\n */\nfunction seqHasTrueEquality(seq) {\n  return seq.find(function (x) {\n    return x != null;\n  }).hasTrueEquality();\n}\nexports.seqHasTrueEquality = seqHasTrueEquality;\n/**\n * @hidden\n */\nfunction zipWithIndex(seq) {\n  return seq.zip(Stream_1.Stream.iterate(0, function (i) {\n    return i + 1;\n  }));\n}\nexports.zipWithIndex = zipWithIndex;\n/**\n * @hidden\n */\nfunction sortOn(seq, getKeys) {\n  return seq.sortBy(function (x, y) {\n    for (var _i = 0, getKeys_1 = getKeys; _i < getKeys_1.length; _i++) {\n      var getKey = getKeys_1[_i];\n      if (getKey.desc) {\n        var a = getKey.desc(x);\n        var b = getKey.desc(y);\n        if (a === b) {\n          continue;\n        }\n        return a < b ? 1 /* GT */ : -1 /* LT */;\n      } else {\n        var a = getKey(x);\n        var b = getKey(y);\n        if (a === b) {\n          continue;\n        }\n        return a > b ? 1 /* GT */ : -1 /* LT */;\n      }\n    }\n    return 0 /* EQ */;\n  });\n}\nexports.sortOn = sortOn;\n/**\n * @hidden\n */\nfunction distinctBy(seq, keyExtractor) {\n  var knownKeys = HashSet_1.HashSet.empty();\n  return seq.filter(function (x) {\n    var key = keyExtractor(x);\n    var r = knownKeys.contains(key);\n    if (!r) {\n      knownKeys = knownKeys.add(key);\n    }\n    return !r;\n  });\n}\nexports.distinctBy = distinctBy;\n/**\n * Utility function to help converting a value to string\n * util.inspect seems to depend on node.\n * @hidden\n */\nfunction toStringHelper(obj, options) {\n  if (options === void 0) {\n    options = {\n      quoteStrings: true\n    };\n  }\n  if (Array.isArray(obj)) {\n    return \"[\" + obj.map(function (o) {\n      return toStringHelper(o, options);\n    }) + \"]\";\n  }\n  if (typeof obj === \"string\") {\n    return options.quoteStrings ? \"'\" + obj + \"'\" : obj;\n  }\n  if (obj && obj.toString !== Object.prototype.toString) {\n    return obj.toString();\n  }\n  // We used to use JSON.stringify here, but that will\n  // throw an exception if there are cycles, which we\n  // absolutely don't want!\n  // https://stackoverflow.com/a/48254637/516188\n  var customStringify = function (v) {\n    var cache = new Set();\n    return JSON.stringify(v, function (key, value) {\n      if (typeof value === 'object' && value !== null) {\n        if (cache.has(value)) {\n          // Circular reference found, discard key\n          return;\n        }\n        // Store value in our set\n        cache.add(value);\n      }\n      return value;\n    });\n  };\n  return customStringify(obj);\n}\nexports.toStringHelper = toStringHelper;\n/**\n * @hidden\n */\nfunction minBy(coll, compare) {\n  return coll.reduce(function (v1, v2) {\n    return compare(v1, v2) < 0 ? v2 : v1;\n  });\n}\nexports.minBy = minBy;\n/**\n * @hidden\n */\nfunction minOn(coll, getSortable) {\n  if (coll.isEmpty()) {\n    return Option_1.Option.none();\n  }\n  var iter = coll[Symbol.iterator]();\n  var step = iter.next();\n  var val = getSortable(step.value);\n  var result = step.value;\n  while (!(step = iter.next()).done) {\n    var curVal = getSortable(step.value);\n    if (curVal < val) {\n      val = curVal;\n      result = step.value;\n    }\n  }\n  return Option_1.Option.of(result);\n}\nexports.minOn = minOn;\n/**\n * @hidden\n */\nfunction maxBy(coll, compare) {\n  return coll.reduce(function (v1, v2) {\n    return compare(v1, v2) > 0 ? v2 : v1;\n  });\n}\nexports.maxBy = maxBy;\n/**\n * @hidden\n */\nfunction maxOn(coll, getSortable) {\n  if (coll.isEmpty()) {\n    return Option_1.Option.none();\n  }\n  var iter = coll[Symbol.iterator]();\n  var step = iter.next();\n  var val = getSortable(step.value);\n  var result = step.value;\n  while (!(step = iter.next()).done) {\n    var curVal = getSortable(step.value);\n    if (curVal > val) {\n      val = curVal;\n      result = step.value;\n    }\n  }\n  return Option_1.Option.of(result);\n}\nexports.maxOn = maxOn;\n/**\n * @hidden\n */\nfunction sumOn(coll, getNumber) {\n  return coll.foldLeft(0, function (soFar, cur) {\n    return soFar + getNumber(cur);\n  });\n}\nexports.sumOn = sumOn;\n/**\n * @hidden\n */\nfunction reduce(coll, combine) {\n  if (coll.isEmpty()) {\n    return Option_1.Option.none();\n  }\n  var iter = coll[Symbol.iterator]();\n  var step = iter.next();\n  var result = step.value;\n  while (!(step = iter.next()).done) {\n    result = combine(result, step.value);\n  }\n  return Option_1.Option.of(result);\n}\nexports.reduce = reduce;\n/**\n * @hidden\n */\nfunction sliding(seq, count) {\n  // in a way should get better performance with Seq.splitAt instead\n  // of Seq.take+Seq.drop, but we should be lazy and not hold another\n  // version of the sequence in memory (though for linked list it's free,\n  // it's not the case for Vector)\n  return seq.isEmpty() ? Stream_1.Stream.empty() : new Stream_1.ConsStream(seq.take(count), Lazy_1.Lazy.of(function () {\n    return sliding(seq.drop(count), count);\n  }));\n}\nexports.sliding = sliding;\n/**\n * @hidden\n */\nfunction removeAll(seq, elts) {\n  var toRemove = HashSet_1.HashSet.ofIterable(elts);\n  // I know T must have equality since the parameter has it and is the same type.\n  return seq.filter(function (x) {\n    return !toRemove.contains(x);\n  });\n}\nexports.removeAll = removeAll;","map":{"version":3,"names":["Option_1","require","Stream_1","Lazy_1","HashSet_1","shuffle","array","currentIndex","length","temporaryValue","randomIndex","Math","floor","random","exports","arrangeBy","collection","getKey","Option","of","groupBy","mapValues","v","single","filter","map","anyMatch","k","isNone","getOrThrow","seqHasTrueEquality","seq","find","x","hasTrueEquality","zipWithIndex","zip","Stream","iterate","i","sortOn","getKeys","sortBy","y","_i","getKeys_1","desc","a","b","distinctBy","keyExtractor","knownKeys","HashSet","empty","key","r","contains","add","toStringHelper","obj","options","quoteStrings","Array","isArray","o","toString","Object","prototype","customStringify","cache","Set","JSON","stringify","value","has","minBy","coll","compare","reduce","v1","v2","minOn","getSortable","isEmpty","none","iter","Symbol","iterator","step","next","val","result","done","curVal","maxBy","maxOn","sumOn","getNumber","foldLeft","soFar","cur","combine","sliding","count","ConsStream","take","Lazy","drop","removeAll","elts","toRemove","ofIterable"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/SeqHelpers.ts"],"sourcesContent":["import { Option } from \"./Option\";\nimport { WithEquality, hasTrueEquality,\n         Ordering, ToOrderable } from \"./Comparison\";\nimport { HashMap } from \"./HashMap\";\nimport { Seq } from \"./Seq\";\nimport { Collection } from \"./Collection\";\nimport { Stream, ConsStream } from \"./Stream\";\nimport { Lazy } from \"./Lazy\";\nimport { HashSet } from \"./HashSet\";\n\n/**\n * @hidden\n */\nexport function shuffle(array: any[]) {\n    // https://stackoverflow.com/a/2450976/516188\n    var currentIndex = array.length, temporaryValue, randomIndex;\n\n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n\n        // Pick a remaining element...\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex -= 1;\n\n        // And swap it with the current element.\n        temporaryValue = array[currentIndex];\n        array[currentIndex] = array[randomIndex];\n        array[randomIndex] = temporaryValue;\n    }\n\n    return array;\n}\n\n/**\n * @hidden\n */\nexport function arrangeBy<T,K>(collection: Collection<T>, getKey: (v:T)=>K&WithEquality): Option<HashMap<K,T>> {\n    return Option.of(collection.groupBy(getKey).mapValues(v => v.single()))\n        .filter(map => !map.anyMatch((k,v) => v.isNone()))\n        .map(map => map.mapValues(v => v.getOrThrow()));\n}\n\n/**\n * @hidden\n */\nexport function seqHasTrueEquality<T>(seq: Seq<T>): boolean {\n    return seq.find(x => x!=null).hasTrueEquality();\n}\n\n/**\n * @hidden\n */\nexport function zipWithIndex<T>(seq: Seq<T>): Seq<[T,number]> {\n    return seq.zip<number>(Stream.iterate(0,i=>i+1));\n}\n\n/**\n * @hidden\n */\nexport function sortOn<T>(seq: Seq<T>, getKeys: Array<ToOrderable<T>|{desc:ToOrderable<T>}>): Seq<T> {\n    return seq.sortBy((x,y) => {\n        for (const getKey of getKeys) {\n            if ((<any>getKey).desc) {\n                const a = (<ToOrderable<T>>(<any>getKey).desc)(x);\n                const b = (<ToOrderable<T>>(<any>getKey).desc)(y);\n                if (a === b) {\n                    continue;\n                }\n                return a<b?Ordering.GT:Ordering.LT;\n            } else {\n                const a = (<ToOrderable<T>>getKey)(x);\n                const b = (<ToOrderable<T>>getKey)(y);\n                if (a === b) {\n                    continue;\n                }\n                return a>b?Ordering.GT:Ordering.LT;\n            }\n        }\n        return Ordering.EQ;\n    });\n}\n\n/**\n * @hidden\n */\nexport function distinctBy<T,U>(seq: Collection<T>, keyExtractor: (x:T)=>U&WithEquality): Collection<T> {\n    let knownKeys = HashSet.empty<U>();\n    return seq.filter(x => {\n        const key = keyExtractor(x);\n        const r = knownKeys.contains(key);\n        if (!r) {\n            knownKeys = knownKeys.add(key);\n        }\n        return !r;\n    });\n}\n\n/**\n * Utility function to help converting a value to string\n * util.inspect seems to depend on node.\n * @hidden\n */\nexport function toStringHelper(\n    obj: any|null,\n    options: {quoteStrings:boolean} = {quoteStrings: true}): string\n{\n    if (Array.isArray(obj)) {\n        return \"[\" + obj.map(o => toStringHelper(o, options)) + \"]\"\n    }\n    if (typeof obj === \"string\") {\n        return options.quoteStrings ? `'${obj}'` : obj;\n    }\n    if (obj && (obj.toString !== Object.prototype.toString)) {\n        return obj.toString();\n    }\n    // We used to use JSON.stringify here, but that will\n    // throw an exception if there are cycles, which we\n    // absolutely don't want!\n    // https://stackoverflow.com/a/48254637/516188\n    const customStringify = function (v:any) {\n        const cache = new Set();\n        return JSON.stringify(v, function (key, value) {\n            if (typeof value === 'object' && value !== null) {\n                if (cache.has(value)) {\n                    // Circular reference found, discard key\n                    return;\n                }\n                // Store value in our set\n                cache.add(value);\n            }\n            return value;\n        });\n    };\n    return customStringify(obj);\n}\n\n/**\n * @hidden\n */\nexport function minBy<T>(coll: Collection<T>, compare: (v1:T,v2:T)=>Ordering): Option<T> {\n    return coll.reduce((v1,v2)=>compare(v1,v2)<0 ? v2 : v1);\n}\n\n/**\n * @hidden\n */\nexport function minOn<T>(coll: Collection<T>, getSortable: ToOrderable<T>): Option<T> {\n    if (coll.isEmpty()) {\n        return Option.none<T>();\n    }\n    let iter = coll[Symbol.iterator]();\n    let step = iter.next();\n    let val = getSortable(step.value);\n    let result = step.value;\n    while (!(step = iter.next()).done) {\n        const curVal = getSortable(step.value);\n        if (curVal < val) {\n            val = curVal;\n            result = step.value;\n        }\n    }\n    return Option.of(result);\n}\n\n/**\n * @hidden\n */\nexport function maxBy<T>(coll: Collection<T>, compare: (v1:T,v2:T)=>Ordering): Option<T> {\n    return coll.reduce((v1,v2)=>compare(v1,v2)>0 ? v2 : v1);\n}\n\n/**\n * @hidden\n */\nexport function maxOn<T>(coll: Collection<T>, getSortable: ToOrderable<T>): Option<T> {\n    if (coll.isEmpty()) {\n        return Option.none<T>();\n    }\n    let iter = coll[Symbol.iterator]();\n    let step = iter.next();\n    let val = getSortable(step.value);\n    let result = step.value;\n    while (!(step = iter.next()).done) {\n        const curVal = getSortable(step.value);\n        if (curVal > val) {\n            val = curVal;\n            result = step.value;\n        }\n    }\n    return Option.of(result);\n}\n\n/**\n * @hidden\n */\nexport function sumOn<T>(coll: Collection<T>, getNumber: (v:T)=>number): number {\n    return coll.foldLeft(0, (soFar,cur)=>soFar+getNumber(cur));\n}\n\n/**\n * @hidden\n */\nexport function reduce<T>(coll: Collection<T>, combine: (v1:T,v2:T)=>T): Option<T> {\n    if (coll.isEmpty()) {\n        return Option.none<T>();\n    }\n    let iter = coll[Symbol.iterator]();\n    let step = iter.next();\n    let result = step.value;\n    while (!(step = iter.next()).done) {\n        result = combine(result, step.value);\n    }\n    return Option.of(result);\n}\n\n/**\n * @hidden\n */\nexport function sliding<T>(seq: Seq<T>, count:number): Stream<Seq<T>> {\n    // in a way should get better performance with Seq.splitAt instead\n    // of Seq.take+Seq.drop, but we should be lazy and not hold another\n    // version of the sequence in memory (though for linked list it's free,\n    // it's not the case for Vector)\n    return seq.isEmpty() ?\n        Stream.empty<Seq<T>>() :\n        new ConsStream(seq.take(count), Lazy.of(() => sliding(seq.drop(count), count)));\n}\n\n/**\n * @hidden\n */\nexport function removeAll<T>(seq: Seq<T>, elts:Iterable<T&WithEquality>): Seq<T> {\n    const toRemove = HashSet.ofIterable(elts);\n    // I know T must have equality since the parameter has it and is the same type.\n    return <Seq<T>><any>(<Seq<T&WithEquality>><any>seq).filter(x => !toRemove.contains(x));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}