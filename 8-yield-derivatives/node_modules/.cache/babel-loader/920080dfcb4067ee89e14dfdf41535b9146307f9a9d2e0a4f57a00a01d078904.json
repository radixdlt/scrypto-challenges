{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Radix = void 0;\nconst tslib_1 = require(\"tslib\");\nconst account_1 = require(\"@radixdlt/account\");\nconst networking_1 = require(\"@radixdlt/networking\");\nconst api_1 = require(\"./api\");\nconst operators_1 = require(\"rxjs/operators\");\nconst rxjs_1 = require(\"rxjs\");\nconst crypto_1 = require(\"@radixdlt/crypto\");\nconst errors_1 = require(\"./errors\");\nconst util_1 = require(\"@radixdlt/util\");\nconst dto_1 = require(\"./dto\");\nconst actions_1 = require(\"./actions\");\nconst wallet_1 = require(\"./wallet\");\nconst _1 = require(\".\");\nconst utils_1 = require(\"./api/utils\");\nconst txTypeFromActions = input => {\n  const {\n    activeAddress\n  } = input;\n  const myAddress = activeAddress.toString();\n  const fromUnique = (0, dto_1.flatMapAddressesOf)(Object.assign(Object.assign({}, input), {\n    includeTo: false\n  })).map(a => a.toString());\n  const toUnique = (0, dto_1.flatMapAddressesOf)(Object.assign(Object.assign({}, input), {\n    includeFrom: false\n  })).map(a => a.toString());\n  const toMe = toUnique.includes(myAddress);\n  const fromMe = fromUnique.includes(myAddress);\n  if (toMe && fromMe) {\n    return dto_1.TransactionType.FROM_ME_TO_ME;\n  } else if (toMe) {\n    return dto_1.TransactionType.INCOMING;\n  } else if (fromMe) {\n    return dto_1.TransactionType.OUTGOING;\n  } else {\n    return dto_1.TransactionType.UNRELATED;\n  }\n};\nconst decorateSimpleExecutedTransactionWithType = (simpleExecutedTX, activeAddress) => Object.assign(Object.assign({}, simpleExecutedTX), {\n  transactionType: txTypeFromActions({\n    actions: simpleExecutedTX.actions,\n    activeAddress\n  })\n});\nconst shouldConfirmTransactionAutomatically = confirmationScheme => confirmationScheme === 'skip';\nconst create = () => {\n  const subs = new rxjs_1.Subscription();\n  const radixLog = util_1.log; // TODO configure child loggers\n  const nodeSubject = new rxjs_1.ReplaySubject();\n  const coreAPISubject = new rxjs_1.ReplaySubject();\n  const walletSubject = new rxjs_1.ReplaySubject();\n  const errorNotificationSubject = new rxjs_1.Subject();\n  const deriveNextLocalHDAccountSubject = new rxjs_1.Subject();\n  const addAccountByPrivateKeySubject = new rxjs_1.Subject();\n  const switchAccountSubject = new rxjs_1.Subject();\n  const tokenBalanceFetchSubject = new rxjs_1.Subject();\n  const stakingFetchSubject = new rxjs_1.Subject();\n  const wallet$ = walletSubject.asObservable();\n  const networkSubject = new rxjs_1.ReplaySubject();\n  const nativeTokenSubject = new rxjs_1.ReplaySubject();\n  let walletSubscription;\n  const coreAPIViaNode$ = nodeSubject.asObservable().pipe((0, operators_1.map)(n => (0, api_1.radixCoreAPI)(n, (0, api_1.nodeAPI)(n.url))));\n  const coreAPI$ = (0, rxjs_1.merge)(coreAPIViaNode$, coreAPISubject.asObservable()).pipe((0, operators_1.shareReplay)(1));\n  // Forwards calls to RadixCoreAPI, return type is a function: `(input?: I) => Observable<O>`\n  const fwdAPICall = (pickFn, errorFn) => (...input) => coreAPI$.pipe((0, operators_1.mergeMap)(a => pickFn(a)(...input)), (0, operators_1.take)(1),\n  // Important!\n  (0, operators_1.catchError)(error => {\n    throw errorFn((0, util_1.isArray)(error) ? error[0] : error);\n  }));\n  const api = {\n    networkId: fwdAPICall(a => a.networkId, m => (0, errors_1.networkIdErr)(m)),\n    tokenBalancesForAddress: fwdAPICall(a => a.tokenBalancesForAddress, m => (0, errors_1.tokenBalancesErr)(m)),\n    transactionHistory: fwdAPICall(a => a.transactionHistory, m => (0, errors_1.transactionHistoryErr)(m)),\n    recentTransactions: fwdAPICall(a => a.recentTransactions, m => (0, errors_1.recentTransactionsErr)(m)),\n    nativeToken: fwdAPICall(a => a.nativeToken, m => (0, errors_1.nativeTokenErr)(m)),\n    tokenInfo: fwdAPICall(a => a.tokenInfo, m => (0, _1.tokenInfoErr)(m)),\n    stakesForAddress: fwdAPICall(a => a.stakesForAddress, m => (0, errors_1.stakesForAddressErr)(m)),\n    unstakesForAddress: fwdAPICall(a => a.unstakesForAddress, m => (0, errors_1.unstakesForAddressErr)(m)),\n    validators: fwdAPICall(a => a.validators, m => (0, errors_1.validatorsErr)(m)),\n    lookupValidator: fwdAPICall(a => a.lookupValidator, m => (0, errors_1.lookupValidatorErr)(m)),\n    getTransaction: fwdAPICall(a => a.transactionStatus, m => (0, errors_1.lookupTxErr)(m)),\n    buildTransaction: fwdAPICall(a => a.buildTransaction, m => (0, errors_1.buildTxFromIntentErr)(m)),\n    finalizeTransaction: fwdAPICall(a => a.finalizeTransaction, m => (0, errors_1.finalizeTxErr)(m)),\n    submitSignedTransaction: fwdAPICall(a => a.submitSignedTransaction, m => (0, errors_1.submitSignedTxErr)(m))\n  };\n  const activeAddress = wallet$.pipe((0, operators_1.mergeMap)(a => a.observeActiveAccount()), (0, operators_1.map)(a => a.address), (0, operators_1.shareReplay)(1));\n  const revealMnemonic = () => wallet$.pipe((0, operators_1.map)(wallet => wallet.revealMnemonic()));\n  const activeAddressToAPIObservableWithTrigger = (trigger, pickFn, errorFn) => (0, rxjs_1.merge)(trigger.pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.map)(result => result[1])), activeAddress).pipe((0, operators_1.withLatestFrom)(coreAPI$), (0, operators_1.switchMap)(([address, api]) => pickFn(api)(address).pipe((0, operators_1.catchError)(error => {\n    console.error(error);\n    errorNotificationSubject.next(errorFn(error));\n    return rxjs_1.EMPTY;\n  }))), (0, operators_1.shareReplay)(1));\n  const tokenBalances = activeAddressToAPIObservableWithTrigger(tokenBalanceFetchSubject, a => a.tokenBalancesForAddress, errors_1.tokenBalancesErr);\n  /*\n      const decorateSimpleTokenBalanceWithTokenInfo = (\n          simpleTokenBalance: SimpleTokenBalance,\n      ): Observable<TokenBalance> =>\n          api.tokenInfo(simpleTokenBalance.tokenIdentifier).pipe(\n              map(\n                  (tokenInfo: Token): TokenBalance => ({\n                      amount: simpleTokenBalance.amount,\n                      token: tokenInfo,\n                  }),\n              ),\n          )\n  */\n  const stakingPositions = activeAddressToAPIObservableWithTrigger(stakingFetchSubject, a => a.stakesForAddress, errors_1.stakesForAddressErr);\n  const unstakingPositions = activeAddressToAPIObservableWithTrigger(stakingFetchSubject, a => a.unstakesForAddress, errors_1.unstakesForAddressErr);\n  const transactionHistory = input => activeAddress.pipe((0, operators_1.take)(1), (0, operators_1.switchMap)(activeAddress => api.transactionHistory(Object.assign(Object.assign({}, input), {\n    address: activeAddress\n  })).pipe((0, operators_1.map)(simpleTxHistory => Object.assign(Object.assign({}, simpleTxHistory), {\n    transactions: simpleTxHistory.transactions.map(simpleExecutedTX => decorateSimpleExecutedTransactionWithType(simpleExecutedTX, activeAddress))\n  })))));\n  const node$ = (0, rxjs_1.merge)(nodeSubject.asObservable(), coreAPISubject.asObservable().pipe((0, operators_1.map)(api => api.node)));\n  const activeAccount = wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.observeActiveAccount()), (0, operators_1.shareReplay)(1), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.equals(cur)));\n  const accounts = wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.observeAccounts()), (0, operators_1.shareReplay)(1));\n  const __makeTransactionFromIntent = (transactionIntent$, options) => {\n    var _a;\n    const txLog = radixLog; // TODO configure child loggers\n    const txSubs = new rxjs_1.Subscription();\n    txLog.debug(`Start of transaction flow, inside constructor of 'TransactionTracking'.`);\n    const signUnsignedTx = unsignedTx => {\n      txLog.debug('Starting signing transaction (async).');\n      return (0, rxjs_1.combineLatest)(transactionIntent$, activeAccount.pipe((0, operators_1.take)(1))).pipe((0, operators_1.mergeMap)(([transactionIntent, account]) => {\n        const nonXRDHRPsOfRRIsInTx = transactionIntent.actions.filter(a => a.type === actions_1.ActionType.TOKEN_TRANSFER).map(a => a).filter(t => t.rri.name !== 'xrd').map(t => t.rri.name);\n        const uniquenonXRDHRPsOfRRIsInTx = [...new Set(nonXRDHRPsOfRRIsInTx)];\n        if (uniquenonXRDHRPsOfRRIsInTx.length > 1) {\n          const errMsg = `Error cannot sign transction with multiple non-XRD RRIs. Unsupported by Ledger app.`;\n          util_1.log.error(errMsg);\n          return (0, rxjs_1.throwError)(new Error(errMsg));\n        }\n        const nonXRDHrp = uniquenonXRDHRPsOfRRIsInTx.length === 1 ? uniquenonXRDHRPsOfRRIsInTx[0] : undefined;\n        return account.sign(unsignedTx.transaction, nonXRDHrp).pipe((0, operators_1.map)(signature => {\n          const publicKeyOfSigner = account.publicKey;\n          txLog.debug(`Finished signing transaction`);\n          return {\n            transaction: unsignedTx.transaction,\n            signature,\n            publicKeyOfSigner\n          };\n        }));\n      }));\n    };\n    const pendingTXSubject = new rxjs_1.Subject();\n    const askUserToConfirmSubject = new rxjs_1.ReplaySubject();\n    const userDidConfirmTransactionSubject = new rxjs_1.ReplaySubject();\n    if (shouldConfirmTransactionAutomatically(options.userConfirmation)) {\n      txLog.debug('Transaction has been setup to be automatically confirmed, requiring no final confirmation input from user.');\n      txSubs.add(askUserToConfirmSubject.subscribe(() => {\n        txLog.debug(`askUserToConfirmSubject got 'next', calling 'next' on 'userDidConfirmTransactionSubject'`);\n        userDidConfirmTransactionSubject.next(0);\n      }));\n    } else {\n      txLog.debug(`Transaction has been setup so that it requires a manual final confirmation from user before being finalized.`);\n      const twoWayConfirmationSubject = options.userConfirmation;\n      txSubs.add(askUserToConfirmSubject.subscribe(ux => {\n        txLog.info(`Forwarding signedUnconfirmedTX and 'userDidConfirmTransactionSubject' to subject 'twoWayConfirmationSubject' now (inside subscribe to 'askUserToConfirmSubject')`);\n        const confirmation = {\n          txToConfirm: ux,\n          confirm: () => userDidConfirmTransactionSubject.next(0)\n        };\n        twoWayConfirmationSubject.next(confirmation);\n      }));\n    }\n    const trackingSubject = new rxjs_1.ReplaySubject();\n    const track = event => {\n      trackingSubject.next(event);\n    };\n    const completionSubject = new rxjs_1.Subject();\n    const trackError = input => {\n      const errorEvent = {\n        eventUpdateType: input.inStep,\n        error: input.error\n      };\n      txLog.debug(`Forwarding error to 'errorSubject'`);\n      track(errorEvent);\n      completionSubject.error(errorEvent.error);\n    };\n    const builtTransaction$ = transactionIntent$.pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.switchMap)(([intent, address]) => {\n      txLog.debug('Transaction intent created => requesting 🛰 API to build it now.');\n      track({\n        transactionState: intent,\n        eventUpdateType: dto_1.TransactionTrackingEventType.INITIATED\n      });\n      return api.buildTransaction(intent, address);\n    }), (0, operators_1.catchError)(e => {\n      txLog.error(`API failed to build transaction`);\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.BUILT_FROM_INTENT\n      });\n      return rxjs_1.EMPTY;\n    }), (0, operators_1.tap)(builtTx => {\n      txLog.debug('TX built by API => asking for confirmation to sign...');\n      track({\n        transactionState: builtTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.BUILT_FROM_INTENT\n      });\n      askUserToConfirmSubject.next(builtTx);\n    }), (0, operators_1.tap)(builtTx => {\n      track({\n        transactionState: builtTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.ASKED_FOR_CONFIRMATION\n      });\n    }));\n    const signedTransaction$ = (0, rxjs_1.combineLatest)([builtTransaction$, userDidConfirmTransactionSubject]).pipe((0, operators_1.map)(([signedTx, _]) => signedTx), (0, operators_1.tap)(unsignedTx => {\n      track({\n        transactionState: unsignedTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.CONFIRMED\n      });\n    }), (0, operators_1.mergeMap)(unsignedTx => signUnsignedTx(unsignedTx)), (0, operators_1.shareReplay)(1), (0, operators_1.catchError)(e => {\n      txLog.error(`API failed to sign transaction, error: ${JSON.stringify(e, null, 4)}`);\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.SIGNED\n      });\n      return rxjs_1.EMPTY;\n    }));\n    const finalizedTx$ = signedTransaction$.pipe((0, operators_1.mergeMap)(signedTx => {\n      txLog.debug(`Finished signing tx => submitting it to 🛰  API.`);\n      track({\n        transactionState: signedTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.SIGNED\n      });\n      return networkSubject.pipe((0, operators_1.mergeMap)(network => api.finalizeTransaction(network, signedTx)));\n    }), (0, operators_1.catchError)(e => {\n      txLog.error(`API failed to submit transaction, error: ${JSON.stringify(e, null, 4)}`);\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.FINALIZED\n      });\n      return rxjs_1.EMPTY;\n    }), (0, operators_1.tap)(finalizedTx => {\n      track({\n        transactionState: finalizedTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.FINALIZED\n      });\n    }));\n    txSubs.add(finalizedTx$.pipe((0, operators_1.mergeMap)(finalizedTx => networkSubject.pipe((0, operators_1.mergeMap)(network => api.submitSignedTransaction(network, {\n      blob: finalizedTx.blob,\n      txID: finalizedTx.txID\n    })))), (0, operators_1.catchError)(e => {\n      txLog.error(`API failed to submit transaction, error: ${JSON.stringify(e, null, 4)}`);\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.SUBMITTED\n      });\n      return rxjs_1.EMPTY;\n    }), (0, operators_1.tap)({\n      next: pendingTx => {\n        txLog.debug(`Submitted transaction with txID='${pendingTx.txID.toString()}', it is now pending.`);\n        track({\n          transactionState: pendingTx,\n          eventUpdateType: dto_1.TransactionTrackingEventType.SUBMITTED\n        });\n        pendingTXSubject.next(pendingTx);\n      },\n      error: submitTXError => {\n        // TODO would be great to have access to txID here, hopefully API includes it in error msg?\n        txLog.error(`Submission of signed transaction to API failed with error: ${submitTXError.message}`);\n        pendingTXSubject.error(submitTXError);\n      }\n    })).subscribe());\n    const pollTxStatusTrigger = ((_a = options.pollTXStatusTrigger) !== null && _a !== void 0 ? _a : (0, rxjs_1.interval)(1000)).pipe((0, operators_1.share)());\n    const transactionStatus$ = (0, rxjs_1.combineLatest)([pollTxStatusTrigger, pendingTXSubject]).pipe((0, operators_1.mergeMap)(([_, pendingTx]) => {\n      txLog.debug(`Asking API for status of transaction with txID: ${pendingTx.txID.toString()}`);\n      return networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(pendingTx.txID, network).pipe((0, operators_1.retryWhen)((0, utils_1.retryOnErrorCode)({\n        maxRetryAttempts: 3,\n        errorCodes: [404]\n      })))));\n    }), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.status === cur.status), (0, operators_1.share)());\n    const transactionCompletedWithStatusConfirmed$ = transactionStatus$.pipe((0, operators_1.skipWhile)(({\n      status\n    }) => status !== dto_1.TransactionStatus.CONFIRMED), (0, operators_1.take)(1));\n    const transactionCompletedWithStatusFailed$ = transactionStatus$.pipe((0, operators_1.skipWhile)(({\n      status\n    }) => status !== dto_1.TransactionStatus.FAILED), (0, operators_1.take)(1));\n    txSubs.add(transactionStatus$.subscribe({\n      next: statusOfTransaction => {\n        const {\n          status,\n          txID\n        } = statusOfTransaction;\n        txLog.debug(`Status ${status.toString()} of transaction with txID='${txID.toString()}'`);\n        track({\n          transactionState: statusOfTransaction,\n          eventUpdateType: dto_1.TransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX\n        });\n      },\n      error: transactionStatusError => {\n        // TODO hmm how to get txID here?\n        txLog.error(`Failed to get status of transaction`, transactionStatusError);\n      }\n    }));\n    txSubs.add(transactionCompletedWithStatusConfirmed$.subscribe({\n      next: statusOfTransaction => {\n        const {\n          txID\n        } = statusOfTransaction;\n        txLog.info(`Transaction with txID='${txID.toString()}' has completed succesfully.`);\n        track({\n          transactionState: statusOfTransaction,\n          eventUpdateType: dto_1.TransactionTrackingEventType.COMPLETED\n        });\n        completionSubject.next(txID);\n        completionSubject.complete();\n        txSubs.unsubscribe();\n      }\n    }));\n    txSubs.add(transactionCompletedWithStatusFailed$.subscribe(status => {\n      const errMsg = `API status of tx with id=${status.txID.toString()} returned 'FAILED'`;\n      txLog.error(errMsg);\n      trackError({\n        error: new Error(errMsg),\n        inStep: dto_1.TransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX\n      });\n      txSubs.unsubscribe();\n    }));\n    return {\n      completion: completionSubject.asObservable(),\n      events: trackingSubject.asObservable()\n    };\n  };\n  const __makeTransactionFromBuilder = (transactionIntentBuilderT, makeTXOptions, builderOptions) => {\n    radixLog.debug(`make transaction from builder`);\n    const intent$ = transactionIntentBuilderT.build(builderOptions !== null && builderOptions !== void 0 ? builderOptions : {\n      skipEncryptionOfMessageIfAny: {\n        spendingSender: activeAddress.pipe((0, operators_1.take)(1)) // IMPORTANT !\n      }\n    });\n    return __makeTransactionFromIntent(intent$, makeTXOptions);\n  };\n  const transferTokens = input => {\n    radixLog.debug(`transferTokens`);\n    const builder = dto_1.TransactionIntentBuilder.create().transferTokens(input.transferInput);\n    let encryptMsgIfAny = false;\n    if (input.message) {\n      builder.message(input.message);\n      encryptMsgIfAny = input.message.encrypt;\n    }\n    return __makeTransactionFromBuilder(builder, Object.assign({}, input), encryptMsgIfAny ? {\n      encryptMessageIfAnyWithAccount: activeAccount.pipe((0, operators_1.take)(1))\n    } : undefined);\n  };\n  const stakeTokens = input => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n    radixLog.debug('stake');\n    const nativeToken = yield (0, rxjs_1.firstValueFrom)(nativeTokenSubject);\n    return __makeTransactionFromBuilder(dto_1.TransactionIntentBuilder.create().stakeTokens(Object.assign(Object.assign({}, input.stakeInput), {\n      tokenIdentifier: nativeToken.rri\n    })), Object.assign({}, input));\n  });\n  const unstakeTokens = input => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n    radixLog.debug('unstake');\n    const nativeToken = yield (0, rxjs_1.firstValueFrom)(nativeTokenSubject);\n    return __makeTransactionFromBuilder(dto_1.TransactionIntentBuilder.create().unstakeTokens(Object.assign(Object.assign({}, input.unstakeInput), {\n      tokenIdentifier: nativeToken.rri\n    })), Object.assign({}, input));\n  });\n  const decryptTransaction = input => {\n    radixLog.debug(`Trying to decrypt transaction with txID=${input.txID.toString()}`);\n    if (!input.message) {\n      const noMsg = `TX contains no message, nothing to decrypt (txID=${input.txID.toString()}).`;\n      radixLog.info(noMsg);\n      return (0, rxjs_1.throwError)(() => new Error(noMsg));\n    }\n    const messageBuffer = Buffer.from(input.message, 'hex');\n    const encryptedMessageResult = crypto_1.Message.fromBuffer(messageBuffer);\n    if (!encryptedMessageResult.isOk()) {\n      const errMessage = `Failed to parse message as 'EncryptedMessage' type, underlying error: '${(0, util_1.msgFromError)(encryptedMessageResult.error)}'. Might not have been encrypted? Try decode string as UTF-8 string.`;\n      util_1.log.warn(errMessage);\n      return (0, rxjs_1.throwError)(new Error(errMessage));\n    }\n    const encryptedMessage = encryptedMessageResult.value;\n    if (encryptedMessage.kind !== 'ENCRYPTED') return (0, rxjs_1.of)(encryptedMessage.plaintext);\n    return activeAccount.pipe((0, operators_1.take)(1), (0, operators_1.mergeMap)(account => {\n      const myPublicKey = account.publicKey;\n      util_1.log.debug(`Trying to decrypt message with activeSigningKey with pubKey=${myPublicKey.toString()}`);\n      const publicKeyOfOtherPartyResult = (0, dto_1.singleRecipientFromActions)(myPublicKey, input.actions);\n      if (!publicKeyOfOtherPartyResult.isOk()) {\n        return (0, rxjs_1.throwError)(new Error((0, util_1.msgFromError)(publicKeyOfOtherPartyResult.error)));\n      }\n      util_1.log.debug(`Trying to decrypt message with publicKeyOfOtherPartyResult=${publicKeyOfOtherPartyResult.toString()}`);\n      return account.decrypt({\n        encryptedMessage,\n        publicKeyOfOtherParty: publicKeyOfOtherPartyResult.value\n      });\n    }), (0, operators_1.take)(1));\n  };\n  const restoreLocalHDAccountsToIndex = index => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.restoreLocalHDAccountsToIndex(index)));\n  subs.add(deriveNextLocalHDAccountSubject.pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.mergeMap)(([derivation, wallet]) => wallet.deriveNextLocalHDAccount(derivation))).subscribe());\n  subs.add(addAccountByPrivateKeySubject.pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.mergeMap)(([privateKeyInput, wallet]) => wallet.addAccountFromPrivateKey(privateKeyInput))).subscribe());\n  subs.add(switchAccountSubject.pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.tap)(([switchTo, wallet]) => wallet.switchAccount(switchTo))).subscribe());\n  let headerSub;\n  const methods = {\n    // we forward the full `RadixAPI`, but we also provide some convenience methods based on active account/address.\n    ledger: Object.assign({}, api),\n    __wallet: wallet$,\n    __node: node$,\n    __reset: () => subs.unsubscribe(),\n    // Primarily useful for testing\n    __withNodeConnection: node$ => {\n      subs.add(node$.subscribe(n => {\n        radixLog.debug(`Using node ${n.url.toString()}`);\n        nodeSubject.next(n);\n      }, error => {\n        errorNotificationSubject.next((0, errors_1.nodeError)(error));\n      }));\n      return methods;\n    },\n    __withAPI: radixCoreAPI$ => {\n      subs.add(radixCoreAPI$.subscribe(a => coreAPISubject.next(a)));\n      return methods;\n    },\n    __withWallet: wallet => {\n      walletSubject.next(wallet);\n      return methods;\n    },\n    __withKeychain: signingKeychain => {\n      (0, rxjs_1.firstValueFrom)(networkSubject).then(network => {\n        const wallet = wallet_1.Wallet.create({\n          signingKeychain,\n          network\n        });\n        methods.__withWallet(wallet);\n      });\n      return methods;\n    },\n    connect: url => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n      methods.__withNodeConnection((0, rxjs_1.of)({\n        url: new URL(url)\n      }));\n      const networkId = yield (0, rxjs_1.firstValueFrom)(api.networkId());\n      const nativeToken = yield (0, rxjs_1.firstValueFrom)(api.nativeToken(networkId));\n      networkSubject.next(networkId);\n      nativeTokenSubject.next(nativeToken);\n    }),\n    login: (password, loadKeystore) => {\n      walletSubscription === null || walletSubscription === void 0 ? void 0 : walletSubscription.unsubscribe();\n      void account_1.SigningKeychain.byLoadingAndDecryptingKeystore({\n        password,\n        load: loadKeystore\n      }).then(signingKeychainResult => {\n        signingKeychainResult.match(signingKeychain => {\n          walletSubscription = networkSubject.subscribe(network => {\n            const wallet = wallet_1.Wallet.create({\n              signingKeychain,\n              network\n            });\n            methods.__withWallet(wallet);\n          });\n        }, error => {\n          errorNotificationSubject.next((0, errors_1.walletError)(error));\n        });\n      });\n      return methods;\n    },\n    errors: errorNotificationSubject.asObservable(),\n    deriveNextAccount: input => {\n      const derivation = input !== null && input !== void 0 ? input : {};\n      deriveNextLocalHDAccountSubject.next(derivation);\n      return methods;\n    },\n    deriveHWAccount: input => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.deriveHWAccount(input))),\n    displayAddressForActiveHWAccountOnHWDeviceForVerification: () => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.displayAddressForActiveHWAccountOnHWDeviceForVerification())),\n    addAccountFromPrivateKey: input => {\n      addAccountByPrivateKeySubject.next(input);\n      return methods;\n    },\n    switchAccount: input => {\n      switchAccountSubject.next(input);\n      return methods;\n    },\n    restoreLocalHDAccountsToIndex,\n    decryptTransaction: decryptTransaction,\n    logLevel: level => {\n      util_1.log.setLevel(level);\n      return methods;\n    },\n    transactionStatus: (txID, trigger) => trigger.pipe((0, operators_1.withLatestFrom)(networkSubject), (0, operators_1.mergeMap)(([_, network]) => api.getTransaction(txID, network)), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.status === cur.status), (0, operators_1.filter)(({\n      txID\n    }) => txID.equals(txID)), (0, operators_1.tap)(({\n      status\n    }) => radixLog.info(`Got transaction status ${status.toString()} for txID: ${txID.toString()}`))),\n    withTokenBalanceFetchTrigger: trigger => {\n      subs.add(trigger.subscribe(tokenBalanceFetchSubject));\n      return methods;\n    },\n    withStakingFetchTrigger: trigger => {\n      subs.add(trigger.subscribe(stakingFetchSubject));\n      return methods;\n    },\n    // Wallet APIs\n    revealMnemonic,\n    activeAddress,\n    activeAccount,\n    accounts,\n    // Active AccountAddress/Account APIs\n    tokenBalances,\n    stakingPositions,\n    unstakingPositions,\n    lookupTransaction: txID => networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(txID, network).pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.map)(([simpleTx, aa]) => decorateSimpleExecutedTransactionWithType(simpleTx, aa))))),\n    transactionHistory,\n    transferTokens,\n    stakeTokens,\n    unstakeTokens,\n    getTransaction: txID => networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(txID, network))),\n    validators: () => networkSubject.pipe((0, operators_1.mergeMap)(network => api.validators(network))),\n    setHeaders: headers => {\n      headerSub.unsubscribe();\n      headerSub = coreAPI$.subscribe(api => api.setHeaders(headers));\n    },\n    targetApiVersion: networking_1.apiVersion\n  };\n  return methods;\n};\nexports.Radix = {\n  create\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","Radix","tslib_1","require","account_1","networking_1","api_1","operators_1","rxjs_1","crypto_1","errors_1","util_1","dto_1","actions_1","wallet_1","_1","utils_1","txTypeFromActions","input","activeAddress","myAddress","toString","fromUnique","flatMapAddressesOf","assign","includeTo","map","a","toUnique","includeFrom","toMe","includes","fromMe","TransactionType","FROM_ME_TO_ME","INCOMING","OUTGOING","UNRELATED","decorateSimpleExecutedTransactionWithType","simpleExecutedTX","transactionType","actions","shouldConfirmTransactionAutomatically","confirmationScheme","create","subs","Subscription","radixLog","log","nodeSubject","ReplaySubject","coreAPISubject","walletSubject","errorNotificationSubject","Subject","deriveNextLocalHDAccountSubject","addAccountByPrivateKeySubject","switchAccountSubject","tokenBalanceFetchSubject","stakingFetchSubject","wallet$","asObservable","networkSubject","nativeTokenSubject","walletSubscription","coreAPIViaNode$","pipe","n","radixCoreAPI","nodeAPI","url","coreAPI$","merge","shareReplay","fwdAPICall","pickFn","errorFn","mergeMap","take","catchError","error","isArray","api","networkId","m","networkIdErr","tokenBalancesForAddress","tokenBalancesErr","transactionHistory","transactionHistoryErr","recentTransactions","recentTransactionsErr","nativeToken","nativeTokenErr","tokenInfo","tokenInfoErr","stakesForAddress","stakesForAddressErr","unstakesForAddress","unstakesForAddressErr","validators","validatorsErr","lookupValidator","lookupValidatorErr","getTransaction","transactionStatus","lookupTxErr","buildTransaction","buildTxFromIntentErr","finalizeTransaction","finalizeTxErr","submitSignedTransaction","submitSignedTxErr","observeActiveAccount","address","revealMnemonic","wallet","activeAddressToAPIObservableWithTrigger","trigger","withLatestFrom","result","switchMap","console","next","EMPTY","tokenBalances","stakingPositions","unstakingPositions","simpleTxHistory","transactions","node$","node","activeAccount","distinctUntilChanged","prev","cur","equals","accounts","observeAccounts","__makeTransactionFromIntent","transactionIntent$","options","_a","txLog","txSubs","debug","signUnsignedTx","unsignedTx","combineLatest","transactionIntent","account","nonXRDHRPsOfRRIsInTx","filter","type","ActionType","TOKEN_TRANSFER","t","rri","name","uniquenonXRDHRPsOfRRIsInTx","Set","length","errMsg","throwError","Error","nonXRDHrp","undefined","sign","transaction","signature","publicKeyOfSigner","publicKey","pendingTXSubject","askUserToConfirmSubject","userDidConfirmTransactionSubject","userConfirmation","add","subscribe","twoWayConfirmationSubject","ux","info","confirmation","txToConfirm","confirm","trackingSubject","track","event","completionSubject","trackError","errorEvent","eventUpdateType","inStep","builtTransaction$","intent","transactionState","TransactionTrackingEventType","INITIATED","e","BUILT_FROM_INTENT","tap","builtTx","ASKED_FOR_CONFIRMATION","signedTransaction$","signedTx","_","CONFIRMED","JSON","stringify","SIGNED","finalizedTx$","network","FINALIZED","finalizedTx","blob","txID","SUBMITTED","pendingTx","submitTXError","message","pollTxStatusTrigger","pollTXStatusTrigger","interval","share","transactionStatus$","retryWhen","retryOnErrorCode","maxRetryAttempts","errorCodes","status","transactionCompletedWithStatusConfirmed$","skipWhile","TransactionStatus","transactionCompletedWithStatusFailed$","FAILED","statusOfTransaction","UPDATE_OF_STATUS_OF_PENDING_TX","transactionStatusError","COMPLETED","complete","unsubscribe","completion","events","__makeTransactionFromBuilder","transactionIntentBuilderT","makeTXOptions","builderOptions","intent$","build","skipEncryptionOfMessageIfAny","spendingSender","transferTokens","builder","TransactionIntentBuilder","transferInput","encryptMsgIfAny","encrypt","encryptMessageIfAnyWithAccount","stakeTokens","__awaiter","firstValueFrom","stakeInput","tokenIdentifier","unstakeTokens","unstakeInput","decryptTransaction","noMsg","messageBuffer","Buffer","from","encryptedMessageResult","Message","fromBuffer","isOk","errMessage","msgFromError","warn","encryptedMessage","kind","of","plaintext","myPublicKey","publicKeyOfOtherPartyResult","singleRecipientFromActions","decrypt","publicKeyOfOtherParty","restoreLocalHDAccountsToIndex","index","derivation","deriveNextLocalHDAccount","privateKeyInput","addAccountFromPrivateKey","switchTo","switchAccount","headerSub","methods","ledger","__wallet","__node","__reset","__withNodeConnection","nodeError","__withAPI","radixCoreAPI$","__withWallet","__withKeychain","signingKeychain","then","Wallet","connect","URL","login","password","loadKeystore","SigningKeychain","byLoadingAndDecryptingKeystore","load","signingKeychainResult","match","walletError","errors","deriveNextAccount","deriveHWAccount","displayAddressForActiveHWAccountOnHWDeviceForVerification","logLevel","level","setLevel","withTokenBalanceFetchTrigger","withStakingFetchTrigger","lookupTransaction","simpleTx","aa","setHeaders","headers","targetApiVersion","apiVersion"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/application/dist/radix.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Radix = void 0;\nconst tslib_1 = require(\"tslib\");\nconst account_1 = require(\"@radixdlt/account\");\nconst networking_1 = require(\"@radixdlt/networking\");\nconst api_1 = require(\"./api\");\nconst operators_1 = require(\"rxjs/operators\");\nconst rxjs_1 = require(\"rxjs\");\nconst crypto_1 = require(\"@radixdlt/crypto\");\nconst errors_1 = require(\"./errors\");\nconst util_1 = require(\"@radixdlt/util\");\nconst dto_1 = require(\"./dto\");\nconst actions_1 = require(\"./actions\");\nconst wallet_1 = require(\"./wallet\");\nconst _1 = require(\".\");\nconst utils_1 = require(\"./api/utils\");\nconst txTypeFromActions = (input) => {\n    const { activeAddress } = input;\n    const myAddress = activeAddress.toString();\n    const fromUnique = (0, dto_1.flatMapAddressesOf)(Object.assign(Object.assign({}, input), { includeTo: false })).map(a => a.toString());\n    const toUnique = (0, dto_1.flatMapAddressesOf)(Object.assign(Object.assign({}, input), { includeFrom: false })).map(a => a.toString());\n    const toMe = toUnique.includes(myAddress);\n    const fromMe = fromUnique.includes(myAddress);\n    if (toMe && fromMe) {\n        return dto_1.TransactionType.FROM_ME_TO_ME;\n    }\n    else if (toMe) {\n        return dto_1.TransactionType.INCOMING;\n    }\n    else if (fromMe) {\n        return dto_1.TransactionType.OUTGOING;\n    }\n    else {\n        return dto_1.TransactionType.UNRELATED;\n    }\n};\nconst decorateSimpleExecutedTransactionWithType = (simpleExecutedTX, activeAddress) => (Object.assign(Object.assign({}, simpleExecutedTX), { transactionType: txTypeFromActions({\n        actions: simpleExecutedTX.actions,\n        activeAddress,\n    }) }));\nconst shouldConfirmTransactionAutomatically = (confirmationScheme) => confirmationScheme === 'skip';\nconst create = () => {\n    const subs = new rxjs_1.Subscription();\n    const radixLog = util_1.log; // TODO configure child loggers\n    const nodeSubject = new rxjs_1.ReplaySubject();\n    const coreAPISubject = new rxjs_1.ReplaySubject();\n    const walletSubject = new rxjs_1.ReplaySubject();\n    const errorNotificationSubject = new rxjs_1.Subject();\n    const deriveNextLocalHDAccountSubject = new rxjs_1.Subject();\n    const addAccountByPrivateKeySubject = new rxjs_1.Subject();\n    const switchAccountSubject = new rxjs_1.Subject();\n    const tokenBalanceFetchSubject = new rxjs_1.Subject();\n    const stakingFetchSubject = new rxjs_1.Subject();\n    const wallet$ = walletSubject.asObservable();\n    const networkSubject = new rxjs_1.ReplaySubject();\n    const nativeTokenSubject = new rxjs_1.ReplaySubject();\n    let walletSubscription;\n    const coreAPIViaNode$ = nodeSubject\n        .asObservable()\n        .pipe((0, operators_1.map)((n) => (0, api_1.radixCoreAPI)(n, (0, api_1.nodeAPI)(n.url))));\n    const coreAPI$ = (0, rxjs_1.merge)(coreAPIViaNode$, coreAPISubject.asObservable()).pipe((0, operators_1.shareReplay)(1));\n    // Forwards calls to RadixCoreAPI, return type is a function: `(input?: I) => Observable<O>`\n    const fwdAPICall = (pickFn, errorFn) => (...input) => coreAPI$.pipe((0, operators_1.mergeMap)(a => pickFn(a)(...input)), (0, operators_1.take)(1), // Important!\n    (0, operators_1.catchError)((error) => {\n        throw errorFn((0, util_1.isArray)(error) ? error[0] : error);\n    }));\n    const api = {\n        networkId: fwdAPICall(a => a.networkId, m => (0, errors_1.networkIdErr)(m)),\n        tokenBalancesForAddress: fwdAPICall(a => a.tokenBalancesForAddress, m => (0, errors_1.tokenBalancesErr)(m)),\n        transactionHistory: fwdAPICall(a => a.transactionHistory, m => (0, errors_1.transactionHistoryErr)(m)),\n        recentTransactions: fwdAPICall(a => a.recentTransactions, m => (0, errors_1.recentTransactionsErr)(m)),\n        nativeToken: fwdAPICall(a => a.nativeToken, m => (0, errors_1.nativeTokenErr)(m)),\n        tokenInfo: fwdAPICall(a => a.tokenInfo, m => (0, _1.tokenInfoErr)(m)),\n        stakesForAddress: fwdAPICall(a => a.stakesForAddress, m => (0, errors_1.stakesForAddressErr)(m)),\n        unstakesForAddress: fwdAPICall(a => a.unstakesForAddress, m => (0, errors_1.unstakesForAddressErr)(m)),\n        validators: fwdAPICall(a => a.validators, m => (0, errors_1.validatorsErr)(m)),\n        lookupValidator: fwdAPICall(a => a.lookupValidator, m => (0, errors_1.lookupValidatorErr)(m)),\n        getTransaction: fwdAPICall(a => a.transactionStatus, m => (0, errors_1.lookupTxErr)(m)),\n        buildTransaction: fwdAPICall(a => a.buildTransaction, m => (0, errors_1.buildTxFromIntentErr)(m)),\n        finalizeTransaction: fwdAPICall(a => a.finalizeTransaction, m => (0, errors_1.finalizeTxErr)(m)),\n        submitSignedTransaction: fwdAPICall(a => a.submitSignedTransaction, m => (0, errors_1.submitSignedTxErr)(m)),\n    };\n    const activeAddress = wallet$.pipe((0, operators_1.mergeMap)(a => a.observeActiveAccount()), (0, operators_1.map)(a => a.address), (0, operators_1.shareReplay)(1));\n    const revealMnemonic = () => wallet$.pipe((0, operators_1.map)((wallet) => wallet.revealMnemonic()));\n    const activeAddressToAPIObservableWithTrigger = (trigger, pickFn, errorFn) => (0, rxjs_1.merge)(trigger.pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.map)(result => result[1])), activeAddress).pipe((0, operators_1.withLatestFrom)(coreAPI$), (0, operators_1.switchMap)(([address, api]) => pickFn(api)(address).pipe((0, operators_1.catchError)(error => {\n        console.error(error);\n        errorNotificationSubject.next(errorFn(error));\n        return rxjs_1.EMPTY;\n    }))), (0, operators_1.shareReplay)(1));\n    const tokenBalances = activeAddressToAPIObservableWithTrigger(tokenBalanceFetchSubject, a => a.tokenBalancesForAddress, errors_1.tokenBalancesErr);\n    /*\n        const decorateSimpleTokenBalanceWithTokenInfo = (\n            simpleTokenBalance: SimpleTokenBalance,\n        ): Observable<TokenBalance> =>\n            api.tokenInfo(simpleTokenBalance.tokenIdentifier).pipe(\n                map(\n                    (tokenInfo: Token): TokenBalance => ({\n                        amount: simpleTokenBalance.amount,\n                        token: tokenInfo,\n                    }),\n                ),\n            )\n    */\n    const stakingPositions = activeAddressToAPIObservableWithTrigger(stakingFetchSubject, a => a.stakesForAddress, errors_1.stakesForAddressErr);\n    const unstakingPositions = activeAddressToAPIObservableWithTrigger(stakingFetchSubject, a => a.unstakesForAddress, errors_1.unstakesForAddressErr);\n    const transactionHistory = (input) => activeAddress.pipe((0, operators_1.take)(1), (0, operators_1.switchMap)(activeAddress => api\n        .transactionHistory(Object.assign(Object.assign({}, input), { address: activeAddress }))\n        .pipe((0, operators_1.map)((simpleTxHistory) => (Object.assign(Object.assign({}, simpleTxHistory), { transactions: simpleTxHistory.transactions.map((simpleExecutedTX) => decorateSimpleExecutedTransactionWithType(simpleExecutedTX, activeAddress)) }))))));\n    const node$ = (0, rxjs_1.merge)(nodeSubject.asObservable(), coreAPISubject.asObservable().pipe((0, operators_1.map)(api => api.node)));\n    const activeAccount = wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.observeActiveAccount()), (0, operators_1.shareReplay)(1), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.equals(cur)));\n    const accounts = wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.observeAccounts()), (0, operators_1.shareReplay)(1));\n    const __makeTransactionFromIntent = (transactionIntent$, options) => {\n        var _a;\n        const txLog = radixLog; // TODO configure child loggers\n        const txSubs = new rxjs_1.Subscription();\n        txLog.debug(`Start of transaction flow, inside constructor of 'TransactionTracking'.`);\n        const signUnsignedTx = (unsignedTx) => {\n            txLog.debug('Starting signing transaction (async).');\n            return (0, rxjs_1.combineLatest)(transactionIntent$, activeAccount.pipe((0, operators_1.take)(1))).pipe((0, operators_1.mergeMap)(([transactionIntent, account,]) => {\n                const nonXRDHRPsOfRRIsInTx = transactionIntent.actions\n                    .filter(a => a.type === actions_1.ActionType.TOKEN_TRANSFER)\n                    .map(a => a)\n                    .filter(t => t.rri.name !== 'xrd')\n                    .map(t => t.rri.name);\n                const uniquenonXRDHRPsOfRRIsInTx = [\n                    ...new Set(nonXRDHRPsOfRRIsInTx),\n                ];\n                if (uniquenonXRDHRPsOfRRIsInTx.length > 1) {\n                    const errMsg = `Error cannot sign transction with multiple non-XRD RRIs. Unsupported by Ledger app.`;\n                    util_1.log.error(errMsg);\n                    return (0, rxjs_1.throwError)(new Error(errMsg));\n                }\n                const nonXRDHrp = uniquenonXRDHRPsOfRRIsInTx.length === 1\n                    ? uniquenonXRDHRPsOfRRIsInTx[0]\n                    : undefined;\n                return account\n                    .sign(unsignedTx.transaction, nonXRDHrp)\n                    .pipe((0, operators_1.map)((signature) => {\n                    const publicKeyOfSigner = account.publicKey;\n                    txLog.debug(`Finished signing transaction`);\n                    return {\n                        transaction: unsignedTx.transaction,\n                        signature,\n                        publicKeyOfSigner,\n                    };\n                }));\n            }));\n        };\n        const pendingTXSubject = new rxjs_1.Subject();\n        const askUserToConfirmSubject = new rxjs_1.ReplaySubject();\n        const userDidConfirmTransactionSubject = new rxjs_1.ReplaySubject();\n        if (shouldConfirmTransactionAutomatically(options.userConfirmation)) {\n            txLog.debug('Transaction has been setup to be automatically confirmed, requiring no final confirmation input from user.');\n            txSubs.add(askUserToConfirmSubject.subscribe(() => {\n                txLog.debug(`askUserToConfirmSubject got 'next', calling 'next' on 'userDidConfirmTransactionSubject'`);\n                userDidConfirmTransactionSubject.next(0);\n            }));\n        }\n        else {\n            txLog.debug(`Transaction has been setup so that it requires a manual final confirmation from user before being finalized.`);\n            const twoWayConfirmationSubject = options.userConfirmation;\n            txSubs.add(askUserToConfirmSubject.subscribe(ux => {\n                txLog.info(`Forwarding signedUnconfirmedTX and 'userDidConfirmTransactionSubject' to subject 'twoWayConfirmationSubject' now (inside subscribe to 'askUserToConfirmSubject')`);\n                const confirmation = {\n                    txToConfirm: ux,\n                    confirm: () => userDidConfirmTransactionSubject.next(0),\n                };\n                twoWayConfirmationSubject.next(confirmation);\n            }));\n        }\n        const trackingSubject = new rxjs_1.ReplaySubject();\n        const track = (event) => {\n            trackingSubject.next(event);\n        };\n        const completionSubject = new rxjs_1.Subject();\n        const trackError = (input) => {\n            const errorEvent = {\n                eventUpdateType: input.inStep,\n                error: input.error,\n            };\n            txLog.debug(`Forwarding error to 'errorSubject'`);\n            track(errorEvent);\n            completionSubject.error(errorEvent.error);\n        };\n        const builtTransaction$ = transactionIntent$.pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.switchMap)(([intent, address]) => {\n            txLog.debug('Transaction intent created => requesting 🛰 API to build it now.');\n            track({\n                transactionState: intent,\n                eventUpdateType: dto_1.TransactionTrackingEventType.INITIATED,\n            });\n            return api.buildTransaction(intent, address);\n        }), (0, operators_1.catchError)((e) => {\n            txLog.error(`API failed to build transaction`);\n            trackError({\n                error: e,\n                inStep: dto_1.TransactionTrackingEventType.BUILT_FROM_INTENT,\n            });\n            return rxjs_1.EMPTY;\n        }), (0, operators_1.tap)(builtTx => {\n            txLog.debug('TX built by API => asking for confirmation to sign...');\n            track({\n                transactionState: builtTx,\n                eventUpdateType: dto_1.TransactionTrackingEventType.BUILT_FROM_INTENT,\n            });\n            askUserToConfirmSubject.next(builtTx);\n        }), (0, operators_1.tap)(builtTx => {\n            track({\n                transactionState: builtTx,\n                eventUpdateType: dto_1.TransactionTrackingEventType.ASKED_FOR_CONFIRMATION,\n            });\n        }));\n        const signedTransaction$ = (0, rxjs_1.combineLatest)([\n            builtTransaction$,\n            userDidConfirmTransactionSubject,\n        ]).pipe((0, operators_1.map)(([signedTx, _]) => signedTx), (0, operators_1.tap)(unsignedTx => {\n            track({\n                transactionState: unsignedTx,\n                eventUpdateType: dto_1.TransactionTrackingEventType.CONFIRMED,\n            });\n        }), (0, operators_1.mergeMap)(unsignedTx => signUnsignedTx(unsignedTx)), (0, operators_1.shareReplay)(1), (0, operators_1.catchError)((e) => {\n            txLog.error(`API failed to sign transaction, error: ${JSON.stringify(e, null, 4)}`);\n            trackError({\n                error: e,\n                inStep: dto_1.TransactionTrackingEventType.SIGNED,\n            });\n            return rxjs_1.EMPTY;\n        }));\n        const finalizedTx$ = signedTransaction$.pipe((0, operators_1.mergeMap)((signedTx) => {\n            txLog.debug(`Finished signing tx => submitting it to 🛰  API.`);\n            track({\n                transactionState: signedTx,\n                eventUpdateType: dto_1.TransactionTrackingEventType.SIGNED,\n            });\n            return networkSubject.pipe((0, operators_1.mergeMap)(network => api.finalizeTransaction(network, signedTx)));\n        }), (0, operators_1.catchError)((e) => {\n            txLog.error(`API failed to submit transaction, error: ${JSON.stringify(e, null, 4)}`);\n            trackError({\n                error: e,\n                inStep: dto_1.TransactionTrackingEventType.FINALIZED,\n            });\n            return rxjs_1.EMPTY;\n        }), (0, operators_1.tap)(finalizedTx => {\n            track({\n                transactionState: finalizedTx,\n                eventUpdateType: dto_1.TransactionTrackingEventType.FINALIZED,\n            });\n        }));\n        txSubs.add(finalizedTx$\n            .pipe((0, operators_1.mergeMap)((finalizedTx) => networkSubject.pipe((0, operators_1.mergeMap)(network => api.submitSignedTransaction(network, {\n            blob: finalizedTx.blob,\n            txID: finalizedTx.txID,\n        })))), (0, operators_1.catchError)((e) => {\n            txLog.error(`API failed to submit transaction, error: ${JSON.stringify(e, null, 4)}`);\n            trackError({\n                error: e,\n                inStep: dto_1.TransactionTrackingEventType.SUBMITTED,\n            });\n            return rxjs_1.EMPTY;\n        }), (0, operators_1.tap)({\n            next: (pendingTx) => {\n                txLog.debug(`Submitted transaction with txID='${pendingTx.txID.toString()}', it is now pending.`);\n                track({\n                    transactionState: pendingTx,\n                    eventUpdateType: dto_1.TransactionTrackingEventType.SUBMITTED,\n                });\n                pendingTXSubject.next(pendingTx);\n            },\n            error: (submitTXError) => {\n                // TODO would be great to have access to txID here, hopefully API includes it in error msg?\n                txLog.error(`Submission of signed transaction to API failed with error: ${submitTXError.message}`);\n                pendingTXSubject.error(submitTXError);\n            },\n        }))\n            .subscribe());\n        const pollTxStatusTrigger = ((_a = options.pollTXStatusTrigger) !== null && _a !== void 0 ? _a : (0, rxjs_1.interval)(1000)).pipe((0, operators_1.share)());\n        const transactionStatus$ = (0, rxjs_1.combineLatest)([\n            pollTxStatusTrigger,\n            pendingTXSubject,\n        ]).pipe((0, operators_1.mergeMap)(([_, pendingTx]) => {\n            txLog.debug(`Asking API for status of transaction with txID: ${pendingTx.txID.toString()}`);\n            return networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(pendingTx.txID, network).pipe((0, operators_1.retryWhen)((0, utils_1.retryOnErrorCode)({\n                maxRetryAttempts: 3,\n                errorCodes: [404],\n            })))));\n        }), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.status === cur.status), (0, operators_1.share)());\n        const transactionCompletedWithStatusConfirmed$ = transactionStatus$.pipe((0, operators_1.skipWhile)(({ status }) => status !== dto_1.TransactionStatus.CONFIRMED), (0, operators_1.take)(1));\n        const transactionCompletedWithStatusFailed$ = transactionStatus$.pipe((0, operators_1.skipWhile)(({ status }) => status !== dto_1.TransactionStatus.FAILED), (0, operators_1.take)(1));\n        txSubs.add(transactionStatus$.subscribe({\n            next: statusOfTransaction => {\n                const { status, txID } = statusOfTransaction;\n                txLog.debug(`Status ${status.toString()} of transaction with txID='${txID.toString()}'`);\n                track({\n                    transactionState: statusOfTransaction,\n                    eventUpdateType: dto_1.TransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX,\n                });\n            },\n            error: (transactionStatusError) => {\n                // TODO hmm how to get txID here?\n                txLog.error(`Failed to get status of transaction`, transactionStatusError);\n            },\n        }));\n        txSubs.add(transactionCompletedWithStatusConfirmed$.subscribe({\n            next: statusOfTransaction => {\n                const { txID } = statusOfTransaction;\n                txLog.info(`Transaction with txID='${txID.toString()}' has completed succesfully.`);\n                track({\n                    transactionState: statusOfTransaction,\n                    eventUpdateType: dto_1.TransactionTrackingEventType.COMPLETED,\n                });\n                completionSubject.next(txID);\n                completionSubject.complete();\n                txSubs.unsubscribe();\n            },\n        }));\n        txSubs.add(transactionCompletedWithStatusFailed$.subscribe(status => {\n            const errMsg = `API status of tx with id=${status.txID.toString()} returned 'FAILED'`;\n            txLog.error(errMsg);\n            trackError({\n                error: new Error(errMsg),\n                inStep: dto_1.TransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX,\n            });\n            txSubs.unsubscribe();\n        }));\n        return {\n            completion: completionSubject.asObservable(),\n            events: trackingSubject.asObservable(),\n        };\n    };\n    const __makeTransactionFromBuilder = (transactionIntentBuilderT, makeTXOptions, builderOptions) => {\n        radixLog.debug(`make transaction from builder`);\n        const intent$ = transactionIntentBuilderT.build(builderOptions !== null && builderOptions !== void 0 ? builderOptions : {\n            skipEncryptionOfMessageIfAny: {\n                spendingSender: activeAddress.pipe((0, operators_1.take)(1)), // IMPORTANT !\n            },\n        });\n        return __makeTransactionFromIntent(intent$, makeTXOptions);\n    };\n    const transferTokens = (input) => {\n        radixLog.debug(`transferTokens`);\n        const builder = dto_1.TransactionIntentBuilder.create().transferTokens(input.transferInput);\n        let encryptMsgIfAny = false;\n        if (input.message) {\n            builder.message(input.message);\n            encryptMsgIfAny = input.message.encrypt;\n        }\n        return __makeTransactionFromBuilder(builder, Object.assign({}, input), encryptMsgIfAny\n            ? {\n                encryptMessageIfAnyWithAccount: activeAccount.pipe((0, operators_1.take)(1)),\n            }\n            : undefined);\n    };\n    const stakeTokens = (input) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n        radixLog.debug('stake');\n        const nativeToken = yield (0, rxjs_1.firstValueFrom)(nativeTokenSubject);\n        return __makeTransactionFromBuilder(dto_1.TransactionIntentBuilder.create().stakeTokens(Object.assign(Object.assign({}, input.stakeInput), { tokenIdentifier: nativeToken.rri })), Object.assign({}, input));\n    });\n    const unstakeTokens = (input) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n        radixLog.debug('unstake');\n        const nativeToken = yield (0, rxjs_1.firstValueFrom)(nativeTokenSubject);\n        return __makeTransactionFromBuilder(dto_1.TransactionIntentBuilder.create().unstakeTokens(Object.assign(Object.assign({}, input.unstakeInput), { tokenIdentifier: nativeToken.rri })), Object.assign({}, input));\n    });\n    const decryptTransaction = (input) => {\n        radixLog.debug(`Trying to decrypt transaction with txID=${input.txID.toString()}`);\n        if (!input.message) {\n            const noMsg = `TX contains no message, nothing to decrypt (txID=${input.txID.toString()}).`;\n            radixLog.info(noMsg);\n            return (0, rxjs_1.throwError)(() => new Error(noMsg));\n        }\n        const messageBuffer = Buffer.from(input.message, 'hex');\n        const encryptedMessageResult = crypto_1.Message.fromBuffer(messageBuffer);\n        if (!encryptedMessageResult.isOk()) {\n            const errMessage = `Failed to parse message as 'EncryptedMessage' type, underlying error: '${(0, util_1.msgFromError)(encryptedMessageResult.error)}'. Might not have been encrypted? Try decode string as UTF-8 string.`;\n            util_1.log.warn(errMessage);\n            return (0, rxjs_1.throwError)(new Error(errMessage));\n        }\n        const encryptedMessage = encryptedMessageResult.value;\n        if (encryptedMessage.kind !== 'ENCRYPTED')\n            return (0, rxjs_1.of)(encryptedMessage.plaintext);\n        return activeAccount.pipe((0, operators_1.take)(1), (0, operators_1.mergeMap)((account) => {\n            const myPublicKey = account.publicKey;\n            util_1.log.debug(`Trying to decrypt message with activeSigningKey with pubKey=${myPublicKey.toString()}`);\n            const publicKeyOfOtherPartyResult = (0, dto_1.singleRecipientFromActions)(myPublicKey, input.actions);\n            if (!publicKeyOfOtherPartyResult.isOk()) {\n                return (0, rxjs_1.throwError)(new Error((0, util_1.msgFromError)(publicKeyOfOtherPartyResult.error)));\n            }\n            util_1.log.debug(`Trying to decrypt message with publicKeyOfOtherPartyResult=${publicKeyOfOtherPartyResult.toString()}`);\n            return account.decrypt({\n                encryptedMessage,\n                publicKeyOfOtherParty: publicKeyOfOtherPartyResult.value,\n            });\n        }), (0, operators_1.take)(1));\n    };\n    const restoreLocalHDAccountsToIndex = (index) => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.restoreLocalHDAccountsToIndex(index)));\n    subs.add(deriveNextLocalHDAccountSubject\n        .pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.mergeMap)(([derivation, wallet]) => wallet.deriveNextLocalHDAccount(derivation)))\n        .subscribe());\n    subs.add(addAccountByPrivateKeySubject\n        .pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.mergeMap)(([privateKeyInput, wallet]) => wallet.addAccountFromPrivateKey(privateKeyInput)))\n        .subscribe());\n    subs.add(switchAccountSubject\n        .pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.tap)(([switchTo, wallet]) => wallet.switchAccount(switchTo)))\n        .subscribe());\n    let headerSub;\n    const methods = {\n        // we forward the full `RadixAPI`, but we also provide some convenience methods based on active account/address.\n        ledger: Object.assign({}, api),\n        __wallet: wallet$,\n        __node: node$,\n        __reset: () => subs.unsubscribe(),\n        // Primarily useful for testing\n        __withNodeConnection: (node$) => {\n            subs.add(node$.subscribe(n => {\n                radixLog.debug(`Using node ${n.url.toString()}`);\n                nodeSubject.next(n);\n            }, (error) => {\n                errorNotificationSubject.next((0, errors_1.nodeError)(error));\n            }));\n            return methods;\n        },\n        __withAPI: (radixCoreAPI$) => {\n            subs.add(radixCoreAPI$.subscribe(a => coreAPISubject.next(a)));\n            return methods;\n        },\n        __withWallet: (wallet) => {\n            walletSubject.next(wallet);\n            return methods;\n        },\n        __withKeychain: (signingKeychain) => {\n            (0, rxjs_1.firstValueFrom)(networkSubject).then(network => {\n                const wallet = wallet_1.Wallet.create({\n                    signingKeychain,\n                    network,\n                });\n                methods.__withWallet(wallet);\n            });\n            return methods;\n        },\n        connect: (url) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n            methods.__withNodeConnection((0, rxjs_1.of)({ url: new URL(url) }));\n            const networkId = yield (0, rxjs_1.firstValueFrom)(api.networkId());\n            const nativeToken = yield (0, rxjs_1.firstValueFrom)(api.nativeToken(networkId));\n            networkSubject.next(networkId);\n            nativeTokenSubject.next(nativeToken);\n        }),\n        login: (password, loadKeystore) => {\n            walletSubscription === null || walletSubscription === void 0 ? void 0 : walletSubscription.unsubscribe();\n            void account_1.SigningKeychain.byLoadingAndDecryptingKeystore({\n                password,\n                load: loadKeystore,\n            }).then(signingKeychainResult => {\n                signingKeychainResult.match((signingKeychain) => {\n                    walletSubscription = networkSubject.subscribe(network => {\n                        const wallet = wallet_1.Wallet.create({\n                            signingKeychain,\n                            network,\n                        });\n                        methods.__withWallet(wallet);\n                    });\n                }, error => {\n                    errorNotificationSubject.next((0, errors_1.walletError)(error));\n                });\n            });\n            return methods;\n        },\n        errors: errorNotificationSubject.asObservable(),\n        deriveNextAccount: (input) => {\n            const derivation = input !== null && input !== void 0 ? input : {};\n            deriveNextLocalHDAccountSubject.next(derivation);\n            return methods;\n        },\n        deriveHWAccount: (input) => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.deriveHWAccount(input))),\n        displayAddressForActiveHWAccountOnHWDeviceForVerification: () => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.displayAddressForActiveHWAccountOnHWDeviceForVerification())),\n        addAccountFromPrivateKey: (input) => {\n            addAccountByPrivateKeySubject.next(input);\n            return methods;\n        },\n        switchAccount: (input) => {\n            switchAccountSubject.next(input);\n            return methods;\n        },\n        restoreLocalHDAccountsToIndex,\n        decryptTransaction: decryptTransaction,\n        logLevel: (level) => {\n            util_1.log.setLevel(level);\n            return methods;\n        },\n        transactionStatus: (txID, trigger) => trigger.pipe((0, operators_1.withLatestFrom)(networkSubject), (0, operators_1.mergeMap)(([_, network]) => api.getTransaction(txID, network)), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.status === cur.status), (0, operators_1.filter)(({ txID }) => txID.equals(txID)), (0, operators_1.tap)(({ status }) => radixLog.info(`Got transaction status ${status.toString()} for txID: ${txID.toString()}`))),\n        withTokenBalanceFetchTrigger: (trigger) => {\n            subs.add(trigger.subscribe(tokenBalanceFetchSubject));\n            return methods;\n        },\n        withStakingFetchTrigger: (trigger) => {\n            subs.add(trigger.subscribe(stakingFetchSubject));\n            return methods;\n        },\n        // Wallet APIs\n        revealMnemonic,\n        activeAddress,\n        activeAccount,\n        accounts,\n        // Active AccountAddress/Account APIs\n        tokenBalances,\n        stakingPositions,\n        unstakingPositions,\n        lookupTransaction: (txID) => networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(txID, network).pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.map)(([simpleTx, aa]) => decorateSimpleExecutedTransactionWithType(simpleTx, aa))))),\n        transactionHistory,\n        transferTokens,\n        stakeTokens,\n        unstakeTokens,\n        getTransaction: (txID) => networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(txID, network))),\n        validators: () => networkSubject.pipe((0, operators_1.mergeMap)(network => api.validators(network))),\n        setHeaders: (headers) => {\n            headerSub.unsubscribe();\n            headerSub = coreAPI$.subscribe(api => api.setHeaders(headers));\n        },\n        targetApiVersion: networking_1.apiVersion,\n    };\n    return methods;\n};\nexports.Radix = {\n    create,\n};\n//# sourceMappingURL=radix.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}