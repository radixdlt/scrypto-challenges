{"ast":null,"code":"/**\n * Simple binary search tree\n */\nvar customUtils = require('./customUtils');\n\n/**\n * Constructor\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction BinarySearchTree(options) {\n  options = options || {};\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) {\n    this.key = options.key;\n  }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n// ================================\n// Methods used to test the tree\n// ================================\n\n/**\n * Get the descendant with max key\n */\nBinarySearchTree.prototype.getMaxKeyDescendant = function () {\n  if (this.right) {\n    return this.right.getMaxKeyDescendant();\n  } else {\n    return this;\n  }\n};\n\n/**\n * Get the maximum key\n */\nBinarySearchTree.prototype.getMaxKey = function () {\n  return this.getMaxKeyDescendant().key;\n};\n\n/**\n * Get the descendant with min key\n */\nBinarySearchTree.prototype.getMinKeyDescendant = function () {\n  if (this.left) {\n    return this.left.getMinKeyDescendant();\n  } else {\n    return this;\n  }\n};\n\n/**\n * Get the minimum key\n */\nBinarySearchTree.prototype.getMinKey = function () {\n  return this.getMinKeyDescendant().key;\n};\n\n/**\n * Check that all nodes (incl. leaves) fullfil condition given by fn\n * test is a function passed every (key, data) and which throws if the condition is not met\n */\nBinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n  test(this.key, this.data);\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(test);\n  }\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(test);\n  }\n};\n\n/**\n * Check that the core BST properties on node ordering are verified\n * Throw if they aren't\n */\nBinarySearchTree.prototype.checkNodeOrdering = function () {\n  var self = this;\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) >= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.left.checkNodeOrdering();\n  }\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) <= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.right.checkNodeOrdering();\n  }\n};\n\n/**\n * Check that all pointers are coherent in this tree\n */\nBinarySearchTree.prototype.checkInternalPointers = function () {\n  if (this.left) {\n    if (this.left.parent !== this) {\n      throw new Error('Parent pointer broken for key ' + this.key);\n    }\n    this.left.checkInternalPointers();\n  }\n  if (this.right) {\n    if (this.right.parent !== this) {\n      throw new Error('Parent pointer broken for key ' + this.key);\n    }\n    this.right.checkInternalPointers();\n  }\n};\n\n/**\n * Check that a tree is a BST as defined here (node ordering and pointer references)\n */\nBinarySearchTree.prototype.checkIsBST = function () {\n  this.checkNodeOrdering();\n  this.checkInternalPointers();\n  if (this.parent) {\n    throw new Error(\"The root shouldn't have a parent\");\n  }\n};\n\n/**\n * Get number of keys inserted\n */\nBinarySearchTree.prototype.getNumberOfKeys = function () {\n  var res;\n  if (!this.hasOwnProperty('key')) {\n    return 0;\n  }\n  res = 1;\n  if (this.left) {\n    res += this.left.getNumberOfKeys();\n  }\n  if (this.right) {\n    res += this.right.getNumberOfKeys();\n  }\n  return res;\n};\n\n// ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n/**\n * Create a BST similar (i.e. same options except for key and value) to the current one\n * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n * @param {Object} options see constructor\n */\nBinarySearchTree.prototype.createSimilar = function (options) {\n  options = options || {};\n  options.unique = this.unique;\n  options.compareKeys = this.compareKeys;\n  options.checkValueEquality = this.checkValueEquality;\n  return new this.constructor(options);\n};\n\n/**\n * Create the left child of this BST and return it\n */\nBinarySearchTree.prototype.createLeftChild = function (options) {\n  var leftChild = this.createSimilar(options);\n  leftChild.parent = this;\n  this.left = leftChild;\n  return leftChild;\n};\n\n/**\n * Create the right child of this BST and return it\n */\nBinarySearchTree.prototype.createRightChild = function (options) {\n  var rightChild = this.createSimilar(options);\n  rightChild.parent = this;\n  this.right = rightChild;\n  return rightChild;\n};\n\n/**\n * Insert a new element\n */\nBinarySearchTree.prototype.insert = function (key, value) {\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    return;\n  }\n\n  // Same key as root\n  if (this.compareKeys(this.key, key) === 0) {\n    if (this.unique) {\n      var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n      err.key = key;\n      err.errorType = 'uniqueViolated';\n      throw err;\n    } else {\n      this.data.push(value);\n    }\n    return;\n  }\n  if (this.compareKeys(key, this.key) < 0) {\n    // Insert in left subtree\n    if (this.left) {\n      this.left.insert(key, value);\n    } else {\n      this.createLeftChild({\n        key: key,\n        value: value\n      });\n    }\n  } else {\n    // Insert in right subtree\n    if (this.right) {\n      this.right.insert(key, value);\n    } else {\n      this.createRightChild({\n        key: key,\n        value: value\n      });\n    }\n  }\n};\n\n/**\n * Search for all data corresponding to a key\n */\nBinarySearchTree.prototype.search = function (key) {\n  if (!this.hasOwnProperty('key')) {\n    return [];\n  }\n  if (this.compareKeys(this.key, key) === 0) {\n    return this.data;\n  }\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      return this.left.search(key);\n    } else {\n      return [];\n    }\n  } else {\n    if (this.right) {\n      return this.right.search(key);\n    } else {\n      return [];\n    }\n  }\n};\n\n/**\n * Return a function that tells whether a given key matches a lower bound\n */\nBinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {\n    return function () {\n      return true;\n    };\n  }\n  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {\n    if (self.compareKeys(query.$gte, query.$gt) === 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$gt) > 0;\n      };\n    }\n    if (self.compareKeys(query.$gte, query.$gt) > 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$gte) >= 0;\n      };\n    } else {\n      return function (key) {\n        return self.compareKeys(key, query.$gt) > 0;\n      };\n    }\n  }\n  if (query.hasOwnProperty('$gt')) {\n    return function (key) {\n      return self.compareKeys(key, query.$gt) > 0;\n    };\n  } else {\n    return function (key) {\n      return self.compareKeys(key, query.$gte) >= 0;\n    };\n  }\n};\n\n/**\n * Return a function that tells whether a given key matches an upper bound\n */\nBinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {\n    return function () {\n      return true;\n    };\n  }\n  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {\n    if (self.compareKeys(query.$lte, query.$lt) === 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$lt) < 0;\n      };\n    }\n    if (self.compareKeys(query.$lte, query.$lt) < 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$lte) <= 0;\n      };\n    } else {\n      return function (key) {\n        return self.compareKeys(key, query.$lt) < 0;\n      };\n    }\n  }\n  if (query.hasOwnProperty('$lt')) {\n    return function (key) {\n      return self.compareKeys(key, query.$lt) < 0;\n    };\n  } else {\n    return function (key) {\n      return self.compareKeys(key, query.$lte) <= 0;\n    };\n  }\n};\n\n// Append all elements in toAppend to array\nfunction append(array, toAppend) {\n  var i;\n  for (i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n\n/**\n * Get all data for a key between bounds\n * Return it in key order\n * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n */\nBinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n  var res = [];\n  if (!this.hasOwnProperty('key')) {\n    return [];\n  } // Empty tree\n\n  lbm = lbm || this.getLowerBoundMatcher(query);\n  ubm = ubm || this.getUpperBoundMatcher(query);\n  if (lbm(this.key) && this.left) {\n    append(res, this.left.betweenBounds(query, lbm, ubm));\n  }\n  if (lbm(this.key) && ubm(this.key)) {\n    append(res, this.data);\n  }\n  if (ubm(this.key) && this.right) {\n    append(res, this.right.betweenBounds(query, lbm, ubm));\n  }\n  return res;\n};\n\n/**\n * Delete the current node if it is a leaf\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfLeaf = function () {\n  if (this.left || this.right) {\n    return false;\n  }\n\n  // The leaf is itself a root\n  if (!this.parent) {\n    delete this.key;\n    this.data = [];\n    return true;\n  }\n  if (this.parent.left === this) {\n    this.parent.left = null;\n  } else {\n    this.parent.right = null;\n  }\n  return true;\n};\n\n/**\n * Delete the current node if it has only one child\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n  var child;\n  if (this.left && !this.right) {\n    child = this.left;\n  }\n  if (!this.left && this.right) {\n    child = this.right;\n  }\n  if (!child) {\n    return false;\n  }\n\n  // Root\n  if (!this.parent) {\n    this.key = child.key;\n    this.data = child.data;\n    this.left = null;\n    if (child.left) {\n      this.left = child.left;\n      child.left.parent = this;\n    }\n    this.right = null;\n    if (child.right) {\n      this.right = child.right;\n      child.right.parent = this;\n    }\n    return true;\n  }\n  if (this.parent.left === this) {\n    this.parent.left = child;\n    child.parent = this.parent;\n  } else {\n    this.parent.right = child;\n    child.parent = this.parent;\n  }\n  return true;\n};\n\n/**\n * Delete a key or just a value\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\nBinarySearchTree.prototype.delete = function (key, value) {\n  var newData = [],\n    replaceWith,\n    self = this;\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      this.left.delete(key, value);\n    }\n    return;\n  }\n  if (this.compareKeys(key, this.key) > 0) {\n    if (this.right) {\n      this.right.delete(key, value);\n    }\n    return;\n  }\n  if (!this.compareKeys(key, this.key) === 0) {\n    return;\n  }\n\n  // Delete only a value\n  if (this.data.length > 1 && value !== undefined) {\n    this.data.forEach(function (d) {\n      if (!self.checkValueEquality(d, value)) {\n        newData.push(d);\n      }\n    });\n    self.data = newData;\n    return;\n  }\n\n  // Delete the whole node\n  if (this.deleteIfLeaf()) {\n    return;\n  }\n  if (this.deleteIfOnlyOneChild()) {\n    return;\n  }\n\n  // We are in the case where the node to delete has two children\n  if (Math.random() >= 0.5) {\n    // Randomize replacement to avoid unbalancing the tree too much\n    // Use the in-order predecessor\n    replaceWith = this.left.getMaxKeyDescendant();\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n    if (this === replaceWith.parent) {\n      // Special case\n      this.left = replaceWith.left;\n      if (replaceWith.left) {\n        replaceWith.left.parent = replaceWith.parent;\n      }\n    } else {\n      replaceWith.parent.right = replaceWith.left;\n      if (replaceWith.left) {\n        replaceWith.left.parent = replaceWith.parent;\n      }\n    }\n  } else {\n    // Use the in-order successor\n    replaceWith = this.right.getMinKeyDescendant();\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n    if (this === replaceWith.parent) {\n      // Special case\n      this.right = replaceWith.right;\n      if (replaceWith.right) {\n        replaceWith.right.parent = replaceWith.parent;\n      }\n    } else {\n      replaceWith.parent.left = replaceWith.right;\n      if (replaceWith.right) {\n        replaceWith.right.parent = replaceWith.parent;\n      }\n    }\n  }\n};\n\n/**\n * Execute a function on every node of the tree, in key order\n * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n */\nBinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n  if (this.left) {\n    this.left.executeOnEveryNode(fn);\n  }\n  fn(this);\n  if (this.right) {\n    this.right.executeOnEveryNode(fn);\n  }\n};\n\n/**\n * Pretty print a tree\n * @param {Boolean} printData To print the nodes' data along with the key\n */\nBinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n  spacing = spacing || \"\";\n  console.log(spacing + \"* \" + this.key);\n  if (printData) {\n    console.log(spacing + \"* \" + this.data);\n  }\n  if (!this.left && !this.right) {\n    return;\n  }\n  if (this.left) {\n    this.left.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n  if (this.right) {\n    this.right.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n};\n\n// Interface\nmodule.exports = BinarySearchTree;","map":{"version":3,"names":["customUtils","require","BinarySearchTree","options","left","right","parent","undefined","hasOwnProperty","key","data","value","unique","compareKeys","defaultCompareKeysFunction","checkValueEquality","defaultCheckValueEquality","prototype","getMaxKeyDescendant","getMaxKey","getMinKeyDescendant","getMinKey","checkAllNodesFullfillCondition","test","checkNodeOrdering","self","k","Error","checkInternalPointers","checkIsBST","getNumberOfKeys","res","createSimilar","constructor","createLeftChild","leftChild","createRightChild","rightChild","insert","push","err","errorType","search","getLowerBoundMatcher","query","$gte","$gt","getUpperBoundMatcher","$lte","$lt","append","array","toAppend","i","length","betweenBounds","lbm","ubm","deleteIfLeaf","deleteIfOnlyOneChild","child","delete","newData","replaceWith","forEach","d","Math","random","executeOnEveryNode","fn","prettyPrint","printData","spacing","console","log","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/binary-search-tree/lib/bst.js"],"sourcesContent":["/**\n * Simple binary search tree\n */\nvar customUtils = require('./customUtils');\n\n\n/**\n * Constructor\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction BinarySearchTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n// ================================\n// Methods used to test the tree\n// ================================\n\n\n/**\n * Get the descendant with max key\n */\nBinarySearchTree.prototype.getMaxKeyDescendant = function () {\n  if (this.right) {\n    return this.right.getMaxKeyDescendant();\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the maximum key\n */\nBinarySearchTree.prototype.getMaxKey = function () {\n  return this.getMaxKeyDescendant().key;\n};\n\n\n/**\n * Get the descendant with min key\n */\nBinarySearchTree.prototype.getMinKeyDescendant = function () {\n  if (this.left) {\n    return this.left.getMinKeyDescendant()\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the minimum key\n */\nBinarySearchTree.prototype.getMinKey = function () {\n  return this.getMinKeyDescendant().key;\n};\n\n\n/**\n * Check that all nodes (incl. leaves) fullfil condition given by fn\n * test is a function passed every (key, data) and which throws if the condition is not met\n */\nBinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n  if (!this.hasOwnProperty('key')) { return; }\n\n  test(this.key, this.data);\n  if (this.left) { this.left.checkAllNodesFullfillCondition(test); }\n  if (this.right) { this.right.checkAllNodesFullfillCondition(test); }\n};\n\n\n/**\n * Check that the core BST properties on node ordering are verified\n * Throw if they aren't\n */\nBinarySearchTree.prototype.checkNodeOrdering = function () {\n  var self = this;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) >= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.left.checkNodeOrdering();\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) <= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.right.checkNodeOrdering();\n  }\n};\n\n\n/**\n * Check that all pointers are coherent in this tree\n */\nBinarySearchTree.prototype.checkInternalPointers = function () {\n  if (this.left) {\n    if (this.left.parent !== this) { throw new Error('Parent pointer broken for key ' + this.key); }\n    this.left.checkInternalPointers();\n  }\n\n  if (this.right) {\n    if (this.right.parent !== this) { throw new Error('Parent pointer broken for key ' + this.key); }\n    this.right.checkInternalPointers();\n  }\n};\n\n\n/**\n * Check that a tree is a BST as defined here (node ordering and pointer references)\n */\nBinarySearchTree.prototype.checkIsBST = function () {\n  this.checkNodeOrdering();\n  this.checkInternalPointers();\n  if (this.parent) { throw new Error(\"The root shouldn't have a parent\"); }\n};\n\n\n/**\n * Get number of keys inserted\n */\nBinarySearchTree.prototype.getNumberOfKeys = function () {\n  var res;\n\n  if (!this.hasOwnProperty('key')) { return 0; }\n\n  res = 1;\n  if (this.left) { res += this.left.getNumberOfKeys(); }\n  if (this.right) { res += this.right.getNumberOfKeys(); }\n\n  return res;\n};\n\n\n\n// ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n/**\n * Create a BST similar (i.e. same options except for key and value) to the current one\n * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n * @param {Object} options see constructor\n */\nBinarySearchTree.prototype.createSimilar = function (options) {\n  options = options || {};\n  options.unique = this.unique;\n  options.compareKeys = this.compareKeys;\n  options.checkValueEquality = this.checkValueEquality;\n\n  return new this.constructor(options);\n};\n\n\n/**\n * Create the left child of this BST and return it\n */\nBinarySearchTree.prototype.createLeftChild = function (options) {\n  var leftChild = this.createSimilar(options);\n  leftChild.parent = this;\n  this.left = leftChild;\n\n  return leftChild;\n};\n\n\n/**\n * Create the right child of this BST and return it\n */\nBinarySearchTree.prototype.createRightChild = function (options) {\n  var rightChild = this.createSimilar(options);\n  rightChild.parent = this;\n  this.right = rightChild;\n\n  return rightChild;\n};\n\n\n/**\n * Insert a new element\n */\nBinarySearchTree.prototype.insert = function (key, value) {\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    return;\n  }\n\n  // Same key as root\n  if (this.compareKeys(this.key, key) === 0) {\n    if (this.unique) {\n      var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n      err.key = key;\n      err.errorType = 'uniqueViolated';\n      throw err;\n    } else {\n      this.data.push(value);\n    }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    // Insert in left subtree\n    if (this.left) {\n      this.left.insert(key, value);\n    } else {\n      this.createLeftChild({ key: key, value: value });\n    }\n  } else {\n    // Insert in right subtree\n    if (this.right) {\n      this.right.insert(key, value);\n    } else {\n      this.createRightChild({ key: key, value: value });\n    }\n  }\n};\n\n\n/**\n * Search for all data corresponding to a key\n */\nBinarySearchTree.prototype.search = function (key) {\n  if (!this.hasOwnProperty('key')) { return []; }\n\n  if (this.compareKeys(this.key, key) === 0) { return this.data; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      return this.left.search(key);\n    } else {\n      return [];\n    }\n  } else {\n    if (this.right) {\n      return this.right.search(key);\n    } else {\n      return [];\n    }\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches a lower bound\n */\nBinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {\n    if (self.compareKeys(query.$gte, query.$gt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n\n    if (self.compareKeys(query.$gte, query.$gt) > 0) {\n      return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$gt')) {\n    return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches an upper bound\n */\nBinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {\n    if (self.compareKeys(query.$lte, query.$lt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n\n    if (self.compareKeys(query.$lte, query.$lt) < 0) {\n      return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$lt')) {\n    return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n  }\n};\n\n\n// Append all elements in toAppend to array\nfunction append (array, toAppend) {\n  var i;\n\n  for (i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n\n\n/**\n * Get all data for a key between bounds\n * Return it in key order\n * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n */\nBinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n  var res = [];\n\n  if (!this.hasOwnProperty('key')) { return []; }   // Empty tree\n\n  lbm = lbm || this.getLowerBoundMatcher(query);\n  ubm = ubm || this.getUpperBoundMatcher(query);\n\n  if (lbm(this.key) && this.left) { append(res, this.left.betweenBounds(query, lbm, ubm)); }\n  if (lbm(this.key) && ubm(this.key)) { append(res, this.data); }\n  if (ubm(this.key) && this.right) { append(res, this.right.betweenBounds(query, lbm, ubm)); }\n\n  return res;\n};\n\n\n/**\n * Delete the current node if it is a leaf\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfLeaf = function () {\n  if (this.left || this.right) { return false; }\n\n  // The leaf is itself a root\n  if (!this.parent) {\n    delete this.key;\n    this.data = [];\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = null;\n  } else {\n    this.parent.right = null;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete the current node if it has only one child\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n  var child;\n\n  if (this.left && !this.right) { child = this.left; }\n  if (!this.left && this.right) { child = this.right; }\n  if (!child) { return false; }\n\n  // Root\n  if (!this.parent) {\n    this.key = child.key;\n    this.data = child.data;\n\n    this.left = null;\n    if (child.left) {\n      this.left = child.left;\n      child.left.parent = this;\n    }\n\n    this.right = null;\n    if (child.right) {\n      this.right = child.right;\n      child.right.parent = this;\n    }\n\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = child;\n    child.parent = this.parent;\n  } else {\n    this.parent.right = child;\n    child.parent = this.parent;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete a key or just a value\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\nBinarySearchTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    ;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) { this.left.delete(key, value); }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) > 0) {\n    if (this.right) { this.right.delete(key, value); }\n    return;\n  }\n\n  if (!this.compareKeys(key, this.key) === 0) { return; }\n\n  // Delete only a value\n  if (this.data.length > 1 && value !== undefined) {\n    this.data.forEach(function (d) {\n      if (!self.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    self.data = newData;\n    return;\n  }\n\n  // Delete the whole node\n  if (this.deleteIfLeaf()) {\n    return;\n  }\n  if (this.deleteIfOnlyOneChild()) {\n    return;\n  }\n\n  // We are in the case where the node to delete has two children\n  if (Math.random() >= 0.5) {   // Randomize replacement to avoid unbalancing the tree too much\n    // Use the in-order predecessor\n    replaceWith = this.left.getMaxKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.left = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.right = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    }\n  } else {\n    // Use the in-order successor\n    replaceWith = this.right.getMinKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.right = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.left = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    }\n  }\n};\n\n\n/**\n * Execute a function on every node of the tree, in key order\n * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n */\nBinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n  if (this.left) { this.left.executeOnEveryNode(fn); }\n  fn(this);\n  if (this.right) { this.right.executeOnEveryNode(fn); }\n};\n\n\n/**\n * Pretty print a tree\n * @param {Boolean} printData To print the nodes' data along with the key\n */\nBinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n  spacing = spacing || \"\";\n\n  console.log(spacing + \"* \" + this.key);\n  if (printData) { console.log(spacing + \"* \" + this.data); }\n\n  if (!this.left && !this.right) { return; }\n\n  if (this.left) {\n    this.left.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n  if (this.right) {\n    this.right.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n};\n\n\n\n\n// Interface\nmodule.exports = BinarySearchTree;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}