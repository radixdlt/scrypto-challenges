{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nexport function take(count) {\n  return function (source) {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\nvar TakeOperator = /*@__PURE__*/function () {\n  function TakeOperator(total) {\n    this.total = total;\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError();\n    }\n  }\n  TakeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  };\n  return TakeOperator;\n}();\nvar TakeSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(TakeSubscriber, _super);\n  function TakeSubscriber(destination, total) {\n    var _this = _super.call(this, destination) || this;\n    _this.total = total;\n    _this.count = 0;\n    return _this;\n  }\n  TakeSubscriber.prototype._next = function (value) {\n    var total = this.total;\n    var count = ++this.count;\n    if (count <= total) {\n      this.destination.next(value);\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  };\n  return TakeSubscriber;\n}(Subscriber);","map":{"version":3,"names":["tslib_1","Subscriber","ArgumentOutOfRangeError","empty","take","count","source","lift","TakeOperator","total","prototype","call","subscriber","subscribe","TakeSubscriber","_super","__extends","destination","_this","_next","value","next","complete","unsubscribe"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/radixdlt/node_modules/rxjs/src/internal/operators/take.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n * Take the first 5 seconds of an infinite 1-second interval Observable\n * ```ts\n * import { interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nclass TakeOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const total = this.total;\n    const count = ++this.count;\n    if (count <= total) {\n      this.destination.next(value);\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  }\n}\n"],"mappings":";AACA,OAAO,KAAEA,OAAU,MAAE,OAAM;AAC3B,SAASC,UAAA,uBAA+B;AACxC,SAASC,uBAAa,yCAAsB;AAkD5C,SAAMC,KAAA,QAAkB,qBAAa;OACnC,SAAOC,KAACC,KAAA,EAAqB;SAC3B,UAASC,MAAQ;QACfD,KAAA,KAAO,GAAK;MACb,OAAAF,KAAA;WACC;MACD,OAAAG,MAAA,CAAAC,IAAA,KAAAC,YAAA,CAAAH,KAAA;IACD;EACH;AAED;IACEG,YAAA,gBAAiC;WAAbA,aAAKC,KAAQ;IAC/B,IAAI,CAAAA,KAAK,GAAAA,KAAS;QAChB,KAAAA,KAAU;MACX,UAAAP,uBAAA;IACF;EAED;cACS,CAAAQ,SAAO,CAAAC,IAAS,GAAC,UAAIC,UAAe,EAAAN,MAAU,EAAE;IACxD,OAAAA,MAAA,CAAAO,SAAA,KAAAC,cAAA,CAAAF,UAAA,OAAAH,KAAA;EACH;EAVA,OAUCD,YAAA;AAOD;IAAgCM,cAAA,0BAAaC,MAAA;EAG3Cf,OAAA,CAAAgB,SAAA,CAAAF,cAAY,EAAAC,MAAoC;WAAhDD,cACEA,CAAAG,WAAM,EAAAR,KAAA;IADwC,IAAAS,KAAA,GAAKH,MAAL,CAAKJ,IAAQ,OAAAM,WAAA;IAFrDC,KAAA,CAAAT,KAAK,GAAWA,KAAE;;IAIzB,OAAAS,KAAA;EAES;gBACG,CAAAR,SAAQ,CAAAS,KAAM,aAAAC,KAAA;IACzB,IAAMX,KAAK,GAAG,IAAE,CAAAA,KAAK;IACrB,IAAIJ,KAAK,KAAI,IAAK,CAAAA,KAAE;QAClBA,KAAK,IAAAI,KAAA,EAAW;MAChB,IAAI,CAAAQ,WAAU,CAAAI,IAAO,CAAAD,KAAA;UACnBf,KAAK,KAAAI,KAAA,EAAY;QACjB,IAAI,CAACQ,WAAW,CAAAK,QAAG;QACpB,KAAAC,WAAA;MACF;IACF;EACH;EAlBgC,OAAAT,cAkB/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}