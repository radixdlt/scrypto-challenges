{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionIntentBuilder = exports.flatMapAddressesOf = exports.getUniqueAddresses = exports.isUnstakeTokensAction = exports.isStakeTokensAction = exports.isTransferTokensAction = exports.singleRecipientFromActions = void 0;\nconst actions_1 = require(\"../actions\");\nconst account_1 = require(\"../../../account\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst actions_2 = require(\"../actions\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst crypto_1 = require(\"../../../crypto\");\nconst prelude_ts_1 = require(\"prelude-ts\");\nconst primitives_1 = require(\"../../../primitives\");\nconst util_1 = require(\"../../../util\");\nconst singleRecipientFromActions = (mine, actions) => {\n  const others = (0, exports.flatMapAddressesOf)({\n    actions\n  }).map(a => a.publicKey).filter(a => !a.equals(mine));\n  if (others.length > 1) {\n    const errMsg = \"Cannot encrypt/decrypt message for a transaction containing more than one recipient addresses.\";\n    util_1.log.error(errMsg);\n    throw new Error(errMsg);\n  }\n  const toSelf = others.length === 0;\n  if (toSelf) {\n    util_1.log.debug(\"Encrypted message is to oneself.\");\n  }\n  return (0, neverthrow_1.ok)(toSelf ? mine : others[0]);\n};\nexports.singleRecipientFromActions = singleRecipientFromActions;\nconst ensureSingleRecipient = input => (0, util_1.toObservableFromResult)((0, exports.singleRecipientFromActions)(input.encryptingAccount.publicKey, input.intendedActionsFrom.intendedActions)).pipe((0, operators_1.map)(singleRecipientPublicKey => ({\n  encryptingAccount: input.encryptingAccount,\n  singleRecipientPublicKey: singleRecipientPublicKey\n})));\nconst mustHaveAtLeastOneAction = new Error('A transaction intent must contain at least one of the following actions: TransferToken, StakeTokens or UnstakeTokens');\nconst isTransferTokensAction = something => {\n  const inspection = something;\n  return inspection.type === actions_1.ActionType.TOKEN_TRANSFER && !!inspection.to_account && !!inspection.from_account && (0, primitives_1.isAmount)(inspection.amount) && (0, account_1.isResourceIdentifier)(inspection.rri);\n};\nexports.isTransferTokensAction = isTransferTokensAction;\nconst isStakeTokensAction = something => {\n  const inspection = something;\n  return inspection.type === actions_1.ActionType.STAKE_TOKENS && !!inspection.from_account && !!inspection.to_validator && (0, primitives_1.isAmount)(inspection.amount);\n};\nexports.isStakeTokensAction = isStakeTokensAction;\nconst isUnstakeTokensAction = something => {\n  const inspection = something;\n  return inspection.type === actions_1.ActionType.UNSTAKE_TOKENS && !!inspection.from_validator && !!inspection.to_account && (0, primitives_1.isAmount)(inspection.amount);\n};\nexports.isUnstakeTokensAction = isUnstakeTokensAction;\nconst decodeApiAddress = address => {\n  const result = account_1.AccountAddress.fromUnsafe(address);\n  return result._unsafeUnwrap();\n};\nconst getUniqueAddresses = input => {\n  var _a, _b;\n  const action = input.action;\n  const includeFrom = (_a = input.includeFrom) !== null && _a !== void 0 ? _a : true;\n  const includeTo = (_b = input.includeTo) !== null && _b !== void 0 ? _b : true;\n  if ((0, exports.isTransferTokensAction)(action)) {\n    const addresses = [];\n    if (includeTo) {\n      addresses.push(decodeApiAddress(action.to_account));\n    }\n    if (includeFrom) {\n      addresses.push(decodeApiAddress(action.from_account));\n    }\n    return addresses;\n  } else if ((0, exports.isStakeTokensAction)(action)) {\n    const addresses = [];\n    if (includeFrom) {\n      addresses.push(decodeApiAddress(action.from_account));\n    }\n    return addresses;\n  } else if ((0, exports.isUnstakeTokensAction)(action)) {\n    const addresses = [];\n    if (includeFrom) {\n      addresses.push(decodeApiAddress(action.to_account));\n    }\n    return addresses;\n  } else {\n    return [];\n  }\n};\nexports.getUniqueAddresses = getUniqueAddresses;\nconst flatMapAddressesOf = input => {\n  const {\n    actions,\n    includeFrom,\n    includeTo\n  } = input;\n  const flatMapped = actions.reduce((acc, action) => {\n    const uniqueAddressOfAction = (0, exports.getUniqueAddresses)({\n      action,\n      includeFrom,\n      includeTo\n    });\n    return acc.concat(...uniqueAddressOfAction);\n  }, []);\n  const set = new Set();\n  return flatMapped.filter(a => {\n    const str = a.toString();\n    const hasNt = !set.has(str);\n    set.add(str);\n    return hasNt;\n  });\n};\nexports.flatMapAddressesOf = flatMapAddressesOf;\nconst isTransactionIntentBuilderEncryptInput = something => {\n  const inspection = something;\n  return inspection.encryptMessageIfAnyWithAccount !== undefined && (0, rxjs_1.isObservable)(inspection.encryptMessageIfAnyWithAccount) && (inspection.spendingSender !== undefined ? (0, rxjs_1.isObservable)(inspection.spendingSender) : true);\n};\nconst isTransactionIntentBuilderDoNotEncryptInput = something => {\n  if (isTransactionIntentBuilderEncryptInput(something)) {\n    return false;\n  }\n  const inspection = something;\n  return inspection.spendingSender !== undefined && (0, rxjs_1.isObservable)(inspection.spendingSender);\n};\nconst isTransactionIntentBuilderDoNotEncryptOption = something => {\n  const inspection = something;\n  return inspection.skipEncryptionOfMessageIfAny !== undefined && isTransactionIntentBuilderDoNotEncryptInput(inspection.skipEncryptionOfMessageIfAny);\n};\nconst create = () => {\n  const intermediateActions = [];\n  let maybePlaintextMsgToEncrypt = prelude_ts_1.Option.none();\n  const snapshotState = () => ({\n    actionInputs: intermediateActions,\n    message: maybePlaintextMsgToEncrypt.getOrUndefined()\n  });\n  const snapshotBuilderState = () => ({\n    __state: snapshotState()\n  });\n  const addAction = (input, type) => {\n    intermediateActions.push(Object.assign({\n      type\n    }, input));\n    return Object.assign(Object.assign({}, methods), snapshotBuilderState());\n  };\n  const transferTokens = input => addAction(input, 'transfer');\n  const stakeTokens = input => addAction(input, 'stake');\n  const unstakeTokens = input => addAction(input, 'unstake');\n  const replaceAnyPreviousMessageWithNew = newMessage => {\n    maybePlaintextMsgToEncrypt = prelude_ts_1.Option.some(newMessage);\n    return Object.assign(Object.assign({}, methods), snapshotBuilderState());\n  };\n  const intendedActionsFromIntermediateActions = from => {\n    if (intermediateActions.length === 0) return (0, neverthrow_1.err)(mustHaveAtLeastOneAction);\n    return (0, neverthrow_1.combine)(intermediateActions.map(i => {\n      const intermediateActionType = i.type;\n      if (intermediateActionType === 'transfer') {\n        if ((0, actions_2.isTransferTokensInput)(i)) {\n          return actions_2.IntendedTransferTokens.create(i, from);\n        } else {\n          throw new Error('Not transfer tokens input');\n        }\n      } else if (intermediateActionType === 'stake') {\n        if ((0, actions_2.isStakeTokensInput)(i)) {\n          return actions_2.IntendedStakeTokens.create(i, from);\n        } else {\n          throw new Error('Not stake tokens input');\n        }\n      } else if (intermediateActionType === 'unstake') {\n        return actions_2.IntendedUnstakeTokens.create(i, from);\n      } else {\n        return (0, neverthrow_1.err)(new Error('Incorrect implementation, forgot something...'));\n      }\n    })).map(intendedActions => ({\n      intendedActions,\n      from\n    }));\n  };\n  const syncBuildDoNotEncryptMessageIfAny = from => intendedActionsFromIntermediateActions(from).map(_ref => {\n    let {\n      intendedActions\n    } = _ref;\n    return {\n      actions: intendedActions,\n      message: maybePlaintextMsgToEncrypt.map(msg => msg.plaintext ? crypto_1.Message.createPlaintext(msg.plaintext).bytes : undefined).getOrUndefined()\n    };\n  });\n  const build = options => {\n    var _a;\n    if (isTransactionIntentBuilderDoNotEncryptOption(options)) {\n      if (maybePlaintextMsgToEncrypt.map(m => m.encrypt).getOrElse(false)) {\n        const errMsg = \"Message in transaction specifies it should be encrypted, but input to TransactionIntentBuilder build method specifies that it (the builder) should not encrypt the message, and does not provide any account with which we can perform encryption.\";\n        console.error(errMsg);\n        util_1.log.error(errMsg);\n        return (0, rxjs_1.throwError)(new Error(errMsg));\n      }\n      return options.skipEncryptionOfMessageIfAny.spendingSender.pipe((0, operators_1.mergeMap)(from => (0, util_1.toObservableFromResult)(syncBuildDoNotEncryptMessageIfAny(from))));\n    }\n    if (!isTransactionIntentBuilderEncryptInput(options)) {\n      throw new Error('Incorrect implementation');\n    }\n    const encryptingAccount$ = options.encryptMessageIfAnyWithAccount;\n    const spendingSender = (_a = options.spendingSender) !== null && _a !== void 0 ? _a : options.encryptMessageIfAnyWithAccount.pipe((0, operators_1.map)(account => account.address));\n    return spendingSender.pipe((0, operators_1.mergeMap)(from => (0, util_1.toObservableFromResult)(intendedActionsFromIntermediateActions(from))), (0, operators_1.mergeMap)(intendedActionsFrom => {\n      const transactionIntentWithoutEncryption = plaintextMessage => {\n        util_1.log.info(\"Successfully built transaction. Actions: \".concat(intendedActionsFrom.intendedActions.map(action => action.type).toString()));\n        return (0, rxjs_1.of)({\n          actions: intendedActionsFrom.intendedActions,\n          message: plaintextMessage !== undefined ? crypto_1.MessageEncryption.encodePlaintext(plaintextMessage) : undefined\n        });\n      };\n      return maybePlaintextMsgToEncrypt.match({\n        Some: msgInTx => {\n          if (!msgInTx.encrypt) {\n            const errMsg = 'You are trying to encrypt a message which was specified not to be encrypted.';\n            console.error(errMsg);\n            util_1.log.error(errMsg);\n            return (0, rxjs_1.throwError)(new Error(errMsg));\n          }\n          return encryptingAccount$.pipe((0, operators_1.mergeMap)(encryptingAccount => ensureSingleRecipient({\n            intendedActionsFrom,\n            encryptingAccount\n          })), (0, operators_1.mergeMap)(actors => actors.encryptingAccount.encrypt({\n            plaintext: msgInTx.plaintext,\n            publicKeyOfOtherParty: actors.singleRecipientPublicKey\n          })), (0, operators_1.map)(encryptedMessage => {\n            util_1.log.info(\"Successfully built transaction with encrypted message. Actions: \".concat(intendedActionsFrom.intendedActions.map(action => action.type).toString()));\n            return {\n              actions: intendedActionsFrom.intendedActions,\n              message: encryptedMessage.combined()\n            };\n          }));\n        },\n        None: () => transactionIntentWithoutEncryption(undefined)\n      });\n    }));\n  };\n  const methods = {\n    transferTokens,\n    stakeTokens,\n    unstakeTokens,\n    build,\n    message: replaceAnyPreviousMessageWithNew,\n    __syncBuildDoNotEncryptMessageIfAny: syncBuildDoNotEncryptMessageIfAny\n  };\n  return Object.assign(Object.assign({}, snapshotBuilderState()), methods);\n};\nexports.TransactionIntentBuilder = {\n  create\n};","map":{"version":3,"names":["actions_1","require","account_1","rxjs_1","operators_1","actions_2","neverthrow_1","crypto_1","prelude_ts_1","primitives_1","util_1","singleRecipientFromActions","mine","actions","others","exports","flatMapAddressesOf","map","a","publicKey","filter","equals","length","errMsg","log","error","Error","toSelf","debug","ok","ensureSingleRecipient","input","toObservableFromResult","encryptingAccount","intendedActionsFrom","intendedActions","pipe","singleRecipientPublicKey","mustHaveAtLeastOneAction","isTransferTokensAction","something","inspection","type","ActionType","TOKEN_TRANSFER","to_account","from_account","isAmount","amount","isResourceIdentifier","rri","isStakeTokensAction","STAKE_TOKENS","to_validator","isUnstakeTokensAction","UNSTAKE_TOKENS","from_validator","decodeApiAddress","address","result","AccountAddress","fromUnsafe","_unsafeUnwrap","getUniqueAddresses","action","includeFrom","_a","includeTo","_b","addresses","push","flatMapped","reduce","acc","uniqueAddressOfAction","concat","set","Set","str","toString","hasNt","has","add","isTransactionIntentBuilderEncryptInput","encryptMessageIfAnyWithAccount","undefined","isObservable","spendingSender","isTransactionIntentBuilderDoNotEncryptInput","isTransactionIntentBuilderDoNotEncryptOption","skipEncryptionOfMessageIfAny","create","intermediateActions","maybePlaintextMsgToEncrypt","Option","none","snapshotState","actionInputs","message","getOrUndefined","snapshotBuilderState","__state","addAction","Object","assign","methods","transferTokens","stakeTokens","unstakeTokens","replaceAnyPreviousMessageWithNew","newMessage","some","intendedActionsFromIntermediateActions","from","err","combine","i","intermediateActionType","isTransferTokensInput","IntendedTransferTokens","isStakeTokensInput","IntendedStakeTokens","IntendedUnstakeTokens","syncBuildDoNotEncryptMessageIfAny","_ref","msg","plaintext","Message","createPlaintext","bytes","build","options","m","encrypt","getOrElse","console","throwError","mergeMap","encryptingAccount$","account","transactionIntentWithoutEncryption","plaintextMessage","info","of","MessageEncryption","encodePlaintext","match","Some","msgInTx","actors","publicKeyOfOtherParty","encryptedMessage","combined","None","__syncBuildDoNotEncryptMessageIfAny","TransactionIntentBuilder"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/application/src/dto/transactionIntentBuilder.ts"],"sourcesContent":["import {\n\tActionInput,\n\tActionType,\n\tExecutedAction,\n\tIntendedAction,\n\tStakeTokensAction,\n\tStakeTokensInput,\n\tTransferTokensAction,\n\tTransferTokensInput,\n\tUnstakeTokensAction,\n\tUnstakeTokensInput,\n} from '../actions'\nimport {\n\tTransactionIntent,\n\tTransactionIntentBuilderDoNotEncryptInput,\n\tTransactionIntentBuilderDoNotEncryptOption,\n\tTransactionIntentBuilderEncryptOption,\n\tTransactionIntentBuilderOptions,\n\tTransactionIntentBuilderState,\n\tTransactionIntentBuilderT,\n} from './_types'\nimport {\n\tAccountAddress,\n\tAccountAddressT,\n\tisResourceIdentifier,\n} from '../../../account'\nimport { isObservable, Observable, of, throwError } from 'rxjs'\nimport { map, mergeMap } from 'rxjs/operators'\nimport {\n\tIntendedTransferTokens,\n\tisTransferTokensInput,\n\tIntendedStakeTokens,\n\tisStakeTokensInput,\n\tIntendedUnstakeTokens,\n} from '../actions'\nimport { combine, err, ok, Result } from 'neverthrow'\nimport {\n\tEncryptedMessageT,\n\tMessage,\n\tMessageEncryption,\n\tPublicKeyT,\n} from '../../../crypto'\nimport { Option } from 'prelude-ts'\nimport { isAmount } from '../../../primitives'\nimport { log, toObservableFromResult } from '../../../util'\nimport { AccountT, MessageInTransaction } from '../_types'\n\ntype IntendedActionsFrom = Readonly<{\n\tintendedActions: IntendedAction[]\n\tfrom: AccountAddressT\n}>\n\nexport const singleRecipientFromActions = (\n\tmine: PublicKeyT,\n\tactions: UserAction[],\n): Result<PublicKeyT, Error> => {\n\tconst others = flatMapAddressesOf({ actions })\n\t\t.map(a => a.publicKey)\n\t\t.filter(a => !a.equals(mine))\n\n\tif (others.length > 1) {\n\t\tconst errMsg = `Cannot encrypt/decrypt message for a transaction containing more than one recipient addresses.`\n\t\tlog.error(errMsg)\n\t\tthrow new Error(errMsg)\n\t}\n\n\tconst toSelf = others.length === 0\n\tif (toSelf) {\n\t\tlog.debug(`Encrypted message is to oneself.`)\n\t}\n\n\treturn ok(toSelf ? mine : others[0])\n}\n\ntype ActorsInEncryption = {\n\tencryptingAccount: AccountT\n\tsingleRecipientPublicKey: PublicKeyT\n}\n\nconst ensureSingleRecipient = (\n\tinput: Readonly<{\n\t\tintendedActionsFrom: IntendedActionsFrom\n\t\tencryptingAccount: AccountT\n\t}>,\n): Observable<ActorsInEncryption> =>\n\ttoObservableFromResult(\n\t\tsingleRecipientFromActions(\n\t\t\tinput.encryptingAccount.publicKey,\n\t\t\tinput.intendedActionsFrom.intendedActions,\n\t\t),\n\t).pipe(\n\t\tmap(singleRecipientPublicKey => ({\n\t\t\tencryptingAccount: input.encryptingAccount,\n\t\t\tsingleRecipientPublicKey: singleRecipientPublicKey,\n\t\t})),\n\t)\n\ntype IntermediateAction = ActionInput & {\n\ttype: 'transfer' | 'stake' | 'unstake'\n}\n\nconst mustHaveAtLeastOneAction = new Error(\n\t'A transaction intent must contain at least one of the following actions: TransferToken, StakeTokens or UnstakeTokens',\n)\n\nexport const isTransferTokensAction = (\n\tsomething: unknown,\n): something is TransferTokensAction => {\n\tconst inspection = something as TransferTokensAction\n\treturn (\n\t\tinspection.type === ActionType.TOKEN_TRANSFER &&\n\t\t!!inspection.to_account &&\n\t\t!!inspection.from_account &&\n\t\tisAmount(inspection.amount) &&\n\t\tisResourceIdentifier(inspection.rri)\n\t)\n}\n\nexport const isStakeTokensAction = (\n\tsomething: unknown,\n): something is StakeTokensAction => {\n\tconst inspection = something as StakeTokensAction\n\treturn (\n\t\tinspection.type === ActionType.STAKE_TOKENS &&\n\t\t!!inspection.from_account &&\n\t\t!!inspection.to_validator &&\n\t\tisAmount(inspection.amount)\n\t)\n}\n\nexport const isUnstakeTokensAction = (\n\tsomething: unknown,\n): something is UnstakeTokensAction => {\n\tconst inspection = something as UnstakeTokensAction\n\treturn (\n\t\tinspection.type === ActionType.UNSTAKE_TOKENS &&\n\t\t!!inspection.from_validator &&\n\t\t!!inspection.to_account &&\n\t\tisAmount(inspection.amount)\n\t)\n}\n\nconst decodeApiAddress = (address: string): AccountAddressT => {\n\tconst result = AccountAddress.fromUnsafe(address)\n\treturn result._unsafeUnwrap()\n}\n\ntype UserAction = IntendedAction | ExecutedAction\nexport const getUniqueAddresses = (\n\tinput: Readonly<{\n\t\taction: UserAction\n\t\tincludeFrom?: boolean\n\t\tincludeTo?: boolean\n\t}>,\n): AccountAddressT[] => {\n\tconst action = input.action\n\tconst includeFrom = input.includeFrom ?? true\n\tconst includeTo = input.includeTo ?? true\n\tif (isTransferTokensAction(action)) {\n\t\tconst addresses: AccountAddressT[] = []\n\t\tif (includeTo) {\n\t\t\taddresses.push(decodeApiAddress(action.to_account))\n\t\t}\n\t\tif (includeFrom) {\n\t\t\taddresses.push(decodeApiAddress(action.from_account))\n\t\t}\n\t\treturn addresses\n\t} else if (isStakeTokensAction(action)) {\n\t\tconst addresses: AccountAddressT[] = []\n\t\tif (includeFrom) {\n\t\t\taddresses.push(decodeApiAddress(action.from_account))\n\t\t}\n\t\treturn addresses\n\t} else if (isUnstakeTokensAction(action)) {\n\t\tconst addresses: AccountAddressT[] = []\n\t\tif (includeFrom) {\n\t\t\taddresses.push(decodeApiAddress(action.to_account))\n\t\t}\n\t\treturn addresses\n\t} else {\n\t\treturn []\n\t}\n}\n\nexport const flatMapAddressesOf = (\n\tinput: Readonly<{\n\t\tactions: UserAction[]\n\t\tincludeFrom?: boolean\n\t\tincludeTo?: boolean\n\t}>,\n): AccountAddressT[] => {\n\tconst { actions, includeFrom, includeTo } = input\n\tconst flatMapped = actions.reduce(\n\t\t(acc: AccountAddressT[], action: UserAction) => {\n\t\t\tconst uniqueAddressOfAction = getUniqueAddresses({\n\t\t\t\taction,\n\t\t\t\tincludeFrom,\n\t\t\t\tincludeTo,\n\t\t\t})\n\t\t\treturn acc.concat(...uniqueAddressOfAction)\n\t\t},\n\t\t[] as AccountAddressT[],\n\t)\n\n\tconst set = new Set<string>()\n\treturn flatMapped.filter(a => {\n\t\tconst str = a.toString()\n\t\tconst hasNt = !set.has(str)\n\t\tset.add(str)\n\t\treturn hasNt\n\t})\n}\n\nconst isTransactionIntentBuilderEncryptInput = (\n\tsomething: unknown,\n): something is TransactionIntentBuilderEncryptOption => {\n\tconst inspection = something as TransactionIntentBuilderEncryptOption\n\treturn (\n\t\tinspection.encryptMessageIfAnyWithAccount !== undefined &&\n\t\tisObservable(inspection.encryptMessageIfAnyWithAccount) &&\n\t\t(inspection.spendingSender !== undefined\n\t\t\t? isObservable(inspection.spendingSender)\n\t\t\t: true)\n\t)\n}\n\nconst isTransactionIntentBuilderDoNotEncryptInput = (\n\tsomething: unknown,\n): something is TransactionIntentBuilderDoNotEncryptInput => {\n\tif (isTransactionIntentBuilderEncryptInput(something)) {\n\t\treturn false\n\t}\n\tconst inspection = something as TransactionIntentBuilderDoNotEncryptInput\n\treturn (\n\t\tinspection.spendingSender !== undefined &&\n\t\tisObservable(inspection.spendingSender)\n\t)\n}\n\nconst isTransactionIntentBuilderDoNotEncryptOption = (\n\tsomething: unknown,\n): something is TransactionIntentBuilderDoNotEncryptOption => {\n\tconst inspection = something as TransactionIntentBuilderDoNotEncryptOption\n\treturn (\n\t\tinspection.skipEncryptionOfMessageIfAny !== undefined &&\n\t\tisTransactionIntentBuilderDoNotEncryptInput(\n\t\t\tinspection.skipEncryptionOfMessageIfAny,\n\t\t)\n\t)\n}\n\nconst create = (): TransactionIntentBuilderT => {\n\tconst intermediateActions: IntermediateAction[] = []\n\tlet maybePlaintextMsgToEncrypt: Option<MessageInTransaction> = Option.none()\n\tconst snapshotState = (): TransactionIntentBuilderState => ({\n\t\tactionInputs: intermediateActions,\n\t\tmessage: maybePlaintextMsgToEncrypt.getOrUndefined(),\n\t})\n\n\tconst snapshotBuilderState = (): {\n\t\t__state: TransactionIntentBuilderState\n\t} => ({\n\t\t__state: snapshotState(),\n\t})\n\n\tconst addAction = (\n\t\tinput: ActionInput,\n\t\ttype: 'transfer' | 'stake' | 'unstake',\n\t): TransactionIntentBuilderT => {\n\t\tintermediateActions.push({\n\t\t\ttype,\n\t\t\t...input,\n\t\t})\n\t\treturn {\n\t\t\t...methods,\n\t\t\t...snapshotBuilderState(),\n\t\t}\n\t}\n\n\tconst transferTokens = (\n\t\tinput: TransferTokensInput,\n\t): TransactionIntentBuilderT => addAction(input, 'transfer')\n\n\tconst stakeTokens = (input: StakeTokensInput): TransactionIntentBuilderT =>\n\t\taddAction(input, 'stake')\n\n\tconst unstakeTokens = (\n\t\tinput: UnstakeTokensInput,\n\t): TransactionIntentBuilderT => addAction(input, 'unstake')\n\n\tconst replaceAnyPreviousMessageWithNew = (\n\t\tnewMessage: MessageInTransaction,\n\t): TransactionIntentBuilderT => {\n\t\tmaybePlaintextMsgToEncrypt = Option.some(newMessage)\n\t\treturn {\n\t\t\t...methods,\n\t\t\t...snapshotBuilderState(),\n\t\t}\n\t}\n\n\tconst intendedActionsFromIntermediateActions = (\n\t\tfrom: AccountAddressT,\n\t): Result<IntendedActionsFrom, Error> => {\n\t\tif (intermediateActions.length === 0)\n\t\t\treturn err(mustHaveAtLeastOneAction)\n\n\t\treturn combine(\n\t\t\tintermediateActions.map(\n\t\t\t\t(i): Result<IntendedAction, Error> => {\n\t\t\t\t\tconst intermediateActionType = i.type\n\t\t\t\t\tif (intermediateActionType === 'transfer') {\n\t\t\t\t\t\tif (isTransferTokensInput(i)) {\n\t\t\t\t\t\t\treturn IntendedTransferTokens.create(i, from)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error('Not transfer tokens input')\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (intermediateActionType === 'stake') {\n\t\t\t\t\t\tif (isStakeTokensInput(i)) {\n\t\t\t\t\t\t\treturn IntendedStakeTokens.create(i, from)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error('Not stake tokens input')\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (intermediateActionType === 'unstake') {\n\t\t\t\t\t\treturn IntendedUnstakeTokens.create(\n\t\t\t\t\t\t\ti as UnstakeTokensInput,\n\t\t\t\t\t\t\tfrom,\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn err(\n\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t'Incorrect implementation, forgot something...',\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t),\n\t\t).map(intendedActions => ({ intendedActions, from }))\n\t}\n\n\tconst syncBuildDoNotEncryptMessageIfAny = (\n\t\tfrom: AccountAddressT,\n\t): Result<TransactionIntent, Error> =>\n\t\tintendedActionsFromIntermediateActions(from).map(\n\t\t\t({ intendedActions }) => ({\n\t\t\t\tactions: intendedActions,\n\t\t\t\tmessage: maybePlaintextMsgToEncrypt\n\t\t\t\t\t.map(msg =>\n\t\t\t\t\t\tmsg.plaintext\n\t\t\t\t\t\t\t? Message.createPlaintext(msg.plaintext).bytes\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t)\n\t\t\t\t\t.getOrUndefined(),\n\t\t\t}),\n\t\t)\n\n\tconst build = (\n\t\toptions: TransactionIntentBuilderOptions,\n\t): Observable<TransactionIntent> => {\n\t\tif (isTransactionIntentBuilderDoNotEncryptOption(options)) {\n\t\t\tif (\n\t\t\t\tmaybePlaintextMsgToEncrypt.map(m => m.encrypt).getOrElse(false)\n\t\t\t) {\n\t\t\t\tconst errMsg = `Message in transaction specifies it should be encrypted, but input to TransactionIntentBuilder build method specifies that it (the builder) should not encrypt the message, and does not provide any account with which we can perform encryption.`\n\t\t\t\tconsole.error(errMsg)\n\t\t\t\tlog.error(errMsg)\n\t\t\t\treturn throwError(new Error(errMsg))\n\t\t\t}\n\n\t\t\treturn options.skipEncryptionOfMessageIfAny.spendingSender.pipe(\n\t\t\t\tmergeMap((from: AccountAddressT) =>\n\t\t\t\t\ttoObservableFromResult(\n\t\t\t\t\t\tsyncBuildDoNotEncryptMessageIfAny(from),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tif (!isTransactionIntentBuilderEncryptInput(options)) {\n\t\t\tthrow new Error('Incorrect implementation')\n\t\t}\n\n\t\tconst encryptingAccount$ = options.encryptMessageIfAnyWithAccount\n\t\tconst spendingSender: Observable<AccountAddressT> =\n\t\t\toptions.spendingSender ??\n\t\t\toptions.encryptMessageIfAnyWithAccount.pipe(\n\t\t\t\tmap(account => account.address),\n\t\t\t)\n\t\treturn spendingSender.pipe(\n\t\t\tmergeMap((from: AccountAddressT) =>\n\t\t\t\ttoObservableFromResult(\n\t\t\t\t\tintendedActionsFromIntermediateActions(from),\n\t\t\t\t),\n\t\t\t),\n\t\t\tmergeMap(\n\t\t\t\t(\n\t\t\t\t\tintendedActionsFrom: IntendedActionsFrom,\n\t\t\t\t): Observable<TransactionIntent> => {\n\t\t\t\t\tconst transactionIntentWithoutEncryption = (\n\t\t\t\t\t\tplaintextMessage?: string,\n\t\t\t\t\t): Observable<TransactionIntent> => {\n\t\t\t\t\t\tlog.info(\n\t\t\t\t\t\t\t`Successfully built transaction. Actions: ${intendedActionsFrom.intendedActions\n\t\t\t\t\t\t\t\t.map(action => action.type)\n\t\t\t\t\t\t\t\t.toString()}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t\treturn of({\n\t\t\t\t\t\t\tactions: intendedActionsFrom.intendedActions,\n\t\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\t\tplaintextMessage !== undefined\n\t\t\t\t\t\t\t\t\t? MessageEncryption.encodePlaintext(\n\t\t\t\t\t\t\t\t\t\t\tplaintextMessage,\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\treturn maybePlaintextMsgToEncrypt.match({\n\t\t\t\t\t\tSome: msgInTx => {\n\t\t\t\t\t\t\tif (!msgInTx.encrypt) {\n\t\t\t\t\t\t\t\tconst errMsg =\n\t\t\t\t\t\t\t\t\t'You are trying to encrypt a message which was specified not to be encrypted.'\n\t\t\t\t\t\t\t\tconsole.error(errMsg)\n\t\t\t\t\t\t\t\tlog.error(errMsg)\n\t\t\t\t\t\t\t\treturn throwError(new Error(errMsg))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn encryptingAccount$.pipe(\n\t\t\t\t\t\t\t\tmergeMap(\n\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\tencryptingAccount: AccountT,\n\t\t\t\t\t\t\t\t\t): Observable<ActorsInEncryption> =>\n\t\t\t\t\t\t\t\t\t\tensureSingleRecipient({\n\t\t\t\t\t\t\t\t\t\t\tintendedActionsFrom,\n\t\t\t\t\t\t\t\t\t\t\tencryptingAccount,\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tmergeMap(\n\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\tactors: ActorsInEncryption,\n\t\t\t\t\t\t\t\t\t): Observable<EncryptedMessageT> =>\n\t\t\t\t\t\t\t\t\t\tactors.encryptingAccount.encrypt({\n\t\t\t\t\t\t\t\t\t\t\tplaintext: msgInTx.plaintext,\n\t\t\t\t\t\t\t\t\t\t\tpublicKeyOfOtherParty:\n\t\t\t\t\t\t\t\t\t\t\t\tactors.singleRecipientPublicKey,\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tmap(\n\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\tencryptedMessage: EncryptedMessageT,\n\t\t\t\t\t\t\t\t\t): TransactionIntent => {\n\t\t\t\t\t\t\t\t\t\tlog.info(\n\t\t\t\t\t\t\t\t\t\t\t`Successfully built transaction with encrypted message. Actions: ${intendedActionsFrom.intendedActions\n\t\t\t\t\t\t\t\t\t\t\t\t.map(action => action.type)\n\t\t\t\t\t\t\t\t\t\t\t\t.toString()}`,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\tactions:\n\t\t\t\t\t\t\t\t\t\t\t\tintendedActionsFrom.intendedActions,\n\t\t\t\t\t\t\t\t\t\t\tmessage: encryptedMessage.combined(),\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tNone: () =>\n\t\t\t\t\t\t\ttransactionIntentWithoutEncryption(undefined),\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t),\n\t\t)\n\t}\n\n\tconst methods = {\n\t\ttransferTokens,\n\t\tstakeTokens,\n\t\tunstakeTokens,\n\t\tbuild,\n\t\tmessage: replaceAnyPreviousMessageWithNew,\n\t\t__syncBuildDoNotEncryptMessageIfAny: syncBuildDoNotEncryptMessageIfAny,\n\t}\n\n\treturn {\n\t\t...snapshotBuilderState(),\n\t\t...methods,\n\t}\n}\n\nexport const TransactionIntentBuilder = {\n\tcreate,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}