{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Action } from './Action';\nvar AsyncAction = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(AsyncAction, _super);\n  function AsyncAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.pending = false;\n    return _this;\n  }\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    if (this.closed) {\n      return this;\n    }\n    this.state = state;\n    var id = this.id;\n    var scheduler = this.scheduler;\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n    this.pending = true;\n    this.delay = delay;\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    clearInterval(id);\n    return undefined;\n  };\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n    this.pending = false;\n    var error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n  AsyncAction.prototype._execute = function (state, delay) {\n    var errored = false;\n    var errorValue = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n  AsyncAction.prototype._unsubscribe = function () {\n    var id = this.id;\n    var scheduler = this.scheduler;\n    var actions = scheduler.actions;\n    var index = actions.indexOf(this);\n    this.work = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n    this.delay = null;\n  };\n  return AsyncAction;\n}(Action);\nexport { AsyncAction };","map":{"version":3,"names":["tslib_1","Action","AsyncAction","_super","__extends","scheduler","work","_this","call","prototype","schedule","state","delay","closed","id","recycleAsyncId","pending","requestAsyncId","setInterval","flush","bind","clearInterval","undefined","execute","Error","error","_execute","errored","errorValue","e","unsubscribe","_unsubscribe","actions","index","indexOf","splice"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/radixdlt/node_modules/rxjs/src/internal/scheduler/AsyncAction.ts"],"sourcesContent":["import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    clearInterval(id);\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}