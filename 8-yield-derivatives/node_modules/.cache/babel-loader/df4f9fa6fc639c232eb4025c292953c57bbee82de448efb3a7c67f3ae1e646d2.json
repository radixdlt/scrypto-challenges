{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageEncryption = void 0;\nconst util_1 = require(\"@radixdlt/util\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst _types_1 = require(\"./_types\");\nconst key_derivation_functions_1 = require(\"../key-derivation-functions\");\nconst symmetric_encryption_1 = require(\"../symmetric-encryption\");\nconst hash_1 = require(\"../hash\");\nconst message_1 = require(\"./message\");\nconst elliptic_curve_1 = require(\"../elliptic-curve\");\nconst sealedMessage_1 = require(\"./sealedMessage\");\nconst calculateSharedSecret = input => {\n  const {\n    diffieHellmanPoint\n  } = input;\n  return diffieHellmanPoint().map(dhKey => {\n    const ephemeralPoint = input.ephemeralPublicKey.decodeToPointOnCurve();\n    const sharedSecretPoint = dhKey.add(ephemeralPoint);\n    const data = sharedSecretPoint.x.toString(16);\n    const buf = Buffer.alloc(32);\n    buf.write(data.padStart(64, '0'), 'hex');\n    return buf;\n  });\n};\nconst kdf = (secret, nonce) => {\n  const salt = (0, hash_1.sha256)(nonce);\n  return key_derivation_functions_1.Scrypt.deriveKey({\n    password: secret,\n    kdf: 'scrypt',\n    params: key_derivation_functions_1.ScryptParams.create({\n      salt\n    })\n  });\n};\nconst decryptAESSealedBox = input => {\n  const nonce = input.aesSealedBox.nonce;\n  const {\n    additionalAuthenticationData\n  } = input;\n  return kdf(input.sharedSecret, nonce).map(symmetricKey => Object.assign(Object.assign({}, input.aesSealedBox), {\n    symmetricKey,\n    additionalAuthenticationData\n  })).andThen(symmetric_encryption_1.AES_GCM.open);\n};\nconst aesSealedBoxFromSealedMessage = sealedMessage => symmetric_encryption_1.AES_GCM_SealedBox.create({\n  authTag: sealedMessage.authTag,\n  ciphertext: sealedMessage.ciphertext,\n  nonce: sealedMessage.nonce\n});\nconst decryptMessage = input => {\n  const ephemeralPublicKey = input.sealedMessage.ephemeralPublicKey;\n  const additionalAuthenticationData = ephemeralPublicKey.asData({\n    compressed: true\n  });\n  return (0, neverthrow_1.combine)([aesSealedBoxFromSealedMessage(input.sealedMessage).asyncAndThen(neverthrow_1.okAsync), calculateSharedSecret(Object.assign(Object.assign({}, input), {\n    ephemeralPublicKey\n  }))]).map(resultList => {\n    const aesSealedBox = resultList[0];\n    const sharedSecret = resultList[1];\n    return {\n      aesSealedBox,\n      sharedSecret,\n      additionalAuthenticationData\n    };\n  }).andThen(decryptAESSealedBox);\n};\nconst decryptEncryptedMessageBuffer = input => message_1.Message.fromBuffer(input.messageBuffer).andThen(message => message.kind === 'ENCRYPTED' ? (0, neverthrow_1.ok)([{\n  diffieHellmanPoint: input.diffieHellmanPoint,\n  sealedMessage: message.sealedMessage\n}]) : (0, neverthrow_1.err)(Error(`Expected an encrypted message, but got a plaintext message.`))).asyncAndThen(a => decryptMessage(...a));\nconst decrypt = input => Buffer.isBuffer(input.encryptedMessage) ? decryptEncryptedMessageBuffer(Object.assign(Object.assign({}, input), {\n  messageBuffer: input.encryptedMessage\n})) : decryptMessage(Object.assign(Object.assign({}, input), {\n  sealedMessage: input.encryptedMessage.sealedMessage\n}));\nconst encodePlaintext = plaintext => typeof plaintext === 'string' ? Buffer.from(plaintext, 'utf-8') : plaintext;\nconst __encryptDeterministic = input => {\n  const {\n    nonce,\n    ephemeralPublicKey\n  } = input;\n  const additionalAuthenticationData = ephemeralPublicKey.asData({\n    compressed: true\n  });\n  const plaintext = encodePlaintext(input.plaintext);\n  if (plaintext.length > message_1.Message.maxLengthOfCipherTextOfSealedMsg) {\n    const errMsg = `Plaintext is too long, expected max #${message_1.Message.maxLengthOfCipherTextOfSealedMsg}, but got: #${plaintext.length}`;\n    return (0, neverthrow_1.errAsync)(new Error(errMsg));\n  }\n  return calculateSharedSecret(Object.assign({}, input)).andThen(sharedSecret => kdf(sharedSecret, nonce).andThen(symmetricKey => (0, symmetric_encryption_1.aesGCMSealDeterministic)({\n    nonce,\n    plaintext,\n    additionalAuthenticationData,\n    symmetricKey\n  })).andThen(s => sealedMessage_1.SealedMessage.fromAESSealedBox(s, ephemeralPublicKey)).andThen(sealedMessage => message_1.Message.createEncrypted(_types_1.EncryptionScheme.DH_ADD_EPH_AESGCM256_SCRYPT_000, sealedMessage)));\n};\nconst encrypt = input => {\n  var _a;\n  const secureRandom = (_a = input.secureRandom) !== null && _a !== void 0 ? _a : util_1.secureRandomGenerator;\n  const nonce = Buffer.from(secureRandom.randomSecureBytes(symmetric_encryption_1.AES_GCM.nonceLength), 'hex');\n  const ephemeralKeyPair = elliptic_curve_1.KeyPair.generateNew(secureRandom);\n  const ephemeralPublicKey = ephemeralKeyPair.publicKey;\n  return __encryptDeterministic(Object.assign(Object.assign({}, input), {\n    nonce,\n    ephemeralPublicKey\n  }));\n};\nexports.MessageEncryption = {\n  __encryptDeterministic,\n  encodePlaintext,\n  encrypt,\n  decrypt\n};","map":{"version":3,"names":["util_1","require","neverthrow_1","_types_1","key_derivation_functions_1","symmetric_encryption_1","hash_1","message_1","elliptic_curve_1","sealedMessage_1","calculateSharedSecret","input","diffieHellmanPoint","map","dhKey","ephemeralPoint","ephemeralPublicKey","decodeToPointOnCurve","sharedSecretPoint","add","data","x","toString","buf","Buffer","alloc","write","padStart","kdf","secret","nonce","salt","sha256","Scrypt","deriveKey","password","params","ScryptParams","create","decryptAESSealedBox","aesSealedBox","additionalAuthenticationData","sharedSecret","symmetricKey","Object","assign","andThen","AES_GCM","open","aesSealedBoxFromSealedMessage","sealedMessage","AES_GCM_SealedBox","authTag","ciphertext","decryptMessage","asData","compressed","combine","asyncAndThen","okAsync","resultList","decryptEncryptedMessageBuffer","Message","fromBuffer","messageBuffer","message","kind","ok","err","Error","a","decrypt","isBuffer","encryptedMessage","encodePlaintext","plaintext","from","__encryptDeterministic","length","maxLengthOfCipherTextOfSealedMsg","errMsg","errAsync","aesGCMSealDeterministic","s","SealedMessage","fromAESSealedBox","createEncrypted","EncryptionScheme","DH_ADD_EPH_AESGCM256_SCRYPT_000","encrypt","secureRandom","_a","secureRandomGenerator","randomSecureBytes","nonceLength","ephemeralKeyPair","KeyPair","generateNew","publicKey","exports","MessageEncryption"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/src/encryption/messageEncryption.ts"],"sourcesContent":["import { secureRandomGenerator } from '@radixdlt/util'\nimport {\n\tcombine,\n\terr,\n\terrAsync,\n\tok,\n\tokAsync,\n\tResult,\n\tResultAsync,\n} from 'neverthrow'\nimport {\n\tEncryptedMessageT,\n\tEncryptionScheme,\n\tMessageDecryptionInput,\n\tMessageEncryptionInput,\n\tMessageType,\n\tPlaintextMessageT,\n\tSealedMessageT,\n} from './_types'\nimport { Scrypt, ScryptParams } from '../key-derivation-functions'\nimport {\n\tAES_GCM_SealedBoxT,\n\tAES_GCM_SealedBox,\n\tAES_GCM,\n\taesGCMSealDeterministic,\n} from '../symmetric-encryption'\nimport { sha256 } from '../hash'\nimport { Message } from './message'\nimport { ECPointOnCurveT, KeyPair, PublicKeyT } from '../elliptic-curve'\nimport { SealedMessage } from './sealedMessage'\n\ntype CalculateSharedSecretInput = Readonly<{\n\tephemeralPublicKey: PublicKeyT\n\tdiffieHellmanPoint: () => ResultAsync<ECPointOnCurveT, Error>\n}>\n\nconst calculateSharedSecret = (\n\tinput: CalculateSharedSecretInput,\n): ResultAsync<Buffer, Error> => {\n\tconst { diffieHellmanPoint } = input\n\treturn diffieHellmanPoint().map((dhKey: ECPointOnCurveT) => {\n\t\tconst ephemeralPoint = input.ephemeralPublicKey.decodeToPointOnCurve()\n\t\tconst sharedSecretPoint = dhKey.add(ephemeralPoint)\n\t\tconst data = sharedSecretPoint.x.toString(16)\n\t\tconst buf = Buffer.alloc(32)\n\t\tbuf.write(data.padStart(64, '0'), 'hex')\n\t\treturn buf\n\t})\n}\n\nconst kdf = (secret: Buffer, nonce: Buffer): ResultAsync<Buffer, Error> => {\n\tconst salt = sha256(nonce)\n\treturn Scrypt.deriveKey({\n\t\tpassword: secret,\n\t\tkdf: 'scrypt',\n\t\tparams: ScryptParams.create({ salt }),\n\t})\n}\n\nconst decryptAESSealedBox = (\n\tinput: Readonly<{\n\t\taesSealedBox: AES_GCM_SealedBoxT\n\t\tsharedSecret: Buffer\n\t\tadditionalAuthenticationData: Buffer\n\t}>,\n): ResultAsync<Buffer, Error> => {\n\tconst nonce = input.aesSealedBox.nonce\n\tconst { additionalAuthenticationData } = input\n\n\treturn kdf(input.sharedSecret, nonce)\n\t\t.map(symmetricKey => ({\n\t\t\t...input.aesSealedBox,\n\t\t\tsymmetricKey,\n\t\t\tadditionalAuthenticationData,\n\t\t}))\n\t\t.andThen(AES_GCM.open)\n}\n\nconst aesSealedBoxFromSealedMessage = (\n\tsealedMessage: SealedMessageT,\n): Result<AES_GCM_SealedBoxT, Error> =>\n\tAES_GCM_SealedBox.create({\n\t\tauthTag: sealedMessage.authTag,\n\t\tciphertext: sealedMessage.ciphertext,\n\t\tnonce: sealedMessage.nonce,\n\t})\n\nconst decryptMessage = (\n\tinput: Readonly<{\n\t\tsealedMessage: SealedMessageT\n\t\tdiffieHellmanPoint: () => ResultAsync<ECPointOnCurveT, Error>\n\t}>,\n): ResultAsync<Buffer, Error> => {\n\tconst ephemeralPublicKey = input.sealedMessage.ephemeralPublicKey\n\n\tconst additionalAuthenticationData = ephemeralPublicKey.asData({\n\t\tcompressed: true,\n\t})\n\n\treturn combine([\n\t\taesSealedBoxFromSealedMessage(input.sealedMessage).asyncAndThen(\n\t\t\tokAsync,\n\t\t),\n\t\tcalculateSharedSecret({\n\t\t\t...input,\n\t\t\tephemeralPublicKey,\n\t\t}),\n\t])\n\t\t.map(resultList => {\n\t\t\tconst aesSealedBox = resultList[0] as AES_GCM_SealedBoxT\n\t\t\tconst sharedSecret = resultList[1] as Buffer\n\t\t\treturn {\n\t\t\t\taesSealedBox,\n\t\t\t\tsharedSecret,\n\t\t\t\tadditionalAuthenticationData,\n\t\t\t}\n\t\t})\n\t\t.andThen(decryptAESSealedBox)\n}\n\nconst decryptEncryptedMessageBuffer = (\n\tinput: Readonly<{\n\t\tmessageBuffer: Buffer\n\t\tdiffieHellmanPoint: () => ResultAsync<ECPointOnCurveT, Error>\n\t}>,\n): ResultAsync<Buffer, Error> =>\n\tMessage.fromBuffer(input.messageBuffer)\n\t\t.andThen(\n\t\t\t(\n\t\t\t\tmessage: EncryptedMessageT | PlaintextMessageT,\n\t\t\t): Result<Parameters<typeof decryptMessage>, Error> =>\n\t\t\t\tmessage.kind === 'ENCRYPTED'\n\t\t\t\t\t? ok([\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdiffieHellmanPoint: input.diffieHellmanPoint,\n\t\t\t\t\t\t\t\tsealedMessage: message.sealedMessage,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t  ])\n\t\t\t\t\t: err(\n\t\t\t\t\t\t\tError(\n\t\t\t\t\t\t\t\t`Expected an encrypted message, but got a plaintext message.`,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t  ),\n\t\t)\n\t\t.asyncAndThen(a => decryptMessage(...a))\n\nconst decrypt = (input: MessageDecryptionInput): ResultAsync<Buffer, Error> =>\n\tBuffer.isBuffer(input.encryptedMessage)\n\t\t? decryptEncryptedMessageBuffer({\n\t\t\t\t...input,\n\t\t\t\tmessageBuffer: input.encryptedMessage,\n\t\t  })\n\t\t: decryptMessage({\n\t\t\t\t...input,\n\t\t\t\tsealedMessage: input.encryptedMessage.sealedMessage,\n\t\t  })\n\ntype DeterministicMessageEncryptionInput = MessageEncryptionInput &\n\tReadonly<{\n\t\tnonce: Buffer\n\t\tephemeralPublicKey: PublicKeyT\n\t}>\n\nconst encodePlaintext = (plaintext: Buffer | string): Buffer =>\n\ttypeof plaintext === 'string' ? Buffer.from(plaintext, 'utf-8') : plaintext\n\nconst __encryptDeterministic = (\n\tinput: DeterministicMessageEncryptionInput,\n): ResultAsync<EncryptedMessageT, Error> => {\n\tconst { nonce, ephemeralPublicKey } = input\n\n\tconst additionalAuthenticationData = ephemeralPublicKey.asData({\n\t\tcompressed: true,\n\t})\n\n\tconst plaintext = encodePlaintext(input.plaintext)\n\n\tif (plaintext.length > Message.maxLengthOfCipherTextOfSealedMsg) {\n\t\tconst errMsg = `Plaintext is too long, expected max #${Message.maxLengthOfCipherTextOfSealedMsg}, but got: #${plaintext.length}`\n\t\treturn errAsync(new Error(errMsg))\n\t}\n\n\treturn calculateSharedSecret({\n\t\t...input,\n\t}).andThen(sharedSecret =>\n\t\tkdf(sharedSecret, nonce)\n\t\t\t.andThen(symmetricKey =>\n\t\t\t\taesGCMSealDeterministic({\n\t\t\t\t\tnonce,\n\t\t\t\t\tplaintext,\n\t\t\t\t\tadditionalAuthenticationData,\n\t\t\t\t\tsymmetricKey,\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.andThen(s => SealedMessage.fromAESSealedBox(s, ephemeralPublicKey))\n\t\t\t.andThen((sealedMessage: SealedMessageT) =>\n\t\t\t\tMessage.createEncrypted(\n\t\t\t\t\tEncryptionScheme.DH_ADD_EPH_AESGCM256_SCRYPT_000,\n\t\t\t\t\tsealedMessage,\n\t\t\t\t),\n\t\t\t),\n\t)\n}\n\nconst encrypt = (\n\tinput: MessageEncryptionInput,\n): ResultAsync<EncryptedMessageT, Error> => {\n\tconst secureRandom = input.secureRandom ?? secureRandomGenerator\n\n\tconst nonce = Buffer.from(\n\t\tsecureRandom.randomSecureBytes(AES_GCM.nonceLength),\n\t\t'hex',\n\t)\n\n\tconst ephemeralKeyPair = KeyPair.generateNew(secureRandom)\n\n\tconst ephemeralPublicKey = ephemeralKeyPair.publicKey\n\n\treturn __encryptDeterministic({\n\t\t...input,\n\t\tnonce,\n\t\tephemeralPublicKey,\n\t})\n}\n\nexport const MessageEncryption = {\n\t__encryptDeterministic,\n\tencodePlaintext,\n\tencrypt,\n\tdecrypt,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}