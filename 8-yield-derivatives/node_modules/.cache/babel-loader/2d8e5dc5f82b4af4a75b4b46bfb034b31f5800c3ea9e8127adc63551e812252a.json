{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigningKey = exports.isSigningKey = void 0;\nconst crypto_1 = require(\"@radixdlt/crypto\");\nconst operators_1 = require(\"rxjs/operators\");\nconst rxjs_1 = require(\"rxjs\");\nconst util_1 = require(\"@radixdlt/util\");\nconst _types_1 = require(\"./_types\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst prelude_ts_1 = require(\"prelude-ts\");\nconst stringifySigningKey = signingKey => `\n\t\ttype: ${signingKey.type.typeIdentifier.toString()},\n\t\tpublicKey: ${signingKey.publicKey.toString(true)},\n\t\thdPath?: ${prelude_ts_1.Option.of(signingKey.hdPath).map(hdp => hdp.toString()).getOrElse('NONE')},\n\t\tisHDSigningKey: ${signingKey.isHDSigningKey ? 'YES' : 'NO'},\n\t\tisHardwareSigningKey: ${signingKey.isHardwareSigningKey ? 'YES' : 'NO'},\n\t`;\nconst makeSigningKeyTypeHD = input => {\n  const {\n    hdPath,\n    hdSigningKeyType\n  } = input;\n  const isHardwareSigningKey = hdSigningKeyType === _types_1.HDSigningKeyTypeIdentifier.HARDWARE_OR_REMOTE;\n  const uniqueKey = `${isHardwareSigningKey ? 'Hardware' : 'Local'}_HD_signingKey_at_path_${hdPath.toString()}`;\n  return {\n    typeIdentifier: _types_1.SigningKeyTypeIdentifier.HD_SIGNING_KEY,\n    hdSigningKeyType,\n    hdPath,\n    uniqueKey,\n    isHDSigningKey: true,\n    isHardwareSigningKey\n  };\n};\nconst makeSigningKeyTypeNonHD = input => {\n  const named = prelude_ts_1.Option.of(input.name).map(n => `named_${n}`).getOrElse('');\n  const uniqueKey = `Non_hd_${named}pubKey${input.publicKey.toString(true)}`;\n  return {\n    typeIdentifier: _types_1.SigningKeyTypeIdentifier.NON_HD_SIGNING_KEY,\n    uniqueKey,\n    isHDSigningKey: false,\n    isHardwareSigningKey: false,\n    name: input.name\n  };\n};\nconst makeDecrypt = diffieHellman => input => (0, util_1.toObservable)(crypto_1.MessageEncryption.decrypt(Object.assign(Object.assign({}, input), {\n  diffieHellmanPoint: () => diffieHellman(input.publicKeyOfOtherParty)\n})).map(buf => buf.toString('utf-8')));\nconst makeEncrypt = diffieHellman => input => (0, util_1.toObservable)(crypto_1.MessageEncryption.encrypt({\n  plaintext: input.plaintext,\n  diffieHellmanPoint: () => diffieHellman(input.publicKeyOfOtherParty)\n}));\nconst makeEncryptHW = hardwareSigningKey => input => hardwareSigningKey.keyExchange(input.publicKeyOfOtherParty, 'encrypt').pipe((0, operators_1.mergeMap)(dhPoint => (0, util_1.toObservable)(crypto_1.MessageEncryption.encrypt({\n  plaintext: input.plaintext,\n  diffieHellmanPoint: () => (0, neverthrow_1.okAsync)(dhPoint)\n}))));\nconst makeDecryptHW = hardwareSigningKey => input => hardwareSigningKey.keyExchange(input.publicKeyOfOtherParty, 'decrypt').pipe((0, operators_1.mergeMap)(dhPoint => (0, util_1.toObservable)(crypto_1.MessageEncryption.decrypt({\n  encryptedMessage: input.encryptedMessage,\n  diffieHellmanPoint: () => (0, neverthrow_1.okAsync)(dhPoint)\n}))), (0, operators_1.map)(b => b.toString('utf8')));\nconst fromPrivateKeyNamedOrFromHDPath = input => {\n  const {\n    privateKey\n  } = input;\n  const publicKey = privateKey.publicKey();\n  const sign = (tx, _nonXrdHRP) => (0, util_1.toObservable)(privateKey.sign(Buffer.from(tx.hashOfBlobToSign, 'hex')));\n  const diffieHellman = privateKey.diffieHellman;\n  const type = input.pathOrName === undefined || typeof input.pathOrName === 'string' ? makeSigningKeyTypeNonHD({\n    publicKey,\n    name: input.pathOrName\n  }) : makeSigningKeyTypeHD({\n    hdPath: input.pathOrName,\n    hdSigningKeyType: _types_1.HDSigningKeyTypeIdentifier.LOCAL\n  });\n  const newSigningKey = Object.assign(Object.assign({}, type), {\n    isLocalHDSigningKey: type.isHDSigningKey && !type.isHardwareSigningKey,\n    decrypt: makeDecrypt(diffieHellman),\n    encrypt: makeEncrypt(diffieHellman),\n    sign: sign,\n    signHash: hashedMessage => (0, util_1.toObservable)(privateKey.sign(hashedMessage)),\n    hdPath: input.pathOrName === undefined || typeof input.pathOrName === 'string' ? undefined : input.pathOrName,\n    publicKey,\n    getPublicKeyDisplayOnlyAddress: () => (0, rxjs_1.of)(publicKey),\n    type,\n    uniqueIdentifier: type.uniqueKey,\n    toString: () => {\n      throw new Error('Overriden below');\n    },\n    equals: other => publicKey.equals(other.publicKey),\n    __diffieHellman: diffieHellman\n  });\n  return Object.assign(Object.assign({}, newSigningKey), {\n    toString: () => stringifySigningKey(newSigningKey)\n  });\n};\nconst fromPrivateKeyAtHDPath = input => fromPrivateKeyNamedOrFromHDPath(Object.assign(Object.assign({}, input), {\n  pathOrName: input.hdPath\n}));\nconst fromPrivateKey = input => fromPrivateKeyNamedOrFromHDPath(Object.assign(Object.assign({}, input), {\n  pathOrName: input.name\n}));\nconst fromHDPathWithHWSigningKey = input => {\n  const {\n    hdPath,\n    hardwareSigningKey\n  } = input;\n  const type = makeSigningKeyTypeHD({\n    hdPath,\n    hdSigningKeyType: _types_1.HDSigningKeyTypeIdentifier.HARDWARE_OR_REMOTE\n  });\n  const newSigningKey = Object.assign(Object.assign({}, type), {\n    isLocalHDSigningKey: false,\n    publicKey: hardwareSigningKey.publicKey,\n    hdPath,\n    getPublicKeyDisplayOnlyAddress: () => hardwareSigningKey.getPublicKeyDisplayOnlyAddress(),\n    sign: (tx, nonXrdHRP) => hardwareSigningKey.sign(tx, nonXrdHRP),\n    signHash: hashesMessage => hardwareSigningKey.signHash(hashesMessage),\n    decrypt: makeDecryptHW(hardwareSigningKey),\n    encrypt: makeEncryptHW(hardwareSigningKey),\n    type,\n    uniqueIdentifier: type.uniqueKey,\n    toString: () => {\n      throw new Error('Overridden below.');\n    },\n    equals: other => hardwareSigningKey.publicKey.equals(other.publicKey),\n    __diffieHellman: _publicKeyOfOtherParty => {\n      throw new Error('No Dh here, only used for testing.');\n    }\n  });\n  return Object.assign(Object.assign({}, newSigningKey), {\n    toString: () => stringifySigningKey(newSigningKey)\n  });\n};\nconst byDerivingNodeAtPath = input => fromPrivateKeyAtHDPath(Object.assign(Object.assign({}, input), {\n  privateKey: input.deriveNodeAtPath().privateKey\n}));\nconst fromHDPathWithHDMasterNode = input => {\n  const hdNodeAtPath = input.hdMasterNode.derive(input.hdPath);\n  return fromPrivateKeyAtHDPath(Object.assign(Object.assign({}, input), {\n    privateKey: hdNodeAtPath.privateKey\n  }));\n};\nconst fromHDPathWithHDMasterSeed = input => {\n  const hdMasterNode = input.hdMasterSeed.masterNode();\n  return fromHDPathWithHDMasterNode(Object.assign(Object.assign({}, input), {\n    hdMasterNode\n  }));\n};\nconst isSigningKey = something => {\n  const inspection = something;\n  return inspection.publicKey !== undefined && (0, crypto_1.isPublicKey)(inspection.publicKey) && inspection.sign !== undefined && inspection.encrypt !== undefined && inspection.decrypt !== undefined && inspection.type !== undefined;\n};\nexports.isSigningKey = isSigningKey;\nexports.SigningKey = {\n  __unsafeFromPrivateKeyAtHDPath: fromPrivateKeyAtHDPath,\n  fromPrivateKey,\n  byDerivingNodeAtPath,\n  fromHDPathWithHWSigningKey,\n  fromHDPathWithHDMasterNode,\n  fromHDPathWithHDMasterSeed\n};","map":{"version":3,"names":["crypto_1","require","operators_1","rxjs_1","util_1","_types_1","neverthrow_1","prelude_ts_1","stringifySigningKey","signingKey","type","typeIdentifier","toString","publicKey","Option","of","hdPath","map","hdp","getOrElse","isHDSigningKey","isHardwareSigningKey","makeSigningKeyTypeHD","input","hdSigningKeyType","HDSigningKeyTypeIdentifier","HARDWARE_OR_REMOTE","uniqueKey","SigningKeyTypeIdentifier","HD_SIGNING_KEY","makeSigningKeyTypeNonHD","named","name","n","NON_HD_SIGNING_KEY","makeDecrypt","diffieHellman","toObservable","MessageEncryption","decrypt","Object","assign","diffieHellmanPoint","publicKeyOfOtherParty","buf","makeEncrypt","encrypt","plaintext","makeEncryptHW","hardwareSigningKey","keyExchange","pipe","mergeMap","dhPoint","okAsync","makeDecryptHW","encryptedMessage","b","fromPrivateKeyNamedOrFromHDPath","privateKey","sign","tx","_nonXrdHRP","Buffer","from","hashOfBlobToSign","pathOrName","undefined","LOCAL","newSigningKey","isLocalHDSigningKey","signHash","hashedMessage","getPublicKeyDisplayOnlyAddress","uniqueIdentifier","Error","equals","other","__diffieHellman","fromPrivateKeyAtHDPath","fromPrivateKey","fromHDPathWithHWSigningKey","nonXrdHRP","hashesMessage","_publicKeyOfOtherParty","byDerivingNodeAtPath","deriveNodeAtPath","fromHDPathWithHDMasterNode","hdNodeAtPath","hdMasterNode","derive","fromHDPathWithHDMasterSeed","hdMasterSeed","masterNode","isSigningKey","something","inspection","isPublicKey","exports","SigningKey","__unsafeFromPrivateKeyAtHDPath"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/account/src/signingKey.ts"],"sourcesContent":["import {\n\tDiffieHellman,\n\tECPointOnCurveT,\n\tEncryptedMessageT,\n\tisPublicKey,\n\tMessageEncryption,\n\tPrivateKeyT,\n\tPublicKeyT,\n\tSignatureT,\n\tHDPathRadixT,\n\tHDMasterSeedT,\n\tHDNodeT,\n} from '@radixdlt/crypto'\nimport { map, mergeMap } from 'rxjs/operators'\nimport { Observable, of } from 'rxjs'\nimport { toObservable } from '@radixdlt/util'\nimport {\n\tSigningKeyDecryptionInput,\n\tSigningKeyEncryptionInput,\n\tSigningKeyT,\n\tSigningKeyTypeHDT,\n\tSigningKeyTypeIdentifier,\n\tSigningKeyTypeNonHDT,\n\tSigningKeyTypeT,\n\tHDSigningKeyTypeIdentifier,\n\tPrivateKeyToSigningKeyInput,\n} from './_types'\nimport { okAsync, ResultAsync } from 'neverthrow'\nimport { Option } from 'prelude-ts'\nimport { HardwareSigningKeyT } from '@radixdlt/hardware-wallet'\nimport { BuiltTransactionReadyToSign } from '@radixdlt/primitives'\n\nconst stringifySigningKey = (signingKey: SigningKeyT): string => `\n\t\ttype: ${signingKey.type.typeIdentifier.toString()},\n\t\tpublicKey: ${signingKey.publicKey.toString(true)},\n\t\thdPath?: ${Option.of<HDPathRadixT>(signingKey.hdPath)\n\t\t\t.map(hdp => hdp.toString())\n\t\t\t.getOrElse('NONE')},\n\t\tisHDSigningKey: ${signingKey.isHDSigningKey ? 'YES' : 'NO'},\n\t\tisHardwareSigningKey: ${signingKey.isHardwareSigningKey ? 'YES' : 'NO'},\n\t`\n\nconst makeSigningKeyTypeHD = (\n\tinput: Readonly<{\n\t\thdPath: HDPathRadixT\n\t\thdSigningKeyType: HDSigningKeyTypeIdentifier\n\t}>,\n): SigningKeyTypeHDT => {\n\tconst { hdPath, hdSigningKeyType } = input\n\tconst isHardwareSigningKey =\n\t\thdSigningKeyType === HDSigningKeyTypeIdentifier.HARDWARE_OR_REMOTE\n\tconst uniqueKey = `${\n\t\tisHardwareSigningKey ? 'Hardware' : 'Local'\n\t}_HD_signingKey_at_path_${hdPath.toString()}`\n\treturn {\n\t\ttypeIdentifier: SigningKeyTypeIdentifier.HD_SIGNING_KEY,\n\t\thdSigningKeyType,\n\t\thdPath,\n\t\tuniqueKey,\n\t\tisHDSigningKey: true,\n\t\tisHardwareSigningKey,\n\t}\n}\n\nconst makeSigningKeyTypeNonHD = (\n\tinput: Readonly<{\n\t\tpublicKey: PublicKeyT\n\t\tname?: string\n\t}>,\n): SigningKeyTypeNonHDT => {\n\tconst named = Option.of(input.name)\n\t\t.map(n => `named_${n}`)\n\t\t.getOrElse('')\n\tconst uniqueKey = `Non_hd_${named}pubKey${input.publicKey.toString(true)}`\n\treturn {\n\t\ttypeIdentifier: SigningKeyTypeIdentifier.NON_HD_SIGNING_KEY,\n\t\tuniqueKey,\n\t\tisHDSigningKey: false,\n\t\tisHardwareSigningKey: false,\n\t\tname: input.name,\n\t}\n}\n\ntype Decrypt = (input: SigningKeyDecryptionInput) => Observable<string>\ntype Encrypt = (\n\tinput: SigningKeyEncryptionInput,\n) => Observable<EncryptedMessageT>\n\nconst makeDecrypt = (diffieHellman: DiffieHellman): Decrypt => (\n\tinput: SigningKeyDecryptionInput,\n): Observable<string> =>\n\ttoObservable(\n\t\tMessageEncryption.decrypt({\n\t\t\t...input,\n\t\t\tdiffieHellmanPoint: (): ResultAsync<ECPointOnCurveT, Error> =>\n\t\t\t\tdiffieHellman(input.publicKeyOfOtherParty),\n\t\t}).map((buf: Buffer) => buf.toString('utf-8')),\n\t)\n\nconst makeEncrypt = (diffieHellman: DiffieHellman): Encrypt => (\n\tinput: SigningKeyEncryptionInput,\n): Observable<EncryptedMessageT> =>\n\ttoObservable(\n\t\tMessageEncryption.encrypt({\n\t\t\tplaintext: input.plaintext,\n\t\t\tdiffieHellmanPoint: (): ResultAsync<ECPointOnCurveT, Error> =>\n\t\t\t\tdiffieHellman(input.publicKeyOfOtherParty),\n\t\t}),\n\t)\n\nconst makeEncryptHW = (hardwareSigningKey: HardwareSigningKeyT): Encrypt => (\n\tinput: SigningKeyEncryptionInput,\n): Observable<EncryptedMessageT> =>\n\thardwareSigningKey.keyExchange(input.publicKeyOfOtherParty, 'encrypt').pipe(\n\t\tmergeMap((dhPoint: ECPointOnCurveT) =>\n\t\t\ttoObservable(\n\t\t\t\tMessageEncryption.encrypt({\n\t\t\t\t\tplaintext: input.plaintext,\n\t\t\t\t\tdiffieHellmanPoint: () => okAsync(dhPoint),\n\t\t\t\t}),\n\t\t\t),\n\t\t),\n\t)\n\nconst makeDecryptHW = (hardwareSigningKey: HardwareSigningKeyT): Decrypt => (\n\tinput: SigningKeyDecryptionInput,\n): Observable<string> =>\n\thardwareSigningKey.keyExchange(input.publicKeyOfOtherParty, 'decrypt').pipe(\n\t\tmergeMap((dhPoint: ECPointOnCurveT) =>\n\t\t\ttoObservable(\n\t\t\t\tMessageEncryption.decrypt({\n\t\t\t\t\tencryptedMessage: input.encryptedMessage,\n\t\t\t\t\tdiffieHellmanPoint: (): ResultAsync<\n\t\t\t\t\t\tECPointOnCurveT,\n\t\t\t\t\t\tError\n\t\t\t\t\t> => okAsync(dhPoint),\n\t\t\t\t}),\n\t\t\t),\n\t\t),\n\t\tmap((b: Buffer) => b.toString('utf8')),\n\t)\n\nconst fromPrivateKeyNamedOrFromHDPath = (\n\tinput: Readonly<{\n\t\tprivateKey: PrivateKeyT\n\t\tpathOrName?: HDPathRadixT | string\n\t}>,\n): SigningKeyT => {\n\tconst { privateKey } = input\n\tconst publicKey: PublicKeyT = privateKey.publicKey()\n\tconst sign = (\n\t\ttx: BuiltTransactionReadyToSign,\n\t\t_nonXrdHRP?: string,\n\t): Observable<SignatureT> =>\n\t\ttoObservable(privateKey.sign(Buffer.from(tx.hashOfBlobToSign, 'hex')))\n\n\tconst diffieHellman = privateKey.diffieHellman\n\n\tconst type: SigningKeyTypeT =\n\t\tinput.pathOrName === undefined || typeof input.pathOrName === 'string'\n\t\t\t? makeSigningKeyTypeNonHD({\n\t\t\t\t\tpublicKey,\n\t\t\t\t\tname: input.pathOrName,\n\t\t\t  })\n\t\t\t: makeSigningKeyTypeHD({\n\t\t\t\t\thdPath: input.pathOrName,\n\t\t\t\t\thdSigningKeyType: HDSigningKeyTypeIdentifier.LOCAL,\n\t\t\t  })\n\n\tconst newSigningKey = {\n\t\t...type, // forward sugar for boolean signingKey type getters\n\t\tisLocalHDSigningKey: type.isHDSigningKey && !type.isHardwareSigningKey,\n\t\tdecrypt: makeDecrypt(diffieHellman),\n\t\tencrypt: makeEncrypt(diffieHellman),\n\t\tsign: sign,\n\t\tsignHash: (hashedMessage: Buffer): Observable<SignatureT> =>\n\t\t\ttoObservable(privateKey.sign(hashedMessage)),\n\t\thdPath:\n\t\t\tinput.pathOrName === undefined ||\n\t\t\ttypeof input.pathOrName === 'string'\n\t\t\t\t? undefined\n\t\t\t\t: input.pathOrName,\n\t\tpublicKey,\n\t\tgetPublicKeyDisplayOnlyAddress: (): Observable<PublicKeyT> =>\n\t\t\tof(publicKey),\n\t\ttype,\n\t\tuniqueIdentifier: type.uniqueKey,\n\t\ttoString: (): string => {\n\t\t\tthrow new Error('Overriden below')\n\t\t},\n\t\tequals: (other: SigningKeyT): boolean =>\n\t\t\tpublicKey.equals(other.publicKey),\n\t\t__diffieHellman: diffieHellman,\n\t}\n\n\treturn {\n\t\t...newSigningKey,\n\t\ttoString: () => stringifySigningKey(newSigningKey),\n\t}\n}\n\nconst fromPrivateKeyAtHDPath = (\n\tinput: Readonly<{\n\t\tprivateKey: PrivateKeyT\n\t\thdPath: HDPathRadixT\n\t}>,\n): SigningKeyT =>\n\tfromPrivateKeyNamedOrFromHDPath({\n\t\t...input,\n\t\tpathOrName: input.hdPath,\n\t})\n\nconst fromPrivateKey = (input: PrivateKeyToSigningKeyInput): SigningKeyT =>\n\tfromPrivateKeyNamedOrFromHDPath({\n\t\t...input,\n\t\tpathOrName: input.name,\n\t})\n\nconst fromHDPathWithHWSigningKey = (\n\tinput: Readonly<{\n\t\thdPath: HDPathRadixT\n\t\thardwareSigningKey: HardwareSigningKeyT\n\t}>,\n): SigningKeyT => {\n\tconst { hdPath, hardwareSigningKey } = input\n\n\tconst type: SigningKeyTypeT = makeSigningKeyTypeHD({\n\t\thdPath,\n\t\thdSigningKeyType: HDSigningKeyTypeIdentifier.HARDWARE_OR_REMOTE,\n\t})\n\n\tconst newSigningKey: SigningKeyT = {\n\t\t...type, // forward sugar for boolean signingKey type getters\n\t\tisLocalHDSigningKey: false, // hardware is not local\n\t\tpublicKey: hardwareSigningKey.publicKey,\n\t\thdPath,\n\t\tgetPublicKeyDisplayOnlyAddress: (): Observable<PublicKeyT> =>\n\t\t\thardwareSigningKey.getPublicKeyDisplayOnlyAddress(),\n\t\tsign: (\n\t\t\ttx: BuiltTransactionReadyToSign,\n\t\t\tnonXrdHRP?: string,\n\t\t): Observable<SignatureT> => hardwareSigningKey.sign(tx, nonXrdHRP),\n\t\tsignHash: (hashesMessage: Buffer): Observable<SignatureT> =>\n\t\t\thardwareSigningKey.signHash(hashesMessage),\n\t\tdecrypt: makeDecryptHW(hardwareSigningKey),\n\t\tencrypt: makeEncryptHW(hardwareSigningKey),\n\t\ttype,\n\t\tuniqueIdentifier: type.uniqueKey,\n\t\ttoString: (): string => {\n\t\t\tthrow new Error('Overridden below.')\n\t\t},\n\t\tequals: (other: SigningKeyT): boolean =>\n\t\t\thardwareSigningKey.publicKey.equals(other.publicKey),\n\t\t__diffieHellman: (\n\t\t\t_publicKeyOfOtherParty: PublicKeyT,\n\t\t): ResultAsync<ECPointOnCurveT, Error> => {\n\t\t\tthrow new Error('No Dh here, only used for testing.')\n\t\t},\n\t}\n\n\treturn {\n\t\t...newSigningKey,\n\t\ttoString: (): string => stringifySigningKey(newSigningKey),\n\t}\n}\n\nconst byDerivingNodeAtPath = (\n\tinput: Readonly<{\n\t\thdPath: HDPathRadixT\n\t\tderiveNodeAtPath: () => HDNodeT\n\t}>,\n): SigningKeyT =>\n\tfromPrivateKeyAtHDPath({\n\t\t...input,\n\t\tprivateKey: input.deriveNodeAtPath().privateKey,\n\t})\n\nconst fromHDPathWithHDMasterNode = (\n\tinput: Readonly<{\n\t\thdPath: HDPathRadixT\n\t\thdMasterNode: HDNodeT\n\t}>,\n): SigningKeyT => {\n\tconst hdNodeAtPath = input.hdMasterNode.derive(input.hdPath)\n\treturn fromPrivateKeyAtHDPath({\n\t\t...input,\n\t\tprivateKey: hdNodeAtPath.privateKey,\n\t})\n}\n\nconst fromHDPathWithHDMasterSeed = (\n\tinput: Readonly<{\n\t\thdPath: HDPathRadixT\n\t\thdMasterSeed: HDMasterSeedT\n\t}>,\n): SigningKeyT => {\n\tconst hdMasterNode = input.hdMasterSeed.masterNode()\n\treturn fromHDPathWithHDMasterNode({ ...input, hdMasterNode })\n}\n\nexport const isSigningKey = (something: unknown): something is SigningKeyT => {\n\tconst inspection = something as SigningKeyT\n\treturn (\n\t\tinspection.publicKey !== undefined &&\n\t\tisPublicKey(inspection.publicKey) &&\n\t\tinspection.sign !== undefined &&\n\t\tinspection.encrypt !== undefined &&\n\t\tinspection.decrypt !== undefined &&\n\t\tinspection.type !== undefined\n\t)\n}\n\nexport const SigningKey = {\n\t__unsafeFromPrivateKeyAtHDPath: fromPrivateKeyAtHDPath,\n\tfromPrivateKey,\n\tbyDerivingNodeAtPath,\n\tfromHDPathWithHWSigningKey,\n\tfromHDPathWithHDMasterNode,\n\tfromHDPathWithHDMasterSeed,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}