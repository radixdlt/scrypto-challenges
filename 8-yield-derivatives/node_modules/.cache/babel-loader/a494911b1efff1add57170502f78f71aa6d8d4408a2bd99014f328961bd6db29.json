{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BIP32PathComponent = exports.isBIP32PathSimpleT = exports.hardenedIncrement = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\nconst bip32_1 = require(\"./bip32\");\nexports.hardenedIncrement = 0x80000000;\nconst assertNotHardened = simplePath => {\n  const {\n    index,\n    isHardened\n  } = simplePath;\n  if (index >= exports.hardenedIncrement) {\n    return (0, neverthrow_1.err)(new Error(\"Incorrect implementation, expected value of index to be less than 'hardenedIncrement' for path components which are hardended. This function will add 'hardenedIncrement' to the value of index passed in, if 'isHardened' flag is set to true. But got value of index: \".concat(index, \", 'isHardened': \").concat(isHardened ? 'true' : 'false')));\n  }\n  return (0, neverthrow_1.ok)(index);\n};\nconst create = input => {\n  const {\n    isHardened\n  } = input;\n  return assertNotHardened(Object.assign({}, input)).map(index => Object.assign(Object.assign({}, input), {\n    index: isHardened ? index + exports.hardenedIncrement : index,\n    value: () => index,\n    toString: () => \"\".concat(index) + (isHardened ? \"'\" : '')\n  }));\n};\nconst isBIP32PathSimpleT = something => {\n  const inspection = something;\n  return inspection.index !== undefined && inspection.isHardened !== undefined;\n};\nexports.isBIP32PathSimpleT = isBIP32PathSimpleT;\nconst fromString = (componentString, level) => {\n  if (componentString.includes(bip32_1.BIP32.pathSeparator)) {\n    return (0, neverthrow_1.err)(new Error('Path component contains separator'));\n  }\n  let component = componentString;\n  let isHardened = false;\n  if (component.endsWith(bip32_1.BIP32.hardener)) {\n    isHardened = true;\n    component = component.replace(bip32_1.BIP32.hardener, '');\n  }\n  let parsedInt = 0;\n  try {\n    parsedInt = parseInt(component, 10);\n  } catch (e) {\n    return (0, neverthrow_1.err)(new Error('Failed to parse integer'));\n  }\n  if (!Number.isInteger(parsedInt)) {\n    return (0, neverthrow_1.err)(new Error('Found no integer'));\n  }\n  return exports.BIP32PathComponent.create({\n    index: parsedInt,\n    isHardened,\n    level\n  });\n};\nexports.BIP32PathComponent = {\n  create,\n  fromString\n};","map":{"version":3,"names":["neverthrow_1","require","bip32_1","exports","hardenedIncrement","assertNotHardened","simplePath","index","isHardened","err","Error","concat","ok","create","input","Object","assign","map","value","toString","isBIP32PathSimpleT","something","inspection","undefined","fromString","componentString","level","includes","BIP32","pathSeparator","component","endsWith","hardener","replace","parsedInt","parseInt","e","Number","isInteger","BIP32PathComponent"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/src/elliptic-curve/hd/bip32/bip32PathComponent.ts"],"sourcesContent":["import { err, ok, Result } from 'neverthrow'\nimport { BIP32PathComponentT, BIP32PathSimpleT, Int32 } from './_types'\nimport { BIP32 } from './bip32'\n\nexport const hardenedIncrement: number = 0x80000000\n\nconst assertNotHardened = (\n\tsimplePath: BIP32PathSimpleT,\n): Result<Int32, Error> => {\n\tconst { index, isHardened } = simplePath\n\tif (index >= hardenedIncrement) {\n\t\treturn err(\n\t\t\tnew Error(\n\t\t\t\t`Incorrect implementation, expected value of index to be less than 'hardenedIncrement' for path components which are hardended. This function will add 'hardenedIncrement' to the value of index passed in, if 'isHardened' flag is set to true. But got value of index: ${index}, 'isHardened': ${\n\t\t\t\t\tisHardened ? 'true' : 'false'\n\t\t\t\t}`,\n\t\t\t),\n\t\t)\n\t}\n\treturn ok(index)\n}\n\nconst create = (\n\tinput: Readonly<{\n\t\tindex: Int32\n\t\tisHardened: boolean\n\t\tlevel: number\n\t}>,\n): Result<BIP32PathComponentT, Error> => {\n\tconst { isHardened } = input\n\treturn assertNotHardened({ ...input }).map(index => ({\n\t\t...input,\n\t\tindex: isHardened ? index + hardenedIncrement : index,\n\t\tvalue: () => index,\n\t\ttoString: (): string => `${index}` + (isHardened ? `'` : ''),\n\t}))\n}\n\nexport const isBIP32PathSimpleT = (\n\tsomething: unknown,\n): something is BIP32PathSimpleT => {\n\tconst inspection = something as BIP32PathSimpleT\n\treturn inspection.index !== undefined && inspection.isHardened !== undefined\n}\n\nconst fromString = (\n\tcomponentString: string,\n\tlevel: number,\n): Result<BIP32PathComponentT, Error> => {\n\tif (componentString.includes(BIP32.pathSeparator)) {\n\t\treturn err(new Error('Path component contains separator'))\n\t}\n\tlet component = componentString\n\tlet isHardened = false\n\tif (component.endsWith(BIP32.hardener)) {\n\t\tisHardened = true\n\t\tcomponent = component.replace(BIP32.hardener, '')\n\t}\n\n\tlet parsedInt: number = 0\n\ttry {\n\t\tparsedInt = parseInt(component, 10)\n\t} catch (e) {\n\t\treturn err(new Error('Failed to parse integer'))\n\t}\n\tif (!Number.isInteger(parsedInt)) {\n\t\treturn err(new Error('Found no integer'))\n\t}\n\n\treturn BIP32PathComponent.create({\n\t\tindex: parsedInt,\n\t\tisHardened,\n\t\tlevel,\n\t})\n}\n\nexport const BIP32PathComponent = {\n\tcreate,\n\tfromString,\n}\n"],"mappings":";;;;;;AAAA,MAAAA,YAAA,GAAAC,OAAA;AAEA,MAAAC,OAAA,GAAAD,OAAA;AAEaE,OAAA,CAAAC,iBAAiB,GAAW,UAAU;AAEnD,MAAMC,iBAAiB,GACtBC,UAA4B,IACH;EACzB,MAAM;IAAEC,KAAK;IAAEC;EAAU,CAAE,GAAGF,UAAU;EACxC,IAAIC,KAAK,IAAIJ,OAAA,CAAAC,iBAAiB,EAAE;IAC/B,OAAO,IAAAJ,YAAA,CAAAS,GAAG,EACT,IAAIC,KAAK,4QAAAC,MAAA,CACmQJ,KAAK,sBAAAI,MAAA,CAC/QH,UAAU,GAAG,MAAM,GAAG,OACvB,CAAE,CACF,CACD;;EAEF,OAAO,IAAAR,YAAA,CAAAY,EAAE,EAACL,KAAK,CAAC;AACjB,CAAC;AAED,MAAMM,MAAM,GACXC,KAIE,IACqC;EACvC,MAAM;IAAEN;EAAU,CAAE,GAAGM,KAAK;EAC5B,OAAOT,iBAAiB,CAAAU,MAAA,CAAAC,MAAA,KAAMF,KAAK,EAAG,CAACG,GAAG,CAACV,KAAK,IAAIQ,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAChDF,KAAK;IACRP,KAAK,EAAEC,UAAU,GAAGD,KAAK,GAAGJ,OAAA,CAAAC,iBAAiB,GAAGG,KAAK;IACrDW,KAAK,EAAEA,CAAA,KAAMX,KAAK;IAClBY,QAAQ,EAAEA,CAAA,KAAc,GAAAR,MAAA,CAAGJ,KAAK,KAAMC,UAAU,SAAS,EAAE;EAAC,EAC3D,CAAC;AACJ,CAAC;AAEM,MAAMY,kBAAkB,GAC9BC,SAAkB,IACgB;EAClC,MAAMC,UAAU,GAAGD,SAA6B;EAChD,OAAOC,UAAU,CAACf,KAAK,KAAKgB,SAAS,IAAID,UAAU,CAACd,UAAU,KAAKe,SAAS;AAC7E,CAAC;AALYpB,OAAA,CAAAiB,kBAAkB,GAAAA,kBAAA;AAO/B,MAAMI,UAAU,GAAGA,CAClBC,eAAuB,EACvBC,KAAa,KAC0B;EACvC,IAAID,eAAe,CAACE,QAAQ,CAACzB,OAAA,CAAA0B,KAAK,CAACC,aAAa,CAAC,EAAE;IAClD,OAAO,IAAA7B,YAAA,CAAAS,GAAG,EAAC,IAAIC,KAAK,CAAC,mCAAmC,CAAC,CAAC;;EAE3D,IAAIoB,SAAS,GAAGL,eAAe;EAC/B,IAAIjB,UAAU,GAAG,KAAK;EACtB,IAAIsB,SAAS,CAACC,QAAQ,CAAC7B,OAAA,CAAA0B,KAAK,CAACI,QAAQ,CAAC,EAAE;IACvCxB,UAAU,GAAG,IAAI;IACjBsB,SAAS,GAAGA,SAAS,CAACG,OAAO,CAAC/B,OAAA,CAAA0B,KAAK,CAACI,QAAQ,EAAE,EAAE,CAAC;;EAGlD,IAAIE,SAAS,GAAW,CAAC;EACzB,IAAI;IACHA,SAAS,GAAGC,QAAQ,CAACL,SAAS,EAAE,EAAE,CAAC;GACnC,CAAC,OAAOM,CAAC,EAAE;IACX,OAAO,IAAApC,YAAA,CAAAS,GAAG,EAAC,IAAIC,KAAK,CAAC,yBAAyB,CAAC,CAAC;;EAEjD,IAAI,CAAC2B,MAAM,CAACC,SAAS,CAACJ,SAAS,CAAC,EAAE;IACjC,OAAO,IAAAlC,YAAA,CAAAS,GAAG,EAAC,IAAIC,KAAK,CAAC,kBAAkB,CAAC,CAAC;;EAG1C,OAAOP,OAAA,CAAAoC,kBAAkB,CAAC1B,MAAM,CAAC;IAChCN,KAAK,EAAE2B,SAAS;IAChB1B,UAAU;IACVkB;GACA,CAAC;AACH,CAAC;AAEYvB,OAAA,CAAAoC,kBAAkB,GAAG;EACjC1B,MAAM;EACNW;CACA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}