{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PublicKey = exports.isPublicKey = void 0;\nconst tslib_1 = require(\"tslib\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst elliptic_1 = require(\"elliptic\");\nconst bn_js_1 = (0, tslib_1.__importDefault)(require(\"bn.js\"));\nconst util_1 = require(\"@radixdlt/util\");\nconst primitives_1 = require(\"@radixdlt/primitives\");\nconst ecPointOnCurve_1 = require(\"./ecPointOnCurve\");\nconst thirdPartyLibEllipticSecp256k1 = new elliptic_1.ec('secp256k1');\nconst isPublicKey = something => {\n  const inspection = something;\n  return inspection.asData !== undefined && inspection.isValidSignature !== undefined && inspection.decodeToPointOnCurve !== undefined && inspection.equals !== undefined && inspection.toString !== undefined;\n};\nexports.isPublicKey = isPublicKey;\n// eslint-disable-next-line max-lines-per-function\nconst publicKeyFromEllipticKey = ecKeyPair => {\n  const validation = ecKeyPair.validate();\n  if (!validation.result) {\n    return (0, neverthrow_1.err)(new Error(`Invalid privateKey: ${validation.reason}`));\n  }\n  const newKeyAsData = input => Buffer.from(ecKeyPair.getPublic(input.compressed, 'array'));\n  const isValidSignature = input => {\n    const message = input.hashedMessage;\n    const signature = input.signature;\n    const r = (0, primitives_1.bnFromUInt256)(signature.r);\n    const s = (0, primitives_1.bnFromUInt256)(signature.s);\n    return ecKeyPair.verify(new bn_js_1.default(message), {\n      r,\n      s\n    });\n  };\n  const equals = other => {\n    const comparePubKeyBytes = compressed => {\n      const newKeyBytes = newKeyAsData({\n        compressed\n      });\n      const otherBytes = other.asData({\n        compressed\n      });\n      return (0, util_1.buffersEquals)(newKeyBytes, otherBytes);\n    };\n    return comparePubKeyBytes(true) && comparePubKeyBytes(false);\n  };\n  const toString = compressed => newKeyAsData({\n    compressed: compressed !== null && compressed !== void 0 ? compressed : true\n  }).toString('hex');\n  const publicKey = {\n    __hex: toString(),\n    asData: newKeyAsData,\n    toString,\n    isValidSignature: isValidSignature,\n    equals: equals,\n    decodeToPointOnCurve: () => {\n      const shortPoint = ecKeyPair.getPublic();\n      const pointOnCurveResult = (0, ecPointOnCurve_1.__pointOnCurveFromEllipticShortPoint)(shortPoint);\n      if (pointOnCurveResult.isErr()) throw new Error(`Incorrect implementation, should always be able to decode a valid public key\n\t\t\t\t\t into a point on the curve, but got error ${pointOnCurveResult.error.message}`);\n      return pointOnCurveResult.value;\n    }\n  };\n  return (0, neverthrow_1.ok)(publicKey);\n};\nconst fromPrivateKey = input => fromPrivateKeyScalar({\n  scalar: input.privateKey.scalar\n});\nconst fromPrivateKeyScalar = input => {\n  const result = publicKeyFromEllipticKey(thirdPartyLibEllipticSecp256k1.keyFromPrivate(input.scalar.toString(16)));\n  if (result.isErr()) {\n    throw new Error(`Failed to derive public key from private key, this should never happend since you passed in an 'PrivateKeyT' type value, which should have been validated. You must somehow have bypassed validation, or our implementation is incorrect, which is a fatal error.`);\n  }\n  return result.value;\n};\nconst fromBuffer = publicKeyBytes => {\n  try {\n    const ecKeyPairElliptic = thirdPartyLibEllipticSecp256k1.keyFromPublic(publicKeyBytes);\n    return publicKeyFromEllipticKey(ecKeyPairElliptic);\n  } catch (e) {\n    const underlyingError = (0, util_1.msgFromError)(e);\n    const errMsg = `Failed to decode bytes into public key, underlying error: ${underlyingError}. bytes: '${publicKeyBytes.toString('hex')}'`;\n    console.error(errMsg);\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n};\nconst compressedByteCount = 33;\nexports.PublicKey = {\n  compressedByteCount,\n  fromBuffer,\n  fromPrivateKey,\n  fromPrivateKeyScalar\n};","map":{"version":3,"names":["neverthrow_1","require","elliptic_1","bn_js_1","tslib_1","__importDefault","util_1","primitives_1","ecPointOnCurve_1","thirdPartyLibEllipticSecp256k1","ec","isPublicKey","something","inspection","asData","undefined","isValidSignature","decodeToPointOnCurve","equals","toString","exports","publicKeyFromEllipticKey","ecKeyPair","validation","validate","result","err","Error","reason","newKeyAsData","input","Buffer","from","getPublic","compressed","message","hashedMessage","signature","r","bnFromUInt256","s","verify","default","other","comparePubKeyBytes","newKeyBytes","otherBytes","buffersEquals","publicKey","__hex","shortPoint","pointOnCurveResult","__pointOnCurveFromEllipticShortPoint","isErr","error","value","ok","fromPrivateKey","fromPrivateKeyScalar","scalar","privateKey","keyFromPrivate","fromBuffer","publicKeyBytes","ecKeyPairElliptic","keyFromPublic","e","underlyingError","msgFromError","errMsg","console","compressedByteCount","PublicKey"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/src/elliptic-curve/publicKey.ts"],"sourcesContent":["import { err, ok, Result } from 'neverthrow'\nimport { curve, ec } from 'elliptic'\nimport BN from 'bn.js'\nimport { buffersEquals, msgFromError } from '@radixdlt/util'\nimport { bnFromUInt256 } from '@radixdlt/primitives'\nimport { UInt256 } from '@radixdlt/uint256'\nimport { __pointOnCurveFromEllipticShortPoint } from './ecPointOnCurve'\nimport { ECPointOnCurveT, PrivateKeyT, PublicKeyT, SignatureT } from './_types'\n\nconst thirdPartyLibEllipticSecp256k1 = new ec('secp256k1')\n\nexport const isPublicKey = (something: unknown): something is PublicKeyT => {\n\tconst inspection = something as PublicKeyT\n\n\treturn (\n\t\tinspection.asData !== undefined &&\n\t\tinspection.isValidSignature !== undefined &&\n\t\tinspection.decodeToPointOnCurve !== undefined &&\n\t\tinspection.equals !== undefined &&\n\t\tinspection.toString !== undefined\n\t)\n}\n\n// eslint-disable-next-line max-lines-per-function\nconst publicKeyFromEllipticKey = (\n\tecKeyPair: ec.KeyPair,\n): Result<PublicKeyT, Error> => {\n\tconst validation = ecKeyPair.validate()\n\n\tif (!validation.result) {\n\t\treturn err(new Error(`Invalid privateKey: ${validation.reason}`))\n\t}\n\n\tconst newKeyAsData = (input: { readonly compressed: boolean }): Buffer =>\n\t\tBuffer.from(ecKeyPair.getPublic(input.compressed, 'array'))\n\n\tconst isValidSignature = (\n\t\tinput: Readonly<{\n\t\t\tsignature: SignatureT\n\t\t\thashedMessage: Buffer\n\t\t}>,\n\t): boolean => {\n\t\tconst message = input.hashedMessage\n\t\tconst signature = input.signature\n\t\tconst r = bnFromUInt256(signature.r)\n\t\tconst s = bnFromUInt256(signature.s)\n\t\treturn ecKeyPair.verify(new BN(message), { r, s })\n\t}\n\n\tconst equals = (other: PublicKeyT): boolean => {\n\t\tconst comparePubKeyBytes = (compressed: boolean): boolean => {\n\t\t\tconst newKeyBytes = newKeyAsData({ compressed })\n\t\t\tconst otherBytes = other.asData({ compressed })\n\t\t\treturn buffersEquals(newKeyBytes, otherBytes)\n\t\t}\n\t\treturn comparePubKeyBytes(true) && comparePubKeyBytes(false)\n\t}\n\n\tconst toString = (compressed?: boolean): string =>\n\t\tnewKeyAsData({ compressed: compressed ?? true }).toString('hex')\n\n\tconst publicKey: PublicKeyT = {\n\t\t__hex: toString(),\n\t\tasData: newKeyAsData,\n\t\ttoString,\n\t\tisValidSignature: isValidSignature,\n\t\tequals: equals,\n\t\tdecodeToPointOnCurve: (): ECPointOnCurveT => {\n\t\t\tconst shortPoint = ecKeyPair.getPublic() as curve.short.ShortPoint\n\t\t\tconst pointOnCurveResult = __pointOnCurveFromEllipticShortPoint(\n\t\t\t\tshortPoint,\n\t\t\t)\n\t\t\tif (pointOnCurveResult.isErr())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Incorrect implementation, should always be able to decode a valid public key\n\t\t\t\t\t into a point on the curve, but got error ${pointOnCurveResult.error.message}`,\n\t\t\t\t)\n\t\t\treturn pointOnCurveResult.value\n\t\t},\n\t}\n\n\treturn ok(publicKey)\n}\n\nconst fromPrivateKey = (\n\tinput: Readonly<{\n\t\tprivateKey: PrivateKeyT\n\t}>,\n): PublicKeyT => fromPrivateKeyScalar({ scalar: input.privateKey.scalar })\n\nconst fromPrivateKeyScalar = (\n\tinput: Readonly<{\n\t\tscalar: UInt256\n\t}>,\n): PublicKeyT => {\n\tconst result = publicKeyFromEllipticKey(\n\t\tthirdPartyLibEllipticSecp256k1.keyFromPrivate(\n\t\t\tinput.scalar.toString(16),\n\t\t),\n\t)\n\n\tif (result.isErr()) {\n\t\tthrow new Error(\n\t\t\t`Failed to derive public key from private key, this should never happend since you passed in an 'PrivateKeyT' type value, which should have been validated. You must somehow have bypassed validation, or our implementation is incorrect, which is a fatal error.`,\n\t\t)\n\t}\n\treturn result.value\n}\n\nconst fromBuffer = (publicKeyBytes: Buffer): Result<PublicKeyT, Error> => {\n\ttry {\n\t\tconst ecKeyPairElliptic = thirdPartyLibEllipticSecp256k1.keyFromPublic(\n\t\t\tpublicKeyBytes,\n\t\t)\n\t\treturn publicKeyFromEllipticKey(ecKeyPairElliptic)\n\t} catch (e) {\n\t\tconst underlyingError = msgFromError(e)\n\t\tconst errMsg = `Failed to decode bytes into public key, underlying error: ${underlyingError}. bytes: '${publicKeyBytes.toString(\n\t\t\t'hex',\n\t\t)}'`\n\t\tconsole.error(errMsg)\n\t\treturn err(new Error(errMsg))\n\t}\n}\n\nconst compressedByteCount = 33\n\nexport const PublicKey = {\n\tcompressedByteCount,\n\tfromBuffer,\n\tfromPrivateKey,\n\tfromPrivateKeyScalar,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}