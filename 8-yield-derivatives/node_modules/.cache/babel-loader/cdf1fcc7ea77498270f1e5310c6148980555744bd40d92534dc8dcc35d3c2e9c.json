{"ast":null,"code":"/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nexport function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n    scheduler = selectorOrScheduler;\n  }\n  var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n  var subject = new ReplaySubject(bufferSize, windowTime, scheduler);\n  return function (source) {\n    return multicast(function () {\n      return subject;\n    }, selector)(source);\n  };\n}","map":{"version":3,"names":["ReplaySubject","multicast","publishReplay","bufferSize","windowTime","selectorOrScheduler","scheduler","selector","undefined","subject","source"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/radixdlt/node_modules/rxjs/src/internal/operators/publishReplay.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction, MonoTypeOperatorFunction, OperatorFunction, SchedulerLike, ObservableInput, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function publishReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport function publishReplay<T, O extends ObservableInput<any>>(bufferSize?: number, windowTime?: number, selector?: (shared: Observable<T>) => O, scheduler?: SchedulerLike): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\nexport function publishReplay<T, R>(bufferSize?: number,\n                                    windowTime?: number,\n                                    selectorOrScheduler?: SchedulerLike | OperatorFunction<T, R>,\n                                    scheduler?: SchedulerLike): UnaryFunction<Observable<T>, ConnectableObservable<R>> {\n\n  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n    scheduler = selectorOrScheduler;\n  }\n\n  const selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n  const subject = new ReplaySubject<T>(bufferSize, windowTime, scheduler);\n\n  return (source: Observable<T>) => multicast(() => subject, selector)(source) as ConnectableObservable<R>;\n}\n"],"mappings":"AACA;AACA,SAASA,aAAW,QAAM,kBAAc;AASxC,SAAMC,SAAU,qBAAoB;OAKlC,SAAIC,aAAmBA,CAAAC,UAAW,EAAAC,UAAA,EAAAC,mBAAkC,EAAEC,SAAA;MACpED,mBAAY,WAAAA,mBAAoB;IACjCC,SAAA,GAAAD,mBAAA;EAED;EACA,IAAME,QAAO,GAAG,OAAIF,mBAAiB,KAAY,UAAY,GAAAA,mBAAW,GAAAG,SAAA;EAExE,IAAAC,OAAO,OAACT,aAA0B,CAAAG,UAAA,EAAUC,UAAA,EAAAE,SAAM;EACnD,iBAAAI,MAAA;IAAA,OAAAT,SAAA;MAAA,OAAAQ,OAAA;IAAA,GAAAF,QAAA,EAAAG,MAAA;EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}