{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = void 0;\nexports.defaultOptions = {\n  skipFirstMutation: false,\n  mutable: false,\n  bfs: false\n};\nvar jsonPathStringify = function (s) {\n  return s.map(function (i) {\n    if (i === \"\") {\n      return '$';\n    } else {\n      return \".\".concat(i);\n    }\n  }).join(\"\");\n};\nvar isCycle = function (s, recursiveStack) {\n  var foundInRecursiveStack = recursiveStack.find(function (recSchema) {\n    return recSchema === s;\n  });\n  if (foundInRecursiveStack) {\n    return foundInRecursiveStack;\n  }\n  return false;\n};\nvar last = function (i, skip) {\n  if (skip === void 0) {\n    skip = 1;\n  }\n  return i[i.length - skip];\n};\n/**\n * Traverse all subschema of a schema, calling the mutator function with each.\n * The mutator is called on leaf nodes first.\n *\n * @param schema the schema to traverse\n * @param mutation the function to pass each node in the subschema tree.\n * @param traverseOptions a set of options for traversal.\n * @param depth For internal use. Tracks the current recursive depth in the tree. This is used to implement\n *              some of the options.\n *\n */\nfunction traverse(schema, mutation, traverseOptions, depth, recursiveStack, mutableStack, pathStack, prePostMap, cycleSet) {\n  if (traverseOptions === void 0) {\n    traverseOptions = exports.defaultOptions;\n  }\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (recursiveStack === void 0) {\n    recursiveStack = [];\n  }\n  if (mutableStack === void 0) {\n    mutableStack = [];\n  }\n  if (pathStack === void 0) {\n    pathStack = [];\n  }\n  if (prePostMap === void 0) {\n    prePostMap = [];\n  }\n  if (cycleSet === void 0) {\n    cycleSet = [];\n  }\n  var opts = __assign(__assign({}, exports.defaultOptions), traverseOptions); // would be nice to make an 'entry' func when we get around to optimizations\n  // booleans are a bit messed. Since all other schemas are objects (non-primitive type\n  // which gets a new address in mem) for each new JS refer to one of 2 memory addrs, and\n  // thus adding it to the recursive stack will prevent it from being explored if the\n  // boolean is seen in a further nested schema.\n  if (depth === 0) {\n    pathStack = [\"\"];\n  }\n  if (typeof schema === \"boolean\" || schema instanceof Boolean) {\n    if (opts.skipFirstMutation === true && depth === 0) {\n      return schema;\n    } else {\n      return mutation(schema, false, jsonPathStringify(pathStack), last(mutableStack));\n    }\n  }\n  var mutableSchema = schema;\n  if (opts.mutable === false) {\n    mutableSchema = __assign({}, schema);\n  }\n  mutableStack.push(mutableSchema);\n  if (opts.bfs === true) {\n    if (opts.skipFirstMutation === false || depth !== 0) {\n      mutableSchema = mutation(mutableSchema, false, jsonPathStringify(pathStack), last(mutableStack, 2));\n    }\n  }\n  recursiveStack.push(schema);\n  prePostMap.push([schema, mutableSchema]);\n  var rec = function (s, path) {\n    var foundCycle = isCycle(s, recursiveStack);\n    if (foundCycle) {\n      cycleSet.push(foundCycle);\n      // if the cycle is a ref to the root schema && skipFirstMutation is try we need to call mutate.\n      // If we don't, it will never happen.\n      if (opts.skipFirstMutation === true && foundCycle === recursiveStack[0]) {\n        return mutation(s, true, jsonPathStringify(path), last(mutableStack));\n      }\n      var _a = prePostMap.find(function (_a) {\n          var orig = _a[0];\n          return foundCycle === orig;\n        }),\n        cycledMutableSchema = _a[1];\n      return cycledMutableSchema;\n    }\n    // else\n    return traverse(s, mutation, traverseOptions, depth + 1, recursiveStack, mutableStack, path, prePostMap, cycleSet);\n  };\n  if (schema.anyOf) {\n    mutableSchema.anyOf = schema.anyOf.map(function (x, i) {\n      var result = rec(x, __spreadArray(__spreadArray([], pathStack, true), [\"anyOf[\".concat(i, \"]\")], false));\n      return result;\n    });\n  } else if (schema.allOf) {\n    mutableSchema.allOf = schema.allOf.map(function (x, i) {\n      var result = rec(x, __spreadArray(__spreadArray([], pathStack, true), [\"allOf[\".concat(i, \"]\")], false));\n      return result;\n    });\n  } else if (schema.oneOf) {\n    mutableSchema.oneOf = schema.oneOf.map(function (x, i) {\n      var result = rec(x, __spreadArray(__spreadArray([], pathStack, true), [\"oneOf[\".concat(i, \"]\")], false));\n      return result;\n    });\n  } else {\n    if (schema.items) {\n      if (schema.items instanceof Array) {\n        mutableSchema.items = schema.items.map(function (x, i) {\n          var result = rec(x, __spreadArray(__spreadArray([], pathStack, true), [\"items[\".concat(i, \"]\")], false));\n          return result;\n        });\n      } else {\n        var foundCycle_1 = isCycle(schema.items, recursiveStack);\n        if (foundCycle_1) {\n          cycleSet.push(foundCycle_1);\n          if (opts.skipFirstMutation === true && foundCycle_1 === recursiveStack[0]) {\n            mutableSchema.items = mutation(schema.items, true, jsonPathStringify(pathStack), last(mutableStack));\n          } else {\n            var _a = prePostMap.find(function (_a) {\n                var orig = _a[0];\n                return foundCycle_1 === orig;\n              }),\n              cycledMutableSchema = _a[1];\n            mutableSchema.items = cycledMutableSchema;\n          }\n        } else {\n          mutableSchema.items = traverse(schema.items, mutation, traverseOptions, depth + 1, recursiveStack, mutableStack, __spreadArray(__spreadArray([], pathStack, true), [\"items\"], false), prePostMap, cycleSet);\n        }\n      }\n    }\n    if (schema.additionalItems !== undefined) {\n      mutableSchema.additionalItems = rec(schema.additionalItems, __spreadArray(__spreadArray([], pathStack, true), [\"additionalItems\"], false));\n    }\n    if (schema.properties !== undefined) {\n      var sProps_1 = schema.properties;\n      var mutableProps_1 = {};\n      Object.keys(schema.properties).forEach(function (schemaPropKey) {\n        mutableProps_1[schemaPropKey] = rec(sProps_1[schemaPropKey], __spreadArray(__spreadArray([], pathStack, true), [\"properties\", schemaPropKey.toString()], false));\n      });\n      mutableSchema.properties = mutableProps_1;\n    }\n    if (schema.patternProperties !== undefined) {\n      var sProps_2 = schema.patternProperties;\n      var mutableProps_2 = {};\n      Object.keys(schema.patternProperties).forEach(function (regex) {\n        mutableProps_2[regex] = rec(sProps_2[regex], __spreadArray(__spreadArray([], pathStack, true), [\"patternProperties\", regex.toString()], false));\n      });\n      mutableSchema.patternProperties = mutableProps_2;\n    }\n    if (schema.additionalProperties !== undefined && !!schema.additionalProperties === true) {\n      mutableSchema.additionalProperties = rec(schema.additionalProperties, __spreadArray(__spreadArray([], pathStack, true), [\"additionalProperties\"], false));\n    }\n  }\n  if (opts.skipFirstMutation === true && depth === 0) {\n    return mutableSchema;\n  }\n  if (opts.bfs === true) {\n    mutableStack.pop();\n    return mutableSchema;\n  } else {\n    var isCycle_1 = cycleSet.indexOf(schema) !== -1;\n    mutableStack.pop();\n    return mutation(mutableSchema, isCycle_1, jsonPathStringify(pathStack), last(mutableStack));\n  }\n}\nexports.default = traverse;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArray","to","from","pack","l","ar","Array","slice","concat","defineProperty","exports","value","defaultOptions","skipFirstMutation","mutable","bfs","jsonPathStringify","map","join","isCycle","recursiveStack","foundInRecursiveStack","find","recSchema","last","skip","traverse","schema","mutation","traverseOptions","depth","mutableStack","pathStack","prePostMap","cycleSet","opts","Boolean","mutableSchema","push","rec","path","foundCycle","_a","orig","cycledMutableSchema","anyOf","x","result","allOf","oneOf","items","foundCycle_1","additionalItems","undefined","properties","sProps_1","mutableProps_1","keys","forEach","schemaPropKey","toString","patternProperties","sProps_2","mutableProps_2","regex","additionalProperties","pop","isCycle_1","indexOf","default"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@json-schema-tools/traverse/build/index.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultOptions = void 0;\nexports.defaultOptions = {\n    skipFirstMutation: false,\n    mutable: false,\n    bfs: false,\n};\nvar jsonPathStringify = function (s) {\n    return s.map(function (i) {\n        if (i === \"\") {\n            return '$';\n        }\n        else {\n            return \".\".concat(i);\n        }\n    }).join(\"\");\n};\nvar isCycle = function (s, recursiveStack) {\n    var foundInRecursiveStack = recursiveStack.find(function (recSchema) { return recSchema === s; });\n    if (foundInRecursiveStack) {\n        return foundInRecursiveStack;\n    }\n    return false;\n};\nvar last = function (i, skip) {\n    if (skip === void 0) { skip = 1; }\n    return i[i.length - skip];\n};\n/**\n * Traverse all subschema of a schema, calling the mutator function with each.\n * The mutator is called on leaf nodes first.\n *\n * @param schema the schema to traverse\n * @param mutation the function to pass each node in the subschema tree.\n * @param traverseOptions a set of options for traversal.\n * @param depth For internal use. Tracks the current recursive depth in the tree. This is used to implement\n *              some of the options.\n *\n */\nfunction traverse(schema, mutation, traverseOptions, depth, recursiveStack, mutableStack, pathStack, prePostMap, cycleSet) {\n    if (traverseOptions === void 0) { traverseOptions = exports.defaultOptions; }\n    if (depth === void 0) { depth = 0; }\n    if (recursiveStack === void 0) { recursiveStack = []; }\n    if (mutableStack === void 0) { mutableStack = []; }\n    if (pathStack === void 0) { pathStack = []; }\n    if (prePostMap === void 0) { prePostMap = []; }\n    if (cycleSet === void 0) { cycleSet = []; }\n    var opts = __assign(__assign({}, exports.defaultOptions), traverseOptions); // would be nice to make an 'entry' func when we get around to optimizations\n    // booleans are a bit messed. Since all other schemas are objects (non-primitive type\n    // which gets a new address in mem) for each new JS refer to one of 2 memory addrs, and\n    // thus adding it to the recursive stack will prevent it from being explored if the\n    // boolean is seen in a further nested schema.\n    if (depth === 0) {\n        pathStack = [\"\"];\n    }\n    if (typeof schema === \"boolean\" || schema instanceof Boolean) {\n        if (opts.skipFirstMutation === true && depth === 0) {\n            return schema;\n        }\n        else {\n            return mutation(schema, false, jsonPathStringify(pathStack), last(mutableStack));\n        }\n    }\n    var mutableSchema = schema;\n    if (opts.mutable === false) {\n        mutableSchema = __assign({}, schema);\n    }\n    mutableStack.push(mutableSchema);\n    if (opts.bfs === true) {\n        if (opts.skipFirstMutation === false || depth !== 0) {\n            mutableSchema = mutation(mutableSchema, false, jsonPathStringify(pathStack), last(mutableStack, 2));\n        }\n    }\n    recursiveStack.push(schema);\n    prePostMap.push([schema, mutableSchema]);\n    var rec = function (s, path) {\n        var foundCycle = isCycle(s, recursiveStack);\n        if (foundCycle) {\n            cycleSet.push(foundCycle);\n            // if the cycle is a ref to the root schema && skipFirstMutation is try we need to call mutate.\n            // If we don't, it will never happen.\n            if (opts.skipFirstMutation === true && foundCycle === recursiveStack[0]) {\n                return mutation(s, true, jsonPathStringify(path), last(mutableStack));\n            }\n            var _a = prePostMap.find(function (_a) {\n                var orig = _a[0];\n                return foundCycle === orig;\n            }), cycledMutableSchema = _a[1];\n            return cycledMutableSchema;\n        }\n        // else\n        return traverse(s, mutation, traverseOptions, depth + 1, recursiveStack, mutableStack, path, prePostMap, cycleSet);\n    };\n    if (schema.anyOf) {\n        mutableSchema.anyOf = schema.anyOf.map(function (x, i) {\n            var result = rec(x, __spreadArray(__spreadArray([], pathStack, true), [\"anyOf[\".concat(i, \"]\")], false));\n            return result;\n        });\n    }\n    else if (schema.allOf) {\n        mutableSchema.allOf = schema.allOf.map(function (x, i) {\n            var result = rec(x, __spreadArray(__spreadArray([], pathStack, true), [\"allOf[\".concat(i, \"]\")], false));\n            return result;\n        });\n    }\n    else if (schema.oneOf) {\n        mutableSchema.oneOf = schema.oneOf.map(function (x, i) {\n            var result = rec(x, __spreadArray(__spreadArray([], pathStack, true), [\"oneOf[\".concat(i, \"]\")], false));\n            return result;\n        });\n    }\n    else {\n        if (schema.items) {\n            if (schema.items instanceof Array) {\n                mutableSchema.items = schema.items.map(function (x, i) {\n                    var result = rec(x, __spreadArray(__spreadArray([], pathStack, true), [\"items[\".concat(i, \"]\")], false));\n                    return result;\n                });\n            }\n            else {\n                var foundCycle_1 = isCycle(schema.items, recursiveStack);\n                if (foundCycle_1) {\n                    cycleSet.push(foundCycle_1);\n                    if (opts.skipFirstMutation === true && foundCycle_1 === recursiveStack[0]) {\n                        mutableSchema.items = mutation(schema.items, true, jsonPathStringify(pathStack), last(mutableStack));\n                    }\n                    else {\n                        var _a = prePostMap.find(function (_a) {\n                            var orig = _a[0];\n                            return foundCycle_1 === orig;\n                        }), cycledMutableSchema = _a[1];\n                        mutableSchema.items = cycledMutableSchema;\n                    }\n                }\n                else {\n                    mutableSchema.items = traverse(schema.items, mutation, traverseOptions, depth + 1, recursiveStack, mutableStack, __spreadArray(__spreadArray([], pathStack, true), [\"items\"], false), prePostMap, cycleSet);\n                }\n            }\n        }\n        if (schema.additionalItems !== undefined) {\n            mutableSchema.additionalItems = rec(schema.additionalItems, __spreadArray(__spreadArray([], pathStack, true), [\"additionalItems\"], false));\n        }\n        if (schema.properties !== undefined) {\n            var sProps_1 = schema.properties;\n            var mutableProps_1 = {};\n            Object.keys(schema.properties).forEach(function (schemaPropKey) {\n                mutableProps_1[schemaPropKey] = rec(sProps_1[schemaPropKey], __spreadArray(__spreadArray([], pathStack, true), [\"properties\", schemaPropKey.toString()], false));\n            });\n            mutableSchema.properties = mutableProps_1;\n        }\n        if (schema.patternProperties !== undefined) {\n            var sProps_2 = schema.patternProperties;\n            var mutableProps_2 = {};\n            Object.keys(schema.patternProperties).forEach(function (regex) {\n                mutableProps_2[regex] = rec(sProps_2[regex], __spreadArray(__spreadArray([], pathStack, true), [\"patternProperties\", regex.toString()], false));\n            });\n            mutableSchema.patternProperties = mutableProps_2;\n        }\n        if (schema.additionalProperties !== undefined && !!schema.additionalProperties === true) {\n            mutableSchema.additionalProperties = rec(schema.additionalProperties, __spreadArray(__spreadArray([], pathStack, true), [\"additionalProperties\"], false));\n        }\n    }\n    if (opts.skipFirstMutation === true && depth === 0) {\n        return mutableSchema;\n    }\n    if (opts.bfs === true) {\n        mutableStack.pop();\n        return mutableSchema;\n    }\n    else {\n        var isCycle_1 = cycleSet.indexOf(schema) !== -1;\n        mutableStack.pop();\n        return mutation(mutableSchema, isCycle_1, jsonPathStringify(pathStack), last(mutableStack));\n    }\n}\nexports.default = traverse;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}