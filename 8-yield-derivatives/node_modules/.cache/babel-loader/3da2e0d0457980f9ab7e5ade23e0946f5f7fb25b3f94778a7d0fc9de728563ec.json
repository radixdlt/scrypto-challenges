{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractAddress = exports.isAbstractAddress = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\nconst crypto_1 = require(\"@radixdlt/crypto\");\nconst util_1 = require(\"@radixdlt/util\");\nconst bech32_1 = require(\"../bech32\");\nconst isAbstractAddress = something => {\n  const inspection = something;\n  return inspection.publicKey !== undefined && (0, crypto_1.isPublicKey)(inspection.publicKey) && inspection.equals !== undefined && inspection.toString !== undefined && inspection.addressType !== undefined;\n};\nexports.isAbstractAddress = isAbstractAddress;\nconst __create = input => {\n  const {\n    hrp,\n    data,\n    encoding,\n    maxLength,\n    network,\n    publicKey,\n    addressType,\n    typeguard\n  } = input;\n  return bech32_1.Bech32.encode({\n    hrp,\n    data,\n    encoding,\n    maxLength\n  }).mapErr(error => {\n    const errMsg = \"Incorrect implementation, failed to Bech32 encode data, underlying error: \".concat((0, util_1.msgFromError)(error), \", but expect to always be able to.\");\n    console.error(errMsg);\n    throw new Error(errMsg);\n  }).map(encoded => {\n    const toString = () => encoded.toString();\n    const equals = other => {\n      if (!(0, exports.isAbstractAddress)(other)) {\n        return false;\n      }\n      return other.publicKey.equals(publicKey) && other.network === network && addressType === other.addressType;\n    };\n    const abstract = {\n      addressType,\n      network,\n      publicKey,\n      toString,\n      equals\n    };\n    if (!typeguard(abstract)) {\n      const errMsg = \"Incorrect implementation, expected to have created an address of type \".concat(addressType.toString());\n      util_1.log.error(errMsg);\n      throw new Error(errMsg);\n    }\n    return abstract;\n  });\n};\nconst byFormattingPublicKeyDataAndBech32ConvertingIt = input => {\n  var _a;\n  const {\n    publicKey,\n    hrpFromNetwork,\n    network\n  } = input;\n  const formatDataToBech32Convert = (_a = input.formatDataToBech32Convert) !== null && _a !== void 0 ? _a : b => b;\n  const publicKeyBytes = publicKey.asData({\n    compressed: true\n  });\n  const bytes = formatDataToBech32Convert(publicKeyBytes);\n  const hrp = hrpFromNetwork(network);\n  return bech32_1.Bech32.convertDataToBech32(bytes).andThen(data => __create(Object.assign(Object.assign({}, input), {\n    hrp,\n    data,\n    publicKey\n  })));\n};\nconst fromString = input => {\n  var _a;\n  const {\n    bechString,\n    networkFromHRP\n  } = input;\n  const validateDataAndExtractPubKeyBytes = (_a = input.validateDataAndExtractPubKeyBytes) !== null && _a !== void 0 ? _a : passthroughData => (0, neverthrow_1.ok)(passthroughData);\n  return bech32_1.Bech32.decode(input).andThen(_ref => {\n    let {\n      hrp,\n      data: bech32Data\n    } = _ref;\n    return bech32_1.Bech32.convertDataFromBech32(bech32Data).map(dataFromBech32 => ({\n      bech32Data,\n      dataFromBech32,\n      hrp\n    }));\n  }).andThen(_ref2 => {\n    let {\n      bech32Data,\n      dataFromBech32,\n      hrp\n    } = _ref2;\n    return validateDataAndExtractPubKeyBytes(dataFromBech32).map(publicKeyBytes => ({\n      bech32Data,\n      publicKeyBytes,\n      hrp\n    }));\n  }).andThen(_ref3 => {\n    let {\n      bech32Data,\n      publicKeyBytes,\n      hrp\n    } = _ref3;\n    return (0, neverthrow_1.combine)([networkFromHRP(hrp), crypto_1.PublicKey.fromBuffer(publicKeyBytes)]).map(resultList => {\n      const network = resultList[0];\n      const publicKey = resultList[1];\n      return {\n        bech32Data,\n        hrp,\n        network,\n        publicKey\n      };\n    });\n  }).andThen(_ref4 => {\n    let {\n      bech32Data,\n      hrp,\n      network,\n      publicKey\n    } = _ref4;\n    return __create(Object.assign(Object.assign({}, input), {\n      network: network,\n      hrp,\n      data: bech32Data,\n      publicKey\n    }));\n  }).map(abstractAddress => {\n    // Soundness check\n    if (abstractAddress.toString().toLowerCase() !== bechString.toLowerCase()) {\n      const errMsg = \"Incorrect implementation, AbstractAddress mismatch, passed in: \".concat(bechString.toLowerCase(), \", created: \").concat(abstractAddress.toString().toLowerCase());\n      util_1.log.error(errMsg);\n      throw new Error(errMsg);\n    }\n    return abstractAddress;\n  });\n};\nexports.AbstractAddress = {\n  byFormattingPublicKeyDataAndBech32ConvertingIt,\n  fromString\n};","map":{"version":3,"names":["neverthrow_1","require","crypto_1","util_1","bech32_1","isAbstractAddress","something","inspection","publicKey","undefined","isPublicKey","equals","toString","addressType","exports","__create","input","hrp","data","encoding","maxLength","network","typeguard","Bech32","encode","mapErr","error","errMsg","concat","msgFromError","console","Error","map","encoded","other","abstract","log","byFormattingPublicKeyDataAndBech32ConvertingIt","hrpFromNetwork","formatDataToBech32Convert","_a","b","publicKeyBytes","asData","compressed","bytes","convertDataToBech32","andThen","Object","assign","fromString","bechString","networkFromHRP","validateDataAndExtractPubKeyBytes","passthroughData","ok","decode","_ref","bech32Data","convertDataFromBech32","dataFromBech32","_ref2","_ref3","combine","PublicKey","fromBuffer","resultList","_ref4","abstractAddress","toLowerCase","AbstractAddress"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/account/src/addresses/abstractAddress.ts"],"sourcesContent":["import { combine, ok, Result } from 'neverthrow'\nimport { isPublicKey, PublicKey, PublicKeyT } from '@radixdlt/crypto'\nimport { log, msgFromError } from '@radixdlt/util'\nimport { Bech32, Encoding } from '../bech32'\nimport { AbstractAddressT, AddressTypeT } from './_types'\nimport { Network } from '@radixdlt/primitives'\n\nexport const isAbstractAddress = (\n\tsomething: unknown,\n): something is AbstractAddressT => {\n\tconst inspection = something as AbstractAddressT\n\treturn (\n\t\tinspection.publicKey !== undefined &&\n\t\tisPublicKey(inspection.publicKey) &&\n\t\tinspection.equals !== undefined &&\n\t\tinspection.toString !== undefined &&\n\t\tinspection.addressType !== undefined\n\t)\n}\n\nexport type TypeGuard<A extends AbstractAddressT> = (\n\tsomething: unknown,\n) => something is A\n\nexport type NetworkFromHRP = (hrp: string) => Result<Network, Error>\nexport type HRPFromNetwork = (network: Network) => string\nexport type FormatDataToBech32Convert = (publicKeyBytes: Buffer) => Buffer\n\nexport type ValidateDataAndExtractPubKeyBytes = (\n\tdata: Buffer,\n) => Result<Buffer, Error>\n\nconst __create = <A extends AbstractAddressT>(\n\tinput: Readonly<{\n\t\thrp: string\n\t\tdata: Buffer\n\t\taddressType: AddressTypeT\n\t\tpublicKey: PublicKeyT\n\t\tnetwork: Network\n\t\ttypeguard: TypeGuard<A>\n\t\tencoding?: Encoding\n\t\tmaxLength?: number\n\t}>,\n): Result<A, Error> => {\n\tconst {\n\t\thrp,\n\t\tdata,\n\t\tencoding,\n\t\tmaxLength,\n\t\tnetwork,\n\t\tpublicKey,\n\t\taddressType,\n\t\ttypeguard,\n\t} = input\n\treturn Bech32.encode({ hrp, data, encoding, maxLength })\n\t\t.mapErr(error => {\n\t\t\tconst errMsg = `Incorrect implementation, failed to Bech32 encode data, underlying error: ${msgFromError(\n\t\t\t\terror,\n\t\t\t)}, but expect to always be able to.`\n\t\t\tconsole.error(errMsg)\n\t\t\tthrow new Error(errMsg)\n\t\t})\n\t\t.map(encoded => {\n\t\t\tconst toString = (): string => encoded.toString()\n\n\t\t\tconst equals = (other: AbstractAddressT): boolean => {\n\t\t\t\tif (!isAbstractAddress(other)) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn (\n\t\t\t\t\tother.publicKey.equals(publicKey) &&\n\t\t\t\t\tother.network === network &&\n\t\t\t\t\taddressType === other.addressType\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst abstract: AbstractAddressT = {\n\t\t\t\taddressType,\n\t\t\t\tnetwork,\n\t\t\t\tpublicKey,\n\t\t\t\ttoString,\n\t\t\t\tequals,\n\t\t\t}\n\n\t\t\tif (!typeguard(abstract)) {\n\t\t\t\tconst errMsg = `Incorrect implementation, expected to have created an address of type ${addressType.toString()}`\n\t\t\t\tlog.error(errMsg)\n\t\t\t\tthrow new Error(errMsg)\n\t\t\t}\n\n\t\t\treturn abstract\n\t\t})\n}\n\nconst byFormattingPublicKeyDataAndBech32ConvertingIt = <\n\tA extends AbstractAddressT\n>(\n\tinput: Readonly<{\n\t\tpublicKey: PublicKeyT\n\t\thrpFromNetwork: HRPFromNetwork\n\t\taddressType: AddressTypeT\n\t\tnetwork: Network\n\t\ttypeguard: TypeGuard<A>\n\t\tformatDataToBech32Convert?: FormatDataToBech32Convert\n\t\tencoding?: Encoding\n\t\tmaxLength?: number\n\t}>,\n): Result<A, Error> => {\n\tconst { publicKey, hrpFromNetwork, network } = input\n\n\tconst formatDataToBech32Convert =\n\t\tinput.formatDataToBech32Convert ?? (b => b)\n\n\tconst publicKeyBytes = publicKey.asData({ compressed: true })\n\tconst bytes = formatDataToBech32Convert(publicKeyBytes)\n\tconst hrp = hrpFromNetwork(network)\n\treturn Bech32.convertDataToBech32(bytes).andThen(data =>\n\t\t__create({\n\t\t\t...input,\n\t\t\thrp,\n\t\t\tdata,\n\t\t\tpublicKey,\n\t\t}),\n\t)\n}\n\nconst fromString = <A extends AbstractAddressT>(\n\tinput: Readonly<{\n\t\tbechString: string\n\t\taddressType: AddressTypeT\n\t\tnetworkFromHRP: NetworkFromHRP\n\t\ttypeguard: TypeGuard<A>\n\t\tvalidateDataAndExtractPubKeyBytes?: ValidateDataAndExtractPubKeyBytes\n\t\tencoding?: Encoding\n\t\tmaxLength?: number\n\t}>,\n): Result<A, Error> => {\n\tconst { bechString, networkFromHRP } = input\n\n\tconst validateDataAndExtractPubKeyBytes =\n\t\tinput.validateDataAndExtractPubKeyBytes ??\n\t\t((passthroughData: Buffer) => ok(passthroughData))\n\n\treturn Bech32.decode(input)\n\t\t.andThen(({ hrp, data: bech32Data }) =>\n\t\t\tBech32.convertDataFromBech32(bech32Data).map(dataFromBech32 => ({\n\t\t\t\tbech32Data,\n\t\t\t\tdataFromBech32,\n\t\t\t\thrp,\n\t\t\t})),\n\t\t)\n\t\t.andThen(({ bech32Data, dataFromBech32, hrp }) =>\n\t\t\tvalidateDataAndExtractPubKeyBytes(dataFromBech32).map(\n\t\t\t\tpublicKeyBytes => ({\n\t\t\t\t\tbech32Data,\n\t\t\t\t\tpublicKeyBytes,\n\t\t\t\t\thrp,\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t\t.andThen(({ bech32Data, publicKeyBytes, hrp }) =>\n\t\t\tcombine([\n\t\t\t\tnetworkFromHRP(hrp),\n\t\t\t\tPublicKey.fromBuffer(publicKeyBytes),\n\t\t\t]).map(resultList => {\n\t\t\t\tconst network = resultList[0]\n\t\t\t\tconst publicKey = resultList[1] as PublicKeyT\n\t\t\t\treturn {\n\t\t\t\t\tbech32Data,\n\t\t\t\t\thrp,\n\t\t\t\t\tnetwork,\n\t\t\t\t\tpublicKey,\n\t\t\t\t}\n\t\t\t}),\n\t\t)\n\t\t.andThen(({ bech32Data, hrp, network, publicKey }) =>\n\t\t\t__create({\n\t\t\t\t...input,\n\t\t\t\tnetwork: network as Network,\n\t\t\t\thrp,\n\t\t\t\tdata: bech32Data,\n\t\t\t\tpublicKey,\n\t\t\t}),\n\t\t)\n\t\t.map(\n\t\t\t(abstractAddress: A): A => {\n\t\t\t\t// Soundness check\n\t\t\t\tif (\n\t\t\t\t\tabstractAddress.toString().toLowerCase() !==\n\t\t\t\t\tbechString.toLowerCase()\n\t\t\t\t) {\n\t\t\t\t\tconst errMsg = `Incorrect implementation, AbstractAddress mismatch, passed in: ${bechString.toLowerCase()}, created: ${abstractAddress\n\t\t\t\t\t\t.toString()\n\t\t\t\t\t\t.toLowerCase()}`\n\t\t\t\t\tlog.error(errMsg)\n\t\t\t\t\tthrow new Error(errMsg)\n\t\t\t\t}\n\t\t\t\treturn abstractAddress\n\t\t\t},\n\t\t)\n}\n\nexport const AbstractAddress = {\n\tbyFormattingPublicKeyDataAndBech32ConvertingIt,\n\tfromString,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}