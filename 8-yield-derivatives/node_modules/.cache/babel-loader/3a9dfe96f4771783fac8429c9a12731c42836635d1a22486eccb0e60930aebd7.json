{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n/**\n * @hidden\n */\nfunction isSortOnSpec(sortSpec) {\n  return sortSpec.sortOn !== undefined;\n}\nexports.isSortOnSpec = isSortOnSpec;","map":{"version":3,"names":["isSortOnSpec","sortSpec","sortOn","undefined","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/ISet.ts"],"sourcesContent":["import { WithEquality, Ordering, ToOrderable } from \"./Comparison\";\nimport { Value} from \"./Value\";\nimport { Collection } from \"./Collection\";\nimport { Vector } from \"./Vector\";\nimport { LinkedList } from \"./LinkedList\";\nimport { Option } from \"./Option\";\n\n/**\n * Ability to specify a sorting function.\n * See [[Seq.sortOn]].\n *\n * You can give a lambda getting a sortable value (number or string) from your\n * object, or a list of lambdas, and in the list you can also put {desc:lambda}\n * items to request descending sorting\n *\n * `{sortOn: ToOrderable<T>|Array<ToOrderable<T>|{desc:ToOrderable<T>}>}`\n */\nexport type SortOnSpec<T> = {sortOn: ToOrderable<T>|Array<ToOrderable<T>|{desc:ToOrderable<T>}>};\n\n/**\n * Ability to specify a sorting function.\n * See [[Seq.sortBy]].\n *\n * `{sortBy: (v1:T,v2:T)=>Ordering}`\n */\nexport type SortBySpec<T> = {sortBy: (v1:T,v2:T)=>Ordering};\n\n/**\n * @hidden\n */\nexport function isSortOnSpec<T>(sortSpec: SortOnSpec<T> | SortBySpec<T>): sortSpec is SortOnSpec<T> {\n    return (<any>sortSpec).sortOn !== undefined;\n}\n\n/**\n * A generic interface for set-like implementations.\n * @param T the item type\n */\nexport interface ISet<T> extends Collection<T> {\n\n    /**\n     * Returns the number of elements in the set.\n     */\n    length(): number;\n\n    /**\n     * true if the set is empty, false otherwise.\n     */\n    isEmpty(): boolean;\n\n    /**\n     * Add an element to this set.\n     */\n    add(elt: T & WithEquality): ISet<T>;\n\n    /**\n     * Add multiple elements to this set.\n     */\n    addAll(elts: Iterable<T & WithEquality>): ISet<T>;\n\n    /**\n     * Returns true if the element you give is present in\n     * the set, false otherwise.\n     */\n    contains(elt: T & WithEquality): boolean;\n\n    /**\n     * Return a new collection where each element was transformed\n     * by the mapper function you give.\n     * The resulting set may be smaller than the source.\n     */\n    map<U>(mapper:(v:T)=>U&WithEquality): ISet<U>;\n\n    /**\n     * Apply the mapper function on every element of this collection.\n     * The mapper function returns an Option; if the Option is a Some,\n     * the value it contains is added to the result Collection, if it's\n     * a None, the value is discarded.\n     */\n    mapOption<U>(mapper:(v:T)=>Option<U&WithEquality>): ISet<U>;\n\n    /**\n     * Call a function for element in the collection.\n     */\n    forEach(fun:(x:T)=>void):ISet<T>;\n\n    /**\n     * Calls the function you give for each item in the set,\n     * your function returns a set, all the sets are\n     * merged.\n     */\n    flatMap<U>(mapper:(v:T)=>ISet<U&WithEquality>): ISet<U>;\n\n    /**\n     * Returns a new Set containing the difference\n     * between this set and the other Set passed as parameter.\n     * also see [[ISet.intersect]]\n     */\n    diff(other: ISet<T&WithEquality>): ISet<T>;\n\n    /**\n     * Returns a new Set containing the intersection\n     * of this set and the other Set passed as parameter\n     * (the elements which are common to both sets)\n     * also see [[ISet.diff]]\n     */\n    intersect(other: ISet<T&WithEquality>): ISet<T>;\n\n    /**\n     * Returns whether this set is a subset of the\n     * set you give as parameter (will return true\n     * also if both sets are equal)\n     */\n    isSubsetOf(other: ISet<T&WithEquality>): boolean;\n\n    /**\n     * Returns a new set with all the elements of the current\n     * Set, minus the elements of the iterable you give as a parameter.\n     * If you call this function with a HashSet as parameter,\n     * rather call 'diff', as it'll be faster.\n     */\n    removeAll(elts: Iterable<T&WithEquality>): ISet<T>;\n\n    /**\n     * Returns true if the predicate returns true for all the\n     * elements in the collection.\n     */\n    allMatch<U extends T>(predicate:(v:T)=>v is U): this is ISet<U>;\n    allMatch(predicate:(v:T)=>boolean): boolean;\n\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    anyMatch(predicate:(v:T)=>boolean): boolean;\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:ISet<T>)=>U): U;\n\n    /**\n     * Converts this set to an array. Since a Set is not ordered\n     * and since this method returns a JS array, it can be awkward\n     * to get an array sorted in the way you'd like. So you can pass\n     * an optional sorting function too.\n     *\n     *     HashSet.of(1,2,3).toArray().sort()\n     *     => [1,2,3]\n     *\n     *     HashSet.of(1,2,3).toArray({sortOn:x=>x})\n     *     => [1,2,3]\n     *\n     *     HashSet.of(1,2,3).toArray({sortBy:(x,y)=>x-y})\n     *     => [1,2,3]\n     *\n     * You can also pass an array in sortOn, listing lambdas to\n     * several fields to sort by those fields, and also {desc:lambda}\n     * to sort by some fields descending.\n     */\n    toArray(sort?: SortOnSpec<T> | SortBySpec<T>): Array<T & WithEquality>;\n\n    /**\n     * Converts this set to an vector\n     */\n    toVector(): Vector<T & WithEquality>;\n\n    /**\n     * Converts this set to an list\n     */\n    toLinkedList(): LinkedList<T & WithEquality>;\n\n    /**\n     * Convert to an ES6 Set.\n     * You must provide a function to convert the\n     * key to a string, number or boolean, because\n     * with other types equality is not correctly\n     * managed by JS.\n     * https://stackoverflow.com/questions/29759480/how-to-customize-object-equality-for-javascript-set\n     * https://esdiscuss.org/topic/maps-with-object-keys\n     *\n     *     HashSet.of(\"a\", \"b\").toJsSet(x=>x);\n     *     => new Set([\"a\", \"b\"])\n     */\n    toJsSet(keyConvert:(k:T)=>string): Set<string>;\n    toJsSet(keyConvert:(k:T)=>number): Set<number>;\n    toJsSet(keyConvert:(k:T)=>boolean): Set<boolean>;\n}\n"],"mappings":";;;AA2BA;;;AAGA,SAAgBA,YAAYA,CAAIC,QAAuC;EACnE,OAAaA,QAAS,CAACC,MAAM,KAAKC,SAAS;AAC/C;AAFAC,OAAA,CAAAJ,YAAA,GAAAA,YAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}