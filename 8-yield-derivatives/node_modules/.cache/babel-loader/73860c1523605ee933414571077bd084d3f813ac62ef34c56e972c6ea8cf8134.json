{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nfunction expand(project, concurrent, scheduler) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n  if (scheduler === void 0) {\n    scheduler = undefined;\n  }\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n  return operators_1.expand(project, concurrent, scheduler)(this);\n}\nexports.expand = expand;","map":{"version":3,"names":["operators_1","require","expand","project","concurrent","scheduler","Number","POSITIVE_INFINITY","undefined","exports"],"sources":["../src/compat/operator/expand.ts"],"sourcesContent":[null],"mappings":";;;;;AACA,IAAAA,WAAA,GAAAC,OAAA;AAKA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA,SAAgBC,MAAMA,CAA4BC,OAAwD,EAC7EC,UAA6C,EAC7CC,SAAoC;EADpC,IAAAD,UAAA;IAAAA,UAAA,GAAqBE,MAAM,CAACC,iBAAiB;EAAA;EAC7C,IAAAF,SAAA;IAAAA,SAAA,GAAAG,SAAoC;EAAA;EAC/DJ,UAAU,GAAG,CAACA,UAAU,IAAI,CAAC,IAAI,CAAC,GAAGE,MAAM,CAACC,iBAAiB,GAAGH,UAAU;EAE1E,OAAOJ,WAAA,CAAAE,MAAW,CAACC,OAAO,EAAEC,UAAU,EAAEC,SAAS,CAAC,CAAC,IAAI,CAAC;AAC1D;AANAI,OAAA,CAAAP,MAAA,GAAAA,MAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}