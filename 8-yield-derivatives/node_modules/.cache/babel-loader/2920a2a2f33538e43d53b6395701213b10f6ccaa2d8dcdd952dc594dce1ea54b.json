{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Radix = void 0;\nconst tslib_1 = require(\"tslib\");\nconst account_1 = require(\"@radixdlt/account\");\nconst networking_1 = require(\"@radixdlt/networking\");\nconst api_1 = require(\"./api\");\nconst operators_1 = require(\"rxjs/operators\");\nconst rxjs_1 = require(\"rxjs\");\nconst crypto_1 = require(\"@radixdlt/crypto\");\nconst errors_1 = require(\"./errors\");\nconst util_1 = require(\"@radixdlt/util\");\nconst dto_1 = require(\"./dto\");\nconst actions_1 = require(\"./actions\");\nconst wallet_1 = require(\"./wallet\");\nconst _1 = require(\".\");\nconst utils_1 = require(\"./api/utils\");\nconst txTypeFromActions = input => {\n  const {\n    activeAddress\n  } = input;\n  const myAddress = activeAddress.toString();\n  const fromUnique = (0, dto_1.flatMapAddressesOf)(Object.assign(Object.assign({}, input), {\n    includeTo: false\n  })).map(a => a.toString());\n  const toUnique = (0, dto_1.flatMapAddressesOf)(Object.assign(Object.assign({}, input), {\n    includeFrom: false\n  })).map(a => a.toString());\n  const toMe = toUnique.includes(myAddress);\n  const fromMe = fromUnique.includes(myAddress);\n  if (toMe && fromMe) {\n    return dto_1.TransactionType.FROM_ME_TO_ME;\n  } else if (toMe) {\n    return dto_1.TransactionType.INCOMING;\n  } else if (fromMe) {\n    return dto_1.TransactionType.OUTGOING;\n  } else {\n    return dto_1.TransactionType.UNRELATED;\n  }\n};\nconst decorateSimpleExecutedTransactionWithType = (simpleExecutedTX, activeAddress) => Object.assign(Object.assign({}, simpleExecutedTX), {\n  transactionType: txTypeFromActions({\n    actions: simpleExecutedTX.actions,\n    activeAddress\n  })\n});\nconst shouldConfirmTransactionAutomatically = confirmationScheme => confirmationScheme === 'skip';\nconst create = () => {\n  const subs = new rxjs_1.Subscription();\n  const radixLog = util_1.log; // TODO configure child loggers\n  const nodeSubject = new rxjs_1.ReplaySubject();\n  const coreAPISubject = new rxjs_1.ReplaySubject();\n  const walletSubject = new rxjs_1.ReplaySubject();\n  const errorNotificationSubject = new rxjs_1.Subject();\n  const deriveNextLocalHDAccountSubject = new rxjs_1.Subject();\n  const addAccountByPrivateKeySubject = new rxjs_1.Subject();\n  const switchAccountSubject = new rxjs_1.Subject();\n  const tokenBalanceFetchSubject = new rxjs_1.Subject();\n  const stakingFetchSubject = new rxjs_1.Subject();\n  const wallet$ = walletSubject.asObservable();\n  const networkSubject = new rxjs_1.ReplaySubject();\n  const nativeTokenSubject = new rxjs_1.ReplaySubject();\n  let walletSubscription;\n  const coreAPIViaNode$ = nodeSubject.asObservable().pipe((0, operators_1.map)(n => (0, api_1.radixCoreAPI)(n, (0, api_1.nodeAPI)(n.url))));\n  const coreAPI$ = (0, rxjs_1.merge)(coreAPIViaNode$, coreAPISubject.asObservable()).pipe((0, operators_1.shareReplay)(1));\n  // Forwards calls to RadixCoreAPI, return type is a function: `(input?: I) => Observable<O>`\n  const fwdAPICall = (pickFn, errorFn) => (...input) => coreAPI$.pipe((0, operators_1.mergeMap)(a => pickFn(a)(...input)), (0, operators_1.take)(1),\n  // Important!\n  (0, operators_1.catchError)(error => {\n    throw errorFn((0, util_1.isArray)(error) ? error[0] : error);\n  }));\n  const api = {\n    networkId: fwdAPICall(a => a.networkId, m => (0, errors_1.networkIdErr)(m)),\n    tokenBalancesForAddress: fwdAPICall(a => a.tokenBalancesForAddress, m => (0, errors_1.tokenBalancesErr)(m)),\n    transactionHistory: fwdAPICall(a => a.transactionHistory, m => (0, errors_1.transactionHistoryErr)(m)),\n    recentTransactions: fwdAPICall(a => a.recentTransactions, m => (0, errors_1.recentTransactionsErr)(m)),\n    nativeToken: fwdAPICall(a => a.nativeToken, m => (0, errors_1.nativeTokenErr)(m)),\n    tokenInfo: fwdAPICall(a => a.tokenInfo, m => (0, _1.tokenInfoErr)(m)),\n    stakesForAddress: fwdAPICall(a => a.stakesForAddress, m => (0, errors_1.stakesForAddressErr)(m)),\n    unstakesForAddress: fwdAPICall(a => a.unstakesForAddress, m => (0, errors_1.unstakesForAddressErr)(m)),\n    validators: fwdAPICall(a => a.validators, m => (0, errors_1.validatorsErr)(m)),\n    lookupValidator: fwdAPICall(a => a.lookupValidator, m => (0, errors_1.lookupValidatorErr)(m)),\n    getTransaction: fwdAPICall(a => a.transactionStatus, m => (0, errors_1.lookupTxErr)(m)),\n    buildTransaction: fwdAPICall(a => a.buildTransaction, m => (0, errors_1.buildTxFromIntentErr)(m)),\n    finalizeTransaction: fwdAPICall(a => a.finalizeTransaction, m => (0, errors_1.finalizeTxErr)(m)),\n    submitSignedTransaction: fwdAPICall(a => a.submitSignedTransaction, m => (0, errors_1.submitSignedTxErr)(m))\n  };\n  const activeAddress = wallet$.pipe((0, operators_1.mergeMap)(a => a.observeActiveAccount()), (0, operators_1.map)(a => a.address), (0, operators_1.shareReplay)(1));\n  const revealMnemonic = () => wallet$.pipe((0, operators_1.map)(wallet => wallet.revealMnemonic()));\n  const activeAddressToAPIObservableWithTrigger = (trigger, pickFn, errorFn) => (0, rxjs_1.merge)(trigger.pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.map)(result => result[1])), activeAddress).pipe((0, operators_1.withLatestFrom)(coreAPI$), (0, operators_1.switchMap)(([address, api]) => pickFn(api)(address).pipe((0, operators_1.catchError)(error => {\n    console.error(error);\n    errorNotificationSubject.next(errorFn(error));\n    return rxjs_1.EMPTY;\n  }))), (0, operators_1.shareReplay)(1));\n  const tokenBalances = activeAddressToAPIObservableWithTrigger(tokenBalanceFetchSubject, a => a.tokenBalancesForAddress, errors_1.tokenBalancesErr);\n  /*\n      const decorateSimpleTokenBalanceWithTokenInfo = (\n          simpleTokenBalance: SimpleTokenBalance,\n      ): Observable<TokenBalance> =>\n          api.tokenInfo(simpleTokenBalance.tokenIdentifier).pipe(\n              map(\n                  (tokenInfo: Token): TokenBalance => ({\n                      amount: simpleTokenBalance.amount,\n                      token: tokenInfo,\n                  }),\n              ),\n          )\n  */\n  const stakingPositions = activeAddressToAPIObservableWithTrigger(stakingFetchSubject, a => a.stakesForAddress, errors_1.stakesForAddressErr);\n  const unstakingPositions = activeAddressToAPIObservableWithTrigger(stakingFetchSubject, a => a.unstakesForAddress, errors_1.unstakesForAddressErr);\n  const transactionHistory = input => activeAddress.pipe((0, operators_1.take)(1), (0, operators_1.switchMap)(activeAddress => api.transactionHistory(Object.assign(Object.assign({}, input), {\n    address: activeAddress\n  })).pipe((0, operators_1.map)(simpleTxHistory => Object.assign(Object.assign({}, simpleTxHistory), {\n    transactions: simpleTxHistory.transactions.map(simpleExecutedTX => decorateSimpleExecutedTransactionWithType(simpleExecutedTX, activeAddress))\n  })))));\n  const node$ = (0, rxjs_1.merge)(nodeSubject.asObservable(), coreAPISubject.asObservable().pipe((0, operators_1.map)(api => api.node)));\n  const activeAccount = wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.observeActiveAccount()), (0, operators_1.shareReplay)(1), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.equals(cur)));\n  const accounts = wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.observeAccounts()), (0, operators_1.shareReplay)(1));\n  const __makeTransactionFromIntent = (transactionIntent$, options) => {\n    var _a;\n    const txLog = radixLog; // TODO configure child loggers\n    const txSubs = new rxjs_1.Subscription();\n    txLog.debug(`Start of transaction flow, inside constructor of 'TransactionTracking'.`);\n    const signUnsignedTx = unsignedTx => {\n      txLog.debug('Starting signing transaction (async).');\n      return (0, rxjs_1.combineLatest)(transactionIntent$, activeAccount.pipe((0, operators_1.take)(1))).pipe((0, operators_1.mergeMap)(([transactionIntent, account]) => {\n        const nonXRDHRPsOfRRIsInTx = transactionIntent.actions.filter(a => a.type === actions_1.ActionType.TOKEN_TRANSFER).map(a => a).filter(t => t.rri.name !== 'xrd').map(t => t.rri.name);\n        const uniquenonXRDHRPsOfRRIsInTx = [...new Set(nonXRDHRPsOfRRIsInTx)];\n        if (uniquenonXRDHRPsOfRRIsInTx.length > 1) {\n          const errMsg = `Error cannot sign transction with multiple non-XRD RRIs. Unsupported by Ledger app.`;\n          util_1.log.error(errMsg);\n          return (0, rxjs_1.throwError)(new Error(errMsg));\n        }\n        const nonXRDHrp = uniquenonXRDHRPsOfRRIsInTx.length === 1 ? uniquenonXRDHRPsOfRRIsInTx[0] : undefined;\n        return account.sign(unsignedTx.transaction, nonXRDHrp).pipe((0, operators_1.map)(signature => {\n          const publicKeyOfSigner = account.publicKey;\n          txLog.debug(`Finished signing transaction`);\n          return {\n            transaction: unsignedTx.transaction,\n            signature,\n            publicKeyOfSigner\n          };\n        }));\n      }));\n    };\n    const pendingTXSubject = new rxjs_1.Subject();\n    const askUserToConfirmSubject = new rxjs_1.ReplaySubject();\n    const userDidConfirmTransactionSubject = new rxjs_1.ReplaySubject();\n    if (shouldConfirmTransactionAutomatically(options.userConfirmation)) {\n      txLog.debug('Transaction has been setup to be automatically confirmed, requiring no final confirmation input from user.');\n      txSubs.add(askUserToConfirmSubject.subscribe(() => {\n        txLog.debug(`askUserToConfirmSubject got 'next', calling 'next' on 'userDidConfirmTransactionSubject'`);\n        userDidConfirmTransactionSubject.next(0);\n      }));\n    } else {\n      txLog.debug(`Transaction has been setup so that it requires a manual final confirmation from user before being finalized.`);\n      const twoWayConfirmationSubject = options.userConfirmation;\n      txSubs.add(askUserToConfirmSubject.subscribe(ux => {\n        txLog.info(`Forwarding signedUnconfirmedTX and 'userDidConfirmTransactionSubject' to subject 'twoWayConfirmationSubject' now (inside subscribe to 'askUserToConfirmSubject')`);\n        const confirmation = {\n          txToConfirm: ux,\n          confirm: () => userDidConfirmTransactionSubject.next(0)\n        };\n        twoWayConfirmationSubject.next(confirmation);\n      }));\n    }\n    const trackingSubject = new rxjs_1.ReplaySubject();\n    const track = event => {\n      trackingSubject.next(event);\n    };\n    const completionSubject = new rxjs_1.Subject();\n    const trackError = input => {\n      const errorEvent = {\n        eventUpdateType: input.inStep,\n        error: input.error\n      };\n      txLog.debug(`Forwarding error to 'errorSubject'`);\n      track(errorEvent);\n      completionSubject.error(errorEvent.error);\n    };\n    const builtTransaction$ = transactionIntent$.pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.switchMap)(([intent, address]) => {\n      txLog.debug('Transaction intent created => requesting ðŸ›° API to build it now.');\n      track({\n        transactionState: intent,\n        eventUpdateType: dto_1.TransactionTrackingEventType.INITIATED\n      });\n      return api.buildTransaction(intent, address);\n    }), (0, operators_1.catchError)(e => {\n      txLog.error(`API failed to build transaction`);\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.BUILT_FROM_INTENT\n      });\n      return rxjs_1.EMPTY;\n    }), (0, operators_1.tap)(builtTx => {\n      txLog.debug('TX built by API => asking for confirmation to sign...');\n      track({\n        transactionState: builtTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.BUILT_FROM_INTENT\n      });\n      askUserToConfirmSubject.next(builtTx);\n    }), (0, operators_1.tap)(builtTx => {\n      track({\n        transactionState: builtTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.ASKED_FOR_CONFIRMATION\n      });\n    }));\n    const signedTransaction$ = (0, rxjs_1.combineLatest)([builtTransaction$, userDidConfirmTransactionSubject]).pipe((0, operators_1.map)(([signedTx, _]) => signedTx), (0, operators_1.tap)(unsignedTx => {\n      track({\n        transactionState: unsignedTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.CONFIRMED\n      });\n    }), (0, operators_1.mergeMap)(unsignedTx => signUnsignedTx(unsignedTx)), (0, operators_1.shareReplay)(1), (0, operators_1.catchError)(e => {\n      txLog.error(`API failed to sign transaction, error: ${JSON.stringify(e, null, 4)}`);\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.SIGNED\n      });\n      return rxjs_1.EMPTY;\n    }));\n    const finalizedTx$ = signedTransaction$.pipe((0, operators_1.mergeMap)(signedTx => {\n      txLog.debug(`Finished signing tx => submitting it to ðŸ›°  API.`);\n      track({\n        transactionState: signedTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.SIGNED\n      });\n      return networkSubject.pipe((0, operators_1.mergeMap)(network => api.finalizeTransaction(network, signedTx)));\n    }), (0, operators_1.catchError)(e => {\n      txLog.error(`API failed to submit transaction, error: ${JSON.stringify(e, null, 4)}`);\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.FINALIZED\n      });\n      return rxjs_1.EMPTY;\n    }), (0, operators_1.tap)(finalizedTx => {\n      track({\n        transactionState: finalizedTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.FINALIZED\n      });\n    }));\n    txSubs.add(finalizedTx$.pipe((0, operators_1.mergeMap)(finalizedTx => networkSubject.pipe((0, operators_1.mergeMap)(network => api.submitSignedTransaction(network, {\n      blob: finalizedTx.blob,\n      txID: finalizedTx.txID\n    })))), (0, operators_1.catchError)(e => {\n      txLog.error(`API failed to submit transaction, error: ${JSON.stringify(e, null, 4)}`);\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.SUBMITTED\n      });\n      return rxjs_1.EMPTY;\n    }), (0, operators_1.tap)({\n      next: pendingTx => {\n        txLog.debug(`Submitted transaction with txID='${pendingTx.txID.toString()}', it is now pending.`);\n        track({\n          transactionState: pendingTx,\n          eventUpdateType: dto_1.TransactionTrackingEventType.SUBMITTED\n        });\n        pendingTXSubject.next(pendingTx);\n      },\n      error: submitTXError => {\n        // TODO would be great to have access to txID here, hopefully API includes it in error msg?\n        txLog.error(`Submission of signed transaction to API failed with error: ${submitTXError.message}`);\n        pendingTXSubject.error(submitTXError);\n      }\n    })).subscribe());\n    const pollTxStatusTrigger = ((_a = options.pollTXStatusTrigger) !== null && _a !== void 0 ? _a : (0, rxjs_1.interval)(1000)).pipe((0, operators_1.share)());\n    const transactionStatus$ = (0, rxjs_1.combineLatest)([pollTxStatusTrigger, pendingTXSubject]).pipe((0, operators_1.mergeMap)(([_, pendingTx]) => {\n      txLog.debug(`Asking API for status of transaction with txID: ${pendingTx.txID.toString()}`);\n      return networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(pendingTx.txID, network).pipe((0, operators_1.retryWhen)((0, utils_1.retryOnErrorCode)({\n        maxRetryAttempts: 3,\n        errorCodes: [404]\n      })))));\n    }), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.status === cur.status), (0, operators_1.share)());\n    const transactionCompletedWithStatusConfirmed$ = transactionStatus$.pipe((0, operators_1.skipWhile)(({\n      status\n    }) => status !== dto_1.TransactionStatus.CONFIRMED), (0, operators_1.take)(1));\n    const transactionCompletedWithStatusFailed$ = transactionStatus$.pipe((0, operators_1.skipWhile)(({\n      status\n    }) => status !== dto_1.TransactionStatus.FAILED), (0, operators_1.take)(1));\n    txSubs.add(transactionStatus$.subscribe({\n      next: statusOfTransaction => {\n        const {\n          status,\n          txID\n        } = statusOfTransaction;\n        txLog.debug(`Status ${status.toString()} of transaction with txID='${txID.toString()}'`);\n        track({\n          transactionState: statusOfTransaction,\n          eventUpdateType: dto_1.TransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX\n        });\n      },\n      error: transactionStatusError => {\n        // TODO hmm how to get txID here?\n        txLog.error(`Failed to get status of transaction`, transactionStatusError);\n      }\n    }));\n    txSubs.add(transactionCompletedWithStatusConfirmed$.subscribe({\n      next: statusOfTransaction => {\n        const {\n          txID\n        } = statusOfTransaction;\n        txLog.info(`Transaction with txID='${txID.toString()}' has completed succesfully.`);\n        track({\n          transactionState: statusOfTransaction,\n          eventUpdateType: dto_1.TransactionTrackingEventType.COMPLETED\n        });\n        completionSubject.next(txID);\n        completionSubject.complete();\n        txSubs.unsubscribe();\n      }\n    }));\n    txSubs.add(transactionCompletedWithStatusFailed$.subscribe(status => {\n      const errMsg = `API status of tx with id=${status.txID.toString()} returned 'FAILED'`;\n      txLog.error(errMsg);\n      trackError({\n        error: new Error(errMsg),\n        inStep: dto_1.TransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX\n      });\n      txSubs.unsubscribe();\n    }));\n    return {\n      completion: completionSubject.asObservable(),\n      events: trackingSubject.asObservable()\n    };\n  };\n  const __makeTransactionFromBuilder = (transactionIntentBuilderT, makeTXOptions, builderOptions) => {\n    radixLog.debug(`make transaction from builder`);\n    const intent$ = transactionIntentBuilderT.build(builderOptions !== null && builderOptions !== void 0 ? builderOptions : {\n      skipEncryptionOfMessageIfAny: {\n        spendingSender: activeAddress.pipe((0, operators_1.take)(1)) // IMPORTANT !\n      }\n    });\n    return __makeTransactionFromIntent(intent$, makeTXOptions);\n  };\n  const transferTokens = input => {\n    radixLog.debug(`transferTokens`);\n    const builder = dto_1.TransactionIntentBuilder.create().transferTokens(input.transferInput);\n    let encryptMsgIfAny = false;\n    if (input.message) {\n      builder.message(input.message);\n      encryptMsgIfAny = input.message.encrypt;\n    }\n    return __makeTransactionFromBuilder(builder, Object.assign({}, input), encryptMsgIfAny ? {\n      encryptMessageIfAnyWithAccount: activeAccount.pipe((0, operators_1.take)(1))\n    } : undefined);\n  };\n  const stakeTokens = input => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n    radixLog.debug('stake');\n    const nativeToken = yield (0, rxjs_1.firstValueFrom)(nativeTokenSubject);\n    return __makeTransactionFromBuilder(dto_1.TransactionIntentBuilder.create().stakeTokens(Object.assign(Object.assign({}, input.stakeInput), {\n      tokenIdentifier: nativeToken.rri\n    })), Object.assign({}, input));\n  });\n  const unstakeTokens = input => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n    radixLog.debug('unstake');\n    const nativeToken = yield (0, rxjs_1.firstValueFrom)(nativeTokenSubject);\n    return __makeTransactionFromBuilder(dto_1.TransactionIntentBuilder.create().unstakeTokens(Object.assign(Object.assign({}, input.unstakeInput), {\n      tokenIdentifier: nativeToken.rri\n    })), Object.assign({}, input));\n  });\n  const decryptTransaction = input => {\n    radixLog.debug(`Trying to decrypt transaction with txID=${input.txID.toString()}`);\n    if (!input.message) {\n      const noMsg = `TX contains no message, nothing to decrypt (txID=${input.txID.toString()}).`;\n      radixLog.info(noMsg);\n      return (0, rxjs_1.throwError)(() => new Error(noMsg));\n    }\n    const messageBuffer = Buffer.from(input.message, 'hex');\n    const encryptedMessageResult = crypto_1.Message.fromBuffer(messageBuffer);\n    if (!encryptedMessageResult.isOk()) {\n      const errMessage = `Failed to parse message as 'EncryptedMessage' type, underlying error: '${(0, util_1.msgFromError)(encryptedMessageResult.error)}'. Might not have been encrypted? Try decode string as UTF-8 string.`;\n      util_1.log.warn(errMessage);\n      return (0, rxjs_1.throwError)(new Error(errMessage));\n    }\n    const encryptedMessage = encryptedMessageResult.value;\n    if (encryptedMessage.kind !== 'ENCRYPTED') return (0, rxjs_1.of)(encryptedMessage.plaintext);\n    return activeAccount.pipe((0, operators_1.take)(1), (0, operators_1.mergeMap)(account => {\n      const myPublicKey = account.publicKey;\n      util_1.log.debug(`Trying to decrypt message with activeSigningKey with pubKey=${myPublicKey.toString()}`);\n      const publicKeyOfOtherPartyResult = (0, dto_1.singleRecipientFromActions)(myPublicKey, input.actions);\n      if (!publicKeyOfOtherPartyResult.isOk()) {\n        return (0, rxjs_1.throwError)(new Error((0, util_1.msgFromError)(publicKeyOfOtherPartyResult.error)));\n      }\n      util_1.log.debug(`Trying to decrypt message with publicKeyOfOtherPartyResult=${publicKeyOfOtherPartyResult.toString()}`);\n      return account.decrypt({\n        encryptedMessage,\n        publicKeyOfOtherParty: publicKeyOfOtherPartyResult.value\n      });\n    }), (0, operators_1.take)(1));\n  };\n  const restoreLocalHDAccountsToIndex = index => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.restoreLocalHDAccountsToIndex(index)));\n  subs.add(deriveNextLocalHDAccountSubject.pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.mergeMap)(([derivation, wallet]) => wallet.deriveNextLocalHDAccount(derivation))).subscribe());\n  subs.add(addAccountByPrivateKeySubject.pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.mergeMap)(([privateKeyInput, wallet]) => wallet.addAccountFromPrivateKey(privateKeyInput))).subscribe());\n  subs.add(switchAccountSubject.pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.tap)(([switchTo, wallet]) => wallet.switchAccount(switchTo))).subscribe());\n  let headerSub;\n  const methods = {\n    // we forward the full `RadixAPI`, but we also provide some convenience methods based on active account/address.\n    ledger: Object.assign({}, api),\n    __wallet: wallet$,\n    __node: node$,\n    __reset: () => subs.unsubscribe(),\n    // Primarily useful for testing\n    __withNodeConnection: node$ => {\n      subs.add(node$.subscribe(n => {\n        radixLog.debug(`Using node ${n.url.toString()}`);\n        nodeSubject.next(n);\n      }, error => {\n        errorNotificationSubject.next((0, errors_1.nodeError)(error));\n      }));\n      return methods;\n    },\n    __withAPI: radixCoreAPI$ => {\n      subs.add(radixCoreAPI$.subscribe(a => coreAPISubject.next(a)));\n      return methods;\n    },\n    __withWallet: wallet => {\n      walletSubject.next(wallet);\n      return methods;\n    },\n    __withKeychain: signingKeychain => {\n      (0, rxjs_1.firstValueFrom)(networkSubject).then(network => {\n        const wallet = wallet_1.Wallet.create({\n          signingKeychain,\n          network\n        });\n        methods.__withWallet(wallet);\n      });\n      return methods;\n    },\n    connect: url => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n      methods.__withNodeConnection((0, rxjs_1.of)({\n        url: new URL(url)\n      }));\n      const networkId = yield (0, rxjs_1.firstValueFrom)(api.networkId());\n      const nativeToken = yield (0, rxjs_1.firstValueFrom)(api.nativeToken(networkId));\n      networkSubject.next(networkId);\n      nativeTokenSubject.next(nativeToken);\n    }),\n    login: (password, loadKeystore) => {\n      walletSubscription === null || walletSubscription === void 0 ? void 0 : walletSubscription.unsubscribe();\n      void account_1.SigningKeychain.byLoadingAndDecryptingKeystore({\n        password,\n        load: loadKeystore\n      }).then(signingKeychainResult => {\n        signingKeychainResult.match(signingKeychain => {\n          walletSubscription = networkSubject.subscribe(network => {\n            const wallet = wallet_1.Wallet.create({\n              signingKeychain,\n              network\n            });\n            methods.__withWallet(wallet);\n          });\n        }, error => {\n          errorNotificationSubject.next((0, errors_1.walletError)(error));\n        });\n      });\n      return methods;\n    },\n    errors: errorNotificationSubject.asObservable(),\n    deriveNextAccount: input => {\n      const derivation = input !== null && input !== void 0 ? input : {};\n      deriveNextLocalHDAccountSubject.next(derivation);\n      return methods;\n    },\n    deriveHWAccount: input => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.deriveHWAccount(input))),\n    displayAddressForActiveHWAccountOnHWDeviceForVerification: () => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.displayAddressForActiveHWAccountOnHWDeviceForVerification())),\n    addAccountFromPrivateKey: input => {\n      addAccountByPrivateKeySubject.next(input);\n      return methods;\n    },\n    switchAccount: input => {\n      switchAccountSubject.next(input);\n      return methods;\n    },\n    restoreLocalHDAccountsToIndex,\n    decryptTransaction: decryptTransaction,\n    logLevel: level => {\n      util_1.log.setLevel(level);\n      return methods;\n    },\n    transactionStatus: (txID, trigger) => trigger.pipe((0, operators_1.withLatestFrom)(networkSubject), (0, operators_1.mergeMap)(([_, network]) => api.getTransaction(txID, network)), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.status === cur.status), (0, operators_1.filter)(({\n      txID\n    }) => txID.equals(txID)), (0, operators_1.tap)(({\n      status\n    }) => radixLog.info(`Got transaction status ${status.toString()} for txID: ${txID.toString()}`))),\n    withTokenBalanceFetchTrigger: trigger => {\n      subs.add(trigger.subscribe(tokenBalanceFetchSubject));\n      return methods;\n    },\n    withStakingFetchTrigger: trigger => {\n      subs.add(trigger.subscribe(stakingFetchSubject));\n      return methods;\n    },\n    // Wallet APIs\n    revealMnemonic,\n    activeAddress,\n    activeAccount,\n    accounts,\n    // Active AccountAddress/Account APIs\n    tokenBalances,\n    stakingPositions,\n    unstakingPositions,\n    lookupTransaction: txID => networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(txID, network).pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.map)(([simpleTx, aa]) => decorateSimpleExecutedTransactionWithType(simpleTx, aa))))),\n    transactionHistory,\n    transferTokens,\n    stakeTokens,\n    unstakeTokens,\n    getTransaction: txID => networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(txID, network))),\n    validators: () => networkSubject.pipe((0, operators_1.mergeMap)(network => api.validators(network))),\n    setHeaders: headers => {\n      headerSub.unsubscribe();\n      headerSub = coreAPI$.subscribe(api => api.setHeaders(headers));\n    },\n    targetApiVersion: networking_1.apiVersion\n  };\n  return methods;\n};\nexports.Radix = {\n  create\n};","map":{"version":3,"names":["account_1","require","networking_1","api_1","operators_1","rxjs_1","crypto_1","errors_1","util_1","dto_1","actions_1","wallet_1","_1","utils_1","txTypeFromActions","input","activeAddress","myAddress","toString","fromUnique","flatMapAddressesOf","Object","assign","includeTo","map","a","toUnique","includeFrom","toMe","includes","fromMe","TransactionType","FROM_ME_TO_ME","INCOMING","OUTGOING","UNRELATED","decorateSimpleExecutedTransactionWithType","simpleExecutedTX","transactionType","actions","shouldConfirmTransactionAutomatically","confirmationScheme","create","subs","Subscription","radixLog","log","nodeSubject","ReplaySubject","coreAPISubject","walletSubject","errorNotificationSubject","Subject","deriveNextLocalHDAccountSubject","addAccountByPrivateKeySubject","switchAccountSubject","tokenBalanceFetchSubject","stakingFetchSubject","wallet$","asObservable","networkSubject","nativeTokenSubject","walletSubscription","coreAPIViaNode$","pipe","n","radixCoreAPI","nodeAPI","url","coreAPI$","merge","shareReplay","fwdAPICall","pickFn","errorFn","mergeMap","take","catchError","error","isArray","api","networkId","m","networkIdErr","tokenBalancesForAddress","tokenBalancesErr","transactionHistory","transactionHistoryErr","recentTransactions","recentTransactionsErr","nativeToken","nativeTokenErr","tokenInfo","tokenInfoErr","stakesForAddress","stakesForAddressErr","unstakesForAddress","unstakesForAddressErr","validators","validatorsErr","lookupValidator","lookupValidatorErr","getTransaction","transactionStatus","lookupTxErr","buildTransaction","buildTxFromIntentErr","finalizeTransaction","finalizeTxErr","submitSignedTransaction","submitSignedTxErr","observeActiveAccount","address","revealMnemonic","wallet","activeAddressToAPIObservableWithTrigger","trigger","withLatestFrom","result","switchMap","console","next","EMPTY","tokenBalances","stakingPositions","unstakingPositions","simpleTxHistory","transactions","node$","node","activeAccount","distinctUntilChanged","prev","cur","equals","accounts","observeAccounts","__makeTransactionFromIntent","transactionIntent$","options","txLog","txSubs","debug","signUnsignedTx","unsignedTx","combineLatest","transactionIntent","account","nonXRDHRPsOfRRIsInTx","filter","type","ActionType","TOKEN_TRANSFER","t","rri","name","uniquenonXRDHRPsOfRRIsInTx","Set","length","errMsg","throwError","Error","nonXRDHrp","undefined","sign","transaction","signature","publicKeyOfSigner","publicKey","pendingTXSubject","askUserToConfirmSubject","userDidConfirmTransactionSubject","userConfirmation","add","subscribe","twoWayConfirmationSubject","ux","info","confirmation","txToConfirm","confirm","trackingSubject","track","event","completionSubject","trackError","errorEvent","eventUpdateType","inStep","builtTransaction$","intent","transactionState","TransactionTrackingEventType","INITIATED","e","BUILT_FROM_INTENT","tap","builtTx","ASKED_FOR_CONFIRMATION","signedTransaction$","signedTx","_","CONFIRMED","JSON","stringify","SIGNED","finalizedTx$","network","FINALIZED","finalizedTx","blob","txID","SUBMITTED","pendingTx","submitTXError","message","pollTxStatusTrigger","_a","pollTXStatusTrigger","interval","share","transactionStatus$","retryWhen","retryOnErrorCode","maxRetryAttempts","errorCodes","status","transactionCompletedWithStatusConfirmed$","skipWhile","TransactionStatus","transactionCompletedWithStatusFailed$","FAILED","statusOfTransaction","UPDATE_OF_STATUS_OF_PENDING_TX","transactionStatusError","COMPLETED","complete","unsubscribe","completion","events","__makeTransactionFromBuilder","transactionIntentBuilderT","makeTXOptions","builderOptions","intent$","build","skipEncryptionOfMessageIfAny","spendingSender","transferTokens","builder","TransactionIntentBuilder","transferInput","encryptMsgIfAny","encrypt","encryptMessageIfAnyWithAccount","stakeTokens","tslib_1","__awaiter","firstValueFrom","stakeInput","tokenIdentifier","unstakeTokens","unstakeInput","decryptTransaction","noMsg","messageBuffer","Buffer","from","encryptedMessageResult","Message","fromBuffer","isOk","errMessage","msgFromError","warn","encryptedMessage","value","kind","of","plaintext","myPublicKey","publicKeyOfOtherPartyResult","singleRecipientFromActions","decrypt","publicKeyOfOtherParty","restoreLocalHDAccountsToIndex","index","derivation","deriveNextLocalHDAccount","privateKeyInput","addAccountFromPrivateKey","switchTo","switchAccount","headerSub","methods","ledger","__wallet","__node","__reset","__withNodeConnection","nodeError","__withAPI","radixCoreAPI$","__withWallet","__withKeychain","signingKeychain","then","Wallet","connect","URL","login","password","loadKeystore","SigningKeychain","byLoadingAndDecryptingKeystore","load","signingKeychainResult","match","walletError","errors","deriveNextAccount","deriveHWAccount","displayAddressForActiveHWAccountOnHWDeviceForVerification","logLevel","level","setLevel","withTokenBalanceFetchTrigger","withStakingFetchTrigger","lookupTransaction","simpleTx","aa","setHeaders","headers","targetApiVersion","apiVersion","exports","Radix"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/application/src/radix.ts"],"sourcesContent":["import {\n\tAccountAddressT,\n\tDeriveHWSigningKeyInput,\n\tDeriveNextInput,\n\tSigningKeychain,\n\tSigningKeychainT,\n} from '@radixdlt/account'\nimport { Network } from '@radixdlt/primitives'\nimport { apiVersion } from '@radixdlt/networking'\nimport { nodeAPI, NodeT, radixCoreAPI, RadixCoreAPI } from './api'\n\nimport {\n\tcatchError,\n\tdistinctUntilChanged,\n\tfilter,\n\tmap,\n\tmergeMap,\n\tretryWhen,\n\tshare,\n\tshareReplay,\n\tskipWhile,\n\tswitchMap,\n\ttake,\n\ttap,\n\twithLatestFrom,\n} from 'rxjs/operators'\nimport {\n\tcombineLatest,\n\tEMPTY,\n\tfirstValueFrom,\n\tinterval,\n\tmerge,\n\tObservable,\n\tof,\n\tReplaySubject,\n\tSubject,\n\tSubscription,\n\tthrowError,\n} from 'rxjs'\nimport { KeystoreT, Message, MnemomicT } from '@radixdlt/crypto'\nimport {\n\tAddAccountByPrivateKeyInput,\n\tAccountsT,\n\tWalletT,\n\tAccountT,\n\tMakeTransactionOptions,\n\tManualUserConfirmTX,\n\tSwitchAccountInput,\n\tTransactionConfirmationBeforeFinalization,\n\tTransferTokensOptions,\n} from './_types'\nimport {\n\tAPIError,\n\tAPIErrorObject,\n\tbuildTxFromIntentErr,\n\tfinalizeTxErr,\n\tlookupTxErr,\n\tlookupValidatorErr,\n\tnativeTokenErr,\n\tnetworkIdErr,\n\tnodeError,\n\trecentTransactionsErr,\n\tstakesForAddressErr,\n\tsubmitSignedTxErr,\n\ttokenBalancesErr,\n\ttransactionHistoryErr,\n\tunstakesForAddressErr,\n\tvalidatorsErr,\n\twalletError,\n} from './errors'\nimport { log, LogLevel, msgFromError, isArray } from '@radixdlt/util'\nimport {\n\tBuiltTransaction,\n\tExecutedTransaction,\n\tFinalizedTransaction,\n\tflatMapAddressesOf,\n\tPendingTransaction,\n\tSignedTransaction,\n\tSimpleExecutedTransaction,\n\tSimpleTransactionHistory,\n\tsingleRecipientFromActions,\n\tToken,\n\tTransactionHistory,\n\tTransactionHistoryActiveAccountRequestInput,\n\tTransactionIdentifierT,\n\tTransactionIntent,\n\tTransactionIntentBuilder,\n\tTransactionIntentBuilderOptions,\n\tTransactionIntentBuilderT,\n\tTransactionStateError,\n\tTransactionStateUpdate,\n\tTransactionTracking,\n\tTransactionTrackingEventType,\n\tTransactionType,\n\tTransactionStatus,\n} from './dto'\nimport {\n\tActionType,\n\tExecutedAction,\n\tTransferTokensAction,\n\tStakeTokensInput,\n\tUnstakeTokensInput,\n} from './actions'\nimport { Wallet } from './wallet'\nimport { tokenInfoErr } from '.'\nimport { retryOnErrorCode } from './api/utils'\n\nconst txTypeFromActions = (\n\tinput: Readonly<{\n\t\tactions: ExecutedAction[]\n\t\tactiveAddress: AccountAddressT\n\t}>,\n): TransactionType => {\n\tconst { activeAddress } = input\n\tconst myAddress = activeAddress.toString()\n\tconst fromUnique = flatMapAddressesOf({\n\t\t...input,\n\t\tincludeTo: false,\n\t}).map(a => a.toString())\n\tconst toUnique = flatMapAddressesOf({\n\t\t...input,\n\t\tincludeFrom: false,\n\t}).map(a => a.toString())\n\n\tconst toMe = toUnique.includes(myAddress)\n\tconst fromMe = fromUnique.includes(myAddress)\n\n\tif (toMe && fromMe) {\n\t\treturn TransactionType.FROM_ME_TO_ME\n\t} else if (toMe) {\n\t\treturn TransactionType.INCOMING\n\t} else if (fromMe) {\n\t\treturn TransactionType.OUTGOING\n\t} else {\n\t\treturn TransactionType.UNRELATED\n\t}\n}\n\nconst decorateSimpleExecutedTransactionWithType = (\n\tsimpleExecutedTX: SimpleExecutedTransaction,\n\tactiveAddress: AccountAddressT,\n): ExecutedTransaction => ({\n\t...simpleExecutedTX,\n\ttransactionType: txTypeFromActions({\n\t\tactions: simpleExecutedTX.actions,\n\t\tactiveAddress,\n\t}),\n})\n\nconst shouldConfirmTransactionAutomatically = (\n\tconfirmationScheme: TransactionConfirmationBeforeFinalization,\n): confirmationScheme is 'skip' => confirmationScheme === 'skip'\n\nconst create = () => {\n\tconst subs = new Subscription()\n\tconst radixLog = log // TODO configure child loggers\n\n\tconst nodeSubject = new ReplaySubject<NodeT>()\n\tconst coreAPISubject = new ReplaySubject<RadixCoreAPI>()\n\tconst walletSubject = new ReplaySubject<WalletT>()\n\tconst errorNotificationSubject = new Subject<APIError>()\n\n\tconst deriveNextLocalHDAccountSubject = new Subject<DeriveNextInput>()\n\tconst addAccountByPrivateKeySubject = new Subject<AddAccountByPrivateKeyInput>()\n\tconst switchAccountSubject = new Subject<SwitchAccountInput>()\n\n\tconst tokenBalanceFetchSubject = new Subject<number>()\n\tconst stakingFetchSubject = new Subject<number>()\n\tconst wallet$ = walletSubject.asObservable()\n\n\tconst networkSubject = new ReplaySubject<Network>()\n\tconst nativeTokenSubject = new ReplaySubject<Token>()\n\n\tlet walletSubscription: Subscription\n\n\tconst coreAPIViaNode$ = nodeSubject\n\t\t.asObservable()\n\t\t.pipe(map((n: NodeT) => radixCoreAPI(n, nodeAPI(n.url))))\n\n\tconst coreAPI$ = merge(coreAPIViaNode$, coreAPISubject.asObservable()).pipe(\n\t\tshareReplay(1),\n\t)\n\t// Forwards calls to RadixCoreAPI, return type is a function: `(input?: I) => Observable<O>`\n\tconst fwdAPICall = <I extends unknown[], O>(\n\t\tpickFn: (api: RadixCoreAPI) => (...input: I) => Observable<O>,\n\t\terrorFn: (error: APIErrorObject) => APIError,\n\t) => (...input: I) =>\n\t\tcoreAPI$.pipe(\n\t\t\tmergeMap(a => pickFn(a)(...input)),\n\t\t\ttake(1), // Important!\n\t\t\tcatchError((error: unknown) => {\n\t\t\t\tthrow errorFn(isArray(error) ? (error as any)[0] : error)\n\t\t\t}),\n\t\t)\n\n\tconst api = {\n\t\tnetworkId: fwdAPICall(\n\t\t\ta => a.networkId,\n\t\t\tm => networkIdErr(m),\n\t\t),\n\n\t\ttokenBalancesForAddress: fwdAPICall(\n\t\t\ta => a.tokenBalancesForAddress,\n\t\t\tm => tokenBalancesErr(m),\n\t\t),\n\n\t\ttransactionHistory: fwdAPICall(\n\t\t\ta => a.transactionHistory,\n\t\t\tm => transactionHistoryErr(m),\n\t\t),\n\n\t\trecentTransactions: fwdAPICall(\n\t\t\ta => a.recentTransactions,\n\t\t\tm => recentTransactionsErr(m),\n\t\t),\n\n\t\tnativeToken: fwdAPICall(\n\t\t\ta => a.nativeToken,\n\t\t\tm => nativeTokenErr(m),\n\t\t),\n\n\t\ttokenInfo: fwdAPICall(\n\t\t\ta => a.tokenInfo,\n\t\t\tm => tokenInfoErr(m),\n\t\t),\n\n\t\tstakesForAddress: fwdAPICall(\n\t\t\ta => a.stakesForAddress,\n\t\t\tm => stakesForAddressErr(m),\n\t\t),\n\n\t\tunstakesForAddress: fwdAPICall(\n\t\t\ta => a.unstakesForAddress,\n\t\t\tm => unstakesForAddressErr(m),\n\t\t),\n\n\t\tvalidators: fwdAPICall(\n\t\t\ta => a.validators,\n\t\t\tm => validatorsErr(m),\n\t\t),\n\n\t\tlookupValidator: fwdAPICall(\n\t\t\ta => a.lookupValidator,\n\t\t\tm => lookupValidatorErr(m),\n\t\t),\n\n\t\tgetTransaction: fwdAPICall(\n\t\t\ta => a.transactionStatus,\n\t\t\tm => lookupTxErr(m),\n\t\t),\n\t\tbuildTransaction: fwdAPICall(\n\t\t\ta => a.buildTransaction,\n\t\t\tm => buildTxFromIntentErr(m),\n\t\t),\n\n\t\tfinalizeTransaction: fwdAPICall(\n\t\t\ta => a.finalizeTransaction,\n\t\t\tm => finalizeTxErr(m),\n\t\t),\n\t\tsubmitSignedTransaction: fwdAPICall(\n\t\t\ta => a.submitSignedTransaction,\n\t\t\tm => submitSignedTxErr(m),\n\t\t),\n\t}\n\n\tconst activeAddress = wallet$.pipe(\n\t\tmergeMap(a => a.observeActiveAccount()),\n\t\tmap(a => a.address),\n\t\tshareReplay(1),\n\t)\n\n\tconst revealMnemonic = (): Observable<MnemomicT> =>\n\t\twallet$.pipe(\n\t\t\tmap((wallet: WalletT): MnemomicT => wallet.revealMnemonic()),\n\t\t)\n\n\tconst activeAddressToAPIObservableWithTrigger = <O>(\n\t\ttrigger: Observable<number>,\n\t\tpickFn: (\n\t\t\tapi: RadixCoreAPI,\n\t\t) => (address: AccountAddressT) => Observable<O>,\n\t\terrorFn: (error: APIErrorObject) => APIError,\n\t): Observable<O> =>\n\t\tmerge(\n\t\t\ttrigger.pipe(\n\t\t\t\twithLatestFrom(activeAddress),\n\t\t\t\tmap(result => result[1]),\n\t\t\t),\n\t\t\tactiveAddress,\n\t\t).pipe(\n\t\t\twithLatestFrom(coreAPI$),\n\t\t\tswitchMap(([address, api]) =>\n\t\t\t\tpickFn(api)(address).pipe(\n\t\t\t\t\tcatchError(error => {\n\t\t\t\t\t\tconsole.error(error)\n\t\t\t\t\t\terrorNotificationSubject.next(errorFn(error))\n\t\t\t\t\t\treturn EMPTY\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t),\n\t\t\tshareReplay(1),\n\t\t)\n\n\tconst tokenBalances = activeAddressToAPIObservableWithTrigger(\n\t\ttokenBalanceFetchSubject,\n\t\ta => a.tokenBalancesForAddress,\n\t\ttokenBalancesErr,\n\t)\n\n\t/*\n\t\tconst decorateSimpleTokenBalanceWithTokenInfo = (\n\t\t\tsimpleTokenBalance: SimpleTokenBalance,\n\t\t): Observable<TokenBalance> =>\n\t\t\tapi.tokenInfo(simpleTokenBalance.tokenIdentifier).pipe(\n\t\t\t\tmap(\n\t\t\t\t\t(tokenInfo: Token): TokenBalance => ({\n\t\t\t\t\t\tamount: simpleTokenBalance.amount,\n\t\t\t\t\t\ttoken: tokenInfo,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t)\n\t*/\n\tconst stakingPositions = activeAddressToAPIObservableWithTrigger(\n\t\tstakingFetchSubject,\n\t\ta => a.stakesForAddress,\n\t\tstakesForAddressErr,\n\t)\n\n\tconst unstakingPositions = activeAddressToAPIObservableWithTrigger(\n\t\tstakingFetchSubject,\n\t\ta => a.unstakesForAddress,\n\t\tunstakesForAddressErr,\n\t)\n\n\tconst transactionHistory = (\n\t\tinput: TransactionHistoryActiveAccountRequestInput,\n\t): Observable<TransactionHistory> =>\n\t\tactiveAddress.pipe(\n\t\t\ttake(1),\n\t\t\tswitchMap(activeAddress =>\n\t\t\t\tapi\n\t\t\t\t\t.transactionHistory({ ...input, address: activeAddress })\n\t\t\t\t\t.pipe(\n\t\t\t\t\t\tmap(\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tsimpleTxHistory: SimpleTransactionHistory,\n\t\t\t\t\t\t\t): TransactionHistory => ({\n\t\t\t\t\t\t\t\t...simpleTxHistory,\n\t\t\t\t\t\t\t\ttransactions: simpleTxHistory.transactions.map(\n\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\tsimpleExecutedTX: SimpleExecutedTransaction,\n\t\t\t\t\t\t\t\t\t): ExecutedTransaction =>\n\t\t\t\t\t\t\t\t\t\tdecorateSimpleExecutedTransactionWithType(\n\t\t\t\t\t\t\t\t\t\t\tsimpleExecutedTX,\n\t\t\t\t\t\t\t\t\t\t\tactiveAddress,\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\tconst node$ = merge(\n\t\tnodeSubject.asObservable(),\n\t\tcoreAPISubject.asObservable().pipe(map(api => api.node)),\n\t)\n\n\tconst activeAccount: Observable<AccountT> = wallet$.pipe(\n\t\tmergeMap(wallet => wallet.observeActiveAccount()),\n\t\tshareReplay(1),\n\t\tdistinctUntilChanged((prev, cur) => prev.equals(cur)),\n\t)\n\n\tconst accounts = wallet$.pipe(\n\t\tmergeMap(wallet => wallet.observeAccounts()),\n\t\tshareReplay(1),\n\t)\n\n\tconst __makeTransactionFromIntent = (\n\t\ttransactionIntent$: Observable<TransactionIntent>,\n\t\toptions: MakeTransactionOptions,\n\t): TransactionTracking => {\n\t\tconst txLog = radixLog // TODO configure child loggers\n\t\tconst txSubs = new Subscription()\n\n\t\ttxLog.debug(\n\t\t\t`Start of transaction flow, inside constructor of 'TransactionTracking'.`,\n\t\t)\n\n\t\tconst signUnsignedTx = (\n\t\t\tunsignedTx: BuiltTransaction,\n\t\t): Observable<SignedTransaction> => {\n\t\t\ttxLog.debug('Starting signing transaction (async).')\n\t\t\treturn combineLatest(\n\t\t\t\ttransactionIntent$,\n\t\t\t\tactiveAccount.pipe(take(1)),\n\t\t\t).pipe(\n\t\t\t\tmergeMap(\n\t\t\t\t\t([\n\t\t\t\t\t\ttransactionIntent,\n\t\t\t\t\t\taccount,\n\t\t\t\t\t]): Observable<SignedTransaction> => {\n\t\t\t\t\t\tconst nonXRDHRPsOfRRIsInTx: string[] = transactionIntent.actions\n\t\t\t\t\t\t\t.filter(a => a.type === ActionType.TOKEN_TRANSFER)\n\t\t\t\t\t\t\t.map(a => a as TransferTokensAction)\n\t\t\t\t\t\t\t.filter(t => t.rri.name !== 'xrd')\n\t\t\t\t\t\t\t.map(t => t.rri.name)\n\n\t\t\t\t\t\tconst uniquenonXRDHRPsOfRRIsInTx = [\n\t\t\t\t\t\t\t...new Set(nonXRDHRPsOfRRIsInTx),\n\t\t\t\t\t\t]\n\n\t\t\t\t\t\tif (uniquenonXRDHRPsOfRRIsInTx.length > 1) {\n\t\t\t\t\t\t\tconst errMsg = `Error cannot sign transction with multiple non-XRD RRIs. Unsupported by Ledger app.`\n\t\t\t\t\t\t\tlog.error(errMsg)\n\t\t\t\t\t\t\treturn throwError(new Error(errMsg))\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst nonXRDHrp =\n\t\t\t\t\t\t\tuniquenonXRDHRPsOfRRIsInTx.length === 1\n\t\t\t\t\t\t\t\t? uniquenonXRDHRPsOfRRIsInTx[0]\n\t\t\t\t\t\t\t\t: undefined\n\n\t\t\t\t\t\treturn account\n\t\t\t\t\t\t\t.sign(unsignedTx.transaction, nonXRDHrp)\n\t\t\t\t\t\t\t.pipe(\n\t\t\t\t\t\t\t\tmap(\n\t\t\t\t\t\t\t\t\t(signature): SignedTransaction => {\n\t\t\t\t\t\t\t\t\t\tconst publicKeyOfSigner =\n\t\t\t\t\t\t\t\t\t\t\taccount.publicKey\n\t\t\t\t\t\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Finished signing transaction`,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttransaction: unsignedTx.transaction,\n\t\t\t\t\t\t\t\t\t\t\tsignature,\n\t\t\t\t\t\t\t\t\t\t\tpublicKeyOfSigner,\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tconst pendingTXSubject = new Subject<PendingTransaction>()\n\n\t\tconst askUserToConfirmSubject = new ReplaySubject<BuiltTransaction>()\n\t\tconst userDidConfirmTransactionSubject = new ReplaySubject<0>()\n\n\t\tif (shouldConfirmTransactionAutomatically(options.userConfirmation)) {\n\t\t\ttxLog.debug(\n\t\t\t\t'Transaction has been setup to be automatically confirmed, requiring no final confirmation input from user.',\n\t\t\t)\n\t\t\ttxSubs.add(\n\t\t\t\taskUserToConfirmSubject.subscribe(() => {\n\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t`askUserToConfirmSubject got 'next', calling 'next' on 'userDidConfirmTransactionSubject'`,\n\t\t\t\t\t)\n\t\t\t\t\tuserDidConfirmTransactionSubject.next(0)\n\t\t\t\t}),\n\t\t\t)\n\t\t} else {\n\t\t\ttxLog.debug(\n\t\t\t\t`Transaction has been setup so that it requires a manual final confirmation from user before being finalized.`,\n\t\t\t)\n\t\t\tconst twoWayConfirmationSubject: Subject<ManualUserConfirmTX> =\n\t\t\t\toptions.userConfirmation\n\n\t\t\ttxSubs.add(\n\t\t\t\taskUserToConfirmSubject.subscribe(ux => {\n\t\t\t\t\ttxLog.info(\n\t\t\t\t\t\t`Forwarding signedUnconfirmedTX and 'userDidConfirmTransactionSubject' to subject 'twoWayConfirmationSubject' now (inside subscribe to 'askUserToConfirmSubject')`,\n\t\t\t\t\t)\n\n\t\t\t\t\tconst confirmation: ManualUserConfirmTX = {\n\t\t\t\t\t\ttxToConfirm: ux,\n\t\t\t\t\t\tconfirm: () => userDidConfirmTransactionSubject.next(0),\n\t\t\t\t\t}\n\t\t\t\t\ttwoWayConfirmationSubject.next(confirmation)\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\n\t\tconst trackingSubject = new ReplaySubject<TransactionStateUpdate>()\n\n\t\tconst track = (event: TransactionStateUpdate): void => {\n\t\t\ttrackingSubject.next(event)\n\t\t}\n\n\t\tconst completionSubject = new Subject<TransactionIdentifierT>()\n\n\t\tconst trackError = (\n\t\t\tinput: Readonly<{\n\t\t\t\terror: Error\n\t\t\t\tinStep: TransactionTrackingEventType\n\t\t\t}>,\n\t\t): void => {\n\t\t\tconst errorEvent: TransactionStateError = {\n\t\t\t\teventUpdateType: input.inStep,\n\t\t\t\terror: input.error,\n\t\t\t}\n\t\t\ttxLog.debug(`Forwarding error to 'errorSubject'`)\n\t\t\ttrack(errorEvent)\n\t\t\tcompletionSubject.error(errorEvent.error)\n\t\t}\n\n\t\tconst builtTransaction$ = transactionIntent$.pipe(\n\t\t\twithLatestFrom(activeAddress),\n\t\t\tswitchMap(\n\t\t\t\t([intent, address]): Observable<BuiltTransaction> => {\n\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t'Transaction intent created => requesting ðŸ›° API to build it now.',\n\t\t\t\t\t)\n\t\t\t\t\ttrack({\n\t\t\t\t\t\ttransactionState: intent,\n\t\t\t\t\t\teventUpdateType: TransactionTrackingEventType.INITIATED,\n\t\t\t\t\t})\n\t\t\t\t\treturn api.buildTransaction(intent, address)\n\t\t\t\t},\n\t\t\t),\n\t\t\tcatchError((e: Error) => {\n\t\t\t\ttxLog.error(`API failed to build transaction`)\n\t\t\t\ttrackError({\n\t\t\t\t\terror: e,\n\t\t\t\t\tinStep: TransactionTrackingEventType.BUILT_FROM_INTENT,\n\t\t\t\t})\n\t\t\t\treturn EMPTY\n\t\t\t}),\n\t\t\ttap(builtTx => {\n\t\t\t\ttxLog.debug(\n\t\t\t\t\t'TX built by API => asking for confirmation to sign...',\n\t\t\t\t)\n\t\t\t\ttrack({\n\t\t\t\t\ttransactionState: builtTx,\n\t\t\t\t\teventUpdateType:\n\t\t\t\t\t\tTransactionTrackingEventType.BUILT_FROM_INTENT,\n\t\t\t\t})\n\t\t\t\taskUserToConfirmSubject.next(builtTx)\n\t\t\t}),\n\t\t\ttap(builtTx => {\n\t\t\t\ttrack({\n\t\t\t\t\ttransactionState: builtTx,\n\t\t\t\t\teventUpdateType:\n\t\t\t\t\t\tTransactionTrackingEventType.ASKED_FOR_CONFIRMATION,\n\t\t\t\t})\n\t\t\t}),\n\t\t)\n\n\t\tconst signedTransaction$ = combineLatest([\n\t\t\tbuiltTransaction$,\n\t\t\tuserDidConfirmTransactionSubject,\n\t\t]).pipe(\n\t\t\tmap(([signedTx, _]) => signedTx),\n\t\t\ttap(unsignedTx => {\n\t\t\t\ttrack({\n\t\t\t\t\ttransactionState: unsignedTx,\n\t\t\t\t\teventUpdateType: TransactionTrackingEventType.CONFIRMED,\n\t\t\t\t})\n\t\t\t}),\n\t\t\tmergeMap(unsignedTx => signUnsignedTx(unsignedTx)),\n\t\t\tshareReplay(1),\n\t\t\tcatchError((e: Error) => {\n\t\t\t\ttxLog.error(\n\t\t\t\t\t`API failed to sign transaction, error: ${JSON.stringify(\n\t\t\t\t\t\te,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t4,\n\t\t\t\t\t)}`,\n\t\t\t\t)\n\t\t\t\ttrackError({\n\t\t\t\t\terror: e,\n\t\t\t\t\tinStep: TransactionTrackingEventType.SIGNED,\n\t\t\t\t})\n\t\t\t\treturn EMPTY\n\t\t\t}),\n\t\t)\n\n\t\tconst finalizedTx$ = signedTransaction$.pipe(\n\t\t\tmergeMap(\n\t\t\t\t(\n\t\t\t\t\tsignedTx: SignedTransaction,\n\t\t\t\t): Observable<FinalizedTransaction> => {\n\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t`Finished signing tx => submitting it to ðŸ›°  API.`,\n\t\t\t\t\t)\n\t\t\t\t\ttrack({\n\t\t\t\t\t\ttransactionState: signedTx,\n\t\t\t\t\t\teventUpdateType: TransactionTrackingEventType.SIGNED,\n\t\t\t\t\t})\n\t\t\t\t\treturn networkSubject.pipe(\n\t\t\t\t\t\tmergeMap(network =>\n\t\t\t\t\t\t\tapi.finalizeTransaction(network, signedTx),\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t),\n\t\t\tcatchError((e: Error) => {\n\t\t\t\ttxLog.error(\n\t\t\t\t\t`API failed to submit transaction, error: ${JSON.stringify(\n\t\t\t\t\t\te,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t4,\n\t\t\t\t\t)}`,\n\t\t\t\t)\n\t\t\t\ttrackError({\n\t\t\t\t\terror: e,\n\t\t\t\t\tinStep: TransactionTrackingEventType.FINALIZED,\n\t\t\t\t})\n\t\t\t\treturn EMPTY\n\t\t\t}),\n\t\t\ttap<FinalizedTransaction>(finalizedTx => {\n\t\t\t\ttrack({\n\t\t\t\t\ttransactionState: finalizedTx,\n\t\t\t\t\teventUpdateType: TransactionTrackingEventType.FINALIZED,\n\t\t\t\t})\n\t\t\t}),\n\t\t)\n\n\t\ttxSubs.add(\n\t\t\tfinalizedTx$\n\t\t\t\t.pipe(\n\t\t\t\t\tmergeMap(\n\t\t\t\t\t\t(finalizedTx): Observable<PendingTransaction> =>\n\t\t\t\t\t\t\tnetworkSubject.pipe(\n\t\t\t\t\t\t\t\tmergeMap(network =>\n\t\t\t\t\t\t\t\t\tapi.submitSignedTransaction(network, {\n\t\t\t\t\t\t\t\t\t\tblob: finalizedTx.blob,\n\t\t\t\t\t\t\t\t\t\ttxID: finalizedTx.txID,\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\tcatchError((e: Error) => {\n\t\t\t\t\t\ttxLog.error(\n\t\t\t\t\t\t\t`API failed to submit transaction, error: ${JSON.stringify(\n\t\t\t\t\t\t\t\te,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t\ttrackError({\n\t\t\t\t\t\t\terror: e,\n\t\t\t\t\t\t\tinStep: TransactionTrackingEventType.SUBMITTED,\n\t\t\t\t\t\t})\n\t\t\t\t\t\treturn EMPTY\n\t\t\t\t\t}),\n\t\t\t\t\ttap({\n\t\t\t\t\t\tnext: (pendingTx: PendingTransaction) => {\n\t\t\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t\t\t`Submitted transaction with txID='${pendingTx.txID.toString()}', it is now pending.`,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\ttrack({\n\t\t\t\t\t\t\t\ttransactionState: pendingTx,\n\t\t\t\t\t\t\t\teventUpdateType:\n\t\t\t\t\t\t\t\t\tTransactionTrackingEventType.SUBMITTED,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tpendingTXSubject.next(pendingTx)\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: (submitTXError: Error) => {\n\t\t\t\t\t\t\t// TODO would be great to have access to txID here, hopefully API includes it in error msg?\n\t\t\t\t\t\t\ttxLog.error(\n\t\t\t\t\t\t\t\t`Submission of signed transaction to API failed with error: ${submitTXError.message}`,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tpendingTXSubject.error(submitTXError)\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.subscribe(),\n\t\t)\n\n\t\tconst pollTxStatusTrigger = (\n\t\t\toptions.pollTXStatusTrigger ?? interval(1000)\n\t\t).pipe(share())\n\n\t\tconst transactionStatus$ = combineLatest([\n\t\t\tpollTxStatusTrigger,\n\t\t\tpendingTXSubject,\n\t\t]).pipe(\n\t\t\tmergeMap(([_, pendingTx]) => {\n\t\t\t\ttxLog.debug(\n\t\t\t\t\t`Asking API for status of transaction with txID: ${pendingTx.txID.toString()}`,\n\t\t\t\t)\n\t\t\t\treturn networkSubject.pipe(\n\t\t\t\t\tmergeMap(network =>\n\t\t\t\t\t\tapi.getTransaction(pendingTx.txID, network).pipe(\n\t\t\t\t\t\t\tretryWhen(\n\t\t\t\t\t\t\t\tretryOnErrorCode({\n\t\t\t\t\t\t\t\t\tmaxRetryAttempts: 3,\n\t\t\t\t\t\t\t\t\terrorCodes: [404],\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t}),\n\t\t\tdistinctUntilChanged((prev, cur) => prev.status === cur.status),\n\t\t\tshare(),\n\t\t)\n\n\t\tconst transactionCompletedWithStatusConfirmed$ = transactionStatus$.pipe(\n\t\t\tskipWhile(({ status }) => status !== TransactionStatus.CONFIRMED),\n\t\t\ttake(1),\n\t\t)\n\n\t\tconst transactionCompletedWithStatusFailed$ = transactionStatus$.pipe(\n\t\t\tskipWhile(({ status }) => status !== TransactionStatus.FAILED),\n\t\t\ttake(1),\n\t\t)\n\n\t\ttxSubs.add(\n\t\t\ttransactionStatus$.subscribe({\n\t\t\t\tnext: statusOfTransaction => {\n\t\t\t\t\tconst { status, txID } = statusOfTransaction\n\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t`Status ${status.toString()} of transaction with txID='${txID.toString()}'`,\n\t\t\t\t\t)\n\t\t\t\t\ttrack({\n\t\t\t\t\t\ttransactionState: statusOfTransaction,\n\t\t\t\t\t\teventUpdateType:\n\t\t\t\t\t\t\tTransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX,\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\terror: (transactionStatusError: Error) => {\n\t\t\t\t\t// TODO hmm how to get txID here?\n\t\t\t\t\ttxLog.error(\n\t\t\t\t\t\t`Failed to get status of transaction`,\n\t\t\t\t\t\ttransactionStatusError,\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t}),\n\t\t)\n\n\t\ttxSubs.add(\n\t\t\ttransactionCompletedWithStatusConfirmed$.subscribe({\n\t\t\t\tnext: statusOfTransaction => {\n\t\t\t\t\tconst { txID } = statusOfTransaction\n\t\t\t\t\ttxLog.info(\n\t\t\t\t\t\t`Transaction with txID='${txID.toString()}' has completed succesfully.`,\n\t\t\t\t\t)\n\t\t\t\t\ttrack({\n\t\t\t\t\t\ttransactionState: statusOfTransaction,\n\t\t\t\t\t\teventUpdateType: TransactionTrackingEventType.COMPLETED,\n\t\t\t\t\t})\n\n\t\t\t\t\tcompletionSubject.next(txID)\n\t\t\t\t\tcompletionSubject.complete()\n\t\t\t\t\ttxSubs.unsubscribe()\n\t\t\t\t},\n\t\t\t}),\n\t\t)\n\n\t\ttxSubs.add(\n\t\t\ttransactionCompletedWithStatusFailed$.subscribe(status => {\n\t\t\t\tconst errMsg = `API status of tx with id=${status.txID.toString()} returned 'FAILED'`\n\t\t\t\ttxLog.error(errMsg)\n\t\t\t\ttrackError({\n\t\t\t\t\terror: new Error(errMsg),\n\t\t\t\t\tinStep:\n\t\t\t\t\t\tTransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX,\n\t\t\t\t})\n\t\t\t\ttxSubs.unsubscribe()\n\t\t\t}),\n\t\t)\n\n\t\treturn {\n\t\t\tcompletion: completionSubject.asObservable(),\n\t\t\tevents: trackingSubject.asObservable(),\n\t\t}\n\t}\n\n\tconst __makeTransactionFromBuilder = (\n\t\ttransactionIntentBuilderT: TransactionIntentBuilderT,\n\t\tmakeTXOptions: MakeTransactionOptions,\n\t\tbuilderOptions?: TransactionIntentBuilderOptions,\n\t): TransactionTracking => {\n\t\tradixLog.debug(`make transaction from builder`)\n\t\tconst intent$ = transactionIntentBuilderT.build(\n\t\t\tbuilderOptions ?? {\n\t\t\t\tskipEncryptionOfMessageIfAny: {\n\t\t\t\t\tspendingSender: activeAddress.pipe(take(1)), // IMPORTANT !\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\t\treturn __makeTransactionFromIntent(intent$, makeTXOptions)\n\t}\n\n\tconst transferTokens = (\n\t\tinput: Omit<TransferTokensOptions, 'from_account'>,\n\t): TransactionTracking => {\n\t\tradixLog.debug(`transferTokens`)\n\t\tconst builder = TransactionIntentBuilder.create().transferTokens(\n\t\t\tinput.transferInput,\n\t\t)\n\n\t\tlet encryptMsgIfAny = false\n\t\tif (input.message) {\n\t\t\tbuilder.message(input.message)\n\t\t\tencryptMsgIfAny = input.message.encrypt\n\t\t}\n\n\t\treturn __makeTransactionFromBuilder(\n\t\t\tbuilder,\n\t\t\t{ ...input },\n\t\t\tencryptMsgIfAny\n\t\t\t\t? {\n\t\t\t\t\t\tencryptMessageIfAnyWithAccount: activeAccount.pipe(\n\t\t\t\t\t\t\ttake(1), // Important !\n\t\t\t\t\t\t),\n\t\t\t\t  }\n\t\t\t\t: undefined,\n\t\t)\n\t}\n\n\tconst stakeTokens = async (\n\t\tinput: MakeTransactionOptions & {\n\t\t\tstakeInput: Omit<StakeTokensInput, 'tokenIdentifier'>\n\t\t},\n\t) => {\n\t\tradixLog.debug('stake')\n\t\tconst nativeToken = await firstValueFrom(nativeTokenSubject)\n\t\treturn __makeTransactionFromBuilder(\n\t\t\tTransactionIntentBuilder.create().stakeTokens({\n\t\t\t\t...input.stakeInput,\n\t\t\t\ttokenIdentifier: nativeToken.rri,\n\t\t\t}),\n\t\t\t{ ...input },\n\t\t)\n\t}\n\n\tconst unstakeTokens = async (\n\t\tinput: MakeTransactionOptions & {\n\t\t\tunstakeInput: Omit<UnstakeTokensInput, 'tokenIdentifier'>\n\t\t},\n\t) => {\n\t\tradixLog.debug('unstake')\n\t\tconst nativeToken = await firstValueFrom(nativeTokenSubject)\n\t\treturn __makeTransactionFromBuilder(\n\t\t\tTransactionIntentBuilder.create().unstakeTokens({\n\t\t\t\t...input.unstakeInput,\n\t\t\t\ttokenIdentifier: nativeToken.rri,\n\t\t\t}),\n\t\t\t{ ...input },\n\t\t)\n\t}\n\n\tconst decryptTransaction = (\n\t\tinput: SimpleExecutedTransaction,\n\t): Observable<string> => {\n\t\tradixLog.debug(\n\t\t\t`Trying to decrypt transaction with txID=${input.txID.toString()}`,\n\t\t)\n\n\t\tif (!input.message) {\n\t\t\tconst noMsg = `TX contains no message, nothing to decrypt (txID=${input.txID.toString()}).`\n\t\t\tradixLog.info(noMsg)\n\t\t\treturn throwError(() => new Error(noMsg))\n\t\t}\n\n\t\tconst messageBuffer = Buffer.from(input.message, 'hex')\n\n\t\tconst encryptedMessageResult = Message.fromBuffer(messageBuffer)\n\n\t\tif (!encryptedMessageResult.isOk()) {\n\t\t\tconst errMessage = `Failed to parse message as 'EncryptedMessage' type, underlying error: '${msgFromError(\n\t\t\t\tencryptedMessageResult.error,\n\t\t\t)}'. Might not have been encrypted? Try decode string as UTF-8 string.`\n\t\t\tlog.warn(errMessage)\n\t\t\treturn throwError(new Error(errMessage))\n\t\t}\n\n\t\tconst encryptedMessage = encryptedMessageResult.value\n\n\t\tif (encryptedMessage.kind !== 'ENCRYPTED')\n\t\t\treturn of(encryptedMessage.plaintext)\n\n\t\treturn activeAccount.pipe(\n\t\t\ttake(1),\n\t\t\tmergeMap((account: AccountT) => {\n\t\t\t\tconst myPublicKey = account.publicKey\n\t\t\t\tlog.debug(\n\t\t\t\t\t`Trying to decrypt message with activeSigningKey with pubKey=${myPublicKey.toString()}`,\n\t\t\t\t)\n\t\t\t\tconst publicKeyOfOtherPartyResult = singleRecipientFromActions(\n\t\t\t\t\tmyPublicKey,\n\t\t\t\t\tinput.actions,\n\t\t\t\t)\n\t\t\t\tif (!publicKeyOfOtherPartyResult.isOk()) {\n\t\t\t\t\treturn throwError(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\tmsgFromError(publicKeyOfOtherPartyResult.error),\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tlog.debug(\n\t\t\t\t\t`Trying to decrypt message with publicKeyOfOtherPartyResult=${publicKeyOfOtherPartyResult.toString()}`,\n\t\t\t\t)\n\n\t\t\t\treturn account.decrypt({\n\t\t\t\t\tencryptedMessage,\n\t\t\t\t\tpublicKeyOfOtherParty: publicKeyOfOtherPartyResult.value,\n\t\t\t\t})\n\t\t\t}),\n\t\t\ttake(1),\n\t\t)\n\t}\n\n\tconst restoreLocalHDAccountsToIndex = (\n\t\tindex: number,\n\t): Observable<AccountsT> =>\n\t\twallet$.pipe(\n\t\t\tmergeMap(wallet => wallet.restoreLocalHDAccountsToIndex(index)),\n\t\t)\n\n\tsubs.add(\n\t\tderiveNextLocalHDAccountSubject\n\t\t\t.pipe(\n\t\t\t\twithLatestFrom(wallet$),\n\t\t\t\tmergeMap(([derivation, wallet]) =>\n\t\t\t\t\twallet.deriveNextLocalHDAccount(derivation),\n\t\t\t\t),\n\t\t\t)\n\t\t\t.subscribe(),\n\t)\n\n\tsubs.add(\n\t\taddAccountByPrivateKeySubject\n\t\t\t.pipe(\n\t\t\t\twithLatestFrom(wallet$),\n\t\t\t\tmergeMap(([privateKeyInput, wallet]) =>\n\t\t\t\t\twallet.addAccountFromPrivateKey(privateKeyInput),\n\t\t\t\t),\n\t\t\t)\n\t\t\t.subscribe(),\n\t)\n\n\tsubs.add(\n\t\tswitchAccountSubject\n\t\t\t.pipe(\n\t\t\t\twithLatestFrom(wallet$),\n\t\t\t\ttap(([switchTo, wallet]) => wallet.switchAccount(switchTo)),\n\t\t\t)\n\t\t\t.subscribe(),\n\t)\n\n\tlet headerSub: Subscription\n\n\tconst methods = {\n\t\t// we forward the full `RadixAPI`, but we also provide some convenience methods based on active account/address.\n\t\tledger: {\n\t\t\t...api,\n\t\t},\n\n\t\t__wallet: wallet$,\n\t\t__node: node$,\n\n\t\t__reset: () => subs.unsubscribe(),\n\n\t\t// Primarily useful for testing\n\t\t__withNodeConnection: (node$: Observable<NodeT>) => {\n\t\t\tsubs.add(\n\t\t\t\tnode$.subscribe(\n\t\t\t\t\tn => {\n\t\t\t\t\t\tradixLog.debug(`Using node ${n.url.toString()}`)\n\t\t\t\t\t\tnodeSubject.next(n)\n\t\t\t\t\t},\n\t\t\t\t\t(error: Error) => {\n\t\t\t\t\t\terrorNotificationSubject.next(nodeError(error) as any)\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t)\n\t\t\treturn methods\n\t\t},\n\n\t\t__withAPI: (radixCoreAPI$: Observable<RadixCoreAPI>) => {\n\t\t\tsubs.add(radixCoreAPI$.subscribe(a => coreAPISubject.next(a)))\n\t\t\treturn methods\n\t\t},\n\n\t\t__withWallet: (wallet: WalletT) => {\n\t\t\twalletSubject.next(wallet)\n\t\t\treturn methods\n\t\t},\n\n\t\t__withKeychain: (signingKeychain: SigningKeychainT) => {\n\t\t\tfirstValueFrom(networkSubject).then(network => {\n\t\t\t\tconst wallet = Wallet.create({\n\t\t\t\t\tsigningKeychain,\n\t\t\t\t\tnetwork,\n\t\t\t\t})\n\t\t\t\tmethods.__withWallet(wallet)\n\t\t\t})\n\t\t\treturn methods\n\t\t},\n\n\t\tconnect: async (url: string) => {\n\t\t\tmethods.__withNodeConnection(of({ url: new URL(url) }))\n\t\t\tconst networkId = await firstValueFrom(api.networkId())\n\t\t\tconst nativeToken = await firstValueFrom(api.nativeToken(networkId))\n\t\t\tnetworkSubject.next(networkId)\n\t\t\tnativeTokenSubject.next(nativeToken)\n\t\t},\n\n\t\tlogin: (password: string, loadKeystore: () => Promise<KeystoreT>) => {\n\t\t\twalletSubscription?.unsubscribe()\n\n\t\t\tvoid SigningKeychain.byLoadingAndDecryptingKeystore({\n\t\t\t\tpassword,\n\t\t\t\tload: loadKeystore,\n\t\t\t}).then(signingKeychainResult => {\n\t\t\t\tsigningKeychainResult.match(\n\t\t\t\t\t(signingKeychain: SigningKeychainT) => {\n\t\t\t\t\t\twalletSubscription = networkSubject.subscribe(\n\t\t\t\t\t\t\tnetwork => {\n\t\t\t\t\t\t\t\tconst wallet = Wallet.create({\n\t\t\t\t\t\t\t\t\tsigningKeychain,\n\t\t\t\t\t\t\t\t\tnetwork,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\tmethods.__withWallet(wallet)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\terrorNotificationSubject.next(walletError(error) as any)\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t})\n\n\t\t\treturn methods\n\t\t},\n\n\t\terrors: errorNotificationSubject.asObservable(),\n\n\t\tderiveNextAccount: (input?: DeriveNextInput) => {\n\t\t\tconst derivation: DeriveNextInput = input ?? {}\n\t\t\tderiveNextLocalHDAccountSubject.next(derivation)\n\t\t\treturn methods\n\t\t},\n\n\t\tderiveHWAccount: (\n\t\t\tinput: DeriveHWSigningKeyInput,\n\t\t): Observable<AccountT> =>\n\t\t\twallet$.pipe(mergeMap(wallet => wallet.deriveHWAccount(input))),\n\n\t\tdisplayAddressForActiveHWAccountOnHWDeviceForVerification: (): Observable<void> =>\n\t\t\twallet$.pipe(\n\t\t\t\tmergeMap(wallet =>\n\t\t\t\t\twallet.displayAddressForActiveHWAccountOnHWDeviceForVerification(),\n\t\t\t\t),\n\t\t\t),\n\n\t\taddAccountFromPrivateKey: (input: AddAccountByPrivateKeyInput) => {\n\t\t\taddAccountByPrivateKeySubject.next(input)\n\t\t\treturn methods\n\t\t},\n\n\t\tswitchAccount: (input: SwitchAccountInput) => {\n\t\t\tswitchAccountSubject.next(input)\n\t\t\treturn methods\n\t\t},\n\n\t\trestoreLocalHDAccountsToIndex,\n\n\t\tdecryptTransaction: decryptTransaction,\n\n\t\tlogLevel: (level: LogLevel) => {\n\t\t\tlog.setLevel(level)\n\t\t\treturn methods\n\t\t},\n\n\t\ttransactionStatus: (\n\t\t\ttxID: TransactionIdentifierT,\n\t\t\ttrigger: Observable<number>,\n\t\t) =>\n\t\t\ttrigger.pipe(\n\t\t\t\twithLatestFrom(networkSubject),\n\t\t\t\tmergeMap(([_, network]) => api.getTransaction(txID, network)),\n\t\t\t\tdistinctUntilChanged((prev, cur) => prev.status === cur.status),\n\t\t\t\tfilter(({ txID }) => txID.equals(txID)),\n\t\t\t\ttap(({ status }) =>\n\t\t\t\t\tradixLog.info(\n\t\t\t\t\t\t`Got transaction status ${status.toString()} for txID: ${txID.toString()}`,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\n\t\twithTokenBalanceFetchTrigger: (trigger: Observable<number>) => {\n\t\t\tsubs.add(trigger.subscribe(tokenBalanceFetchSubject))\n\t\t\treturn methods\n\t\t},\n\n\t\twithStakingFetchTrigger: (trigger: Observable<number>) => {\n\t\t\tsubs.add(trigger.subscribe(stakingFetchSubject))\n\t\t\treturn methods\n\t\t},\n\n\t\t// Wallet APIs\n\t\trevealMnemonic,\n\t\tactiveAddress,\n\t\tactiveAccount,\n\t\taccounts,\n\n\t\t// Active AccountAddress/Account APIs\n\t\ttokenBalances,\n\t\tstakingPositions,\n\t\tunstakingPositions,\n\n\t\tlookupTransaction: (\n\t\t\ttxID: TransactionIdentifierT,\n\t\t): Observable<ExecutedTransaction> =>\n\t\t\tnetworkSubject.pipe(\n\t\t\t\tmergeMap(network =>\n\t\t\t\t\tapi.getTransaction(txID, network).pipe(\n\t\t\t\t\t\twithLatestFrom(activeAddress),\n\t\t\t\t\t\tmap(([simpleTx, aa]) =>\n\t\t\t\t\t\t\tdecorateSimpleExecutedTransactionWithType(\n\t\t\t\t\t\t\t\tsimpleTx,\n\t\t\t\t\t\t\t\taa,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\n\t\ttransactionHistory,\n\t\ttransferTokens,\n\t\tstakeTokens,\n\t\tunstakeTokens,\n\n\t\tgetTransaction: (txID: TransactionIdentifierT) =>\n\t\t\tnetworkSubject.pipe(\n\t\t\t\tmergeMap(network => api.getTransaction(txID, network)),\n\t\t\t),\n\n\t\tvalidators: () =>\n\t\t\tnetworkSubject.pipe(mergeMap(network => api.validators(network))),\n\n\t\tsetHeaders: (headers: Record<string, string>) => {\n\t\t\theaderSub.unsubscribe()\n\t\t\theaderSub = coreAPI$.subscribe(api => api.setHeaders(headers))\n\t\t},\n\n\t\ttargetApiVersion: apiVersion,\n\t}\n\n\treturn methods\n}\n\nexport const Radix = {\n\tcreate,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}