{"ast":null,"code":"\"use strict\";\n\n/**\n * The [[Either]] type represents an alternative between two value types.\n * A \"left\" value which is also conceptually tied to a failure,\n * or a \"right\" value which is conceptually tied to success.\n *\n * The code is organized through the class [[Left]], the class [[Right]],\n * and the type alias [[Either]] (Left or Right).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[EitherStatic]] and are accessed through the global constant Either.\n *\n * Examples:\n *\n *     Either.right<number,number>(5);\n *     Either.left<number,number>(2);\n *     Either.right<number,number>(5).map(x => x*2);\n *\n * Left has the extra [[Left.getLeft]] method that [[Right]] doesn't have.\n * Right has the extra [[Right.get]] method that [[Left]] doesn't have.\n */\nexports.__esModule = true;\nvar Value_1 = require(\"./Value\");\nvar Option_1 = require(\"./Option\");\nvar LinkedList_1 = require(\"./LinkedList\");\nvar Vector_1 = require(\"./Vector\");\nvar Comparison_1 = require(\"./Comparison\");\nvar Contract_1 = require(\"./Contract\");\n/**\n * Holds the \"static methods\" for [[Either]]\n */\nvar EitherStatic = /** @class */function () {\n  function EitherStatic() {}\n  /**\n   * Constructs an Either containing a left value which you give.\n   */\n  EitherStatic.prototype.left = function (val) {\n    return new Left(val);\n  };\n  /**\n   * Constructs an Either containing a right value which you give.\n   */\n  EitherStatic.prototype.right = function (val) {\n    return new Right(val);\n  };\n  /**\n   * Curried type guard for Either\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))\n   *         .filter(Either.isLeft)\n   *         .map(o => o.getLeft())\n   *     => Vector.of(1)\n   */\n  EitherStatic.prototype.isLeft = function (e) {\n    return e.isLeft();\n  };\n  /**\n   * Curried type guard for Either\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))\n   *         .filter(Either.isRight)\n   *         .map(o => o.get())\n   *     => Vector.of(2)\n   */\n  EitherStatic.prototype.isRight = function (e) {\n    return e.isRight();\n  };\n  /**\n   * Turns a list of eithers in an either containing a list of items.\n   * Useful in many contexts.\n   *\n   *     Either.sequence(Vector.of(\n   *         Either.right<number,number>(1),\n   *         Either.right<number,number>(2)));\n   *     => Either.right(Vector.of(1,2))\n   *\n   * But if a single element is Left, everything is discarded:\n   *\n   *     Either.sequence(Vector.of(\n   *           Either.right<number,number>(1),\n   *           Either.left<number,number>(2),\n   *           Either.left<number,number>(3)));\n   *     => Either.left(2)\n   *\n   * Also see [[EitherStatic.traverse]]\n   */\n  EitherStatic.prototype.sequence = function (elts) {\n    return exports.Either.traverse(elts, function (x) {\n      return x;\n    });\n  };\n  /**\n   * Takes a list, a function that can transform list elements\n   * to eithers, then return an either containing a list of\n   * the transformed elements.\n   *\n   *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?\n   *         Either.right(\"user\" + x.toString()) : Either.left(\"invalid id!\");\n   *     Either.traverse([4, 3, 2], getUserById);\n   *     => Either.right(Vector.of(\"user4\", \"user3\", \"user2\"))\n   *\n   * But if a single element results in Left, everything is discarded:\n   *\n   *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?\n   *         Either.right(\"user\" + x.toString()) : Either.left(\"invalid id!\");\n   *     Either.traverse([4, -3, 2], getUserById);\n   *     => Either.left(\"invalid id!\")\n   *\n   * Also see [[EitherStatic.sequence]]\n   */\n  EitherStatic.prototype.traverse = function (elts, fn) {\n    var r = Vector_1.Vector.empty();\n    var iterator = elts[Symbol.iterator]();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      var v = fn(curItem.value);\n      if (v.isLeft()) {\n        return v;\n      }\n      r = r.append(v.get());\n      curItem = iterator.next();\n    }\n    return exports.Either.right(r);\n  };\n  /**\n   * Turns a list of eithers in an either containing a list of items.\n   * Compared to [[EitherStatic.sequence]], sequenceAcc 'accumulates'\n   * the errors, instead of short-circuiting on the first error.\n   *\n   *     Either.sequenceAcc(Vector.of(\n   *         Either.right<number,number>(1),\n   *         Either.right<number,number>(2)));\n   *     => Either.right(Vector.of(1,2))\n   *\n   * But if a single element is Left, you get all the lefts:\n   *\n   *     Either.sequenceAcc(Vector.of(\n   *           Either.right<number,number>(1),\n   *           Either.left<number,number>(2),\n   *           Either.left<number,number>(3)));\n   *     => Either.left(Vector.of(2,3))\n   */\n  EitherStatic.prototype.sequenceAcc = function (elts) {\n    var _a = Vector_1.Vector.ofIterable(elts).partition(exports.Either.isLeft),\n      lefts = _a[0],\n      rights = _a[1];\n    if (lefts.isEmpty()) {\n      return exports.Either.right(rights.map(function (r) {\n        return r.getOrThrow();\n      }));\n    }\n    return exports.Either.left(lefts.map(function (l) {\n      return l.getLeft();\n    }));\n  };\n  /**\n   * Applicative lifting for Either.\n   * Takes a function which operates on basic values, and turns it\n   * in a function that operates on eithers of these values ('lifts'\n   * the function). The 2 is because it works on functions taking two\n   * parameters.\n   *\n   *     const lifted = Either.liftA2(\n   *         (x:number,y:number) => x+y, {} as string);\n   *     lifted(\n   *         Either.right<string,number>(5),\n   *         Either.right<string,number>(6));\n   *     => Either.right(11)\n   *\n   *     const lifted = Either.liftA2(\n   *         (x:number,y:number) => x+y, {} as string);\n   *     lifted(\n   *         Either.right<string,number>(5),\n   *         Either.left<string,number>(\"bad\"));\n   *     => Either.left(\"bad\")\n   *\n   * @param R1 the first right type\n   * @param R2 the second right type\n   * @param L the left type\n   * @param V the new right type as returned by the combining function.\n   */\n  EitherStatic.prototype.liftA2 = function (fn, leftWitness) {\n    return function (p1, p2) {\n      return p1.flatMap(function (a1) {\n        return p2.map(function (a2) {\n          return fn(a1, a2);\n        });\n      });\n    };\n  };\n  /**\n   * Applicative lifting for Either. 'p' stands for 'properties'.\n   *\n   * Takes a function which operates on a simple JS object, and turns it\n   * in a function that operates on the same JS object type except which each field\n   * wrapped in an Either ('lifts' the function).\n   * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters\n   * is not two.\n   *\n   *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n   *     const lifted = Either.liftAp(fn, {} as number);\n   *     lifted({\n   *         a: Either.right<number,number>(5),\n   *         b: Either.right<number,number>(6),\n   *         c: Either.right<number,number>(3)});\n   *     => Either.right(14)\n   *\n   *     const lifted = Either.liftAp<number,{a:number,b:number},number>(\n   *         x => x.a+x.b);\n   *     lifted({\n   *         a: Either.right<number,number>(5),\n   *         b: Either.left<number,number>(2)});\n   *     => Either.left(2)\n   *\n   * @param L the left type\n   * @param A the object property type specifying the parameters for your function\n   * @param B the type returned by your function, returned wrapped in an either by liftAp.\n   */\n  EitherStatic.prototype.liftAp = function (fn, leftWitness) {\n    return function (x) {\n      var copy = {};\n      for (var p in x) {\n        if (x[p].isLeft()) {\n          return x[p];\n        }\n        copy[p] = x[p].getOrThrow();\n      }\n      return exports.Either.right(fn(copy));\n    };\n  };\n  /**\n   * Applicative lifting for Either. 'p' stands for 'properties'.\n   * Compared to [[EitherStatic.liftAp]], liftApAcc 'accumulates'\n   * the errors, instead of short-circuiting on the first error.\n   *\n   * Takes a function which operates on a simple JS object, and turns it\n   * in a function that operates on the same JS object type except which each field\n   * wrapped in an Either ('lifts' the function).\n   * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters\n   * is not two.\n   *\n   *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n   *     const lifted = Either.liftApAcc(fn, {} as number);\n   *     lifted({\n   *         a: Either.right<number,number>(5),\n   *         b: Either.right<number,number>(6),\n   *         c:Either.right<number,number>(3)});\n   *     => Either.right(14)\n   *\n   *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n   *     const lifted = Either.liftApAcc(fn, {} as number);\n   *     lifted({\n   *         a: Either.right<number,number>(5),\n   *         b: Either.left<number,number>(2),\n   *         c: Either.left<number,number>(6)});\n   *     => Either.left(Vector.of(2, 6))\n   *\n   * @param L the left type\n   * @param A the object property type specifying the parameters for your function\n   * @param B the type returned by your function, returned wrapped in an either by liftAp.\n   */\n  EitherStatic.prototype.liftApAcc = function (fn, leftWitness) {\n    var leftErrs = [];\n    return function (x) {\n      var copy = {};\n      for (var p in x) {\n        var field = x[p];\n        if (field.isLeft()) {\n          leftErrs.push(field.getLeft());\n        } else {\n          copy[p] = x[p].getOrThrow();\n        }\n      }\n      if (leftErrs.length === 0) {\n        return exports.Either.right(fn(copy));\n      } else {\n        return exports.Either.left(Vector_1.Vector.ofIterable(leftErrs));\n      }\n    };\n  };\n  /**\n   * Take a partial function (may return undefined or throw),\n   * and lift it to return an [[Either]] instead.\n   *\n   * Note that unlike the [[OptionStatic.lift]] version, if\n   * the function returns undefined, the Either.lift version will throw\n   * (the Option.lift version returns None()): if you want to do\n   * pure side-effects which may throw, you're better off just using\n   * javascript try blocks.\n   *\n   * When using typescript, to help the compiler infer the left type,\n   * you can either pass a second parameter like `{} as <type>`, or\n   * call with `lift<L,R>(...)`.\n   *\n   *     const add = Either.lift((x:number,y:number) => x+y, {} as string);\n   *     add(1,2);\n   *     => Either.right(3)\n   *\n   *     const undef = Either.lift((x:number,y:number,z:number) => undefined);\n   *     undef(1,2,3);\n   *     => throws\n   *\n   *     const throws = Either.lift(() => {throw \"x\"});\n   *     throws();\n   *     => Either.left(\"x\")\n   */\n  EitherStatic.prototype.lift = function (fn, witness) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      try {\n        var r = fn.apply(void 0, args);\n        if (r !== undefined) {\n          return exports.Either.right(r);\n        }\n      } catch (err) {\n        return exports.Either.left(err);\n      }\n      throw new Error(\"liftEither got undefined!\");\n    };\n  };\n  /**\n   * Take a no-parameter partial function (may return undefined or throw),\n   * call it, and return an [[Either]] instead.\n   *\n   * Note that unlike the [[OptionStatic.try_]] version, if\n   * the function returns undefined, this function will throw\n   * (the Option.try_ version returns None()): if you want to do\n   * pure side-effects which may throw, you're better off just using\n   * javascript try blocks.\n   *\n   * When using typescript, to help the compiler infer the left type,\n   * you can either pass a second parameter like `{} as <type>`, or\n   * call with `try_<L,R>(...)`.\n   *\n   *     Either.try_(Math.random, {} as string);\n   *     => Either.right(0.49884723907769635)\n   *\n   *     Either.try_(() => undefined);\n   *     => throws\n   *\n   *     Either.try_(() => {throw \"x\"});\n   *     => Either.left(\"x\")\n   *\n   * Also see [[EitherStatic.lift]], [[OptionStatic.try_]],\n   * [[OptionStatic.tryNullable]]\n   */\n  EitherStatic.prototype.try_ = function (fn, witness) {\n    return exports.Either.lift(fn)();\n  };\n  return EitherStatic;\n}();\nexports.EitherStatic = EitherStatic;\n/**\n * The Either constant allows to call the either \"static\" methods\n */\nexports.Either = new EitherStatic();\n/**\n * Represents an [[Either]] containing a left value,\n * conceptually tied to a failure.\n * \"static methods\" available through [[EitherStatic]]\n * @param L the \"left\" item type 'failure'\n * @param R the \"right\" item type 'success'\n */\nvar Left = /** @class */function () {\n  function Left(value) {\n    this.value = value;\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * Returns true since this is a Left\n   */\n  Left.prototype.isLeft = function () {\n    return true;\n  };\n  /**\n   * Returns false since this is a Left\n   */\n  Left.prototype.isRight = function () {\n    return false;\n  };\n  /**\n   * Returns true if this is either is a right and contains the value you give.\n   */\n  Left.prototype.contains = function (val) {\n    return false;\n  };\n  /**\n   * If this either is a right, applies the function you give\n   * to its contents and build a new right either, otherwise return this.\n   */\n  Left.prototype.map = function (fn) {\n    return this;\n  };\n  /**\n   * If this either is a right, call the function you give with\n   * the contents, and return what the function returns, else\n   * returns this.\n   * This is the monadic bind.\n   */\n  Left.prototype.flatMap = function (fn) {\n    return this;\n  };\n  /**\n   * If this either is a left, call the function you give with\n   * the left value and return a new either left with the result\n   * of the function, else return this.\n   */\n  Left.prototype.mapLeft = function (fn) {\n    return new Left(fn(this.value));\n  };\n  /**\n   * Map the either: you give a function to apply to the value,\n   * a function in case it's a left, a function in case it's a right.\n   */\n  Left.prototype.bimap = function (fnL, fnR) {\n    return new Left(fnL(this.value));\n  };\n  /**\n   * \"filter\" the either. If it was a Left, it stays a Left.\n   * If it was a Right and the predicate you pass returns\n   * true for its value, return the either unchanged.\n   * But if it was a left and the predicate returns false,\n   * return a Left with the value returned by the function\n   * passed as second parameter.\n   *\n   *     Either.right<string,number>(-3)\n   *         .filter(x => x >= 0, v => \"got negative value: \" + v);\n   *     => Either.left<string,number>(\"got negative value: -3\")\n   */\n  Left.prototype.filter = function (p, filterVal) {\n    return this;\n  };\n  /**\n   * Combines two eithers. If this either is a right, returns it.\n   * If it's a left, returns the other one.\n   */\n  Left.prototype.orElse = function (other) {\n    return other;\n  };\n  /**\n   * Has no effect if this Either is a right. If it's a left however,\n   * the function you give will be called, receiving as parameter\n   * the left contents, and an Either equivalent to the one your\n   * function returns will be returned.\n   */\n  Left.prototype.recoverWith = function (recoveryFn) {\n    return recoveryFn(this.value);\n  };\n  /**\n   * Execute a side-effecting function if the either\n   * is a right; returns the either.\n   */\n  Left.prototype.ifRight = function (fn) {\n    return this;\n  };\n  /**\n   * Execute a side-effecting function if the either\n   * is a left; returns the either.\n   */\n  Left.prototype.ifLeft = function (fn) {\n    fn(this.value);\n    return this;\n  };\n  /**\n   * Handle both branches of the either and return a value\n   * (can also be used for side-effects).\n   * This is the catamorphism for either.\n   *\n   *     Either.right<string,number>(5).match({\n   *         Left:  x => \"left \" + x,\n   *         Right: x => \"right \" + x\n   *     });\n   *     => \"right 5\"\n   */\n  Left.prototype.match = function (cases) {\n    return cases.Left(this.value);\n  };\n  /**\n   * If this either is a right, return its value, else throw\n   * an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message, or an Error object.\n   */\n  Left.prototype.getOrThrow = function (errorInfo) {\n    if (typeof errorInfo === 'string') {\n      throw new Error(errorInfo || \"Left.getOrThrow called!\");\n    }\n    throw errorInfo || new Error(\"Left.getOrThrow called!\");\n  };\n  /**\n   * If this either is a right, return its value, else return\n   * the value you give.\n   */\n  Left.prototype.getOrElse = function (other) {\n    return other;\n  };\n  /**\n   * Get the value contained in this left.\n   * NOTE: we know it's there, since this method\n   * belongs to Left, not Either.\n   */\n  Left.prototype.getLeft = function () {\n    return this.value;\n  };\n  /**\n   * If this either is a left, return its value, else throw\n   * an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message.\n   */\n  Left.prototype.getLeftOrThrow = function (message) {\n    return this.value;\n  };\n  /**\n   * If this either is a left, return its value, else return\n   * the value you give.\n   */\n  Left.prototype.getLeftOrElse = function (other) {\n    return this.value;\n  };\n  /**\n   * Convert this either to an option, conceptually dropping\n   * the left (failing) value.\n   */\n  Left.prototype.toOption = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * Convert to a vector. If it's a left, it's the empty\n   * vector, if it's a right, it's a one-element vector with\n   * the contents of the either.\n   */\n  Left.prototype.toVector = function () {\n    return Vector_1.Vector.empty();\n  };\n  /**\n   * Convert to a list. If it's a left, it's the empty\n   * list, if it's a right, it's a one-element list with\n   * the contents of the either.\n   */\n  Left.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.empty();\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  Left.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  Left.prototype.hasTrueEquality = function () {\n    return this.value && this.value.hasTrueEquality ? this.value.hasTrueEquality() : Comparison_1.hasTrueEquality(this.value);\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  Left.prototype.hashCode = function () {\n    return Comparison_1.getHashCode(this.value);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  Left.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || !other.isRight || other.isRight()) {\n      return false;\n    }\n    var leftOther = other;\n    Contract_1.contractTrueEquality(\"Either.equals\", this, leftOther);\n    return Comparison_1.areEqual(this.value, leftOther.value);\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   */\n  Left.prototype.toString = function () {\n    return \"Left(\" + this.value + \")\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   */\n  Left.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return Left;\n}();\nexports.Left = Left;\n/**\n * Represents an [[Either]] containing a success value,\n * conceptually tied to a success.\n * \"static methods\" available through [[EitherStatic]]\n * @param L the \"left\" item type 'failure'\n * @param R the \"right\" item type 'success'\n */\nvar Right = /** @class */function () {\n  function Right(value) {\n    this.value = value;\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * Returns false since this is a Right\n   */\n  Right.prototype.isLeft = function () {\n    return false;\n  };\n  /**\n   * Returns true since this is a Right\n   */\n  Right.prototype.isRight = function () {\n    return true;\n  };\n  /**\n   * Returns true if this is either is a right and contains the value you give.\n   */\n  Right.prototype.contains = function (val) {\n    return Comparison_1.areEqual(this.value, val);\n  };\n  /**\n   * If this either is a right, applies the function you give\n   * to its contents and build a new right either, otherwise return this.\n   */\n  Right.prototype.map = function (fn) {\n    return new Right(fn(this.value));\n  };\n  /**\n   * If this either is a right, call the function you give with\n   * the contents, and return what the function returns, else\n   * returns this.\n   * This is the monadic bind.\n   */\n  Right.prototype.flatMap = function (fn) {\n    return fn(this.value);\n  };\n  /**\n   * If this either is a left, call the function you give with\n   * the left value and return a new either left with the result\n   * of the function, else return this.\n   */\n  Right.prototype.mapLeft = function (fn) {\n    return this;\n  };\n  /**\n   * Map the either: you give a function to apply to the value,\n   * a function in case it's a left, a function in case it's a right.\n   */\n  Right.prototype.bimap = function (fnL, fnR) {\n    return new Right(fnR(this.value));\n  };\n  /**\n   * \"filter\" the either. If it was a Left, it stays a Left.\n   * If it was a Right and the predicate you pass returns\n   * true for its value, return the either unchanged.\n   * But if it was a left and the predicate returns false,\n   * return a Left with the value returned by the function\n   * passed as second parameter.\n   *\n   *     Either.right<string,number>(-3)\n   *         .filter(x => x >= 0, v => \"got negative value: \" + v);\n   *     => Either.left<string,number>(\"got negative value: -3\")\n   */\n  Right.prototype.filter = function (p, filterVal) {\n    if (p(this.value)) {\n      return this;\n    }\n    return new Left(filterVal(this.value));\n  };\n  /**\n   * Combines two eithers. If this either is a right, returns it.\n   * If it's a left, returns the other one.\n   */\n  Right.prototype.orElse = function (other) {\n    return this;\n  };\n  /**\n   * Has no effect if this Either is a right. If it's a left however,\n   * the function you give will be called, receiving as parameter\n   * the left contents, and an Either equivalent to the one your\n   * function returns will be returned.\n   */\n  Right.prototype.recoverWith = function (recoveryFn) {\n    return this;\n  };\n  /**\n   * Execute a side-effecting function if the either\n   * is a right; returns the either.\n   */\n  Right.prototype.ifRight = function (fn) {\n    fn(this.value);\n    return this;\n  };\n  /**\n   * Execute a side-effecting function if the either\n   * is a left; returns the either.\n   */\n  Right.prototype.ifLeft = function (fn) {\n    return this;\n  };\n  /**\n   * Handle both branches of the either and return a value\n   * (can also be used for side-effects).\n   * This is the catamorphism for either.\n   *\n   *     Either.right<string,number>(5).match({\n   *         Left:  x => \"left \" + x,\n   *         Right: x => \"right \" + x\n   *     });\n   *     => \"right 5\"\n   */\n  Right.prototype.match = function (cases) {\n    return cases.Right(this.value);\n  };\n  /**\n   * Get the value contained in this right.\n   * NOTE: we know it's there, since this method\n   * belongs to Right, not Either.\n   */\n  Right.prototype.get = function () {\n    return this.value;\n  };\n  /**\n   * If this either is a right, return its value, else throw\n   * an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message, or an Error object.\n   */\n  Right.prototype.getOrThrow = function (errorInfo) {\n    return this.value;\n  };\n  /**\n   * If this either is a right, return its value, else return\n   * the value you give.\n   */\n  Right.prototype.getOrElse = function (other) {\n    return this.value;\n  };\n  /**\n   * If this either is a left, return its value, else throw\n   * an exception.\n   * You can optionally pass a message that'll be used as the\n   * exception message.\n   */\n  Right.prototype.getLeftOrThrow = function (message) {\n    throw message || \"Left.getOrThrow called!\";\n  };\n  /**\n   * If this either is a left, return its value, else return\n   * the value you give.\n   */\n  Right.prototype.getLeftOrElse = function (other) {\n    return other;\n  };\n  /**\n   * Convert this either to an option, conceptually dropping\n   * the left (failing) value.\n   */\n  Right.prototype.toOption = function () {\n    return Option_1.Option.of(this.value);\n  };\n  /**\n   * Convert to a vector. If it's a left, it's the empty\n   * vector, if it's a right, it's a one-element vector with\n   * the contents of the either.\n   */\n  Right.prototype.toVector = function () {\n    return Vector_1.Vector.of(this.value);\n  };\n  /**\n   * Convert to a list. If it's a left, it's the empty\n   * list, if it's a right, it's a one-element list with\n   * the contents of the either.\n   */\n  Right.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.of(this.value);\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  Right.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  Right.prototype.hasTrueEquality = function () {\n    return this.value && this.value.hasTrueEquality ? this.value.hasTrueEquality() : Comparison_1.hasTrueEquality(this.value);\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  Right.prototype.hashCode = function () {\n    return Comparison_1.getHashCode(this.value);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  Right.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || !other.isRight || !other.isRight()) {\n      return false;\n    }\n    var rightOther = other;\n    Contract_1.contractTrueEquality(\"Either.equals\", this, rightOther);\n    return Comparison_1.areEqual(this.value, rightOther.value);\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   */\n  Right.prototype.toString = function () {\n    return \"Right(\" + this.value + \")\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   */\n  Right.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return Right;\n}();\nexports.Right = Right;","map":{"version":3,"names":["exports","__esModule","Value_1","require","Option_1","LinkedList_1","Vector_1","Comparison_1","Contract_1","EitherStatic","prototype","left","val","Left","right","Right","isLeft","e","isRight","sequence","elts","Either","traverse","x","fn","r","Vector","empty","iterator","Symbol","curItem","next","done","v","value","append","get","sequenceAcc","_a","ofIterable","partition","lefts","rights","isEmpty","map","getOrThrow","l","getLeft","liftA2","leftWitness","p1","p2","flatMap","a1","a2","liftAp","copy","p","liftApAcc","leftErrs","field","push","length","lift","witness","args","_i","arguments","apply","undefined","err","Error","try_","className","contains","mapLeft","bimap","fnL","fnR","filter","filterVal","orElse","other","recoverWith","recoveryFn","ifRight","ifLeft","match","cases","errorInfo","getOrElse","getLeftOrThrow","message","getLeftOrElse","toOption","Option","none","toVector","toLinkedList","LinkedList","transform","converter","hasTrueEquality","hashCode","getHashCode","equals","leftOther","contractTrueEquality","areEqual","toString","inspect","of","rightOther"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/dist/src/Either.js"],"sourcesContent":["\"use strict\";\n/**\n * The [[Either]] type represents an alternative between two value types.\n * A \"left\" value which is also conceptually tied to a failure,\n * or a \"right\" value which is conceptually tied to success.\n *\n * The code is organized through the class [[Left]], the class [[Right]],\n * and the type alias [[Either]] (Left or Right).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[EitherStatic]] and are accessed through the global constant Either.\n *\n * Examples:\n *\n *     Either.right<number,number>(5);\n *     Either.left<number,number>(2);\n *     Either.right<number,number>(5).map(x => x*2);\n *\n * Left has the extra [[Left.getLeft]] method that [[Right]] doesn't have.\n * Right has the extra [[Right.get]] method that [[Left]] doesn't have.\n */\nexports.__esModule = true;\nvar Value_1 = require(\"./Value\");\nvar Option_1 = require(\"./Option\");\nvar LinkedList_1 = require(\"./LinkedList\");\nvar Vector_1 = require(\"./Vector\");\nvar Comparison_1 = require(\"./Comparison\");\nvar Contract_1 = require(\"./Contract\");\n/**\n * Holds the \"static methods\" for [[Either]]\n */\nvar EitherStatic = /** @class */ (function () {\n    function EitherStatic() {\n    }\n    /**\n     * Constructs an Either containing a left value which you give.\n     */\n    EitherStatic.prototype.left = function (val) {\n        return new Left(val);\n    };\n    /**\n     * Constructs an Either containing a right value which you give.\n     */\n    EitherStatic.prototype.right = function (val) {\n        return new Right(val);\n    };\n    /**\n     * Curried type guard for Either\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))\n     *         .filter(Either.isLeft)\n     *         .map(o => o.getLeft())\n     *     => Vector.of(1)\n     */\n    EitherStatic.prototype.isLeft = function (e) {\n        return e.isLeft();\n    };\n    /**\n     * Curried type guard for Either\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))\n     *         .filter(Either.isRight)\n     *         .map(o => o.get())\n     *     => Vector.of(2)\n     */\n    EitherStatic.prototype.isRight = function (e) {\n        return e.isRight();\n    };\n    /**\n     * Turns a list of eithers in an either containing a list of items.\n     * Useful in many contexts.\n     *\n     *     Either.sequence(Vector.of(\n     *         Either.right<number,number>(1),\n     *         Either.right<number,number>(2)));\n     *     => Either.right(Vector.of(1,2))\n     *\n     * But if a single element is Left, everything is discarded:\n     *\n     *     Either.sequence(Vector.of(\n     *           Either.right<number,number>(1),\n     *           Either.left<number,number>(2),\n     *           Either.left<number,number>(3)));\n     *     => Either.left(2)\n     *\n     * Also see [[EitherStatic.traverse]]\n     */\n    EitherStatic.prototype.sequence = function (elts) {\n        return exports.Either.traverse(elts, function (x) { return x; });\n    };\n    /**\n     * Takes a list, a function that can transform list elements\n     * to eithers, then return an either containing a list of\n     * the transformed elements.\n     *\n     *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?\n     *         Either.right(\"user\" + x.toString()) : Either.left(\"invalid id!\");\n     *     Either.traverse([4, 3, 2], getUserById);\n     *     => Either.right(Vector.of(\"user4\", \"user3\", \"user2\"))\n     *\n     * But if a single element results in Left, everything is discarded:\n     *\n     *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?\n     *         Either.right(\"user\" + x.toString()) : Either.left(\"invalid id!\");\n     *     Either.traverse([4, -3, 2], getUserById);\n     *     => Either.left(\"invalid id!\")\n     *\n     * Also see [[EitherStatic.sequence]]\n     */\n    EitherStatic.prototype.traverse = function (elts, fn) {\n        var r = Vector_1.Vector.empty();\n        var iterator = elts[Symbol.iterator]();\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            var v = fn(curItem.value);\n            if (v.isLeft()) {\n                return v;\n            }\n            r = r.append(v.get());\n            curItem = iterator.next();\n        }\n        return exports.Either.right(r);\n    };\n    /**\n     * Turns a list of eithers in an either containing a list of items.\n     * Compared to [[EitherStatic.sequence]], sequenceAcc 'accumulates'\n     * the errors, instead of short-circuiting on the first error.\n     *\n     *     Either.sequenceAcc(Vector.of(\n     *         Either.right<number,number>(1),\n     *         Either.right<number,number>(2)));\n     *     => Either.right(Vector.of(1,2))\n     *\n     * But if a single element is Left, you get all the lefts:\n     *\n     *     Either.sequenceAcc(Vector.of(\n     *           Either.right<number,number>(1),\n     *           Either.left<number,number>(2),\n     *           Either.left<number,number>(3)));\n     *     => Either.left(Vector.of(2,3))\n     */\n    EitherStatic.prototype.sequenceAcc = function (elts) {\n        var _a = Vector_1.Vector.ofIterable(elts).partition(exports.Either.isLeft), lefts = _a[0], rights = _a[1];\n        if (lefts.isEmpty()) {\n            return exports.Either.right(rights.map(function (r) { return r.getOrThrow(); }));\n        }\n        return exports.Either.left(lefts.map(function (l) { return l.getLeft(); }));\n    };\n    /**\n     * Applicative lifting for Either.\n     * Takes a function which operates on basic values, and turns it\n     * in a function that operates on eithers of these values ('lifts'\n     * the function). The 2 is because it works on functions taking two\n     * parameters.\n     *\n     *     const lifted = Either.liftA2(\n     *         (x:number,y:number) => x+y, {} as string);\n     *     lifted(\n     *         Either.right<string,number>(5),\n     *         Either.right<string,number>(6));\n     *     => Either.right(11)\n     *\n     *     const lifted = Either.liftA2(\n     *         (x:number,y:number) => x+y, {} as string);\n     *     lifted(\n     *         Either.right<string,number>(5),\n     *         Either.left<string,number>(\"bad\"));\n     *     => Either.left(\"bad\")\n     *\n     * @param R1 the first right type\n     * @param R2 the second right type\n     * @param L the left type\n     * @param V the new right type as returned by the combining function.\n     */\n    EitherStatic.prototype.liftA2 = function (fn, leftWitness) {\n        return function (p1, p2) { return p1.flatMap(function (a1) { return p2.map(function (a2) { return fn(a1, a2); }); }); };\n    };\n    /**\n     * Applicative lifting for Either. 'p' stands for 'properties'.\n     *\n     * Takes a function which operates on a simple JS object, and turns it\n     * in a function that operates on the same JS object type except which each field\n     * wrapped in an Either ('lifts' the function).\n     * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters\n     * is not two.\n     *\n     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n     *     const lifted = Either.liftAp(fn, {} as number);\n     *     lifted({\n     *         a: Either.right<number,number>(5),\n     *         b: Either.right<number,number>(6),\n     *         c: Either.right<number,number>(3)});\n     *     => Either.right(14)\n     *\n     *     const lifted = Either.liftAp<number,{a:number,b:number},number>(\n     *         x => x.a+x.b);\n     *     lifted({\n     *         a: Either.right<number,number>(5),\n     *         b: Either.left<number,number>(2)});\n     *     => Either.left(2)\n     *\n     * @param L the left type\n     * @param A the object property type specifying the parameters for your function\n     * @param B the type returned by your function, returned wrapped in an either by liftAp.\n     */\n    EitherStatic.prototype.liftAp = function (fn, leftWitness) {\n        return function (x) {\n            var copy = {};\n            for (var p in x) {\n                if (x[p].isLeft()) {\n                    return x[p];\n                }\n                copy[p] = x[p].getOrThrow();\n            }\n            return exports.Either.right(fn(copy));\n        };\n    };\n    /**\n     * Applicative lifting for Either. 'p' stands for 'properties'.\n     * Compared to [[EitherStatic.liftAp]], liftApAcc 'accumulates'\n     * the errors, instead of short-circuiting on the first error.\n     *\n     * Takes a function which operates on a simple JS object, and turns it\n     * in a function that operates on the same JS object type except which each field\n     * wrapped in an Either ('lifts' the function).\n     * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters\n     * is not two.\n     *\n     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n     *     const lifted = Either.liftApAcc(fn, {} as number);\n     *     lifted({\n     *         a: Either.right<number,number>(5),\n     *         b: Either.right<number,number>(6),\n     *         c:Either.right<number,number>(3)});\n     *     => Either.right(14)\n     *\n     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;\n     *     const lifted = Either.liftApAcc(fn, {} as number);\n     *     lifted({\n     *         a: Either.right<number,number>(5),\n     *         b: Either.left<number,number>(2),\n     *         c: Either.left<number,number>(6)});\n     *     => Either.left(Vector.of(2, 6))\n     *\n     * @param L the left type\n     * @param A the object property type specifying the parameters for your function\n     * @param B the type returned by your function, returned wrapped in an either by liftAp.\n     */\n    EitherStatic.prototype.liftApAcc = function (fn, leftWitness) {\n        var leftErrs = [];\n        return function (x) {\n            var copy = {};\n            for (var p in x) {\n                var field = x[p];\n                if (field.isLeft()) {\n                    leftErrs.push(field.getLeft());\n                }\n                else {\n                    copy[p] = x[p].getOrThrow();\n                }\n            }\n            if (leftErrs.length === 0) {\n                return exports.Either.right(fn(copy));\n            }\n            else {\n                return exports.Either.left(Vector_1.Vector.ofIterable(leftErrs));\n            }\n        };\n    };\n    /**\n     * Take a partial function (may return undefined or throw),\n     * and lift it to return an [[Either]] instead.\n     *\n     * Note that unlike the [[OptionStatic.lift]] version, if\n     * the function returns undefined, the Either.lift version will throw\n     * (the Option.lift version returns None()): if you want to do\n     * pure side-effects which may throw, you're better off just using\n     * javascript try blocks.\n     *\n     * When using typescript, to help the compiler infer the left type,\n     * you can either pass a second parameter like `{} as <type>`, or\n     * call with `lift<L,R>(...)`.\n     *\n     *     const add = Either.lift((x:number,y:number) => x+y, {} as string);\n     *     add(1,2);\n     *     => Either.right(3)\n     *\n     *     const undef = Either.lift((x:number,y:number,z:number) => undefined);\n     *     undef(1,2,3);\n     *     => throws\n     *\n     *     const throws = Either.lift(() => {throw \"x\"});\n     *     throws();\n     *     => Either.left(\"x\")\n     */\n    EitherStatic.prototype.lift = function (fn, witness) {\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            try {\n                var r = fn.apply(void 0, args);\n                if (r !== undefined) {\n                    return exports.Either.right(r);\n                }\n            }\n            catch (err) {\n                return exports.Either.left(err);\n            }\n            throw new Error(\"liftEither got undefined!\");\n        };\n    };\n    /**\n     * Take a no-parameter partial function (may return undefined or throw),\n     * call it, and return an [[Either]] instead.\n     *\n     * Note that unlike the [[OptionStatic.try_]] version, if\n     * the function returns undefined, this function will throw\n     * (the Option.try_ version returns None()): if you want to do\n     * pure side-effects which may throw, you're better off just using\n     * javascript try blocks.\n     *\n     * When using typescript, to help the compiler infer the left type,\n     * you can either pass a second parameter like `{} as <type>`, or\n     * call with `try_<L,R>(...)`.\n     *\n     *     Either.try_(Math.random, {} as string);\n     *     => Either.right(0.49884723907769635)\n     *\n     *     Either.try_(() => undefined);\n     *     => throws\n     *\n     *     Either.try_(() => {throw \"x\"});\n     *     => Either.left(\"x\")\n     *\n     * Also see [[EitherStatic.lift]], [[OptionStatic.try_]],\n     * [[OptionStatic.tryNullable]]\n     */\n    EitherStatic.prototype.try_ = function (fn, witness) {\n        return exports.Either.lift(fn)();\n    };\n    return EitherStatic;\n}());\nexports.EitherStatic = EitherStatic;\n/**\n * The Either constant allows to call the either \"static\" methods\n */\nexports.Either = new EitherStatic();\n/**\n * Represents an [[Either]] containing a left value,\n * conceptually tied to a failure.\n * \"static methods\" available through [[EitherStatic]]\n * @param L the \"left\" item type 'failure'\n * @param R the \"right\" item type 'success'\n */\nvar Left = /** @class */ (function () {\n    function Left(value) {\n        this.value = value;\n        /**\n         * @hidden\n         */\n        this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n    }\n    /**\n     * Returns true since this is a Left\n     */\n    Left.prototype.isLeft = function () {\n        return true;\n    };\n    /**\n     * Returns false since this is a Left\n     */\n    Left.prototype.isRight = function () {\n        return false;\n    };\n    /**\n     * Returns true if this is either is a right and contains the value you give.\n     */\n    Left.prototype.contains = function (val) {\n        return false;\n    };\n    /**\n     * If this either is a right, applies the function you give\n     * to its contents and build a new right either, otherwise return this.\n     */\n    Left.prototype.map = function (fn) {\n        return this;\n    };\n    /**\n     * If this either is a right, call the function you give with\n     * the contents, and return what the function returns, else\n     * returns this.\n     * This is the monadic bind.\n     */\n    Left.prototype.flatMap = function (fn) {\n        return this;\n    };\n    /**\n     * If this either is a left, call the function you give with\n     * the left value and return a new either left with the result\n     * of the function, else return this.\n     */\n    Left.prototype.mapLeft = function (fn) {\n        return new Left(fn(this.value));\n    };\n    /**\n     * Map the either: you give a function to apply to the value,\n     * a function in case it's a left, a function in case it's a right.\n     */\n    Left.prototype.bimap = function (fnL, fnR) {\n        return new Left(fnL(this.value));\n    };\n    /**\n     * \"filter\" the either. If it was a Left, it stays a Left.\n     * If it was a Right and the predicate you pass returns\n     * true for its value, return the either unchanged.\n     * But if it was a left and the predicate returns false,\n     * return a Left with the value returned by the function\n     * passed as second parameter.\n     *\n     *     Either.right<string,number>(-3)\n     *         .filter(x => x >= 0, v => \"got negative value: \" + v);\n     *     => Either.left<string,number>(\"got negative value: -3\")\n     */\n    Left.prototype.filter = function (p, filterVal) {\n        return this;\n    };\n    /**\n     * Combines two eithers. If this either is a right, returns it.\n     * If it's a left, returns the other one.\n     */\n    Left.prototype.orElse = function (other) {\n        return other;\n    };\n    /**\n     * Has no effect if this Either is a right. If it's a left however,\n     * the function you give will be called, receiving as parameter\n     * the left contents, and an Either equivalent to the one your\n     * function returns will be returned.\n     */\n    Left.prototype.recoverWith = function (recoveryFn) {\n        return recoveryFn(this.value);\n    };\n    /**\n     * Execute a side-effecting function if the either\n     * is a right; returns the either.\n     */\n    Left.prototype.ifRight = function (fn) {\n        return this;\n    };\n    /**\n     * Execute a side-effecting function if the either\n     * is a left; returns the either.\n     */\n    Left.prototype.ifLeft = function (fn) {\n        fn(this.value);\n        return this;\n    };\n    /**\n     * Handle both branches of the either and return a value\n     * (can also be used for side-effects).\n     * This is the catamorphism for either.\n     *\n     *     Either.right<string,number>(5).match({\n     *         Left:  x => \"left \" + x,\n     *         Right: x => \"right \" + x\n     *     });\n     *     => \"right 5\"\n     */\n    Left.prototype.match = function (cases) {\n        return cases.Left(this.value);\n    };\n    /**\n     * If this either is a right, return its value, else throw\n     * an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message, or an Error object.\n     */\n    Left.prototype.getOrThrow = function (errorInfo) {\n        if (typeof errorInfo === 'string') {\n            throw new Error(errorInfo || \"Left.getOrThrow called!\");\n        }\n        throw errorInfo || new Error(\"Left.getOrThrow called!\");\n    };\n    /**\n     * If this either is a right, return its value, else return\n     * the value you give.\n     */\n    Left.prototype.getOrElse = function (other) {\n        return other;\n    };\n    /**\n     * Get the value contained in this left.\n     * NOTE: we know it's there, since this method\n     * belongs to Left, not Either.\n     */\n    Left.prototype.getLeft = function () {\n        return this.value;\n    };\n    /**\n     * If this either is a left, return its value, else throw\n     * an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message.\n     */\n    Left.prototype.getLeftOrThrow = function (message) {\n        return this.value;\n    };\n    /**\n     * If this either is a left, return its value, else return\n     * the value you give.\n     */\n    Left.prototype.getLeftOrElse = function (other) {\n        return this.value;\n    };\n    /**\n     * Convert this either to an option, conceptually dropping\n     * the left (failing) value.\n     */\n    Left.prototype.toOption = function () {\n        return Option_1.Option.none();\n    };\n    /**\n     * Convert to a vector. If it's a left, it's the empty\n     * vector, if it's a right, it's a one-element vector with\n     * the contents of the either.\n     */\n    Left.prototype.toVector = function () {\n        return Vector_1.Vector.empty();\n    };\n    /**\n     * Convert to a list. If it's a left, it's the empty\n     * list, if it's a right, it's a one-element list with\n     * the contents of the either.\n     */\n    Left.prototype.toLinkedList = function () {\n        return LinkedList_1.LinkedList.empty();\n    };\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    Left.prototype.transform = function (converter) {\n        return converter(this);\n    };\n    Left.prototype.hasTrueEquality = function () {\n        return (this.value && this.value.hasTrueEquality) ?\n            this.value.hasTrueEquality() :\n            Comparison_1.hasTrueEquality(this.value);\n    };\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    Left.prototype.hashCode = function () {\n        return Comparison_1.getHashCode(this.value);\n    };\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    Left.prototype.equals = function (other) {\n        if (other === this) {\n            return true;\n        }\n        if ((!other) || (!other.isRight) || other.isRight()) {\n            return false;\n        }\n        var leftOther = other;\n        Contract_1.contractTrueEquality(\"Either.equals\", this, leftOther);\n        return Comparison_1.areEqual(this.value, leftOther.value);\n    };\n    /**\n     * Get a human-friendly string representation of that value.\n     */\n    Left.prototype.toString = function () {\n        return \"Left(\" + this.value + \")\";\n    };\n    /**\n     * Used by the node REPL to display values.\n     */\n    Left.prototype[Value_1.inspect] = function () {\n        return this.toString();\n    };\n    return Left;\n}());\nexports.Left = Left;\n/**\n * Represents an [[Either]] containing a success value,\n * conceptually tied to a success.\n * \"static methods\" available through [[EitherStatic]]\n * @param L the \"left\" item type 'failure'\n * @param R the \"right\" item type 'success'\n */\nvar Right = /** @class */ (function () {\n    function Right(value) {\n        this.value = value;\n        /**\n         * @hidden\n         */\n        this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n    }\n    /**\n     * Returns false since this is a Right\n     */\n    Right.prototype.isLeft = function () {\n        return false;\n    };\n    /**\n     * Returns true since this is a Right\n     */\n    Right.prototype.isRight = function () {\n        return true;\n    };\n    /**\n     * Returns true if this is either is a right and contains the value you give.\n     */\n    Right.prototype.contains = function (val) {\n        return Comparison_1.areEqual(this.value, val);\n    };\n    /**\n     * If this either is a right, applies the function you give\n     * to its contents and build a new right either, otherwise return this.\n     */\n    Right.prototype.map = function (fn) {\n        return new Right(fn(this.value));\n    };\n    /**\n     * If this either is a right, call the function you give with\n     * the contents, and return what the function returns, else\n     * returns this.\n     * This is the monadic bind.\n     */\n    Right.prototype.flatMap = function (fn) {\n        return fn(this.value);\n    };\n    /**\n     * If this either is a left, call the function you give with\n     * the left value and return a new either left with the result\n     * of the function, else return this.\n     */\n    Right.prototype.mapLeft = function (fn) {\n        return this;\n    };\n    /**\n     * Map the either: you give a function to apply to the value,\n     * a function in case it's a left, a function in case it's a right.\n     */\n    Right.prototype.bimap = function (fnL, fnR) {\n        return new Right(fnR(this.value));\n    };\n    /**\n     * \"filter\" the either. If it was a Left, it stays a Left.\n     * If it was a Right and the predicate you pass returns\n     * true for its value, return the either unchanged.\n     * But if it was a left and the predicate returns false,\n     * return a Left with the value returned by the function\n     * passed as second parameter.\n     *\n     *     Either.right<string,number>(-3)\n     *         .filter(x => x >= 0, v => \"got negative value: \" + v);\n     *     => Either.left<string,number>(\"got negative value: -3\")\n     */\n    Right.prototype.filter = function (p, filterVal) {\n        if (p(this.value)) {\n            return this;\n        }\n        return new Left(filterVal(this.value));\n    };\n    /**\n     * Combines two eithers. If this either is a right, returns it.\n     * If it's a left, returns the other one.\n     */\n    Right.prototype.orElse = function (other) {\n        return this;\n    };\n    /**\n     * Has no effect if this Either is a right. If it's a left however,\n     * the function you give will be called, receiving as parameter\n     * the left contents, and an Either equivalent to the one your\n     * function returns will be returned.\n     */\n    Right.prototype.recoverWith = function (recoveryFn) {\n        return this;\n    };\n    /**\n     * Execute a side-effecting function if the either\n     * is a right; returns the either.\n     */\n    Right.prototype.ifRight = function (fn) {\n        fn(this.value);\n        return this;\n    };\n    /**\n     * Execute a side-effecting function if the either\n     * is a left; returns the either.\n     */\n    Right.prototype.ifLeft = function (fn) {\n        return this;\n    };\n    /**\n     * Handle both branches of the either and return a value\n     * (can also be used for side-effects).\n     * This is the catamorphism for either.\n     *\n     *     Either.right<string,number>(5).match({\n     *         Left:  x => \"left \" + x,\n     *         Right: x => \"right \" + x\n     *     });\n     *     => \"right 5\"\n     */\n    Right.prototype.match = function (cases) {\n        return cases.Right(this.value);\n    };\n    /**\n     * Get the value contained in this right.\n     * NOTE: we know it's there, since this method\n     * belongs to Right, not Either.\n     */\n    Right.prototype.get = function () {\n        return this.value;\n    };\n    /**\n     * If this either is a right, return its value, else throw\n     * an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message, or an Error object.\n     */\n    Right.prototype.getOrThrow = function (errorInfo) {\n        return this.value;\n    };\n    /**\n     * If this either is a right, return its value, else return\n     * the value you give.\n     */\n    Right.prototype.getOrElse = function (other) {\n        return this.value;\n    };\n    /**\n     * If this either is a left, return its value, else throw\n     * an exception.\n     * You can optionally pass a message that'll be used as the\n     * exception message.\n     */\n    Right.prototype.getLeftOrThrow = function (message) {\n        throw message || \"Left.getOrThrow called!\";\n    };\n    /**\n     * If this either is a left, return its value, else return\n     * the value you give.\n     */\n    Right.prototype.getLeftOrElse = function (other) {\n        return other;\n    };\n    /**\n     * Convert this either to an option, conceptually dropping\n     * the left (failing) value.\n     */\n    Right.prototype.toOption = function () {\n        return Option_1.Option.of(this.value);\n    };\n    /**\n     * Convert to a vector. If it's a left, it's the empty\n     * vector, if it's a right, it's a one-element vector with\n     * the contents of the either.\n     */\n    Right.prototype.toVector = function () {\n        return Vector_1.Vector.of(this.value);\n    };\n    /**\n     * Convert to a list. If it's a left, it's the empty\n     * list, if it's a right, it's a one-element list with\n     * the contents of the either.\n     */\n    Right.prototype.toLinkedList = function () {\n        return LinkedList_1.LinkedList.of(this.value);\n    };\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    Right.prototype.transform = function (converter) {\n        return converter(this);\n    };\n    Right.prototype.hasTrueEquality = function () {\n        return (this.value && this.value.hasTrueEquality) ?\n            this.value.hasTrueEquality() :\n            Comparison_1.hasTrueEquality(this.value);\n    };\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    Right.prototype.hashCode = function () {\n        return Comparison_1.getHashCode(this.value);\n    };\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    Right.prototype.equals = function (other) {\n        if (other === this) {\n            return true;\n        }\n        if ((!other) || (!other.isRight) || (!other.isRight())) {\n            return false;\n        }\n        var rightOther = other;\n        Contract_1.contractTrueEquality(\"Either.equals\", this, rightOther);\n        return Comparison_1.areEqual(this.value, rightOther.value);\n    };\n    /**\n     * Get a human-friendly string representation of that value.\n     */\n    Right.prototype.toString = function () {\n        return \"Right(\" + this.value + \")\";\n    };\n    /**\n     * Used by the node REPL to display values.\n     */\n    Right.prototype[Value_1.inspect] = function () {\n        return this.toString();\n    };\n    return Right;\n}());\nexports.Right = Right;\n//# sourceMappingURL=Either.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}