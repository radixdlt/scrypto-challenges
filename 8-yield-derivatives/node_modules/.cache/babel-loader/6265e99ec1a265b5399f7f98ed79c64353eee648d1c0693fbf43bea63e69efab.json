{"ast":null,"code":"var customUtils = require('./customUtils'),\n  model = require('./model'),\n  async = require('async'),\n  Executor = require('./executor'),\n  Index = require('./indexes'),\n  util = require('util'),\n  _ = require('underscore'),\n  Persistence = require('./persistence'),\n  Cursor = require('./cursor');\n\n/**\n * Create a new collection\n * @param {String} options.filename Optional, datastore will be in-memory only if not provided\n * @param {Boolean} options.timestampData Optional, defaults to false. If set to true, createdAt and updatedAt will be created and populated automatically (if not specified by user)\n * @param {Boolean} options.inMemoryOnly Optional, defaults to false\n * @param {String} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n * @param {Boolean} options.autoload Optional, defaults to false\n * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown\n * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks\n * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt\n * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting\n *\n * Event Emitter - Events\n * * compaction.done - Fired whenever a compaction operation was finished\n */\nfunction Datastore(options) {\n  var filename;\n\n  // Retrocompatibility with v0.6 and before\n  if (typeof options === 'string') {\n    filename = options;\n    this.inMemoryOnly = false; // Default\n  } else {\n    options = options || {};\n    filename = options.filename;\n    this.inMemoryOnly = options.inMemoryOnly || false;\n    this.autoload = options.autoload || false;\n    this.timestampData = options.timestampData || false;\n  }\n\n  // Determine whether in memory or persistent\n  if (!filename || typeof filename !== 'string' || filename.length === 0) {\n    this.filename = null;\n    this.inMemoryOnly = true;\n  } else {\n    this.filename = filename;\n  }\n\n  // String comparison function\n  this.compareStrings = options.compareStrings;\n\n  // Persistence handling\n  this.persistence = new Persistence({\n    db: this,\n    nodeWebkitAppName: options.nodeWebkitAppName,\n    afterSerialization: options.afterSerialization,\n    beforeDeserialization: options.beforeDeserialization,\n    corruptAlertThreshold: options.corruptAlertThreshold\n  });\n\n  // This new executor is ready if we don't use persistence\n  // If we do, it will only be ready once loadDatabase is called\n  this.executor = new Executor();\n  if (this.inMemoryOnly) {\n    this.executor.ready = true;\n  }\n\n  // Indexed by field name, dot notation can be used\n  // _id is always indexed and since _ids are generated randomly the underlying\n  // binary is always well-balanced\n  this.indexes = {};\n  this.indexes._id = new Index({\n    fieldName: '_id',\n    unique: true\n  });\n  this.ttlIndexes = {};\n\n  // Queue a load of the database right away and call the onload handler\n  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception\n  if (this.autoload) {\n    this.loadDatabase(options.onload || function (err) {\n      if (err) {\n        throw err;\n      }\n    });\n  }\n}\nutil.inherits(Datastore, require('events').EventEmitter);\n\n/**\n * Load the database from the datafile, and trigger the execution of buffered commands if any\n */\nDatastore.prototype.loadDatabase = function () {\n  this.executor.push({\n    this: this.persistence,\n    fn: this.persistence.loadDatabase,\n    arguments: arguments\n  }, true);\n};\n\n/**\n * Get an array of all the data in the database\n */\nDatastore.prototype.getAllData = function () {\n  return this.indexes._id.getAll();\n};\n\n/**\n * Reset all currently defined indexes\n */\nDatastore.prototype.resetIndexes = function (newData) {\n  var self = this;\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].reset(newData);\n  });\n};\n\n/**\n * Ensure an index is kept for this field. Same parameters as lib/indexes\n * For now this function is synchronous, we need to test how much time it takes\n * We use an async API for consistency with the rest of the code\n * @param {String} options.fieldName\n * @param {Boolean} options.unique\n * @param {Boolean} options.sparse\n * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.ensureIndex = function (options, cb) {\n  var err,\n    callback = cb || function () {};\n  options = options || {};\n  if (!options.fieldName) {\n    err = new Error(\"Cannot create an index without a fieldName\");\n    err.missingFieldName = true;\n    return callback(err);\n  }\n  if (this.indexes[options.fieldName]) {\n    return callback(null);\n  }\n  this.indexes[options.fieldName] = new Index(options);\n  if (options.expireAfterSeconds !== undefined) {\n    this.ttlIndexes[options.fieldName] = options.expireAfterSeconds;\n  } // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here\n\n  try {\n    this.indexes[options.fieldName].insert(this.getAllData());\n  } catch (e) {\n    delete this.indexes[options.fieldName];\n    return callback(e);\n  }\n\n  // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function\n  this.persistence.persistNewState([{\n    $$indexCreated: options\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null);\n  });\n};\n\n/**\n * Remove an index\n * @param {String} fieldName\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.removeIndex = function (fieldName, cb) {\n  var callback = cb || function () {};\n  delete this.indexes[fieldName];\n  this.persistence.persistNewState([{\n    $$indexRemoved: fieldName\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null);\n  });\n};\n\n/**\n * Add one or several document(s) to all indexes\n */\nDatastore.prototype.addToIndexes = function (doc) {\n  var i,\n    failingIndex,\n    error,\n    keys = Object.keys(this.indexes);\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].insert(doc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the insert on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].remove(doc);\n    }\n    throw error;\n  }\n};\n\n/**\n * Remove one or several document(s) from all indexes\n */\nDatastore.prototype.removeFromIndexes = function (doc) {\n  var self = this;\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].remove(doc);\n  });\n};\n\n/**\n * Update one or several documents in all indexes\n * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs\n * If one update violates a constraint, all changes are rolled back\n */\nDatastore.prototype.updateIndexes = function (oldDoc, newDoc) {\n  var i,\n    failingIndex,\n    error,\n    keys = Object.keys(this.indexes);\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].update(oldDoc, newDoc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the update on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);\n    }\n    throw error;\n  }\n};\n\n/**\n * Return the list of candidates for a given query\n * Crude implementation for now, we return the candidates given by the first usable index if any\n * We try the following query types, in this order: basic match, $in match, comparison match\n * One way to make it better would be to enable the use of multiple indexes if the first usable index\n * returns too much data. I may do it in the future.\n *\n * Returned candidates will be scanned to find and remove all expired documents\n *\n * @param {Query} query\n * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations\n * @param {Function} callback Signature err, docs\n */\nDatastore.prototype.getCandidates = function (query, dontExpireStaleDocs, callback) {\n  var indexNames = Object.keys(this.indexes),\n    self = this,\n    usableQueryKeys;\n  if (typeof dontExpireStaleDocs === 'function') {\n    callback = dontExpireStaleDocs;\n    dontExpireStaleDocs = false;\n  }\n  async.waterfall([\n  // STEP 1: get candidates list by checking indexes from most to least frequent usecase\n  function (cb) {\n    // For a basic match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));\n    }\n\n    // For a $in match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && query[k].hasOwnProperty('$in')) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));\n    }\n\n    // For a comparison match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));\n    }\n\n    // By default, return all the DB data\n    return cb(null, self.getAllData());\n  }\n  // STEP 2: remove all expired documents\n  , function (docs) {\n    if (dontExpireStaleDocs) {\n      return callback(null, docs);\n    }\n    var expiredDocsIds = [],\n      validDocs = [],\n      ttlIndexesFieldNames = Object.keys(self.ttlIndexes);\n    docs.forEach(function (doc) {\n      var valid = true;\n      ttlIndexesFieldNames.forEach(function (i) {\n        if (doc[i] !== undefined && util.isDate(doc[i]) && Date.now() > doc[i].getTime() + self.ttlIndexes[i] * 1000) {\n          valid = false;\n        }\n      });\n      if (valid) {\n        validDocs.push(doc);\n      } else {\n        expiredDocsIds.push(doc._id);\n      }\n    });\n    async.eachSeries(expiredDocsIds, function (_id, cb) {\n      self._remove({\n        _id: _id\n      }, {}, function (err) {\n        if (err) {\n          return callback(err);\n        }\n        return cb();\n      });\n    }, function (err) {\n      return callback(null, validDocs);\n    });\n  }]);\n};\n\n/**\n * Insert a new document\n * @param {Function} cb Optional callback, signature: err, insertedDoc\n *\n * @api private Use Datastore.insert which has the same signature\n */\nDatastore.prototype._insert = function (newDoc, cb) {\n  var callback = cb || function () {},\n    preparedDoc;\n  try {\n    preparedDoc = this.prepareDocumentForInsertion(newDoc);\n    this._insertInCache(preparedDoc);\n  } catch (e) {\n    return callback(e);\n  }\n  this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, model.deepCopy(preparedDoc));\n  });\n};\n\n/**\n * Create a new _id that's not already in use\n */\nDatastore.prototype.createNewId = function () {\n  var tentativeId = customUtils.uid(16);\n  // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely small, so this is O(1)\n  if (this.indexes._id.getMatching(tentativeId).length > 0) {\n    tentativeId = this.createNewId();\n  }\n  return tentativeId;\n};\n\n/**\n * Prepare a document (or array of documents) to be inserted in a database\n * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input\n * @api private\n */\nDatastore.prototype.prepareDocumentForInsertion = function (newDoc) {\n  var preparedDoc,\n    self = this;\n  if (util.isArray(newDoc)) {\n    preparedDoc = [];\n    newDoc.forEach(function (doc) {\n      preparedDoc.push(self.prepareDocumentForInsertion(doc));\n    });\n  } else {\n    preparedDoc = model.deepCopy(newDoc);\n    if (preparedDoc._id === undefined) {\n      preparedDoc._id = this.createNewId();\n    }\n    var now = new Date();\n    if (this.timestampData && preparedDoc.createdAt === undefined) {\n      preparedDoc.createdAt = now;\n    }\n    if (this.timestampData && preparedDoc.updatedAt === undefined) {\n      preparedDoc.updatedAt = now;\n    }\n    model.checkObject(preparedDoc);\n  }\n  return preparedDoc;\n};\n\n/**\n * If newDoc is an array of documents, this will insert all documents in the cache\n * @api private\n */\nDatastore.prototype._insertInCache = function (preparedDoc) {\n  if (util.isArray(preparedDoc)) {\n    this._insertMultipleDocsInCache(preparedDoc);\n  } else {\n    this.addToIndexes(preparedDoc);\n  }\n};\n\n/**\n * If one insertion fails (e.g. because of a unique constraint), roll back all previous\n * inserts and throws the error\n * @api private\n */\nDatastore.prototype._insertMultipleDocsInCache = function (preparedDocs) {\n  var i, failingI, error;\n  for (i = 0; i < preparedDocs.length; i += 1) {\n    try {\n      this.addToIndexes(preparedDocs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.removeFromIndexes(preparedDocs[i]);\n    }\n    throw error;\n  }\n};\nDatastore.prototype.insert = function () {\n  this.executor.push({\n    this: this,\n    fn: this._insert,\n    arguments: arguments\n  });\n};\n\n/**\n * Count all documents matching the query\n * @param {Object} query MongoDB-style query\n */\nDatastore.prototype.count = function (query, callback) {\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, docs.length);\n  });\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n/**\n * Find all documents matching the query\n * If no callback is passed, we return the cursor so that user can limit, skip and finally exec\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.find = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      } // If not assume projection is an object and callback undefined\n      break;\n  }\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    var res = [],\n      i;\n    if (err) {\n      return callback(err);\n    }\n    for (i = 0; i < docs.length; i += 1) {\n      res.push(model.deepCopy(docs[i]));\n    }\n    return callback(null, res);\n  });\n  cursor.projection(projection);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n/**\n * Find one document matching the query\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.findOne = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      } // If not assume projection is an object and callback undefined\n      break;\n  }\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    if (err) {\n      return callback(err);\n    }\n    if (docs.length === 1) {\n      return callback(null, model.deepCopy(docs[0]));\n    } else {\n      return callback(null, null);\n    }\n  });\n  cursor.projection(projection).limit(1);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n/**\n * Update all docs matching query\n * @param {Object} query\n * @param {Object} updateQuery\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n *                 options.upsert If true, document is inserted if the query doesn't match anything\n *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)\n * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)\n *                      If update was an upsert, upsert flag is set to true\n *                      affectedDocuments can be one of the following:\n *                        * For an upsert, the upserted document\n *                        * For an update with returnUpdatedDocs option false, null\n *                        * For an update with returnUpdatedDocs true and multi false, the updated document\n *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents\n *\n * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,\n *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert\n *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of\n *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the\n *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on\n *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.\n *\n * @api private Use Datastore.update which has the same signature\n */\nDatastore.prototype._update = function (query, updateQuery, options, cb) {\n  var callback,\n    self = this,\n    numReplaced = 0,\n    multi,\n    upsert,\n    i;\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n  upsert = options.upsert !== undefined ? options.upsert : false;\n  async.waterfall([function (cb) {\n    // If upsert option is set, check whether we need to insert the doc\n    if (!upsert) {\n      return cb();\n    }\n\n    // Need to use an internal function not tied to the executor to avoid deadlock\n    var cursor = new Cursor(self, query);\n    cursor.limit(1)._exec(function (err, docs) {\n      if (err) {\n        return callback(err);\n      }\n      if (docs.length === 1) {\n        return cb();\n      } else {\n        var toBeInserted;\n        try {\n          model.checkObject(updateQuery);\n          // updateQuery is a simple object with no modifier, use it as the document to insert\n          toBeInserted = updateQuery;\n        } catch (e) {\n          // updateQuery contains modifiers, use the find query as the base,\n          // strip it from all operators and update it according to updateQuery\n          try {\n            toBeInserted = model.modify(model.deepCopy(query, true), updateQuery);\n          } catch (err) {\n            return callback(err);\n          }\n        }\n        return self._insert(toBeInserted, function (err, newDoc) {\n          if (err) {\n            return callback(err);\n          }\n          return callback(null, 1, newDoc, true);\n        });\n      }\n    });\n  }, function () {\n    // Perform the update\n    var modifiedDoc,\n      modifications = [],\n      createdAt;\n    self.getCandidates(query, function (err, candidates) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Preparing update (if an error is thrown here neither the datafile nor\n      // the in-memory indexes are affected)\n      try {\n        for (i = 0; i < candidates.length; i += 1) {\n          if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {\n            numReplaced += 1;\n            if (self.timestampData) {\n              createdAt = candidates[i].createdAt;\n            }\n            modifiedDoc = model.modify(candidates[i], updateQuery);\n            if (self.timestampData) {\n              modifiedDoc.createdAt = createdAt;\n              modifiedDoc.updatedAt = new Date();\n            }\n            modifications.push({\n              oldDoc: candidates[i],\n              newDoc: modifiedDoc\n            });\n          }\n        }\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Change the docs in memory\n      try {\n        self.updateIndexes(modifications);\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Update the datafile\n      var updatedDocs = _.pluck(modifications, 'newDoc');\n      self.persistence.persistNewState(updatedDocs, function (err) {\n        if (err) {\n          return callback(err);\n        }\n        if (!options.returnUpdatedDocs) {\n          return callback(null, numReplaced);\n        } else {\n          var updatedDocsDC = [];\n          updatedDocs.forEach(function (doc) {\n            updatedDocsDC.push(model.deepCopy(doc));\n          });\n          if (!multi) {\n            updatedDocsDC = updatedDocsDC[0];\n          }\n          return callback(null, numReplaced, updatedDocsDC);\n        }\n      });\n    });\n  }]);\n};\nDatastore.prototype.update = function () {\n  this.executor.push({\n    this: this,\n    fn: this._update,\n    arguments: arguments\n  });\n};\n\n/**\n * Remove all docs matching the query\n * For now very naive implementation (similar to update)\n * @param {Object} query\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n * @param {Function} cb Optional callback, signature: err, numRemoved\n *\n * @api private Use Datastore.remove which has the same signature\n */\nDatastore.prototype._remove = function (query, options, cb) {\n  var callback,\n    self = this,\n    numRemoved = 0,\n    removedDocs = [],\n    multi;\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n  this.getCandidates(query, true, function (err, candidates) {\n    if (err) {\n      return callback(err);\n    }\n    try {\n      candidates.forEach(function (d) {\n        if (model.match(d, query) && (multi || numRemoved === 0)) {\n          numRemoved += 1;\n          removedDocs.push({\n            $$deleted: true,\n            _id: d._id\n          });\n          self.removeFromIndexes(d);\n        }\n      });\n    } catch (err) {\n      return callback(err);\n    }\n    self.persistence.persistNewState(removedDocs, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      return callback(null, numRemoved);\n    });\n  });\n};\nDatastore.prototype.remove = function () {\n  this.executor.push({\n    this: this,\n    fn: this._remove,\n    arguments: arguments\n  });\n};\nmodule.exports = Datastore;","map":{"version":3,"names":["customUtils","require","model","async","Executor","Index","util","_","Persistence","Cursor","Datastore","options","filename","inMemoryOnly","autoload","timestampData","length","compareStrings","persistence","db","nodeWebkitAppName","afterSerialization","beforeDeserialization","corruptAlertThreshold","executor","ready","indexes","_id","fieldName","unique","ttlIndexes","loadDatabase","onload","err","inherits","EventEmitter","prototype","push","this","fn","arguments","getAllData","getAll","resetIndexes","newData","self","Object","keys","forEach","i","reset","ensureIndex","cb","callback","Error","missingFieldName","expireAfterSeconds","undefined","insert","e","persistNewState","$$indexCreated","removeIndex","$$indexRemoved","addToIndexes","doc","failingIndex","error","remove","removeFromIndexes","updateIndexes","oldDoc","newDoc","update","revertUpdate","getCandidates","query","dontExpireStaleDocs","indexNames","usableQueryKeys","waterfall","k","isDate","intersection","getMatching","hasOwnProperty","$in","getBetweenBounds","docs","expiredDocsIds","validDocs","ttlIndexesFieldNames","valid","Date","now","getTime","eachSeries","_remove","_insert","preparedDoc","prepareDocumentForInsertion","_insertInCache","isArray","deepCopy","createNewId","tentativeId","uid","createdAt","updatedAt","checkObject","_insertMultipleDocsInCache","preparedDocs","failingI","count","cursor","exec","find","projection","res","findOne","limit","_update","updateQuery","numReplaced","multi","upsert","_exec","toBeInserted","modify","modifiedDoc","modifications","candidates","match","updatedDocs","pluck","returnUpdatedDocs","updatedDocsDC","numRemoved","removedDocs","d","$$deleted","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/nedb/lib/datastore.js"],"sourcesContent":["var customUtils = require('./customUtils')\n  , model = require('./model')\n  , async = require('async')\n  , Executor = require('./executor')\n  , Index = require('./indexes')\n  , util = require('util')\n  , _ = require('underscore')\n  , Persistence = require('./persistence')\n  , Cursor = require('./cursor')\n  ;\n\n\n/**\n * Create a new collection\n * @param {String} options.filename Optional, datastore will be in-memory only if not provided\n * @param {Boolean} options.timestampData Optional, defaults to false. If set to true, createdAt and updatedAt will be created and populated automatically (if not specified by user)\n * @param {Boolean} options.inMemoryOnly Optional, defaults to false\n * @param {String} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n * @param {Boolean} options.autoload Optional, defaults to false\n * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown\n * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks\n * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt\n * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting\n *\n * Event Emitter - Events\n * * compaction.done - Fired whenever a compaction operation was finished\n */\nfunction Datastore (options) {\n  var filename;\n\n  // Retrocompatibility with v0.6 and before\n  if (typeof options === 'string') {\n    filename = options;\n    this.inMemoryOnly = false;   // Default\n  } else {\n    options = options || {};\n    filename = options.filename;\n    this.inMemoryOnly = options.inMemoryOnly || false;\n    this.autoload = options.autoload || false;\n    this.timestampData = options.timestampData || false;\n  }\n\n  // Determine whether in memory or persistent\n  if (!filename || typeof filename !== 'string' || filename.length === 0) {\n    this.filename = null;\n    this.inMemoryOnly = true;\n  } else {\n    this.filename = filename;\n  }\n\n  // String comparison function\n  this.compareStrings = options.compareStrings;\n\n  // Persistence handling\n  this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName\n                                      , afterSerialization: options.afterSerialization\n                                      , beforeDeserialization: options.beforeDeserialization\n                                      , corruptAlertThreshold: options.corruptAlertThreshold\n                                      });\n\n  // This new executor is ready if we don't use persistence\n  // If we do, it will only be ready once loadDatabase is called\n  this.executor = new Executor();\n  if (this.inMemoryOnly) { this.executor.ready = true; }\n\n  // Indexed by field name, dot notation can be used\n  // _id is always indexed and since _ids are generated randomly the underlying\n  // binary is always well-balanced\n  this.indexes = {};\n  this.indexes._id = new Index({ fieldName: '_id', unique: true });\n  this.ttlIndexes = {};\n\n  // Queue a load of the database right away and call the onload handler\n  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception\n  if (this.autoload) { this.loadDatabase(options.onload || function (err) {\n    if (err) { throw err; }\n  }); }\n}\n\nutil.inherits(Datastore, require('events').EventEmitter);\n\n\n/**\n * Load the database from the datafile, and trigger the execution of buffered commands if any\n */\nDatastore.prototype.loadDatabase = function () {\n  this.executor.push({ this: this.persistence, fn: this.persistence.loadDatabase, arguments: arguments }, true);\n};\n\n\n/**\n * Get an array of all the data in the database\n */\nDatastore.prototype.getAllData = function () {\n  return this.indexes._id.getAll();\n};\n\n\n/**\n * Reset all currently defined indexes\n */\nDatastore.prototype.resetIndexes = function (newData) {\n  var self = this;\n\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].reset(newData);\n  });\n};\n\n\n/**\n * Ensure an index is kept for this field. Same parameters as lib/indexes\n * For now this function is synchronous, we need to test how much time it takes\n * We use an async API for consistency with the rest of the code\n * @param {String} options.fieldName\n * @param {Boolean} options.unique\n * @param {Boolean} options.sparse\n * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.ensureIndex = function (options, cb) {\n  var err\n    , callback = cb || function () {};\n\n  options = options || {};\n\n  if (!options.fieldName) {\n    err = new Error(\"Cannot create an index without a fieldName\");\n    err.missingFieldName = true;\n    return callback(err);\n  }\n  if (this.indexes[options.fieldName]) { return callback(null); }\n\n  this.indexes[options.fieldName] = new Index(options);\n  if (options.expireAfterSeconds !== undefined) { this.ttlIndexes[options.fieldName] = options.expireAfterSeconds; }   // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here\n\n  try {\n    this.indexes[options.fieldName].insert(this.getAllData());\n  } catch (e) {\n    delete this.indexes[options.fieldName];\n    return callback(e);\n  }\n\n  // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function\n  this.persistence.persistNewState([{ $$indexCreated: options }], function (err) {\n    if (err) { return callback(err); }\n    return callback(null);\n  });\n};\n\n\n/**\n * Remove an index\n * @param {String} fieldName\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.removeIndex = function (fieldName, cb) {\n  var callback = cb || function () {};\n\n  delete this.indexes[fieldName];\n\n  this.persistence.persistNewState([{ $$indexRemoved: fieldName }], function (err) {\n    if (err) { return callback(err); }\n    return callback(null);\n  });\n};\n\n\n/**\n * Add one or several document(s) to all indexes\n */\nDatastore.prototype.addToIndexes = function (doc) {\n  var i, failingIndex, error\n    , keys = Object.keys(this.indexes)\n    ;\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].insert(doc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the insert on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].remove(doc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Remove one or several document(s) from all indexes\n */\nDatastore.prototype.removeFromIndexes = function (doc) {\n  var self = this;\n\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].remove(doc);\n  });\n};\n\n\n/**\n * Update one or several documents in all indexes\n * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs\n * If one update violates a constraint, all changes are rolled back\n */\nDatastore.prototype.updateIndexes = function (oldDoc, newDoc) {\n  var i, failingIndex, error\n    , keys = Object.keys(this.indexes)\n    ;\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].update(oldDoc, newDoc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the update on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Return the list of candidates for a given query\n * Crude implementation for now, we return the candidates given by the first usable index if any\n * We try the following query types, in this order: basic match, $in match, comparison match\n * One way to make it better would be to enable the use of multiple indexes if the first usable index\n * returns too much data. I may do it in the future.\n *\n * Returned candidates will be scanned to find and remove all expired documents\n *\n * @param {Query} query\n * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations\n * @param {Function} callback Signature err, docs\n */\nDatastore.prototype.getCandidates = function (query, dontExpireStaleDocs, callback) {\n  var indexNames = Object.keys(this.indexes)\n    , self = this\n    , usableQueryKeys;\n\n  if (typeof dontExpireStaleDocs === 'function') {\n    callback = dontExpireStaleDocs;\n    dontExpireStaleDocs = false;\n  }\n\n  async.waterfall([\n  // STEP 1: get candidates list by checking indexes from most to least frequent usecase\n  function (cb) {\n    // For a basic match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));\n    }\n\n    // For a $in match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && query[k].hasOwnProperty('$in')) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));\n    }\n\n    // For a comparison match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));\n    }\n\n    // By default, return all the DB data\n    return cb(null, self.getAllData());\n  }\n  // STEP 2: remove all expired documents\n  , function (docs) {\n    if (dontExpireStaleDocs) { return callback(null, docs); }\n\n    var expiredDocsIds = [], validDocs = [], ttlIndexesFieldNames = Object.keys(self.ttlIndexes);\n\n    docs.forEach(function (doc) {\n      var valid = true;\n      ttlIndexesFieldNames.forEach(function (i) {\n        if (doc[i] !== undefined && util.isDate(doc[i]) && Date.now() > doc[i].getTime() + self.ttlIndexes[i] * 1000) {\n          valid = false;\n        }\n      });\n      if (valid) { validDocs.push(doc); } else { expiredDocsIds.push(doc._id); }\n    });\n\n    async.eachSeries(expiredDocsIds, function (_id, cb) {\n      self._remove({ _id: _id }, {}, function (err) {\n        if (err) { return callback(err); }\n        return cb();\n      });\n    }, function (err) {\n      return callback(null, validDocs);\n    });\n  }]);\n};\n\n\n/**\n * Insert a new document\n * @param {Function} cb Optional callback, signature: err, insertedDoc\n *\n * @api private Use Datastore.insert which has the same signature\n */\nDatastore.prototype._insert = function (newDoc, cb) {\n  var callback = cb || function () {}\n    , preparedDoc\n    ;\n\n  try {\n    preparedDoc = this.prepareDocumentForInsertion(newDoc)\n    this._insertInCache(preparedDoc);\n  } catch (e) {\n    return callback(e);\n  }\n\n  this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {\n    if (err) { return callback(err); }\n    return callback(null, model.deepCopy(preparedDoc));\n  });\n};\n\n/**\n * Create a new _id that's not already in use\n */\nDatastore.prototype.createNewId = function () {\n  var tentativeId = customUtils.uid(16);\n  // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely small, so this is O(1)\n  if (this.indexes._id.getMatching(tentativeId).length > 0) {\n    tentativeId = this.createNewId();\n  }\n  return tentativeId;\n};\n\n/**\n * Prepare a document (or array of documents) to be inserted in a database\n * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input\n * @api private\n */\nDatastore.prototype.prepareDocumentForInsertion = function (newDoc) {\n  var preparedDoc, self = this;\n\n  if (util.isArray(newDoc)) {\n    preparedDoc = [];\n    newDoc.forEach(function (doc) { preparedDoc.push(self.prepareDocumentForInsertion(doc)); });\n  } else {\n    preparedDoc = model.deepCopy(newDoc);\n    if (preparedDoc._id === undefined) { preparedDoc._id = this.createNewId(); }\n    var now = new Date();\n    if (this.timestampData && preparedDoc.createdAt === undefined) { preparedDoc.createdAt = now; }\n    if (this.timestampData && preparedDoc.updatedAt === undefined) { preparedDoc.updatedAt = now; }\n    model.checkObject(preparedDoc);\n  }\n\n  return preparedDoc;\n};\n\n/**\n * If newDoc is an array of documents, this will insert all documents in the cache\n * @api private\n */\nDatastore.prototype._insertInCache = function (preparedDoc) {\n  if (util.isArray(preparedDoc)) {\n    this._insertMultipleDocsInCache(preparedDoc);\n  } else {\n    this.addToIndexes(preparedDoc);\n  }\n};\n\n/**\n * If one insertion fails (e.g. because of a unique constraint), roll back all previous\n * inserts and throws the error\n * @api private\n */\nDatastore.prototype._insertMultipleDocsInCache = function (preparedDocs) {\n  var i, failingI, error;\n\n  for (i = 0; i < preparedDocs.length; i += 1) {\n    try {\n      this.addToIndexes(preparedDocs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.removeFromIndexes(preparedDocs[i]);\n    }\n\n    throw error;\n  }\n};\n\nDatastore.prototype.insert = function () {\n  this.executor.push({ this: this, fn: this._insert, arguments: arguments });\n};\n\n\n/**\n * Count all documents matching the query\n * @param {Object} query MongoDB-style query\n */\nDatastore.prototype.count = function(query, callback) {\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    if (err) { return callback(err); }\n    return callback(null, docs.length);\n  });\n\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Find all documents matching the query\n * If no callback is passed, we return the cursor so that user can limit, skip and finally exec\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.find = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      }   // If not assume projection is an object and callback undefined\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    var res = [], i;\n\n    if (err) { return callback(err); }\n\n    for (i = 0; i < docs.length; i += 1) {\n      res.push(model.deepCopy(docs[i]));\n    }\n    return callback(null, res);\n  });\n\n  cursor.projection(projection);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Find one document matching the query\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.findOne = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      }   // If not assume projection is an object and callback undefined\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    if (err) { return callback(err); }\n    if (docs.length === 1) {\n      return callback(null, model.deepCopy(docs[0]));\n    } else {\n      return callback(null, null);\n    }\n  });\n\n  cursor.projection(projection).limit(1);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Update all docs matching query\n * @param {Object} query\n * @param {Object} updateQuery\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n *                 options.upsert If true, document is inserted if the query doesn't match anything\n *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)\n * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)\n *                      If update was an upsert, upsert flag is set to true\n *                      affectedDocuments can be one of the following:\n *                        * For an upsert, the upserted document\n *                        * For an update with returnUpdatedDocs option false, null\n *                        * For an update with returnUpdatedDocs true and multi false, the updated document\n *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents\n *\n * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,\n *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert\n *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of\n *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the\n *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on\n *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.\n *\n * @api private Use Datastore.update which has the same signature\n */\nDatastore.prototype._update = function (query, updateQuery, options, cb) {\n  var callback\n    , self = this\n    , numReplaced = 0\n    , multi, upsert\n    , i\n    ;\n\n  if (typeof options === 'function') { cb = options; options = {}; }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n  upsert = options.upsert !== undefined ? options.upsert : false;\n\n  async.waterfall([\n  function (cb) {   // If upsert option is set, check whether we need to insert the doc\n    if (!upsert) { return cb(); }\n\n    // Need to use an internal function not tied to the executor to avoid deadlock\n    var cursor = new Cursor(self, query);\n    cursor.limit(1)._exec(function (err, docs) {\n      if (err) { return callback(err); }\n      if (docs.length === 1) {\n        return cb();\n      } else {\n        var toBeInserted;\n\n        try {\n          model.checkObject(updateQuery);\n          // updateQuery is a simple object with no modifier, use it as the document to insert\n          toBeInserted = updateQuery;\n        } catch (e) {\n          // updateQuery contains modifiers, use the find query as the base,\n          // strip it from all operators and update it according to updateQuery\n          try {\n            toBeInserted = model.modify(model.deepCopy(query, true), updateQuery);\n          } catch (err) {\n            return callback(err);\n          }\n        }\n\n        return self._insert(toBeInserted, function (err, newDoc) {\n          if (err) { return callback(err); }\n          return callback(null, 1, newDoc, true);\n        });\n      }\n    });\n  }\n  , function () {   // Perform the update\n    var modifiedDoc , modifications = [], createdAt;\n\n    self.getCandidates(query, function (err, candidates) {\n      if (err) { return callback(err); }\n\n      // Preparing update (if an error is thrown here neither the datafile nor\n      // the in-memory indexes are affected)\n      try {\n        for (i = 0; i < candidates.length; i += 1) {\n          if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {\n            numReplaced += 1;\n            if (self.timestampData) { createdAt = candidates[i].createdAt; }\n            modifiedDoc = model.modify(candidates[i], updateQuery);\n            if (self.timestampData) {\n              modifiedDoc.createdAt = createdAt;\n              modifiedDoc.updatedAt = new Date();\n            }\n            modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });\n          }\n        }\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Change the docs in memory\n      try {\n        self.updateIndexes(modifications);\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Update the datafile\n      var updatedDocs = _.pluck(modifications, 'newDoc');\n      self.persistence.persistNewState(updatedDocs, function (err) {\n        if (err) { return callback(err); }\n        if (!options.returnUpdatedDocs) {\n          return callback(null, numReplaced);\n        } else {\n          var updatedDocsDC = [];\n          updatedDocs.forEach(function (doc) { updatedDocsDC.push(model.deepCopy(doc)); });\n          if (! multi) { updatedDocsDC = updatedDocsDC[0]; }\n          return callback(null, numReplaced, updatedDocsDC);\n        }\n      });\n    });\n  }]);\n};\n\nDatastore.prototype.update = function () {\n  this.executor.push({ this: this, fn: this._update, arguments: arguments });\n};\n\n\n/**\n * Remove all docs matching the query\n * For now very naive implementation (similar to update)\n * @param {Object} query\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n * @param {Function} cb Optional callback, signature: err, numRemoved\n *\n * @api private Use Datastore.remove which has the same signature\n */\nDatastore.prototype._remove = function (query, options, cb) {\n  var callback\n    , self = this, numRemoved = 0, removedDocs = [], multi\n    ;\n\n  if (typeof options === 'function') { cb = options; options = {}; }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n\n  this.getCandidates(query, true, function (err, candidates) {\n    if (err) { return callback(err); }\n\n    try {\n      candidates.forEach(function (d) {\n        if (model.match(d, query) && (multi || numRemoved === 0)) {\n          numRemoved += 1;\n          removedDocs.push({ $$deleted: true, _id: d._id });\n          self.removeFromIndexes(d);\n        }\n      });\n    } catch (err) { return callback(err); }\n\n    self.persistence.persistNewState(removedDocs, function (err) {\n      if (err) { return callback(err); }\n      return callback(null, numRemoved);\n    });\n  });\n};\n\nDatastore.prototype.remove = function () {\n  this.executor.push({ this: this, fn: this._remove, arguments: arguments });\n};\n\n\n\nmodule.exports = Datastore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}