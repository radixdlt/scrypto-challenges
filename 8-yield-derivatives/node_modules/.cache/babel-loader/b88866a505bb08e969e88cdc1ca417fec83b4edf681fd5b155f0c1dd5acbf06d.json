{"ast":null,"code":"/**\n * A javascript implementation of a cryptographically-secure\n * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\n * here though the use of SHA-256 is not enforced; when generating an\n * a PRNG context, the hashing algorithm and block cipher used for\n * the generator are specified via a plugin.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\nvar _crypto = null;\nif (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions['node-webkit']) {\n  _crypto = require('crypto');\n}\n\n/* PRNG API */\nvar prng = module.exports = forge.prng = forge.prng || {};\n\n/**\n * Creates a new PRNG context.\n *\n * A PRNG plugin must be passed in that will provide:\n *\n * 1. A function that initializes the key and seed of a PRNG context. It\n *   will be given a 16 byte key and a 16 byte seed. Any key expansion\n *   or transformation of the seed from a byte string into an array of\n *   integers (or similar) should be performed.\n * 2. The cryptographic function used by the generator. It takes a key and\n *   a seed.\n * 3. A seed increment function. It takes the seed and returns seed + 1.\n * 4. An api to create a message digest.\n *\n * For an example, see random.js.\n *\n * @param plugin the PRNG plugin to use.\n */\nprng.create = function (plugin) {\n  var ctx = {\n    plugin: plugin,\n    key: null,\n    seed: null,\n    time: null,\n    // number of reseeds so far\n    reseeds: 0,\n    // amount of data generated so far\n    generated: 0,\n    // no initial key bytes\n    keyBytes: ''\n  };\n\n  // create 32 entropy pools (each is a message digest)\n  var md = plugin.md;\n  var pools = new Array(32);\n  for (var i = 0; i < 32; ++i) {\n    pools[i] = md.create();\n  }\n  ctx.pools = pools;\n\n  // entropy pools are written to cyclically, starting at index 0\n  ctx.pool = 0;\n\n  /**\n   * Generates random bytes. The bytes may be generated synchronously or\n   * asynchronously. Web workers must use the asynchronous interface or\n   * else the behavior is undefined.\n   *\n   * @param count the number of random bytes to generate.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generate = function (count, callback) {\n    // do synchronously\n    if (!callback) {\n      return ctx.generateSync(count);\n    }\n\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n    var b = forge.util.createBuffer();\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generate` call\n    ctx.key = null;\n    generate();\n    function generate(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      // sufficient bytes generated\n      if (b.length() >= count) {\n        return callback(null, b.getBytes(count));\n      }\n\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if (ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n      if (ctx.key === null) {\n        // prevent stack overflow\n        return forge.util.nextTick(function () {\n          _reseed(generate);\n        });\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n      forge.util.setImmediate(generate);\n    }\n  };\n\n  /**\n   * Generates random bytes synchronously.\n   *\n   * @param count the number of random bytes to generate.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generateSync = function (count) {\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generateSync` call\n    ctx.key = null;\n    var b = forge.util.createBuffer();\n    while (b.length() < count) {\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if (ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n      if (ctx.key === null) {\n        _reseedSync();\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n    }\n    return b.getBytes(count);\n  };\n\n  /**\n   * Private function that asynchronously reseeds a generator.\n   *\n   * @param callback(err) called once the operation completes.\n   */\n  function _reseed(callback) {\n    if (ctx.pools[0].messageLength >= 32) {\n      _seed();\n      return callback();\n    }\n    // not enough seed data...\n    var needed = 32 - ctx.pools[0].messageLength << 5;\n    ctx.seedFile(needed, function (err, bytes) {\n      if (err) {\n        return callback(err);\n      }\n      ctx.collect(bytes);\n      _seed();\n      callback();\n    });\n  }\n\n  /**\n   * Private function that synchronously reseeds a generator.\n   */\n  function _reseedSync() {\n    if (ctx.pools[0].messageLength >= 32) {\n      return _seed();\n    }\n    // not enough seed data...\n    var needed = 32 - ctx.pools[0].messageLength << 5;\n    ctx.collect(ctx.seedFileSync(needed));\n    _seed();\n  }\n\n  /**\n   * Private function that seeds a generator once enough bytes are available.\n   */\n  function _seed() {\n    // update reseed count\n    ctx.reseeds = ctx.reseeds === 0xffffffff ? 0 : ctx.reseeds + 1;\n\n    // goal is to update `key` via:\n    // key = hash(key + s)\n    //   where 's' is all collected entropy from selected pools, then...\n\n    // create a plugin-based message digest\n    var md = ctx.plugin.md.create();\n\n    // consume current key bytes\n    md.update(ctx.keyBytes);\n\n    // digest the entropy of pools whose index k meet the\n    // condition 'n mod 2^k == 0' where n is the number of reseeds\n    var _2powK = 1;\n    for (var k = 0; k < 32; ++k) {\n      if (ctx.reseeds % _2powK === 0) {\n        md.update(ctx.pools[k].digest().getBytes());\n        ctx.pools[k].start();\n      }\n      _2powK = _2powK << 1;\n    }\n\n    // get digest for key bytes\n    ctx.keyBytes = md.digest().getBytes();\n\n    // paranoid deviation from Fortuna:\n    // update `seed` via `seed = hash(key)`\n    // instead of initializing to zero once and only\n    // ever incrementing it\n    md.start();\n    md.update(ctx.keyBytes);\n    var seedBytes = md.digest().getBytes();\n\n    // update state\n    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\n    ctx.seed = ctx.plugin.formatSeed(seedBytes);\n    ctx.generated = 0;\n  }\n\n  /**\n   * The built-in default seedFile. This seedFile is used when entropy\n   * is needed immediately.\n   *\n   * @param needed the number of bytes that are needed.\n   *\n   * @return the random bytes.\n   */\n  function defaultSeedFile(needed) {\n    // use window.crypto.getRandomValues strong source of entropy if available\n    var getRandomValues = null;\n    var globalScope = forge.util.globalScope;\n    var _crypto = globalScope.crypto || globalScope.msCrypto;\n    if (_crypto && _crypto.getRandomValues) {\n      getRandomValues = function (arr) {\n        return _crypto.getRandomValues(arr);\n      };\n    }\n    var b = forge.util.createBuffer();\n    if (getRandomValues) {\n      while (b.length() < needed) {\n        // max byte length is 65536 before QuotaExceededError is thrown\n        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\n        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\n        var entropy = new Uint32Array(Math.floor(count));\n        try {\n          getRandomValues(entropy);\n          for (var i = 0; i < entropy.length; ++i) {\n            b.putInt32(entropy[i]);\n          }\n        } catch (e) {\n          /* only ignore QuotaExceededError */\n          if (!(typeof QuotaExceededError !== 'undefined' && e instanceof QuotaExceededError)) {\n            throw e;\n          }\n        }\n      }\n    }\n\n    // be sad and add some weak random data\n    if (b.length() < needed) {\n      /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\n      implemented with David G. Carta's optimization: with 32 bit math\n      and without division (Public Domain). */\n      var hi, lo, next;\n      var seed = Math.floor(Math.random() * 0x010000);\n      while (b.length() < needed) {\n        lo = 16807 * (seed & 0xFFFF);\n        hi = 16807 * (seed >> 16);\n        lo += (hi & 0x7FFF) << 16;\n        lo += hi >> 15;\n        lo = (lo & 0x7FFFFFFF) + (lo >> 31);\n        seed = lo & 0xFFFFFFFF;\n\n        // consume lower 3 bytes of seed\n        for (var i = 0; i < 3; ++i) {\n          // throw in more pseudo random\n          next = seed >>> (i << 3);\n          next ^= Math.floor(Math.random() * 0x0100);\n          b.putByte(String.fromCharCode(next & 0xFF));\n        }\n      }\n    }\n    return b.getBytes(needed);\n  }\n  // initialize seed file APIs\n  if (_crypto) {\n    // use nodejs async API\n    ctx.seedFile = function (needed, callback) {\n      _crypto.randomBytes(needed, function (err, bytes) {\n        if (err) {\n          return callback(err);\n        }\n        callback(null, bytes.toString());\n      });\n    };\n    // use nodejs sync API\n    ctx.seedFileSync = function (needed) {\n      return _crypto.randomBytes(needed).toString();\n    };\n  } else {\n    ctx.seedFile = function (needed, callback) {\n      try {\n        callback(null, defaultSeedFile(needed));\n      } catch (e) {\n        callback(e);\n      }\n    };\n    ctx.seedFileSync = defaultSeedFile;\n  }\n\n  /**\n   * Adds entropy to a prng ctx's accumulator.\n   *\n   * @param bytes the bytes of entropy as a string.\n   */\n  ctx.collect = function (bytes) {\n    // iterate over pools distributing entropy cyclically\n    var count = bytes.length;\n    for (var i = 0; i < count; ++i) {\n      ctx.pools[ctx.pool].update(bytes.substr(i, 1));\n      ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;\n    }\n  };\n\n  /**\n   * Collects an integer of n bits.\n   *\n   * @param i the integer entropy.\n   * @param n the number of bits in the integer.\n   */\n  ctx.collectInt = function (i, n) {\n    var bytes = '';\n    for (var x = 0; x < n; x += 8) {\n      bytes += String.fromCharCode(i >> x & 0xFF);\n    }\n    ctx.collect(bytes);\n  };\n\n  /**\n   * Registers a Web Worker to receive immediate entropy from the main thread.\n   * This method is required until Web Workers can access the native crypto\n   * API. This method should be called twice for each created worker, once in\n   * the main thread, and once in the worker itself.\n   *\n   * @param worker the worker to register.\n   */\n  ctx.registerWorker = function (worker) {\n    // worker receives random bytes\n    if (worker === self) {\n      ctx.seedFile = function (needed, callback) {\n        function listener(e) {\n          var data = e.data;\n          if (data.forge && data.forge.prng) {\n            self.removeEventListener('message', listener);\n            callback(data.forge.prng.err, data.forge.prng.bytes);\n          }\n        }\n        self.addEventListener('message', listener);\n        self.postMessage({\n          forge: {\n            prng: {\n              needed: needed\n            }\n          }\n        });\n      };\n    } else {\n      // main thread sends random bytes upon request\n      var listener = function (e) {\n        var data = e.data;\n        if (data.forge && data.forge.prng) {\n          ctx.seedFile(data.forge.prng.needed, function (err, bytes) {\n            worker.postMessage({\n              forge: {\n                prng: {\n                  err: err,\n                  bytes: bytes\n                }\n              }\n            });\n          });\n        }\n      };\n      // TODO: do we need to remove the event listener when the worker dies?\n      worker.addEventListener('message', listener);\n    }\n  };\n  return ctx;\n};","map":{"version":3,"names":["forge","require","_crypto","util","isNodejs","options","usePureJavaScript","process","versions","prng","module","exports","create","plugin","ctx","key","seed","time","reseeds","generated","keyBytes","md","pools","Array","i","pool","generate","count","callback","generateSync","cipher","increment","formatKey","formatSeed","b","createBuffer","err","length","getBytes","nextTick","_reseed","bytes","putBytes","setImmediate","_reseedSync","messageLength","_seed","needed","seedFile","collect","seedFileSync","update","_2powK","k","digest","start","seedBytes","defaultSeedFile","getRandomValues","globalScope","crypto","msCrypto","arr","Math","max","min","entropy","Uint32Array","floor","putInt32","e","QuotaExceededError","hi","lo","next","random","putByte","String","fromCharCode","randomBytes","toString","substr","collectInt","n","x","registerWorker","worker","self","listener","data","removeEventListener","addEventListener","postMessage"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/node-forge/lib/prng.js"],"sourcesContent":["/**\n * A javascript implementation of a cryptographically-secure\n * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\n * here though the use of SHA-256 is not enforced; when generating an\n * a PRNG context, the hashing algorithm and block cipher used for\n * the generator are specified via a plugin.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nvar _crypto = null;\nif(forge.util.isNodejs && !forge.options.usePureJavaScript &&\n  !process.versions['node-webkit']) {\n  _crypto = require('crypto');\n}\n\n/* PRNG API */\nvar prng = module.exports = forge.prng = forge.prng || {};\n\n/**\n * Creates a new PRNG context.\n *\n * A PRNG plugin must be passed in that will provide:\n *\n * 1. A function that initializes the key and seed of a PRNG context. It\n *   will be given a 16 byte key and a 16 byte seed. Any key expansion\n *   or transformation of the seed from a byte string into an array of\n *   integers (or similar) should be performed.\n * 2. The cryptographic function used by the generator. It takes a key and\n *   a seed.\n * 3. A seed increment function. It takes the seed and returns seed + 1.\n * 4. An api to create a message digest.\n *\n * For an example, see random.js.\n *\n * @param plugin the PRNG plugin to use.\n */\nprng.create = function(plugin) {\n  var ctx = {\n    plugin: plugin,\n    key: null,\n    seed: null,\n    time: null,\n    // number of reseeds so far\n    reseeds: 0,\n    // amount of data generated so far\n    generated: 0,\n    // no initial key bytes\n    keyBytes: ''\n  };\n\n  // create 32 entropy pools (each is a message digest)\n  var md = plugin.md;\n  var pools = new Array(32);\n  for(var i = 0; i < 32; ++i) {\n    pools[i] = md.create();\n  }\n  ctx.pools = pools;\n\n  // entropy pools are written to cyclically, starting at index 0\n  ctx.pool = 0;\n\n  /**\n   * Generates random bytes. The bytes may be generated synchronously or\n   * asynchronously. Web workers must use the asynchronous interface or\n   * else the behavior is undefined.\n   *\n   * @param count the number of random bytes to generate.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generate = function(count, callback) {\n    // do synchronously\n    if(!callback) {\n      return ctx.generateSync(count);\n    }\n\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n    var b = forge.util.createBuffer();\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generate` call\n    ctx.key = null;\n\n    generate();\n\n    function generate(err) {\n      if(err) {\n        return callback(err);\n      }\n\n      // sufficient bytes generated\n      if(b.length() >= count) {\n        return callback(null, b.getBytes(count));\n      }\n\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if(ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if(ctx.key === null) {\n        // prevent stack overflow\n        return forge.util.nextTick(function() {\n          _reseed(generate);\n        });\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n\n      forge.util.setImmediate(generate);\n    }\n  };\n\n  /**\n   * Generates random bytes synchronously.\n   *\n   * @param count the number of random bytes to generate.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generateSync = function(count) {\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generateSync` call\n    ctx.key = null;\n\n    var b = forge.util.createBuffer();\n    while(b.length() < count) {\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if(ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if(ctx.key === null) {\n        _reseedSync();\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n    }\n\n    return b.getBytes(count);\n  };\n\n  /**\n   * Private function that asynchronously reseeds a generator.\n   *\n   * @param callback(err) called once the operation completes.\n   */\n  function _reseed(callback) {\n    if(ctx.pools[0].messageLength >= 32) {\n      _seed();\n      return callback();\n    }\n    // not enough seed data...\n    var needed = (32 - ctx.pools[0].messageLength) << 5;\n    ctx.seedFile(needed, function(err, bytes) {\n      if(err) {\n        return callback(err);\n      }\n      ctx.collect(bytes);\n      _seed();\n      callback();\n    });\n  }\n\n  /**\n   * Private function that synchronously reseeds a generator.\n   */\n  function _reseedSync() {\n    if(ctx.pools[0].messageLength >= 32) {\n      return _seed();\n    }\n    // not enough seed data...\n    var needed = (32 - ctx.pools[0].messageLength) << 5;\n    ctx.collect(ctx.seedFileSync(needed));\n    _seed();\n  }\n\n  /**\n   * Private function that seeds a generator once enough bytes are available.\n   */\n  function _seed() {\n    // update reseed count\n    ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;\n\n    // goal is to update `key` via:\n    // key = hash(key + s)\n    //   where 's' is all collected entropy from selected pools, then...\n\n    // create a plugin-based message digest\n    var md = ctx.plugin.md.create();\n\n    // consume current key bytes\n    md.update(ctx.keyBytes);\n\n    // digest the entropy of pools whose index k meet the\n    // condition 'n mod 2^k == 0' where n is the number of reseeds\n    var _2powK = 1;\n    for(var k = 0; k < 32; ++k) {\n      if(ctx.reseeds % _2powK === 0) {\n        md.update(ctx.pools[k].digest().getBytes());\n        ctx.pools[k].start();\n      }\n      _2powK = _2powK << 1;\n    }\n\n    // get digest for key bytes\n    ctx.keyBytes = md.digest().getBytes();\n\n    // paranoid deviation from Fortuna:\n    // update `seed` via `seed = hash(key)`\n    // instead of initializing to zero once and only\n    // ever incrementing it\n    md.start();\n    md.update(ctx.keyBytes);\n    var seedBytes = md.digest().getBytes();\n\n    // update state\n    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\n    ctx.seed = ctx.plugin.formatSeed(seedBytes);\n    ctx.generated = 0;\n  }\n\n  /**\n   * The built-in default seedFile. This seedFile is used when entropy\n   * is needed immediately.\n   *\n   * @param needed the number of bytes that are needed.\n   *\n   * @return the random bytes.\n   */\n  function defaultSeedFile(needed) {\n    // use window.crypto.getRandomValues strong source of entropy if available\n    var getRandomValues = null;\n    var globalScope = forge.util.globalScope;\n    var _crypto = globalScope.crypto || globalScope.msCrypto;\n    if(_crypto && _crypto.getRandomValues) {\n      getRandomValues = function(arr) {\n        return _crypto.getRandomValues(arr);\n      };\n    }\n\n    var b = forge.util.createBuffer();\n    if(getRandomValues) {\n      while(b.length() < needed) {\n        // max byte length is 65536 before QuotaExceededError is thrown\n        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\n        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\n        var entropy = new Uint32Array(Math.floor(count));\n        try {\n          getRandomValues(entropy);\n          for(var i = 0; i < entropy.length; ++i) {\n            b.putInt32(entropy[i]);\n          }\n        } catch(e) {\n          /* only ignore QuotaExceededError */\n          if(!(typeof QuotaExceededError !== 'undefined' &&\n            e instanceof QuotaExceededError)) {\n            throw e;\n          }\n        }\n      }\n    }\n\n    // be sad and add some weak random data\n    if(b.length() < needed) {\n      /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\n      implemented with David G. Carta's optimization: with 32 bit math\n      and without division (Public Domain). */\n      var hi, lo, next;\n      var seed = Math.floor(Math.random() * 0x010000);\n      while(b.length() < needed) {\n        lo = 16807 * (seed & 0xFFFF);\n        hi = 16807 * (seed >> 16);\n        lo += (hi & 0x7FFF) << 16;\n        lo += hi >> 15;\n        lo = (lo & 0x7FFFFFFF) + (lo >> 31);\n        seed = lo & 0xFFFFFFFF;\n\n        // consume lower 3 bytes of seed\n        for(var i = 0; i < 3; ++i) {\n          // throw in more pseudo random\n          next = seed >>> (i << 3);\n          next ^= Math.floor(Math.random() * 0x0100);\n          b.putByte(String.fromCharCode(next & 0xFF));\n        }\n      }\n    }\n\n    return b.getBytes(needed);\n  }\n  // initialize seed file APIs\n  if(_crypto) {\n    // use nodejs async API\n    ctx.seedFile = function(needed, callback) {\n      _crypto.randomBytes(needed, function(err, bytes) {\n        if(err) {\n          return callback(err);\n        }\n        callback(null, bytes.toString());\n      });\n    };\n    // use nodejs sync API\n    ctx.seedFileSync = function(needed) {\n      return _crypto.randomBytes(needed).toString();\n    };\n  } else {\n    ctx.seedFile = function(needed, callback) {\n      try {\n        callback(null, defaultSeedFile(needed));\n      } catch(e) {\n        callback(e);\n      }\n    };\n    ctx.seedFileSync = defaultSeedFile;\n  }\n\n  /**\n   * Adds entropy to a prng ctx's accumulator.\n   *\n   * @param bytes the bytes of entropy as a string.\n   */\n  ctx.collect = function(bytes) {\n    // iterate over pools distributing entropy cyclically\n    var count = bytes.length;\n    for(var i = 0; i < count; ++i) {\n      ctx.pools[ctx.pool].update(bytes.substr(i, 1));\n      ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;\n    }\n  };\n\n  /**\n   * Collects an integer of n bits.\n   *\n   * @param i the integer entropy.\n   * @param n the number of bits in the integer.\n   */\n  ctx.collectInt = function(i, n) {\n    var bytes = '';\n    for(var x = 0; x < n; x += 8) {\n      bytes += String.fromCharCode((i >> x) & 0xFF);\n    }\n    ctx.collect(bytes);\n  };\n\n  /**\n   * Registers a Web Worker to receive immediate entropy from the main thread.\n   * This method is required until Web Workers can access the native crypto\n   * API. This method should be called twice for each created worker, once in\n   * the main thread, and once in the worker itself.\n   *\n   * @param worker the worker to register.\n   */\n  ctx.registerWorker = function(worker) {\n    // worker receives random bytes\n    if(worker === self) {\n      ctx.seedFile = function(needed, callback) {\n        function listener(e) {\n          var data = e.data;\n          if(data.forge && data.forge.prng) {\n            self.removeEventListener('message', listener);\n            callback(data.forge.prng.err, data.forge.prng.bytes);\n          }\n        }\n        self.addEventListener('message', listener);\n        self.postMessage({forge: {prng: {needed: needed}}});\n      };\n    } else {\n      // main thread sends random bytes upon request\n      var listener = function(e) {\n        var data = e.data;\n        if(data.forge && data.forge.prng) {\n          ctx.seedFile(data.forge.prng.needed, function(err, bytes) {\n            worker.postMessage({forge: {prng: {err: err, bytes: bytes}}});\n          });\n        }\n      };\n      // TODO: do we need to remove the event listener when the worker dies?\n      worker.addEventListener('message', listener);\n    }\n  };\n\n  return ctx;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}