{"ast":null,"code":"/**\n * Manage access to data, be it to find, update or remove it\n */\nvar model = require('./model'),\n  _ = require('underscore');\n\n/**\n * Create a new cursor for this collection\n * @param {Datastore} db - The datastore this cursor is bound to\n * @param {Query} query - The query this cursor will operate on\n * @param {Function} execFn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove\n */\nfunction Cursor(db, query, execFn) {\n  this.db = db;\n  this.query = query || {};\n  if (execFn) {\n    this.execFn = execFn;\n  }\n}\n\n/**\n * Set a limit to the number of results\n */\nCursor.prototype.limit = function (limit) {\n  this._limit = limit;\n  return this;\n};\n\n/**\n * Skip a the number of results\n */\nCursor.prototype.skip = function (skip) {\n  this._skip = skip;\n  return this;\n};\n\n/**\n * Sort results of the query\n * @param {SortQuery} sortQuery - SortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending\n */\nCursor.prototype.sort = function (sortQuery) {\n  this._sort = sortQuery;\n  return this;\n};\n\n/**\n * Add the use of a projection\n * @param {Object} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2\n *                              { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits\n */\nCursor.prototype.projection = function (projection) {\n  this._projection = projection;\n  return this;\n};\n\n/**\n * Apply the projection\n */\nCursor.prototype.project = function (candidates) {\n  var res = [],\n    self = this,\n    keepId,\n    action,\n    keys;\n  if (this._projection === undefined || Object.keys(this._projection).length === 0) {\n    return candidates;\n  }\n  keepId = this._projection._id === 0 ? false : true;\n  this._projection = _.omit(this._projection, '_id');\n\n  // Check for consistency\n  keys = Object.keys(this._projection);\n  keys.forEach(function (k) {\n    if (action !== undefined && self._projection[k] !== action) {\n      throw new Error(\"Can't both keep and omit fields except for _id\");\n    }\n    action = self._projection[k];\n  });\n\n  // Do the actual projection\n  candidates.forEach(function (candidate) {\n    var toPush;\n    if (action === 1) {\n      // pick-type projection\n      toPush = {\n        $set: {}\n      };\n      keys.forEach(function (k) {\n        toPush.$set[k] = model.getDotValue(candidate, k);\n        if (toPush.$set[k] === undefined) {\n          delete toPush.$set[k];\n        }\n      });\n      toPush = model.modify({}, toPush);\n    } else {\n      // omit-type projection\n      toPush = {\n        $unset: {}\n      };\n      keys.forEach(function (k) {\n        toPush.$unset[k] = true;\n      });\n      toPush = model.modify(candidate, toPush);\n    }\n    if (keepId) {\n      toPush._id = candidate._id;\n    } else {\n      delete toPush._id;\n    }\n    res.push(toPush);\n  });\n  return res;\n};\n\n/**\n * Get all matching elements\n * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne\n * This is an internal function, use exec which uses the executor\n *\n * @param {Function} callback - Signature: err, results\n */\nCursor.prototype._exec = function (_callback) {\n  var res = [],\n    added = 0,\n    skipped = 0,\n    self = this,\n    error = null,\n    i,\n    keys,\n    key;\n  function callback(error, res) {\n    if (self.execFn) {\n      return self.execFn(error, res, _callback);\n    } else {\n      return _callback(error, res);\n    }\n  }\n  this.db.getCandidates(this.query, function (err, candidates) {\n    if (err) {\n      return callback(err);\n    }\n    try {\n      for (i = 0; i < candidates.length; i += 1) {\n        if (model.match(candidates[i], self.query)) {\n          // If a sort is defined, wait for the results to be sorted before applying limit and skip\n          if (!self._sort) {\n            if (self._skip && self._skip > skipped) {\n              skipped += 1;\n            } else {\n              res.push(candidates[i]);\n              added += 1;\n              if (self._limit && self._limit <= added) {\n                break;\n              }\n            }\n          } else {\n            res.push(candidates[i]);\n          }\n        }\n      }\n    } catch (err) {\n      return callback(err);\n    }\n\n    // Apply all sorts\n    if (self._sort) {\n      keys = Object.keys(self._sort);\n\n      // Sorting\n      var criteria = [];\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        criteria.push({\n          key: key,\n          direction: self._sort[key]\n        });\n      }\n      res.sort(function (a, b) {\n        var criterion, compare, i;\n        for (i = 0; i < criteria.length; i++) {\n          criterion = criteria[i];\n          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), self.db.compareStrings);\n          if (compare !== 0) {\n            return compare;\n          }\n        }\n        return 0;\n      });\n\n      // Applying limit and skip\n      var limit = self._limit || res.length,\n        skip = self._skip || 0;\n      res = res.slice(skip, skip + limit);\n    }\n\n    // Apply projection\n    try {\n      res = self.project(res);\n    } catch (e) {\n      error = e;\n      res = undefined;\n    }\n    return callback(error, res);\n  });\n};\nCursor.prototype.exec = function () {\n  this.db.executor.push({\n    this: this,\n    fn: this._exec,\n    arguments: arguments\n  });\n};\n\n// Interface\nmodule.exports = Cursor;","map":{"version":3,"names":["model","require","_","Cursor","db","query","execFn","prototype","limit","_limit","skip","_skip","sort","sortQuery","_sort","projection","_projection","project","candidates","res","self","keepId","action","keys","undefined","Object","length","_id","omit","forEach","k","Error","candidate","toPush","$set","getDotValue","modify","$unset","push","_exec","_callback","added","skipped","error","i","key","callback","getCandidates","err","match","criteria","direction","a","b","criterion","compare","compareThings","compareStrings","slice","e","exec","executor","this","fn","arguments","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/nedb/lib/cursor.js"],"sourcesContent":["/**\n * Manage access to data, be it to find, update or remove it\n */\nvar model = require('./model')\n  , _ = require('underscore')\n  ;\n\n\n\n/**\n * Create a new cursor for this collection\n * @param {Datastore} db - The datastore this cursor is bound to\n * @param {Query} query - The query this cursor will operate on\n * @param {Function} execFn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove\n */\nfunction Cursor (db, query, execFn) {\n  this.db = db;\n  this.query = query || {};\n  if (execFn) { this.execFn = execFn; }\n}\n\n\n/**\n * Set a limit to the number of results\n */\nCursor.prototype.limit = function(limit) {\n  this._limit = limit;\n  return this;\n};\n\n\n/**\n * Skip a the number of results\n */\nCursor.prototype.skip = function(skip) {\n  this._skip = skip;\n  return this;\n};\n\n\n/**\n * Sort results of the query\n * @param {SortQuery} sortQuery - SortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending\n */\nCursor.prototype.sort = function(sortQuery) {\n  this._sort = sortQuery;\n  return this;\n};\n\n\n/**\n * Add the use of a projection\n * @param {Object} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2\n *                              { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits\n */\nCursor.prototype.projection = function(projection) {\n  this._projection = projection;\n  return this;\n};\n\n\n/**\n * Apply the projection\n */\nCursor.prototype.project = function (candidates) {\n  var res = [], self = this\n    , keepId, action, keys\n    ;\n\n  if (this._projection === undefined || Object.keys(this._projection).length === 0) {\n    return candidates;\n  }\n\n  keepId = this._projection._id === 0 ? false : true;\n  this._projection = _.omit(this._projection, '_id');\n\n  // Check for consistency\n  keys = Object.keys(this._projection);\n  keys.forEach(function (k) {\n    if (action !== undefined && self._projection[k] !== action) { throw new Error(\"Can't both keep and omit fields except for _id\"); }\n    action = self._projection[k];\n  });\n\n  // Do the actual projection\n  candidates.forEach(function (candidate) {\n    var toPush;\n    if (action === 1) {   // pick-type projection\n      toPush = { $set: {} };\n      keys.forEach(function (k) {\n        toPush.$set[k] = model.getDotValue(candidate, k);\n        if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }\n      });\n      toPush = model.modify({}, toPush);\n    } else {   // omit-type projection\n      toPush = { $unset: {} };\n      keys.forEach(function (k) { toPush.$unset[k] = true });\n      toPush = model.modify(candidate, toPush);\n    }\n    if (keepId) {\n      toPush._id = candidate._id;\n    } else {\n      delete toPush._id;\n    }\n    res.push(toPush);\n  });\n\n  return res;\n};\n\n\n/**\n * Get all matching elements\n * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne\n * This is an internal function, use exec which uses the executor\n *\n * @param {Function} callback - Signature: err, results\n */\nCursor.prototype._exec = function(_callback) {\n  var res = [], added = 0, skipped = 0, self = this\n    , error = null\n    , i, keys, key\n    ;\n\n  function callback (error, res) {\n    if (self.execFn) {\n      return self.execFn(error, res, _callback);\n    } else {\n      return _callback(error, res);\n    }\n  }\n\n  this.db.getCandidates(this.query, function (err, candidates) {\n    if (err) { return callback(err); }\n\n    try {\n      for (i = 0; i < candidates.length; i += 1) {\n        if (model.match(candidates[i], self.query)) {\n          // If a sort is defined, wait for the results to be sorted before applying limit and skip\n          if (!self._sort) {\n            if (self._skip && self._skip > skipped) {\n              skipped += 1;\n            } else {\n              res.push(candidates[i]);\n              added += 1;\n              if (self._limit && self._limit <= added) { break; }\n            }\n          } else {\n            res.push(candidates[i]);\n          }\n        }\n      }\n    } catch (err) {\n      return callback(err);\n    }\n\n    // Apply all sorts\n    if (self._sort) {\n      keys = Object.keys(self._sort);\n\n      // Sorting\n      var criteria = [];\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        criteria.push({ key: key, direction: self._sort[key] });\n      }\n      res.sort(function(a, b) {\n        var criterion, compare, i;\n        for (i = 0; i < criteria.length; i++) {\n          criterion = criteria[i];\n          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), self.db.compareStrings);\n          if (compare !== 0) {\n            return compare;\n          }\n        }\n        return 0;\n      });\n\n      // Applying limit and skip\n      var limit = self._limit || res.length\n        , skip = self._skip || 0;\n\n      res = res.slice(skip, skip + limit);\n    }\n\n    // Apply projection\n    try {\n      res = self.project(res);\n    } catch (e) {\n      error = e;\n      res = undefined;\n    }\n\n    return callback(error, res);\n  });\n};\n\nCursor.prototype.exec = function () {\n  this.db.executor.push({ this: this, fn: this._exec, arguments: arguments });\n};\n\n\n\n// Interface\nmodule.exports = Cursor;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}