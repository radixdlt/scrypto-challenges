{"ast":null,"code":"import { operate } from '../util/lift';\nimport { EMPTY } from '../observable/empty';\nimport { OperatorSubscriber } from './OperatorSubscriber';\nexport function retry(configOrCount) {\n  if (configOrCount === void 0) {\n    configOrCount = Infinity;\n  }\n  var config;\n  if (configOrCount && typeof configOrCount === 'object') {\n    config = configOrCount;\n  } else {\n    config = {\n      count: configOrCount\n    };\n  }\n  var count = config.count,\n    _a = config.resetOnSuccess,\n    resetOnSuccess = _a === void 0 ? false : _a;\n  return count <= 0 ? function () {\n    return EMPTY;\n  } : operate(function (source, subscriber) {\n    var soFar = 0;\n    var innerSub;\n    var subscribeForRetry = function () {\n      var syncUnsub = false;\n      innerSub = source.subscribe(new OperatorSubscriber(subscriber, function (value) {\n        if (resetOnSuccess) {\n          soFar = 0;\n        }\n        subscriber.next(value);\n      }, undefined, function (err) {\n        if (soFar++ < count) {\n          if (innerSub) {\n            innerSub.unsubscribe();\n            innerSub = null;\n            subscribeForRetry();\n          } else {\n            syncUnsub = true;\n          }\n        } else {\n          subscriber.error(err);\n        }\n      }));\n      if (syncUnsub) {\n        innerSub.unsubscribe();\n        innerSub = null;\n        subscribeForRetry();\n      }\n    };\n    subscribeForRetry();\n  });\n}","map":{"version":3,"names":["operate","EMPTY","OperatorSubscriber","retry","configOrCount","Infinity","config","count","_a","resetOnSuccess","source","subscriber","soFar","innerSub","subscribeForRetry","syncUnsub","subscribe","value","next","undefined","err","unsubscribe","error"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/rxjs/src/internal/operators/retry.ts"],"sourcesContent":["import { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { Subscription } from '../Subscription';\nimport { EMPTY } from '../observable/empty';\nimport { OperatorSubscriber } from './OperatorSubscriber';\n\nexport interface RetryConfig {\n  count: number;\n  resetOnSuccess?: boolean;\n}\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * ![](retry.png)\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n *\n * ## Example\n * ```ts\n * import { interval, of, throwError } from 'rxjs';\n * import { mergeMap, retry } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   mergeMap(val => {\n *     if(val > 5){\n *       return throwError('Error!');\n *     }\n *     return of(val);\n *   }),\n *   //retry 2 times on error\n *   retry(2)\n * );\n *\n * const subscribe = example.subscribe({\n *   next: val => console.log(val),\n *   error: val => console.log(`${val}: Retried 2 times then quit!`)\n * });\n *\n * // Output:\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // \"Error!: Retried 2 times then quit!\"\n * ```\n *\n * @param {number} count - Number of retry attempts before failing.\n * @param {boolean} resetOnSuccess - When set to `true` every successful emission will reset the error count\n * @return A function that returns an Observable that will resubscribe to the\n * source stream when the source stream errors, at most `count` times.\n */\nexport function retry<T>(count?: number): MonoTypeOperatorFunction<T>;\nexport function retry<T>(config: RetryConfig): MonoTypeOperatorFunction<T>;\nexport function retry<T>(configOrCount: number | RetryConfig = Infinity): MonoTypeOperatorFunction<T> {\n  let config: RetryConfig;\n  if (configOrCount && typeof configOrCount === 'object') {\n    config = configOrCount;\n  } else {\n    config = {\n      count: configOrCount,\n    };\n  }\n  const { count, resetOnSuccess = false } = config;\n\n  return count <= 0\n    ? () => EMPTY\n    : operate((source, subscriber) => {\n        let soFar = 0;\n        let innerSub: Subscription | null;\n        const subscribeForRetry = () => {\n          let syncUnsub = false;\n          innerSub = source.subscribe(\n            new OperatorSubscriber(\n              subscriber,\n              (value) => {\n                if (resetOnSuccess) {\n                  soFar = 0;\n                }\n                subscriber.next(value);\n              },\n              // Completions are passed through to consumer.\n              undefined,\n              (err) => {\n                if (soFar++ < count) {\n                  if (innerSub) {\n                    innerSub.unsubscribe();\n                    innerSub = null;\n                    subscribeForRetry();\n                  } else {\n                    syncUnsub = true;\n                  }\n                } else {\n                  subscriber.error(err);\n                }\n              }\n            )\n          );\n          if (syncUnsub) {\n            innerSub.unsubscribe();\n            innerSub = null;\n            subscribeForRetry();\n          }\n        };\n        subscribeForRetry();\n      });\n}\n"],"mappings":"AACA,SAASA,OAAO,QAAQ,cAAc;AAEtC,SAASC,KAAK,QAAQ,qBAAqB;AAC3C,SAASC,kBAAkB,QAAQ,sBAAsB;AAuDzD,OAAM,SAAUC,KAAKA,CAAIC,aAA8C;EAA9C,IAAAA,aAAA;IAAAA,aAAA,GAAAC,QAA8C;EAAA;EACrE,IAAIC,MAAmB;EACvB,IAAIF,aAAa,IAAI,OAAOA,aAAa,KAAK,QAAQ,EAAE;IACtDE,MAAM,GAAGF,aAAa;GACvB,MAAM;IACLE,MAAM,GAAG;MACPC,KAAK,EAAEH;KACR;;EAEK,IAAAG,KAAK,GAA6BD,MAAM,CAAAC,KAAnC;IAAEC,EAAA,GAA2BF,MAAM,CAAAG,cAAX;IAAtBA,cAAc,GAAAD,EAAA,cAAG,KAAK,GAAAA,EAAA;EAErC,OAAOD,KAAK,IAAI,CAAC,GACb;IAAM,OAAAN,KAAK;EAAL,CAAK,GACXD,OAAO,CAAC,UAACU,MAAM,EAAEC,UAAU;IACzB,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,QAA6B;IACjC,IAAMC,iBAAiB,GAAG,SAAAA,CAAA;MACxB,IAAIC,SAAS,GAAG,KAAK;MACrBF,QAAQ,GAAGH,MAAM,CAACM,SAAS,CACzB,IAAId,kBAAkB,CACpBS,UAAU,EACV,UAACM,KAAK;QACJ,IAAIR,cAAc,EAAE;UAClBG,KAAK,GAAG,CAAC;;QAEXD,UAAU,CAACO,IAAI,CAACD,KAAK,CAAC;MACxB,CAAC,EAEDE,SAAS,EACT,UAACC,GAAG;QACF,IAAIR,KAAK,EAAE,GAAGL,KAAK,EAAE;UACnB,IAAIM,QAAQ,EAAE;YACZA,QAAQ,CAACQ,WAAW,EAAE;YACtBR,QAAQ,GAAG,IAAI;YACfC,iBAAiB,EAAE;WACpB,MAAM;YACLC,SAAS,GAAG,IAAI;;SAEnB,MAAM;UACLJ,UAAU,CAACW,KAAK,CAACF,GAAG,CAAC;;MAEzB,CAAC,CACF,CACF;MACD,IAAIL,SAAS,EAAE;QACbF,QAAQ,CAACQ,WAAW,EAAE;QACtBR,QAAQ,GAAG,IAAI;QACfC,iBAAiB,EAAE;;IAEvB,CAAC;IACDA,iBAAiB,EAAE;EACrB,CAAC,CAAC;AACR","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}