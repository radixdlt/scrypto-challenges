{"ast":null,"code":"/**\n * Specific customUtils for the browser, where we don't have access to the Crypto and Buffer modules\n */\n\n/**\n * Taken from the crypto-browserify module\n * https://github.com/dominictarr/crypto-browserify\n * NOTE: Math.random() does not guarantee \"cryptographic quality\" but we actually don't need it\n */\nfunction randomBytes(size) {\n  var bytes = new Array(size);\n  var r;\n  for (var i = 0, r; i < size; i++) {\n    if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n    bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n  }\n  return bytes;\n}\n\n/**\n * Taken from the base64-js module\n * https://github.com/beatgammit/base64-js/\n */\nfunction byteArrayToBase64(uint8) {\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    extraBytes = uint8.length % 3 // if we have 1 byte left, pad 2 bytes\n    ,\n    output = \"\",\n    temp,\n    length,\n    i;\n  function tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n  }\n  ;\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n    output += tripletToBase64(temp);\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  switch (extraBytes) {\n    case 1:\n      temp = uint8[uint8.length - 1];\n      output += lookup[temp >> 2];\n      output += lookup[temp << 4 & 0x3F];\n      output += '==';\n      break;\n    case 2:\n      temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n      output += lookup[temp >> 10];\n      output += lookup[temp >> 4 & 0x3F];\n      output += lookup[temp << 2 & 0x3F];\n      output += '=';\n      break;\n  }\n  return output;\n}\n\n/**\n * Return a random alphanumerical string of length len\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\n * (il the base64 conversion yields too many pluses and slashes) but\n * that's not an issue here\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\n * See http://en.wikipedia.org/wiki/Birthday_problem\n */\nfunction uid(len) {\n  return byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+\\/]/g, '').slice(0, len);\n}\nmodule.exports.uid = uid;","map":{"version":3,"names":["randomBytes","size","bytes","Array","r","i","Math","random","byteArrayToBase64","uint8","lookup","extraBytes","length","output","temp","tripletToBase64","num","uid","len","ceil","max","replace","slice","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/nedb/browser-version/browser-specific/lib/customUtils.js"],"sourcesContent":["/**\n * Specific customUtils for the browser, where we don't have access to the Crypto and Buffer modules\n */\n\n/**\n * Taken from the crypto-browserify module\n * https://github.com/dominictarr/crypto-browserify\n * NOTE: Math.random() does not guarantee \"cryptographic quality\" but we actually don't need it\n */\nfunction randomBytes (size) {\n  var bytes = new Array(size);\n  var r;\n\n  for (var i = 0, r; i < size; i++) {\n    if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n    bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n  }\n\n  return bytes;\n}\n\n\n/**\n * Taken from the base64-js module\n * https://github.com/beatgammit/base64-js/\n */\nfunction byteArrayToBase64 (uint8) {\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n    , extraBytes = uint8.length % 3   // if we have 1 byte left, pad 2 bytes\n    , output = \"\"\n    , temp, length, i;\n\n  function tripletToBase64 (num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n  };\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n    output += tripletToBase64(temp);\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  switch (extraBytes) {\n    case 1:\n      temp = uint8[uint8.length - 1];\n      output += lookup[temp >> 2];\n      output += lookup[(temp << 4) & 0x3F];\n      output += '==';\n      break;\n    case 2:\n      temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n      output += lookup[temp >> 10];\n      output += lookup[(temp >> 4) & 0x3F];\n      output += lookup[(temp << 2) & 0x3F];\n      output += '=';\n      break;\n  }\n\n  return output;\n}\n\n\n/**\n * Return a random alphanumerical string of length len\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\n * (il the base64 conversion yields too many pluses and slashes) but\n * that's not an issue here\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\n * See http://en.wikipedia.org/wiki/Birthday_problem\n */\nfunction uid (len) {\n  return byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+\\/]/g, '').slice(0, len);\n}\n\n\n\nmodule.exports.uid = uid;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}