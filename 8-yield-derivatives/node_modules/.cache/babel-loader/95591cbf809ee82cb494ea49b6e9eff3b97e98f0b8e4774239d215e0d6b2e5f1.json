{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValidatorAddress = exports.isValidatorAddressOrUnsafeInput = exports.isValidatorAddress = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\nconst crypto_1 = require(\"@radixdlt/crypto\");\nconst bech32_1 = require(\"../bech32\");\nconst abstractAddress_1 = require(\"./abstractAddress\");\nconst _types_1 = require(\"./_types\");\nconst primitives_1 = require(\"@radixdlt/primitives\");\nconst isValidatorAddress = something => {\n  if (!(0, abstractAddress_1.isAbstractAddress)(something)) return false;\n  return something.addressType === _types_1.AddressTypeT.VALIDATOR;\n};\nexports.isValidatorAddress = isValidatorAddress;\nconst maxLength = 300; // arbitrarily chosen\nconst encoding = bech32_1.Encoding.BECH32;\nconst hrpFromNetwork = network => primitives_1.HRP[network].validator;\nconst networkFromHRP = hrp => hrp === primitives_1.HRP.mainnet.validator ? (0, neverthrow_1.ok)(primitives_1.Network.MAINNET) : hrp === primitives_1.HRP.stokenet.validator ? (0, neverthrow_1.ok)(primitives_1.Network.STOKENET) : hrp === primitives_1.HRP.localnet.validator ? (0, neverthrow_1.ok)(primitives_1.Network.LOCALNET) : hrp === primitives_1.HRP.releasenet.validator ? (0, neverthrow_1.ok)(primitives_1.Network.RELEASENET) : hrp === primitives_1.HRP.rcnet.validator ? (0, neverthrow_1.ok)(primitives_1.Network.RCNET) : hrp === primitives_1.HRP.milestonenet.validator ? (0, neverthrow_1.ok)(primitives_1.Network.MILESTONENET) : hrp === primitives_1.HRP.testnet6.validator ? (0, neverthrow_1.ok)(primitives_1.Network.TESTNET6) : hrp === primitives_1.HRP.sandpitnet.validator ? (0, neverthrow_1.ok)(primitives_1.Network.SANDPITNET) : (0, neverthrow_1.err)(Error(\"Failed to parse network from HRP \".concat(hrp, \" for ValidatorAddress.\")));\nconst fromPublicKeyAndNetwork = input => abstractAddress_1.AbstractAddress.byFormattingPublicKeyDataAndBech32ConvertingIt(Object.assign(Object.assign({}, input), {\n  network: input.network,\n  hrpFromNetwork,\n  addressType: _types_1.AddressTypeT.VALIDATOR,\n  typeguard: exports.isValidatorAddress,\n  encoding,\n  maxLength\n})).orElse(e => {\n  throw new Error(\"Expected to always be able to create validator address from publicKey and network, but got error: \".concat(e.message));\n})._unsafeUnwrap({\n  withStackTrace: true\n});\nconst fromString = bechString => abstractAddress_1.AbstractAddress.fromString({\n  bechString,\n  addressType: _types_1.AddressTypeT.VALIDATOR,\n  typeguard: exports.isValidatorAddress,\n  networkFromHRP,\n  encoding,\n  maxLength\n});\nconst fromBuffer = buffer => {\n  const fromBuf = buf => crypto_1.PublicKey.fromBuffer(buf).map(publicKey => fromPublicKeyAndNetwork({\n    publicKey,\n    network: primitives_1.Network.MAINNET // should change\n  }));\n  if (buffer.length === 34 && buffer[0] === 0x04) {\n    const sliced = buffer.slice(1);\n    if (sliced.length !== 33) {\n      return (0, neverthrow_1.err)(new Error('Failed to slice buffer.'));\n    }\n    return fromBuf(sliced);\n  } else if (buffer.length === 33) {\n    return fromBuf(buffer);\n  } else {\n    return (0, neverthrow_1.err)(new Error(\"Bad length of buffer, got #\".concat(buffer.length, \" bytes, but expected 33.\")));\n  }\n};\nconst isValidatorAddressUnsafeInput = something => typeof something === 'string' || Buffer.isBuffer(something);\nconst isValidatorAddressOrUnsafeInput = something => (0, exports.isValidatorAddress)(something) || isValidatorAddressUnsafeInput(something);\nexports.isValidatorAddressOrUnsafeInput = isValidatorAddressOrUnsafeInput;\nconst fromUnsafe = input => (0, exports.isValidatorAddress)(input) ? (0, neverthrow_1.ok)(input) : typeof input === 'string' ? fromString(input) : fromBuffer(input);\nexports.ValidatorAddress = {\n  fromUnsafe,\n  fromPublicKeyAndNetwork\n};","map":{"version":3,"names":["neverthrow_1","require","crypto_1","bech32_1","abstractAddress_1","_types_1","primitives_1","isValidatorAddress","something","isAbstractAddress","addressType","AddressTypeT","VALIDATOR","exports","maxLength","encoding","Encoding","BECH32","hrpFromNetwork","network","HRP","validator","networkFromHRP","hrp","mainnet","ok","Network","MAINNET","stokenet","STOKENET","localnet","LOCALNET","releasenet","RELEASENET","rcnet","RCNET","milestonenet","MILESTONENET","testnet6","TESTNET6","sandpitnet","SANDPITNET","err","Error","concat","fromPublicKeyAndNetwork","input","AbstractAddress","byFormattingPublicKeyDataAndBech32ConvertingIt","Object","assign","typeguard","orElse","e","message","_unsafeUnwrap","withStackTrace","fromString","bechString","fromBuffer","buffer","fromBuf","buf","PublicKey","map","publicKey","length","sliced","slice","isValidatorAddressUnsafeInput","Buffer","isBuffer","isValidatorAddressOrUnsafeInput","fromUnsafe","ValidatorAddress"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/account/src/addresses/validatorAddress.ts"],"sourcesContent":["import { err, ok, Result } from 'neverthrow'\nimport { PublicKey, PublicKeyT } from '@radixdlt/crypto'\nimport { Encoding } from '../bech32'\nimport {\n\tAbstractAddress,\n\tHRPFromNetwork,\n\tisAbstractAddress,\n\tNetworkFromHRP,\n} from './abstractAddress'\nimport { AddressTypeT, ValidatorAddressT } from './_types'\nimport { HRP, Network } from '@radixdlt/primitives'\n\nexport const isValidatorAddress = (\n\tsomething: unknown,\n): something is ValidatorAddressT => {\n\tif (!isAbstractAddress(something)) return false\n\treturn something.addressType === AddressTypeT.VALIDATOR\n}\n\nconst maxLength = 300 // arbitrarily chosen\nconst encoding = Encoding.BECH32\n\nconst hrpFromNetwork = (network: Network) => HRP[network].validator\n\nconst networkFromHRP: NetworkFromHRP = hrp =>\n\thrp === HRP.mainnet.validator\n\t\t? ok(Network.MAINNET)\n\t\t: hrp === HRP.stokenet.validator\n\t\t? ok(Network.STOKENET)\n\t\t: hrp === HRP.localnet.validator\n\t\t? ok(Network.LOCALNET)\n\t\t: hrp === HRP.releasenet.validator\n\t\t? ok(Network.RELEASENET)\n\t\t: hrp === HRP.rcnet.validator\n\t\t? ok(Network.RCNET)\n\t\t: hrp === HRP.milestonenet.validator\n\t\t? ok(Network.MILESTONENET)\n\t\t: hrp === HRP.testnet6.validator\n\t\t? ok(Network.TESTNET6)\n\t\t: hrp === HRP.sandpitnet.validator\n\t\t? ok(Network.SANDPITNET)\n\t\t: err(\n\t\t\t\tError(\n\t\t\t\t\t`Failed to parse network from HRP ${hrp} for ValidatorAddress.`,\n\t\t\t\t),\n\t\t  )\n\nconst fromPublicKeyAndNetwork = (\n\tinput: Readonly<{\n\t\tpublicKey: PublicKeyT\n\t\tnetwork: Network\n\t}>,\n): ValidatorAddressT =>\n\tAbstractAddress.byFormattingPublicKeyDataAndBech32ConvertingIt({\n\t\t...input,\n\t\tnetwork: input.network,\n\t\thrpFromNetwork,\n\t\taddressType: AddressTypeT.VALIDATOR,\n\t\ttypeguard: isValidatorAddress,\n\t\tencoding,\n\t\tmaxLength,\n\t})\n\t\t.orElse(e => {\n\t\t\tthrow new Error(\n\t\t\t\t`Expected to always be able to create validator address from publicKey and network, but got error: ${e.message}`,\n\t\t\t)\n\t\t})\n\t\t._unsafeUnwrap({ withStackTrace: true })\n\nconst fromString = (bechString: string): Result<ValidatorAddressT, Error> =>\n\tAbstractAddress.fromString({\n\t\tbechString,\n\t\taddressType: AddressTypeT.VALIDATOR,\n\t\ttypeguard: isValidatorAddress,\n\t\tnetworkFromHRP,\n\t\tencoding,\n\t\tmaxLength,\n\t})\n\nconst fromBuffer = (buffer: Buffer): Result<ValidatorAddressT, Error> => {\n\tconst fromBuf = (buf: Buffer): Result<ValidatorAddressT, Error> =>\n\t\tPublicKey.fromBuffer(buf).map(publicKey =>\n\t\t\tfromPublicKeyAndNetwork({\n\t\t\t\tpublicKey,\n\t\t\t\tnetwork: Network.MAINNET, // should change\n\t\t\t}),\n\t\t)\n\n\tif (buffer.length === 34 && buffer[0] === 0x04) {\n\t\tconst sliced = buffer.slice(1)\n\t\tif (sliced.length !== 33) {\n\t\t\treturn err(new Error('Failed to slice buffer.'))\n\t\t}\n\t\treturn fromBuf(sliced)\n\t} else if (buffer.length === 33) {\n\t\treturn fromBuf(buffer)\n\t} else {\n\t\treturn err(\n\t\t\tnew Error(\n\t\t\t\t`Bad length of buffer, got #${buffer.length} bytes, but expected 33.`,\n\t\t\t),\n\t\t)\n\t}\n}\n\nexport type ValidatorAddressUnsafeInput = string | Buffer\n\nconst isValidatorAddressUnsafeInput = (\n\tsomething: unknown,\n): something is ValidatorAddressUnsafeInput =>\n\ttypeof something === 'string' || Buffer.isBuffer(something)\n\nexport type ValidatorAddressOrUnsafeInput =\n\t| ValidatorAddressUnsafeInput\n\t| ValidatorAddressT\n\nexport const isValidatorAddressOrUnsafeInput = (\n\tsomething: unknown,\n): something is ValidatorAddressOrUnsafeInput =>\n\tisValidatorAddress(something) || isValidatorAddressUnsafeInput(something)\n\nconst fromUnsafe = (\n\tinput: ValidatorAddressOrUnsafeInput,\n): Result<ValidatorAddressT, Error> =>\n\tisValidatorAddress(input)\n\t\t? ok(input)\n\t\t: typeof input === 'string'\n\t\t? fromString(input)\n\t\t: fromBuffer(input)\n\nexport const ValidatorAddress = {\n\tfromUnsafe,\n\tfromPublicKeyAndNetwork,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}