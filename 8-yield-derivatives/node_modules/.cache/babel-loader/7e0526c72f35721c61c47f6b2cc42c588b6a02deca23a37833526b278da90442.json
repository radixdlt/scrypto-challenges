{"ast":null,"code":"'use strict';\n\nconst bignumber = require('bignumber.js').BigNumber;\nconst utils = require('./utils');\nconst url = require('url');\nconst MINUS_ONE = new bignumber(-1);\nconst TEN = new bignumber(10);\nconst TWO = new bignumber(2);\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} [err] - the error that was thrown parsing the tag, or null\n   */\n  constructor(tag, value, err) {\n    this.tag = tag;\n    this.value = value;\n    this.err = err;\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + typeof this.tag + ')');\n    }\n    if (this.tag < 0 || (this.tag | 0) !== this.tag) {\n      throw new Error('Tag must be a positive integer: ' + this.tag);\n    }\n  }\n\n  /**\n   * Convert to a String\n   *\n   * @returns {string} string of the form '1(2)'\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`;\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {Object} gen The generator to push onto\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag);\n    return gen.pushAny(this.value);\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n  convert(converters) {\n    let f = converters != null ? converters[this.tag] : void 0;\n    if (typeof f !== 'function') {\n      f = Tagged['_tag_' + this.tag];\n      if (typeof f !== 'function') {\n        return this;\n      }\n    }\n    try {\n      return f.call(Tagged, this.value);\n    } catch (error) {\n      this.err = error;\n      return this;\n    }\n  }\n  static _tag_0(v) {\n    return new Date(v);\n  }\n  static _tag_1(v) {\n    return new Date(v * 1000);\n  }\n  static _tag_2(v) {\n    return utils.bufferToBignumber(v);\n  }\n  static _tag_3(v) {\n    return MINUS_ONE.minus(utils.bufferToBignumber(v));\n  }\n  static _tag_4(v) {\n    return TEN.pow(v[0]).times(v[1]);\n  }\n  static _tag_5(v) {\n    return TWO.pow(v[0]).times(v[1]);\n  }\n  static _tag_32(v) {\n    return url.parse(v);\n  }\n  static _tag_35(v) {\n    return new RegExp(v);\n  }\n}\nmodule.exports = Tagged;","map":{"version":3,"names":["bignumber","require","BigNumber","utils","url","MINUS_ONE","TEN","TWO","Tagged","constructor","tag","value","err","Error","toString","JSON","stringify","encodeCBOR","gen","_pushTag","pushAny","convert","converters","f","call","error","_tag_0","v","Date","_tag_1","_tag_2","bufferToBignumber","_tag_3","minus","_tag_4","pow","times","_tag_5","_tag_32","parse","_tag_35","RegExp","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/cbor/lib/tagged.js"],"sourcesContent":["'use strict'\n\nconst bignumber = require('bignumber.js').BigNumber\nconst utils = require('./utils')\nconst url = require('url')\n\nconst MINUS_ONE = new bignumber(-1)\nconst TEN = new bignumber(10)\nconst TWO = new bignumber(2)\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} [err] - the error that was thrown parsing the tag, or null\n   */\n  constructor(tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error('Tag must be a positive integer: ' + this.tag)\n    }\n  }\n\n  /**\n   * Convert to a String\n   *\n   * @returns {string} string of the form '1(2)'\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {Object} gen The generator to push onto\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n  convert(converters) {\n    let f = converters != null ? converters[this.tag] : void 0\n    if (typeof f !== 'function') {\n      f = Tagged['_tag_' + this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(Tagged, this.value)\n    } catch (error) {\n      this.err = error\n      return this\n    }\n  }\n\n  static _tag_0(v) {\n    return new Date(v)\n  }\n\n  static _tag_1(v) {\n    return new Date(v * 1000)\n  }\n\n  static _tag_2(v) {\n    return utils.bufferToBignumber(v)\n  }\n\n  static _tag_3(v) {\n    return MINUS_ONE.minus(utils.bufferToBignumber(v))\n  }\n\n  static _tag_4(v) {\n    return TEN.pow(v[0]).times(v[1])\n  }\n\n  static _tag_5(v) {\n    return TWO.pow(v[0]).times(v[1])\n  }\n\n  static _tag_32(v) {\n    return url.parse(v)\n  }\n\n  static _tag_35(v) {\n    return new RegExp(v)\n  }\n}\n\nmodule.exports = Tagged\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}