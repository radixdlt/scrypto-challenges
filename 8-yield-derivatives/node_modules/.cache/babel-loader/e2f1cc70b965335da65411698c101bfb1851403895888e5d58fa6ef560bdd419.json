{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EncryptionScheme = exports.MessageType = exports.MESSAGE_TYPE_BYTES = exports.ENCRYPTION_SCHEME_BYTES = void 0;\nexports.ENCRYPTION_SCHEME_BYTES = 1;\nexports.MESSAGE_TYPE_BYTES = 1;\nvar MessageType;\n(function (MessageType) {\n  MessageType[MessageType[\"PLAINTEXT\"] = 0] = \"PLAINTEXT\";\n  MessageType[MessageType[\"ENCRYPTED\"] = 1] = \"ENCRYPTED\";\n  MessageType[MessageType[\"HEX\"] = 30] = \"HEX\";\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\nvar EncryptionScheme;\n(function (EncryptionScheme) {\n  EncryptionScheme[EncryptionScheme[\"NONE\"] = 0] = \"NONE\";\n  EncryptionScheme[EncryptionScheme[\"DH_ADD_EPH_AESGCM256_SCRYPT_000\"] = 255] = \"DH_ADD_EPH_AESGCM256_SCRYPT_000\";\n})(EncryptionScheme = exports.EncryptionScheme || (exports.EncryptionScheme = {}));","map":{"version":3,"names":["exports","ENCRYPTION_SCHEME_BYTES","MESSAGE_TYPE_BYTES","MessageType","EncryptionScheme"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/src/encryption/_types.ts"],"sourcesContent":["import { Byte, SecureRandom } from '@radixdlt/util'\nimport { ResultAsync } from 'neverthrow'\nimport { ECPointOnCurveT, PublicKeyT } from '../elliptic-curve'\n\nexport type MessageEncryptionInput = Readonly<{\n\tplaintext: Buffer | string\n\tdiffieHellmanPoint: () => ResultAsync<ECPointOnCurveT, Error>\n\tsecureRandom?: SecureRandom\n}>\n\nexport type MessageDecryptionInput = Readonly<{\n\tencryptedMessage: Buffer | EncryptedMessageT\n\tdiffieHellmanPoint: () => ResultAsync<ECPointOnCurveT, Error>\n}>\n\nexport const ENCRYPTION_SCHEME_BYTES = 1\n\nexport const MESSAGE_TYPE_BYTES = 1\n\nexport enum MessageType {\n\tPLAINTEXT = 0x00,\n\tENCRYPTED = 0x01,\n\tHEX = 0x1e,\n}\n\nexport enum EncryptionScheme {\n\tNONE = 0x00,\n\tDH_ADD_EPH_AESGCM256_SCRYPT_000 = 0xff,\n}\n\nexport type SealedMessageT = Readonly<{\n\t/* The public key of the ephemeral key pair. 33 bytes */\n\tephemeralPublicKey: PublicKeyT\n\n\t/* The nonce used to encrypt the data. 12 bytes. AKA \"IV\". */\n\tnonce: Buffer\n\n\t/* An authentication tag. 16 bytes, e.g. AES GCM tag. */\n\tauthTag: Buffer\n\n\t/* The encrypted data. Max 162 bytes. */\n\tciphertext: Buffer\n\n\tcombined: () => Buffer\n}>\n\ntype Message<Kind extends keyof typeof MessageType> = {\n\tkind: Kind\n}\n\n// Max 255 bytes\nexport type EncryptedMessageT = Message<'ENCRYPTED'> & {\n\tencryptionScheme: EncryptionScheme\n\n\t/* Encrypted message with metadata containing about how it can be decrypted. Max 223 bytes. */\n\tsealedMessage: SealedMessageT\n\n\tcombined: () => Buffer\n}\n\nexport type PlaintextMessageT = Message<'PLAINTEXT'> & {\n\tplaintext: string\n\tbytes: Buffer\n}\n"],"mappings":";;;;;;AAeaA,OAAA,CAAAC,uBAAuB,GAAG,CAAC;AAE3BD,OAAA,CAAAE,kBAAkB,GAAG,CAAC;AAEnC,IAAYC,WAIX;AAJD,WAAYA,WAAW;EACtBA,WAAA,CAAAA,WAAA,gCAAgB;EAChBA,WAAA,CAAAA,WAAA,gCAAgB;EAChBA,WAAA,CAAAA,WAAA,qBAAU;AACX,CAAC,EAJWA,WAAW,GAAXH,OAAA,CAAAG,WAAW,KAAXH,OAAA,CAAAG,WAAW;AAMvB,IAAYC,gBAGX;AAHD,WAAYA,gBAAgB;EAC3BA,gBAAA,CAAAA,gBAAA,sBAAW;EACXA,gBAAA,CAAAA,gBAAA,8EAAsC;AACvC,CAAC,EAHWA,gBAAgB,GAAhBJ,OAAA,CAAAI,gBAAgB,KAAhBJ,OAAA,CAAAI,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}