{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\nconst stream = require('stream');\nconst util = require('util');\nconst bignumber = require('bignumber.js').BigNumber;\nconst constants = require('./constants');\nconst NUMBYTES = constants.NUMBYTES;\nconst SHIFT32 = constants.SHIFT32;\nconst MAX_SAFE_HIGH = 0x1fffff;\nexports.hasBigInt = typeof BigInt === 'function';\n\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n */\nconst TD = typeof TextDecoder === 'function' ? TextDecoder : util.TextDecoder;\n/* istanbul ignore else */\nif (TD) {\n  // node 11+, browsers : node 8.3+\n  const td = new TD('utf8', {\n    fatal: true,\n    ignoreBOM: true\n  });\n  exports.utf8 = buf => td.decode(buf);\n  exports.utf8.checksUTF8 = true;\n} else {\n  // TODO: polyfill a slow one or wait for node6 to die\n  exports.utf8 = buf => buf.toString('utf8');\n  exports.utf8.checksUTF8 = false;\n}\nexports.parseCBORint = function (ai, buf) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0);\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0);\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0);\n    case NUMBYTES.EIGHT:\n      const f = buf.readUInt32BE(0);\n      const g = buf.readUInt32BE(4);\n      if (f > MAX_SAFE_HIGH) {\n        return new bignumber(f).times(SHIFT32).plus(g);\n      } else {\n        return f * SHIFT32 + g;\n      }\n    default:\n      throw new Error('Invalid additional info for int: ' + ai);\n  }\n};\nexports.writeHalf = function writeHalf(buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4);\n  u32.writeFloatBE(half, 0);\n  const u = u32.readUInt32BE(0);\n\n  // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits are 0,\n  // we won't lose anything in the conversion\n  if ((u & 0x1FFF) !== 0) {\n    return false;\n  }\n\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  let s16 = u >> 16 & 0x8000; // top bit is sign\n  const exp = u >> 23 & 0xff; // then 5 bits of exponent\n  const mant = u & 0x7fffff;\n\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if (exp >= 113 && exp <= 142) {\n    s16 += (exp - 112 << 10) + (mant >> 13);\n  } else if (exp >= 103 && exp < 113) {\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n\n    if (mant & (1 << 126 - exp) - 1) {\n      return false;\n    }\n    s16 += mant + 0x800000 >> 126 - exp;\n  } else {\n    //   } else if (exp == 255 && mant == 0) { /* Inf */\n    //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n    //   } else\n    //     goto float32;           /* loss of range */\n\n    return false;\n  }\n\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16);\n  return true;\n};\nexports.parseHalf = function parseHalf(buf) {\n  const sign = buf[0] & 0x80 ? -1 : 1;\n  const exp = (buf[0] & 0x7C) >> 2;\n  const mant = (buf[0] & 0x03) << 8 | buf[1];\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant;\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308);\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant);\n  }\n};\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf);\n    case 4:\n      return buf.readFloatBE(0);\n    case 8:\n      return buf.readDoubleBE(0);\n    default:\n      throw new Error('Invalid float size: ' + buf.length);\n  }\n};\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex');\n};\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '');\n  let start = 0;\n  let end = s.length % 8 || 8;\n  const chunks = [];\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2));\n    start = end;\n    end += 8;\n  }\n  return Buffer.from(chunks);\n};\nexports.extend = function extend(old = {}, ...adds) {\n  const len = adds.length;\n  for (let j = 0; j < len; j++) {\n    const a = adds[j];\n    for (const k in a) {\n      const v = a[k];\n      old[k] = v;\n    }\n  }\n  return old;\n};\nexports.arrayEqual = function arrayEqual(a, b) {\n  if (a == null && b == null) {\n    return true;\n  }\n  if (a == null || b == null) {\n    return false;\n  }\n  return a.length === b.length && a.every((elem, i) => elem === b[i]);\n};\nexports.bufferEqual = function bufferEqual(a, b) {\n  if (a == null && b == null) {\n    return true;\n  }\n  if (a == null || b == null) {\n    return false;\n  }\n  if (!(Buffer.isBuffer(a) && Buffer.isBuffer(b) && a.length === b.length)) {\n    return false;\n  }\n  const len = a.length;\n  let ret = true;\n  let i;\n  let j;\n  for (i = j = 0; j < len; i = ++j) {\n    const byte = a[i];\n    ret = ret && b[i] === byte;\n  }\n  return !!ret;\n};\nexports.bufferToBignumber = function bufferToBignumber(buf) {\n  return new bignumber(buf.toString('hex'), 16);\n};\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return BigInt('0x' + buf.toString('hex'));\n};\nexports.DeHexStream = class DeHexStream extends stream.Readable {\n  constructor(hex) {\n    super();\n    hex = hex.replace(/^0x/, '');\n    if (hex) {\n      this.push(Buffer.from(hex, 'hex'));\n    }\n    this.push(null);\n  }\n};\nexports.HexStream = class HexStream extends stream.Transform {\n  constructor(options) {\n    super(options);\n  }\n  _transform(fresh, encoding, cb) {\n    this.push(fresh.toString('hex'));\n    return cb();\n  }\n};\nexports.printError = function printError(er) {\n  if (er != null) {\n    return console.error(er);\n  }\n};\nexports.streamFiles = function streamFiles(files, streamFunc, cb) {\n  const f = files.shift();\n  if (!f) {\n    return cb();\n  }\n  const sf = streamFunc();\n  sf.on('end', () => exports.streamFiles(files, streamFunc, cb));\n  sf.on('error', cb);\n  const s = f === '-' ? process.stdin : f instanceof stream.Stream ? f : fs.createReadStream(f);\n  s.on('error', cb);\n  return s.pipe(sf);\n};\nexports.guessEncoding = function guessEncoding(input) {\n  if (typeof input == 'string') {\n    return 'hex';\n  } else if (Buffer.isBuffer(input)) {\n    return undefined;\n  }\n  throw new Error('Unknown input type');\n};","map":{"version":3,"names":["fs","require","stream","util","bignumber","BigNumber","constants","NUMBYTES","SHIFT32","MAX_SAFE_HIGH","exports","hasBigInt","BigInt","TD","TextDecoder","td","fatal","ignoreBOM","utf8","buf","decode","checksUTF8","toString","parseCBORint","ai","ONE","readUInt8","TWO","readUInt16BE","FOUR","readUInt32BE","EIGHT","f","g","times","plus","Error","writeHalf","half","u32","Buffer","allocUnsafe","writeFloatBE","u","s16","exp","mant","writeUInt16BE","parseHalf","sign","Math","pow","parseCBORfloat","length","readFloatBE","readDoubleBE","hex","s","from","replace","bin","start","end","chunks","push","parseInt","slice","extend","old","adds","len","j","a","k","v","arrayEqual","b","every","elem","i","bufferEqual","isBuffer","ret","byte","bufferToBignumber","bufferToBigInt","DeHexStream","Readable","constructor","HexStream","Transform","options","_transform","fresh","encoding","cb","printError","er","console","error","streamFiles","files","streamFunc","shift","sf","on","process","stdin","Stream","createReadStream","pipe","guessEncoding","input","undefined"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/cbor/lib/utils.js"],"sourcesContent":["'use strict'\n\nconst fs = require('fs')\nconst stream = require('stream')\nconst util = require('util')\nconst bignumber = require('bignumber.js').BigNumber\n\nconst constants = require('./constants')\nconst NUMBYTES = constants.NUMBYTES\nconst SHIFT32 = constants.SHIFT32\nconst MAX_SAFE_HIGH = 0x1fffff\n\nexports.hasBigInt = (typeof BigInt === 'function')\n\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n */\nconst TD = (typeof TextDecoder === 'function') ? TextDecoder : util.TextDecoder\n/* istanbul ignore else */\nif (TD) {\n  // node 11+, browsers : node 8.3+\n  const td = new TD('utf8', {fatal: true, ignoreBOM: true})\n  exports.utf8 = (buf) => td.decode(buf)\n  exports.utf8.checksUTF8 = true\n} else {\n  // TODO: polyfill a slow one or wait for node6 to die\n  exports.utf8 = (buf) => buf.toString('utf8') \n  exports.utf8.checksUTF8 = false  \n}\n\nexports.parseCBORint = function(ai, buf) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0)\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0)\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0)\n    case NUMBYTES.EIGHT:\n      const f = buf.readUInt32BE(0)\n      const g = buf.readUInt32BE(4)\n      if (f > MAX_SAFE_HIGH) {\n        return new bignumber(f).times(SHIFT32).plus(g)\n      } else {\n        return (f * SHIFT32) + g\n      }\n    default:\n      throw new Error('Invalid additional info for int: ' + ai)\n  }\n}\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4)\n  u32.writeFloatBE(half, 0)\n  const u = u32.readUInt32BE(0)\n\n  // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits are 0,\n  // we won't lose anything in the conversion\n  if ((u & 0x1FFF) !== 0) {\n    return false\n  }\n\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  let s16 = (u >> 16) & 0x8000 // top bit is sign\n  const exp = (u >> 23) & 0xff // then 5 bits of exponent\n  const mant = u & 0x7fffff\n\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13)\n  } else if ((exp >= 103) && (exp < 113)) {\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp))\n  } else {\n  //   } else if (exp == 255 && mant == 0) { /* Inf */\n  //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n    //   } else\n    //     goto float32;           /* loss of range */\n\n    return false\n  }\n\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16)\n  return true\n}\n\nexports.parseHalf = function parseHalf(buf) {\n  const sign = buf[0] & 0x80 ? -1 : 1\n  const exp = (buf[0] & 0x7C) >> 2\n  const mant = ((buf[0] & 0x03) << 8) | buf[1]\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308)\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant)\n  }\n}\n\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf)\n    case 4:\n      return buf.readFloatBE(0)\n    case 8:\n      return buf.readDoubleBE(0)\n    default:\n      throw new Error('Invalid float size: ' + buf.length)\n  }\n}\n\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex')\n}\n\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '')\n  let start = 0\n  let end = (s.length % 8) || 8\n  const chunks = []\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2))\n    start = end\n    end += 8\n  }\n  return Buffer.from(chunks)\n}\n\nexports.extend = function extend(old={}, ...adds) {\n  const len = adds.length\n  for (let j = 0; j < len; j++) {\n    const a = adds[j]\n    for (const k in a) {\n      const v = a[k]\n      old[k] = v\n    }\n  }\n  return old\n}\n\nexports.arrayEqual = function arrayEqual(a, b) {\n  if ((a == null) && (b == null)) {\n    return true\n  }\n  if ((a == null) || (b == null)) {\n    return false\n  }\n  return (a.length === b.length) && a.every((elem, i) => elem === b[i])\n}\n\nexports.bufferEqual = function bufferEqual(a, b) {\n  if ((a == null) && (b == null)) {\n    return true\n  }\n  if ((a == null) || (b == null)) {\n    return false\n  }\n  if (!(Buffer.isBuffer(a) && Buffer.isBuffer(b) && (a.length === b.length))) {\n    return false\n  }\n  const len = a.length\n  let ret = true\n  let i\n  let j\n  for (i = j = 0; j < len; i = ++j) {\n    const byte = a[i]\n    ret = ret && (b[i] === byte)\n  }\n  return !!ret\n}\n\nexports.bufferToBignumber = function bufferToBignumber(buf) {\n  return new bignumber(buf.toString('hex'), 16)\n}\n\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return BigInt('0x' + buf.toString('hex'))\n}\n\nexports.DeHexStream = class DeHexStream extends stream.Readable {\n  constructor(hex) {\n    super()\n    hex = hex.replace(/^0x/, '')\n    if (hex) {\n      this.push(Buffer.from(hex, 'hex'))\n    }\n    this.push(null)\n  }\n}\n\nexports.HexStream = class HexStream extends stream.Transform {\n  constructor(options) {\n    super(options)\n  }\n\n  _transform(fresh, encoding, cb) {\n    this.push(fresh.toString('hex'))\n    return cb()\n  }\n}\n\nexports.printError = function printError(er) {\n  if (er != null) {\n    return console.error(er)\n  }\n}\n\nexports.streamFiles = function streamFiles(files, streamFunc, cb) {\n  const f = files.shift()\n  if (!f) {\n    return cb()\n  }\n  const sf = streamFunc()\n  sf.on('end', () => exports.streamFiles(files, streamFunc, cb))\n  sf.on('error', cb)\n  const s = (f === '-') ?\n    process.stdin : (f instanceof stream.Stream) ? f : fs.createReadStream(f)\n  s.on('error', cb)\n  return s.pipe(sf)\n}\n\nexports.guessEncoding = function guessEncoding(input) {\n  if (typeof input == 'string') {\n    return 'hex'\n  } else if (Buffer.isBuffer(input)) {\n    return undefined\n  }\n  throw new Error('Unknown input type')\n}\n\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AACxB,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAME,IAAI,GAAGF,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMG,SAAS,GAAGH,OAAO,CAAC,cAAc,CAAC,CAACI,SAAS;AAEnD,MAAMC,SAAS,GAAGL,OAAO,CAAC,aAAa,CAAC;AACxC,MAAMM,QAAQ,GAAGD,SAAS,CAACC,QAAQ;AACnC,MAAMC,OAAO,GAAGF,SAAS,CAACE,OAAO;AACjC,MAAMC,aAAa,GAAG,QAAQ;AAE9BC,OAAO,CAACC,SAAS,GAAI,OAAOC,MAAM,KAAK,UAAW;;AAElD;AACA;AACA;AACA;AACA,MAAMC,EAAE,GAAI,OAAOC,WAAW,KAAK,UAAU,GAAIA,WAAW,GAAGX,IAAI,CAACW,WAAW;AAC/E;AACA,IAAID,EAAE,EAAE;EACN;EACA,MAAME,EAAE,GAAG,IAAIF,EAAE,CAAC,MAAM,EAAE;IAACG,KAAK,EAAE,IAAI;IAAEC,SAAS,EAAE;EAAI,CAAC,CAAC;EACzDP,OAAO,CAACQ,IAAI,GAAIC,GAAG,IAAKJ,EAAE,CAACK,MAAM,CAACD,GAAG,CAAC;EACtCT,OAAO,CAACQ,IAAI,CAACG,UAAU,GAAG,IAAI;AAChC,CAAC,MAAM;EACL;EACAX,OAAO,CAACQ,IAAI,GAAIC,GAAG,IAAKA,GAAG,CAACG,QAAQ,CAAC,MAAM,CAAC;EAC5CZ,OAAO,CAACQ,IAAI,CAACG,UAAU,GAAG,KAAK;AACjC;AAEAX,OAAO,CAACa,YAAY,GAAG,UAASC,EAAE,EAAEL,GAAG,EAAE;EACvC,QAAQK,EAAE;IACR,KAAKjB,QAAQ,CAACkB,GAAG;MACf,OAAON,GAAG,CAACO,SAAS,CAAC,CAAC,CAAC;IACzB,KAAKnB,QAAQ,CAACoB,GAAG;MACf,OAAOR,GAAG,CAACS,YAAY,CAAC,CAAC,CAAC;IAC5B,KAAKrB,QAAQ,CAACsB,IAAI;MAChB,OAAOV,GAAG,CAACW,YAAY,CAAC,CAAC,CAAC;IAC5B,KAAKvB,QAAQ,CAACwB,KAAK;MACjB,MAAMC,CAAC,GAAGb,GAAG,CAACW,YAAY,CAAC,CAAC,CAAC;MAC7B,MAAMG,CAAC,GAAGd,GAAG,CAACW,YAAY,CAAC,CAAC,CAAC;MAC7B,IAAIE,CAAC,GAAGvB,aAAa,EAAE;QACrB,OAAO,IAAIL,SAAS,CAAC4B,CAAC,CAAC,CAACE,KAAK,CAAC1B,OAAO,CAAC,CAAC2B,IAAI,CAACF,CAAC,CAAC;MAChD,CAAC,MAAM;QACL,OAAQD,CAAC,GAAGxB,OAAO,GAAIyB,CAAC;MAC1B;IACF;MACE,MAAM,IAAIG,KAAK,CAAC,mCAAmC,GAAGZ,EAAE,CAAC;EAC7D;AACF,CAAC;AAEDd,OAAO,CAAC2B,SAAS,GAAG,SAASA,SAASA,CAAClB,GAAG,EAAEmB,IAAI,EAAE;EAChD;;EAEA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,MAAMC,GAAG,GAAGC,MAAM,CAACC,WAAW,CAAC,CAAC,CAAC;EACjCF,GAAG,CAACG,YAAY,CAACJ,IAAI,EAAE,CAAC,CAAC;EACzB,MAAMK,CAAC,GAAGJ,GAAG,CAACT,YAAY,CAAC,CAAC,CAAC;;EAE7B;;EAEA;EACA;EACA,IAAI,CAACa,CAAC,GAAG,MAAM,MAAM,CAAC,EAAE;IACtB,OAAO,KAAK;EACd;;EAEA;EACA;EACA;;EAEA,IAAIC,GAAG,GAAID,CAAC,IAAI,EAAE,GAAI,MAAM,EAAC;EAC7B,MAAME,GAAG,GAAIF,CAAC,IAAI,EAAE,GAAI,IAAI,EAAC;EAC7B,MAAMG,IAAI,GAAGH,CAAC,GAAG,QAAQ;;EAEzB;EACA;;EAEA;;EAEA;EACA;;EAEA,IAAKE,GAAG,IAAI,GAAG,IAAMA,GAAG,IAAI,GAAI,EAAE;IAChCD,GAAG,IAAI,CAAEC,GAAG,GAAG,GAAG,IAAK,EAAE,KAAKC,IAAI,IAAI,EAAE,CAAC;EAC3C,CAAC,MAAM,IAAKD,GAAG,IAAI,GAAG,IAAMA,GAAG,GAAG,GAAI,EAAE;IACtC;IACA;IACA;IACA;;IAEA,IAAIC,IAAI,GAAI,CAAC,CAAC,IAAK,GAAG,GAAGD,GAAI,IAAI,CAAE,EAAE;MACnC,OAAO,KAAK;IACd;IACAD,GAAG,IAAME,IAAI,GAAG,QAAQ,IAAM,GAAG,GAAGD,GAAK;EAC3C,CAAC,MAAM;IACP;IACA;;IAEE;;IAEA;IACA;;IAEA,OAAO,KAAK;EACd;;EAEA;EACA;EACA;EACA1B,GAAG,CAAC4B,aAAa,CAACH,GAAG,CAAC;EACtB,OAAO,IAAI;AACb,CAAC;AAEDlC,OAAO,CAACsC,SAAS,GAAG,SAASA,SAASA,CAAC7B,GAAG,EAAE;EAC1C,MAAM8B,IAAI,GAAG9B,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC;EACnC,MAAM0B,GAAG,GAAG,CAAC1B,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,CAAC;EAChC,MAAM2B,IAAI,GAAI,CAAC3B,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,CAAC,GAAIA,GAAG,CAAC,CAAC,CAAC;EAC5C,IAAI,CAAC0B,GAAG,EAAE;IACR,OAAOI,IAAI,GAAG,qBAAqB,GAAGH,IAAI;EAC5C,CAAC,MAAM,IAAID,GAAG,KAAK,IAAI,EAAE;IACvB,OAAOI,IAAI,IAAIH,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;EACtC,CAAC,MAAM;IACL,OAAOG,IAAI,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEN,GAAG,GAAG,EAAE,CAAC,IAAI,IAAI,GAAGC,IAAI,CAAC;EACrD;AACF,CAAC;AAEDpC,OAAO,CAAC0C,cAAc,GAAG,SAASA,cAAcA,CAACjC,GAAG,EAAE;EACpD,QAAQA,GAAG,CAACkC,MAAM;IAChB,KAAK,CAAC;MACJ,OAAO3C,OAAO,CAACsC,SAAS,CAAC7B,GAAG,CAAC;IAC/B,KAAK,CAAC;MACJ,OAAOA,GAAG,CAACmC,WAAW,CAAC,CAAC,CAAC;IAC3B,KAAK,CAAC;MACJ,OAAOnC,GAAG,CAACoC,YAAY,CAAC,CAAC,CAAC;IAC5B;MACE,MAAM,IAAInB,KAAK,CAAC,sBAAsB,GAAGjB,GAAG,CAACkC,MAAM,CAAC;EACxD;AACF,CAAC;AAED3C,OAAO,CAAC8C,GAAG,GAAG,SAASA,GAAGA,CAACC,CAAC,EAAE;EAC5B,OAAOjB,MAAM,CAACkB,IAAI,CAACD,CAAC,CAACE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE,KAAK,CAAC;AACjD,CAAC;AAEDjD,OAAO,CAACkD,GAAG,GAAG,SAASA,GAAGA,CAACH,CAAC,EAAE;EAC5BA,CAAC,GAAGA,CAAC,CAACE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;EACxB,IAAIE,KAAK,GAAG,CAAC;EACb,IAAIC,GAAG,GAAIL,CAAC,CAACJ,MAAM,GAAG,CAAC,IAAK,CAAC;EAC7B,MAAMU,MAAM,GAAG,EAAE;EACjB,OAAOD,GAAG,IAAIL,CAAC,CAACJ,MAAM,EAAE;IACtBU,MAAM,CAACC,IAAI,CAACC,QAAQ,CAACR,CAAC,CAACS,KAAK,CAACL,KAAK,EAAEC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;IAC7CD,KAAK,GAAGC,GAAG;IACXA,GAAG,IAAI,CAAC;EACV;EACA,OAAOtB,MAAM,CAACkB,IAAI,CAACK,MAAM,CAAC;AAC5B,CAAC;AAEDrD,OAAO,CAACyD,MAAM,GAAG,SAASA,MAAMA,CAACC,GAAG,GAAC,CAAC,CAAC,EAAE,GAAGC,IAAI,EAAE;EAChD,MAAMC,GAAG,GAAGD,IAAI,CAAChB,MAAM;EACvB,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,EAAEC,CAAC,EAAE,EAAE;IAC5B,MAAMC,CAAC,GAAGH,IAAI,CAACE,CAAC,CAAC;IACjB,KAAK,MAAME,CAAC,IAAID,CAAC,EAAE;MACjB,MAAME,CAAC,GAAGF,CAAC,CAACC,CAAC,CAAC;MACdL,GAAG,CAACK,CAAC,CAAC,GAAGC,CAAC;IACZ;EACF;EACA,OAAON,GAAG;AACZ,CAAC;AAED1D,OAAO,CAACiE,UAAU,GAAG,SAASA,UAAUA,CAACH,CAAC,EAAEI,CAAC,EAAE;EAC7C,IAAKJ,CAAC,IAAI,IAAI,IAAMI,CAAC,IAAI,IAAK,EAAE;IAC9B,OAAO,IAAI;EACb;EACA,IAAKJ,CAAC,IAAI,IAAI,IAAMI,CAAC,IAAI,IAAK,EAAE;IAC9B,OAAO,KAAK;EACd;EACA,OAAQJ,CAAC,CAACnB,MAAM,KAAKuB,CAAC,CAACvB,MAAM,IAAKmB,CAAC,CAACK,KAAK,CAAC,CAACC,IAAI,EAAEC,CAAC,KAAKD,IAAI,KAAKF,CAAC,CAACG,CAAC,CAAC,CAAC;AACvE,CAAC;AAEDrE,OAAO,CAACsE,WAAW,GAAG,SAASA,WAAWA,CAACR,CAAC,EAAEI,CAAC,EAAE;EAC/C,IAAKJ,CAAC,IAAI,IAAI,IAAMI,CAAC,IAAI,IAAK,EAAE;IAC9B,OAAO,IAAI;EACb;EACA,IAAKJ,CAAC,IAAI,IAAI,IAAMI,CAAC,IAAI,IAAK,EAAE;IAC9B,OAAO,KAAK;EACd;EACA,IAAI,EAAEpC,MAAM,CAACyC,QAAQ,CAACT,CAAC,CAAC,IAAIhC,MAAM,CAACyC,QAAQ,CAACL,CAAC,CAAC,IAAKJ,CAAC,CAACnB,MAAM,KAAKuB,CAAC,CAACvB,MAAO,CAAC,EAAE;IAC1E,OAAO,KAAK;EACd;EACA,MAAMiB,GAAG,GAAGE,CAAC,CAACnB,MAAM;EACpB,IAAI6B,GAAG,GAAG,IAAI;EACd,IAAIH,CAAC;EACL,IAAIR,CAAC;EACL,KAAKQ,CAAC,GAAGR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,EAAES,CAAC,GAAG,EAAER,CAAC,EAAE;IAChC,MAAMY,IAAI,GAAGX,CAAC,CAACO,CAAC,CAAC;IACjBG,GAAG,GAAGA,GAAG,IAAKN,CAAC,CAACG,CAAC,CAAC,KAAKI,IAAK;EAC9B;EACA,OAAO,CAAC,CAACD,GAAG;AACd,CAAC;AAEDxE,OAAO,CAAC0E,iBAAiB,GAAG,SAASA,iBAAiBA,CAACjE,GAAG,EAAE;EAC1D,OAAO,IAAIf,SAAS,CAACe,GAAG,CAACG,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC;AAC/C,CAAC;AAEDZ,OAAO,CAAC2E,cAAc,GAAG,SAASA,cAAcA,CAAClE,GAAG,EAAE;EACpD,OAAOP,MAAM,CAAC,IAAI,GAAGO,GAAG,CAACG,QAAQ,CAAC,KAAK,CAAC,CAAC;AAC3C,CAAC;AAEDZ,OAAO,CAAC4E,WAAW,GAAG,MAAMA,WAAW,SAASpF,MAAM,CAACqF,QAAQ,CAAC;EAC9DC,WAAWA,CAAChC,GAAG,EAAE;IACf,KAAK,CAAC,CAAC;IACPA,GAAG,GAAGA,GAAG,CAACG,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;IAC5B,IAAIH,GAAG,EAAE;MACP,IAAI,CAACQ,IAAI,CAACxB,MAAM,CAACkB,IAAI,CAACF,GAAG,EAAE,KAAK,CAAC,CAAC;IACpC;IACA,IAAI,CAACQ,IAAI,CAAC,IAAI,CAAC;EACjB;AACF,CAAC;AAEDtD,OAAO,CAAC+E,SAAS,GAAG,MAAMA,SAAS,SAASvF,MAAM,CAACwF,SAAS,CAAC;EAC3DF,WAAWA,CAACG,OAAO,EAAE;IACnB,KAAK,CAACA,OAAO,CAAC;EAChB;EAEAC,UAAUA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,EAAE,EAAE;IAC9B,IAAI,CAAC/B,IAAI,CAAC6B,KAAK,CAACvE,QAAQ,CAAC,KAAK,CAAC,CAAC;IAChC,OAAOyE,EAAE,CAAC,CAAC;EACb;AACF,CAAC;AAEDrF,OAAO,CAACsF,UAAU,GAAG,SAASA,UAAUA,CAACC,EAAE,EAAE;EAC3C,IAAIA,EAAE,IAAI,IAAI,EAAE;IACd,OAAOC,OAAO,CAACC,KAAK,CAACF,EAAE,CAAC;EAC1B;AACF,CAAC;AAEDvF,OAAO,CAAC0F,WAAW,GAAG,SAASA,WAAWA,CAACC,KAAK,EAAEC,UAAU,EAAEP,EAAE,EAAE;EAChE,MAAM/D,CAAC,GAAGqE,KAAK,CAACE,KAAK,CAAC,CAAC;EACvB,IAAI,CAACvE,CAAC,EAAE;IACN,OAAO+D,EAAE,CAAC,CAAC;EACb;EACA,MAAMS,EAAE,GAAGF,UAAU,CAAC,CAAC;EACvBE,EAAE,CAACC,EAAE,CAAC,KAAK,EAAE,MAAM/F,OAAO,CAAC0F,WAAW,CAACC,KAAK,EAAEC,UAAU,EAAEP,EAAE,CAAC,CAAC;EAC9DS,EAAE,CAACC,EAAE,CAAC,OAAO,EAAEV,EAAE,CAAC;EAClB,MAAMtC,CAAC,GAAIzB,CAAC,KAAK,GAAG,GAClB0E,OAAO,CAACC,KAAK,GAAI3E,CAAC,YAAY9B,MAAM,CAAC0G,MAAM,GAAI5E,CAAC,GAAGhC,EAAE,CAAC6G,gBAAgB,CAAC7E,CAAC,CAAC;EAC3EyB,CAAC,CAACgD,EAAE,CAAC,OAAO,EAAEV,EAAE,CAAC;EACjB,OAAOtC,CAAC,CAACqD,IAAI,CAACN,EAAE,CAAC;AACnB,CAAC;AAED9F,OAAO,CAACqG,aAAa,GAAG,SAASA,aAAaA,CAACC,KAAK,EAAE;EACpD,IAAI,OAAOA,KAAK,IAAI,QAAQ,EAAE;IAC5B,OAAO,KAAK;EACd,CAAC,MAAM,IAAIxE,MAAM,CAACyC,QAAQ,CAAC+B,KAAK,CAAC,EAAE;IACjC,OAAOC,SAAS;EAClB;EACA,MAAM,IAAI7E,KAAK,CAAC,oBAAoB,CAAC;AACvC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}