{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\nconst url = require('url');\nconst bignumber = require('bignumber.js').BigNumber;\nconst NoFilter = require('nofilter');\nconst Tagged = require('./tagged');\nconst Simple = require('./simple');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst MT = constants.MT;\nconst NUMBYTES = constants.NUMBYTES;\nconst SHIFT32 = constants.SHIFT32;\nconst SYMS = constants.SYMS;\nconst TAG = constants.TAG;\nconst HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;\nconst FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;\nconst DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;\nconst TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;\nconst FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;\nconst UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;\nconst NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;\nconst MAXINT_BN = new bignumber('0x20000000000000');\nconst BUF_NAN = Buffer.from('f97e00', 'hex');\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex');\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex');\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex');\nconst LOOP_DETECT = Symbol('CBOR_LOOP_DETECT');\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends {stream.Transform}\n */\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {Object} [options={}] - options for the encoder\n   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,\n   *   `function(Encoder)` for semantic types to be encoded.  Not needed\n   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.\n   * @param {boolean} [options.canonical=false] - should the output be\n   *   canonicalized\n   * @param {boolean|Symbol} [options.detectLoops=false] - should object loops\n   *   be detected?  This will currently modify the encoded object graph\n   *   by adding a Symbol property to each object.  If this bothers you,\n   *   call `removeLoopDetectors` on the encoded object when done.  Do not\n   *   encode the same object twice on the same encoder, without calling\n   *   `removeLoopDetectors` in between.\n   * @param {(\"number\"|\"float\"|\"int\"|\"string\")} [options.dateType=\"number\"] -\n   *   how should dates be encoded?  \"number\" means float or int, if no\n   *   fractional seconds.\n   * @param {any} [options.encodeUndefined=undefined] - How should an \n   *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n   *   undefined.  If this is a buffer, use those bytes without re-encoding\n   *   them.  If this is a function, the function will be called (which is\n   *   a good time to throw an exception, if that's what you want), and the \n   *   return value will be used according to these rules.  Anything\n   *   else will be encoded as CBOR.\n   * @param {boolean} [options.disallowUndefinedKeys=false] - Should \"undefined\"\n   *   be disallowed as a key in a Map that is serialized?  If this is true,\n   *   encode(new Map([[undefined, 1]])) will throw an exception.  Note that\n   *   it is impossible to get a key of undefined in a normal JS object.\n   */\n  constructor(options) {\n    const opts = Object.assign({}, options, {\n      readableObjectMode: false,\n      writableObjectMode: true\n    });\n    super(opts);\n    this.canonical = opts.canonical;\n    this.encodeUndefined = opts.encodeUndefined;\n    this.disallowUndefinedKeys = !!opts.disallowUndefinedKeys;\n    this.dateType = opts.dateType != null ? opts.dateType.toLowerCase() : 'number';\n\n    // new Symbol for each instance.  Note: means we can't re-use the same\n    // encoder and encoded object\n    if (typeof opts.detectLoops === 'symbol') {\n      this.detectLoops = opts.detectLoops;\n    } else {\n      this.detectLoops = !!opts.detectLoops ? Symbol('CBOR_DETECT') : null;\n    }\n    this.semanticTypes = [Array, this._pushArray, Date, this._pushDate, Buffer, this._pushBuffer, Map, this._pushMap, NoFilter, this._pushNoFilter, RegExp, this._pushRegexp, Set, this._pushSet, bignumber, this._pushBigNumber, ArrayBuffer, this._pushUint8Array, Uint8ClampedArray, this._pushUint8Array, Uint8Array, this._pushUint8Array, Uint16Array, this._pushArray, Uint32Array, this._pushArray, Int8Array, this._pushArray, Int16Array, this._pushArray, Int32Array, this._pushArray, Float32Array, this._pushFloat32Array, Float64Array, this._pushFloat64Array];\n\n    // tsc doesn't know about old Url\n    if (url['Url']) {\n      this.semanticTypes.push(url['Url'], this._pushUrl);\n    }\n    if (url['URL']) {\n      this.semanticTypes.push(url['URL'], this._pushURL);\n    }\n    const addTypes = opts.genTypes || [];\n    for (let i = 0, len = addTypes.length; i < len; i += 2) {\n      this.addSemanticType(addTypes[i], addTypes[i + 1]);\n    }\n  }\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh);\n    // Old transformers might not return bool.  undefined !== false\n    return cb(ret === false ? new Error('Push Error') : undefined);\n  }\n  _flush(cb) {\n    return cb();\n  }\n\n  /**\n   * @callback encodeFunction\n   * @param {Encoder} encoder - the encoder to serialize into.  Call \"write\"\n   *   on the encoder as needed.\n   * @return {bool} - true on success, else false\n   */\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This is\n   * useful for objects for which you can't add an encodeCBOR method\n   *\n   * @param {any} type\n   * @param {any} fun\n   * @returns {encodeFunction}\n   */\n  addSemanticType(type, fun) {\n    for (let i = 0, len = this.semanticTypes.length; i < len; i += 2) {\n      const typ = this.semanticTypes[i];\n      if (typ === type) {\n        const old = this.semanticTypes[i + 1];\n        this.semanticTypes[i + 1] = fun;\n        return old;\n      }\n    }\n    this.semanticTypes.push(type, fun);\n    return null;\n  }\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1);\n    b.writeUInt8(val, 0);\n    return this.push(b);\n  }\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2);\n    b.writeUInt16BE(val, 0);\n    return this.push(b);\n  }\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeUInt32BE(val, 0);\n    return this.push(b);\n  }\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeFloatBE(val, 0);\n    return this.push(b);\n  }\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8);\n    b.writeDoubleBE(val, 0);\n    return this.push(b);\n  }\n  _pushNaN() {\n    return this.push(BUF_NAN);\n  }\n  _pushInfinity(obj) {\n    const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;\n    return this.push(half);\n  }\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2);\n      if (utils.writeHalf(b2, obj)) {\n        if (utils.parseHalf(b2) === obj) {\n          return this._pushUInt8(HALF) && this.push(b2);\n        }\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);\n    }\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);\n  }\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5;\n    switch (false) {\n      case !(obj < 24):\n        return this._pushUInt8(m | obj);\n      case !(obj <= 0xff):\n        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);\n      case !(obj <= 0xffff):\n        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);\n      case !(obj <= 0xffffffff):\n        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);\n      case !(obj <= Number.MAX_SAFE_INTEGER):\n        return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);\n      default:\n        if (mt === MT.NEG_INT) {\n          return this._pushFloat(orig);\n        } else {\n          return this._pushFloat(obj);\n        }\n    }\n  }\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO);\n    }\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj);\n    } else {\n      return this._pushInt(obj, MT.POS_INT);\n    }\n  }\n  _pushNumber(obj) {\n    switch (false) {\n      case !isNaN(obj):\n        return this._pushNaN();\n      case isFinite(obj):\n        return this._pushInfinity(obj);\n      case Math.round(obj) !== obj:\n        return this._pushIntNum(obj);\n      default:\n        return this._pushFloat(obj);\n    }\n  }\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8');\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');\n  }\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE);\n  }\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED);\n      case 'function':\n        return this.pushAny(this.encodeUndefined.call(this, obj));\n      case 'object':\n        if (Buffer.isBuffer(this.encodeUndefined)) {\n          return this.push(this.encodeUndefined);\n        }\n    }\n    return this.pushAny(this.encodeUndefined);\n  }\n  _pushNull(obj) {\n    return this._pushUInt8(NULL);\n  }\n  _pushArray(gen, obj) {\n    const len = obj.length;\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG);\n  }\n  _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) && gen._pushString(obj.toISOString());\n      case 'int':\n      case 'integer':\n        return gen._pushTag(TAG.DATE_EPOCH) && gen._pushIntNum(Math.round(obj / 1000));\n      case 'float':\n        // force float\n        return gen._pushTag(TAG.DATE_EPOCH) && gen._pushFloat(obj / 1000);\n      case 'number':\n      default:\n        // if we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj / 1000);\n    }\n  }\n  _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);\n  }\n  _pushNoFilter(gen, obj) {\n    return gen._pushBuffer(gen, obj.slice());\n  }\n  _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);\n  }\n  _pushSet(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false;\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _pushUrl(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());\n  }\n  _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());\n  }\n\n  /**\n   * @param {bignumber} obj\n   * @private\n   */\n  _pushBigint(obj) {\n    let tag = TAG.POS_BIGINT;\n    if (obj.isNegative()) {\n      obj = obj.negated().minus(1);\n      tag = TAG.NEG_BIGINT;\n    }\n    let str = obj.toString(16);\n    if (str.length % 2) {\n      str = '0' + str;\n    }\n    const buf = Buffer.from(str, 'hex');\n    return this._pushTag(tag) && this._pushBuffer(this, buf);\n  }\n\n  /**\n   * @param {bigint} obj\n   * @private\n   */\n  _pushJSBigint(obj) {\n    let tag = TAG.POS_BIGINT;\n    if (obj < 0) {\n      obj = -obj + BigInt('-1'); // avoid syntax error on old runtimes\n      tag = TAG.NEG_BIGINT;\n    }\n    let str = obj.toString(16);\n    if (str.length % 2) {\n      str = '0' + str;\n    }\n    const buf = Buffer.from(str, 'hex');\n    return this._pushTag(tag) && this._pushBuffer(this, buf);\n  }\n  _pushBigNumber(gen, obj) {\n    if (obj.isNaN()) {\n      return gen._pushNaN();\n    }\n    if (!obj.isFinite()) {\n      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);\n    }\n    if (obj.isInteger()) {\n      return gen._pushBigint(obj);\n    }\n    if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {\n      return false;\n    }\n    const dec = obj.decimalPlaces();\n    const slide = obj.times(new bignumber(10).pow(dec));\n    if (!gen._pushIntNum(-dec)) {\n      return false;\n    }\n    if (slide.abs().isLessThan(MAXINT_BN)) {\n      return gen._pushIntNum(slide.toNumber());\n    } else {\n      return gen._pushBigint(slide);\n    }\n  }\n  _pushMap(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.MAP)) {\n      return false;\n    }\n    // memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const entries = [...obj.entries()];\n      const enc = new Encoder(this); // TODO: fix genTypes\n      const bs = new NoFilter({\n        highWaterMark: this.readableHighWaterMark\n      });\n      enc.pipe(bs);\n      entries.sort(([a], [b]) => {\n        // a, b are the keys\n        enc.pushAny(a);\n        const a_cbor = bs.read();\n        enc.pushAny(b);\n        const b_cbor = bs.read();\n        return a_cbor.compare(b_cbor);\n      });\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n          throw new Error('Invalid Map key: undefined');\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    } else {\n      for (const [k, v] of obj) {\n        if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n          throw new Error('Invalid Map key: undefined');\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  _pushUint8Array(gen, obj) {\n    return gen._pushBuffer(gen, Buffer.from(obj));\n  }\n  _pushFloat32Array(gen, obj) {\n    const len = obj.length;\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _pushFloat64Array(gen, obj) {\n    const len = obj.length;\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  removeLoopDetectors(obj) {\n    if (!this.detectLoops || typeof obj !== 'object' || !obj) {\n      return false;\n    }\n    const dl = obj[LOOP_DETECT];\n    if (!dl || dl !== this.detectLoops) {\n      // ironically, use loop marking to detect loops on removal as well\n      return false;\n    }\n    delete obj[LOOP_DETECT];\n    if (Array.isArray(obj)) {\n      for (const i of obj) {\n        this.removeLoopDetectors(i);\n      }\n    } else {\n      for (const k in obj) {\n        this.removeLoopDetectors(obj[k]);\n      }\n    }\n    return true;\n  }\n  _pushObject(obj) {\n    if (!obj) {\n      return this._pushNull(obj);\n    }\n    if (this.detectLoops) {\n      if (obj[LOOP_DETECT] === this.detectLoops) {\n        throw new Error('Loop detected while CBOR encoding');\n      } else {\n        obj[LOOP_DETECT] = this.detectLoops;\n      }\n    }\n    const f = obj.encodeCBOR;\n    if (typeof f === 'function') {\n      return f.call(obj, this);\n    }\n    for (let i = 0, len1 = this.semanticTypes.length; i < len1; i += 2) {\n      const typ = this.semanticTypes[i];\n      if (obj instanceof typ) {\n        return this.semanticTypes[i + 1].call(obj, this, obj);\n      }\n    }\n    const keys = Object.keys(obj);\n    const cbor_keys = {};\n    if (this.canonical) {\n      // note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));\n        return a_cbor.compare(b_cbor);\n      });\n    }\n    if (!this._pushInt(keys.length, MT.MAP)) {\n      return false;\n    }\n    let ck;\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j];\n      if (this.canonical && (ck = cbor_keys[k])) {\n        if (!this.push(ck)) {\n          // already a Buffer\n          return false;\n        }\n      } else {\n        if (!this._pushString(k)) {\n          return false;\n        }\n      }\n      if (!this.pushAny(obj[k])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Push any supported type onto the encoded stream\n   *\n   * @param {any} obj\n   * @returns {boolean} true on success\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj);\n      case 'bigint':\n        return this._pushJSBigint(obj);\n      case 'string':\n        return this._pushString(obj);\n      case 'boolean':\n        return this._pushBoolean(obj);\n      case 'undefined':\n        return this._pushUndefined(obj);\n      case 'object':\n        return this._pushObject(obj);\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null);\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(void 0);\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new Error('Unknown symbol: ' + obj.toString());\n        }\n      default:\n        throw new Error('Unknown type: ' + typeof obj + ', ' + (!!obj ? obj.toString() : ''));\n    }\n  }\n\n  /* backwards-compat wrapper */\n  _pushAny(obj) {\n    // TODO: write deprecation warning\n    return this.pushAny(obj);\n  }\n  _encodeAll(objs) {\n    const bs = new NoFilter({\n      highWaterMark: this.readableHighWaterMark\n    });\n    this.pipe(bs);\n    for (const o of objs) {\n      this.pushAny(o);\n    }\n    this.end();\n    return bs.read();\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs);\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({\n      canonical: true\n    })._encodeAll(objs);\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @static\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   * @returns {Buffer} - the encoded objects\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj]);\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this \n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = [];\n      const enc = new Encoder(options);\n      enc.on('data', buf => bufs.push(buf));\n      enc.on('error', reject);\n      enc.on('finish', () => resolve(Buffer.concat(bufs)));\n      enc.pushAny(obj);\n      enc.end();\n    });\n  }\n}\nmodule.exports = Encoder;","map":{"version":3,"names":["stream","require","url","bignumber","BigNumber","NoFilter","Tagged","Simple","utils","constants","MT","NUMBYTES","SHIFT32","SYMS","TAG","HALF","SIMPLE_FLOAT","TWO","FLOAT","FOUR","DOUBLE","EIGHT","TRUE","SIMPLE","FALSE","UNDEFINED","NULL","MAXINT_BN","BUF_NAN","Buffer","from","BUF_INF_NEG","BUF_INF_POS","BUF_NEG_ZERO","LOOP_DETECT","Symbol","Encoder","Transform","constructor","options","opts","Object","assign","readableObjectMode","writableObjectMode","canonical","encodeUndefined","disallowUndefinedKeys","dateType","toLowerCase","detectLoops","semanticTypes","Array","_pushArray","Date","_pushDate","_pushBuffer","Map","_pushMap","_pushNoFilter","RegExp","_pushRegexp","Set","_pushSet","_pushBigNumber","ArrayBuffer","_pushUint8Array","Uint8ClampedArray","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","_pushFloat32Array","Float64Array","_pushFloat64Array","push","_pushUrl","_pushURL","addTypes","genTypes","i","len","length","addSemanticType","_transform","fresh","encoding","cb","ret","pushAny","Error","undefined","_flush","type","fun","typ","old","_pushUInt8","val","b","allocUnsafe","writeUInt8","_pushUInt16BE","writeUInt16BE","_pushUInt32BE","writeUInt32BE","_pushFloatBE","writeFloatBE","_pushDoubleBE","writeDoubleBE","_pushNaN","_pushInfinity","obj","half","_pushFloat","b2","writeHalf","parseHalf","Math","fround","_pushInt","mt","orig","m","ONE","Number","MAX_SAFE_INTEGER","floor","NEG_INT","_pushIntNum","is","POS_INT","_pushNumber","isNaN","isFinite","round","_pushString","byteLength","UTF8_STRING","_pushBoolean","_pushUndefined","call","isBuffer","_pushNull","gen","ARRAY","j","_pushTag","tag","DATE_STRING","toISOString","DATE_EPOCH","BYTE_STRING","slice","REGEXP","source","size","x","URI","format","toString","_pushBigint","POS_BIGINT","isNegative","negated","minus","NEG_BIGINT","str","buf","_pushJSBigint","BigInt","Infinity","isInteger","DECIMAL_FRAC","dec","decimalPlaces","slide","times","pow","abs","isLessThan","toNumber","MAP","entries","enc","bs","highWaterMark","readableHighWaterMark","pipe","sort","a","a_cbor","read","b_cbor","compare","k","v","removeLoopDetectors","dl","isArray","_pushObject","f","encodeCBOR","len1","keys","cbor_keys","encode","ck","len2","_pushAny","_encodeAll","objs","o","end","encodeCanonical","encodeOne","encodeAsync","Promise","resolve","reject","bufs","on","concat","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/cbor/lib/encoder.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst url = require('url')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\nconst Tagged = require('./tagged')\nconst Simple = require('./simple')\nconst utils = require('./utils')\n\nconst constants = require('./constants')\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SHIFT32 = constants.SHIFT32\nconst SYMS = constants.SYMS\nconst TAG = constants.TAG\nconst HALF = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.TWO\nconst FLOAT = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.FOUR\nconst DOUBLE = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.EIGHT\nconst TRUE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.TRUE\nconst FALSE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.FALSE\nconst UNDEFINED = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.UNDEFINED\nconst NULL = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.NULL\n\nconst MAXINT_BN = new bignumber('0x20000000000000')\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex')\nconst LOOP_DETECT = Symbol('CBOR_LOOP_DETECT')\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends {stream.Transform}\n */\nclass Encoder extends stream.Transform {\n\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {Object} [options={}] - options for the encoder\n   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,\n   *   `function(Encoder)` for semantic types to be encoded.  Not needed\n   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.\n   * @param {boolean} [options.canonical=false] - should the output be\n   *   canonicalized\n   * @param {boolean|Symbol} [options.detectLoops=false] - should object loops\n   *   be detected?  This will currently modify the encoded object graph\n   *   by adding a Symbol property to each object.  If this bothers you,\n   *   call `removeLoopDetectors` on the encoded object when done.  Do not\n   *   encode the same object twice on the same encoder, without calling\n   *   `removeLoopDetectors` in between.\n   * @param {(\"number\"|\"float\"|\"int\"|\"string\")} [options.dateType=\"number\"] -\n   *   how should dates be encoded?  \"number\" means float or int, if no\n   *   fractional seconds.\n   * @param {any} [options.encodeUndefined=undefined] - How should an \n   *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n   *   undefined.  If this is a buffer, use those bytes without re-encoding\n   *   them.  If this is a function, the function will be called (which is\n   *   a good time to throw an exception, if that's what you want), and the \n   *   return value will be used according to these rules.  Anything\n   *   else will be encoded as CBOR.\n   * @param {boolean} [options.disallowUndefinedKeys=false] - Should \"undefined\"\n   *   be disallowed as a key in a Map that is serialized?  If this is true,\n   *   encode(new Map([[undefined, 1]])) will throw an exception.  Note that\n   *   it is impossible to get a key of undefined in a normal JS object.\n   */\n  constructor(options) {\n    const opts = Object.assign({}, options, {\n      readableObjectMode: false,\n      writableObjectMode: true\n    })\n    super(opts)\n\n    this.canonical = opts.canonical\n    this.encodeUndefined = opts.encodeUndefined\n    this.disallowUndefinedKeys = !!opts.disallowUndefinedKeys\n    this.dateType = (opts.dateType != null) ?\n      opts.dateType.toLowerCase() : 'number'\n\n    // new Symbol for each instance.  Note: means we can't re-use the same\n    // encoder and encoded object\n    if (typeof(opts.detectLoops) === 'symbol') {\n      this.detectLoops = opts.detectLoops\n    } else {\n      this.detectLoops = !!opts.detectLoops ? Symbol('CBOR_DETECT') : null\n    }\n\n    this.semanticTypes = [\n      Array, this._pushArray,\n      Date, this._pushDate,\n      Buffer, this._pushBuffer,\n      Map, this._pushMap,\n      NoFilter, this._pushNoFilter,\n      RegExp, this._pushRegexp,\n      Set, this._pushSet,\n      bignumber, this._pushBigNumber,\n      ArrayBuffer, this._pushUint8Array,\n      Uint8ClampedArray, this._pushUint8Array,\n      Uint8Array, this._pushUint8Array,\n      Uint16Array, this._pushArray,\n      Uint32Array, this._pushArray,\n      Int8Array, this._pushArray,\n      Int16Array, this._pushArray,\n      Int32Array, this._pushArray,\n      Float32Array, this._pushFloat32Array,\n      Float64Array, this._pushFloat64Array\n    ]\n\n    // tsc doesn't know about old Url\n    if (url['Url']) {\n      this.semanticTypes.push(url['Url'], this._pushUrl)\n    }\n    if (url['URL']) {\n      this.semanticTypes.push(url['URL'], this._pushURL)\n    }\n\n    const addTypes = opts.genTypes || []\n    for (let i = 0, len = addTypes.length; i < len; i += 2) {\n      this.addSemanticType(addTypes[i], addTypes[i + 1])\n    }\n  }\n\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh)\n    // Old transformers might not return bool.  undefined !== false\n    return cb((ret === false) ? new Error('Push Error') : undefined)\n  }\n\n  _flush(cb) {\n    return cb()\n  }\n\n  /**\n   * @callback encodeFunction\n   * @param {Encoder} encoder - the encoder to serialize into.  Call \"write\"\n   *   on the encoder as needed.\n   * @return {bool} - true on success, else false\n   */\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This is\n   * useful for objects for which you can't add an encodeCBOR method\n   *\n   * @param {any} type\n   * @param {any} fun\n   * @returns {encodeFunction}\n   */\n  addSemanticType(type, fun) {\n    for (let i = 0, len = this.semanticTypes.length; i < len; i += 2) {\n      const typ = this.semanticTypes[i]\n      if (typ === type) {\n        const old = this.semanticTypes[i + 1]\n        this.semanticTypes[i + 1] = fun\n        return old\n      }\n    }\n    this.semanticTypes.push(type, fun)\n    return null\n  }\n\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1)\n    b.writeUInt8(val, 0)\n    return this.push(b)\n  }\n\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2)\n    b.writeUInt16BE(val, 0)\n    return this.push(b)\n  }\n\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeUInt32BE(val, 0)\n    return this.push(b)\n  }\n\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeFloatBE(val, 0)\n    return this.push(b)\n  }\n\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8)\n    b.writeDoubleBE(val, 0)\n    return this.push(b)\n  }\n\n  _pushNaN() {\n    return this.push(BUF_NAN)\n  }\n\n  _pushInfinity(obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2)\n      if (utils.writeHalf(b2, obj)) {\n        if (utils.parseHalf(b2) === obj) {\n          return this._pushUInt8(HALF) && this.push(b2)\n        }\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5\n    switch (false) {\n      case !(obj < 24):\n        return this._pushUInt8(m | obj)\n      case !(obj <= 0xff):\n        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n      case !(obj <= 0xffff):\n        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n      case !(obj <= 0xffffffff):\n        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n      case !(obj <= Number.MAX_SAFE_INTEGER):\n        return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n          this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n          this._pushUInt32BE(obj % SHIFT32)\n      default:\n        if (mt === MT.NEG_INT) {\n          return this._pushFloat(orig)\n        } else {\n          return this._pushFloat(obj)\n        }\n    }\n  }\n\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO)\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    } else {\n      return this._pushInt(obj, MT.POS_INT)\n    }\n  }\n\n  _pushNumber(obj) {\n    switch (false) {\n      case !isNaN(obj):\n        return this._pushNaN()\n      case isFinite(obj):\n        return this._pushInfinity(obj)\n      case Math.round(obj) !== obj:\n        return this._pushIntNum(obj)\n      default:\n        return this._pushFloat(obj)\n    }\n  }\n\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8')\n  }\n\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED)\n      case 'function':\n        return this.pushAny(this.encodeUndefined.call(this, obj))\n      case 'object':\n        if (Buffer.isBuffer(this.encodeUndefined)) {\n          return this.push(this.encodeUndefined)\n        }\n    }\n    return this.pushAny(this.encodeUndefined)\n  }\n\n  _pushNull(obj) {\n    return this._pushUInt8(NULL)\n  }\n\n  _pushArray(gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) &&\n          gen._pushString(obj.toISOString())\n      case 'int':\n      case 'integer':\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushIntNum(Math.round(obj / 1000))\n      case 'float':\n        // force float\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushFloat(obj / 1000)\n      case 'number':\n      default:\n        // if we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen.pushAny(obj / 1000)\n    }\n  }\n\n  _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  _pushNoFilter(gen, obj) {\n    return gen._pushBuffer(gen, obj.slice())\n  }\n\n  _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  _pushSet(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushUrl(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format())\n  }\n\n  _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString())\n  }\n\n  /**\n   * @param {bignumber} obj\n   * @private\n   */\n  _pushBigint(obj) {\n    let tag = TAG.POS_BIGINT\n    if (obj.isNegative()) {\n      obj = obj.negated().minus(1)\n      tag = TAG.NEG_BIGINT\n    }\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && this._pushBuffer(this, buf)\n  }\n\n  /**\n   * @param {bigint} obj\n   * @private\n   */\n  _pushJSBigint(obj) {\n    let tag = TAG.POS_BIGINT\n    if (obj < 0) {\n      obj = -obj + BigInt('-1') // avoid syntax error on old runtimes\n      tag = TAG.NEG_BIGINT\n    }\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && this._pushBuffer(this, buf)\n  }\n\n  _pushBigNumber(gen, obj) {\n    if (obj.isNaN()) {\n      return gen._pushNaN()\n    }\n    if (!obj.isFinite()) {\n      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity)\n    }\n    if (obj.isInteger()) {\n      return gen._pushBigint(obj)\n    }\n    if (!(gen._pushTag(TAG.DECIMAL_FRAC) &&\n      gen._pushInt(2, MT.ARRAY))) {\n      return false\n    }\n\n    const dec = obj.decimalPlaces()\n    const slide = obj.times(new bignumber(10).pow(dec))\n    if (!gen._pushIntNum(-dec)) {\n      return false\n    }\n    if (slide.abs().isLessThan(MAXINT_BN)) {\n      return gen._pushIntNum(slide.toNumber())\n    } else {\n      return gen._pushBigint(slide)\n    }\n  }\n\n  _pushMap(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.MAP)) {\n      return false\n    }\n    // memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const entries = [...obj.entries()]\n      const enc = new Encoder(this) // TODO: fix genTypes\n      const bs = new NoFilter({highWaterMark:this.readableHighWaterMark})\n      enc.pipe(bs)\n      entries.sort(([a], [b]) => {\n        // a, b are the keys\n        enc.pushAny(a)\n        const a_cbor = bs.read()\n        enc.pushAny(b)\n        const b_cbor = bs.read()\n        return a_cbor.compare(b_cbor)\n      })\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    } else {\n      for (const [k, v] of obj) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  _pushUint8Array(gen, obj) {\n    return gen._pushBuffer(gen, Buffer.from(obj))\n  }\n\n  _pushFloat32Array(gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushFloat64Array(gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  removeLoopDetectors(obj) {\n    if (!this.detectLoops || (typeof(obj) !== 'object') || !obj) {\n      return false\n    }\n    const dl = obj[LOOP_DETECT]\n    if (!dl || (dl !== this.detectLoops)) {\n      // ironically, use loop marking to detect loops on removal as well\n      return false\n    }\n    delete obj[LOOP_DETECT]\n    if (Array.isArray(obj)) {\n      for (const i of obj) {\n        this.removeLoopDetectors(i)\n      }\n    } else {\n      for (const k in obj) {\n        this.removeLoopDetectors(obj[k])\n      }\n    }\n    return true\n  }\n\n  _pushObject(obj) {\n    if (!obj) {\n      return this._pushNull(obj)\n    }\n    if (this.detectLoops) {\n      if (obj[LOOP_DETECT] === this.detectLoops) {\n        throw new Error('Loop detected while CBOR encoding')\n      } else {\n        obj[LOOP_DETECT] = this.detectLoops\n      }\n    }\n    const f = obj.encodeCBOR\n    if (typeof f === 'function') {\n      return f.call(obj, this)\n    }\n    for (let i = 0, len1 = this.semanticTypes.length; i < len1; i += 2) {\n      const typ = this.semanticTypes[i]\n      if (obj instanceof typ) {\n        return this.semanticTypes[i + 1].call(obj, this, obj)\n      }\n    }\n    const keys = Object.keys(obj)\n    const cbor_keys = {}\n    if (this.canonical) {\n      // note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a))\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b))\n\n        return a_cbor.compare(b_cbor)\n      })\n    }\n    if (!this._pushInt(keys.length, MT.MAP)) {\n      return false\n    }\n    let ck\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j]\n      if (this.canonical && ((ck = cbor_keys[k]))) {\n        if (!this.push(ck)) { // already a Buffer\n          return false\n        }\n      } else {\n        if (!this._pushString(k)) {\n          return false\n        }\n      }\n      if (!this.pushAny(obj[k])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Push any supported type onto the encoded stream\n   *\n   * @param {any} obj\n   * @returns {boolean} true on success\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj)\n      case 'bigint':\n        return this._pushJSBigint(obj)\n      case 'string':\n        return this._pushString(obj)\n      case 'boolean':\n        return this._pushBoolean(obj)\n      case 'undefined':\n        return this._pushUndefined(obj)\n      case 'object':\n        return this._pushObject(obj)\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(void 0)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new Error('Unknown symbol: ' + obj.toString())\n        }\n      default:\n        throw new Error(\n          'Unknown type: ' + typeof obj + ', ' +\n          (!!obj ? obj.toString() : ''))\n    }\n  }\n\n  /* backwards-compat wrapper */\n  _pushAny(obj) {\n    // TODO: write deprecation warning\n    return this.pushAny(obj)\n  }\n\n  _encodeAll(objs) {\n    const bs = new NoFilter({ highWaterMark:this.readableHighWaterMark })\n    this.pipe(bs)\n    for (const o of objs) {\n      this.pushAny(o)\n    }\n    this.end()\n    return bs.read()\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs)\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({canonical: true})._encodeAll(objs)\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @static\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   * @returns {Buffer} - the encoded objects\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj])\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this \n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = []\n      const enc = new Encoder(options)\n      enc.on('data', buf => bufs.push(buf))\n      enc.on('error', reject)\n      enc.on('finish', () => resolve(Buffer.concat(bufs)))\n      enc.pushAny(obj)\n      enc.end()\n    })\n  }\n}\n\nmodule.exports = Encoder\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}