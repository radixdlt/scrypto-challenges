{"ast":null,"code":"/**\n * Javascript implementation of PKCS#1 PSS signature padding.\n *\n * @author Stefan Siegl\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n */\nvar forge = require('./forge');\nrequire('./random');\nrequire('./util');\n\n// shortcut for PSS API\nvar pss = module.exports = forge.pss = forge.pss || {};\n\n/**\n * Creates a PSS signature scheme object.\n *\n * There are several ways to provide a salt for encoding:\n *\n * 1. Specify the saltLength only and the built-in PRNG will generate it.\n * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that\n *   will be used.\n * 3. Specify the salt itself as a forge.util.ByteBuffer.\n *\n * @param options the options to use:\n *          md the message digest object to use, a forge md instance.\n *          mgf the mask generation function to use, a forge mgf instance.\n *          [saltLength] the length of the salt in octets.\n *          [prng] the pseudo-random number generator to use to produce a salt.\n *          [salt] the salt to use when encoding.\n *\n * @return a signature scheme object.\n */\npss.create = function (options) {\n  // backwards compatibility w/legacy args: hash, mgf, sLen\n  if (arguments.length === 3) {\n    options = {\n      md: arguments[0],\n      mgf: arguments[1],\n      saltLength: arguments[2]\n    };\n  }\n  var hash = options.md;\n  var mgf = options.mgf;\n  var hLen = hash.digestLength;\n  var salt_ = options.salt || null;\n  if (typeof salt_ === 'string') {\n    // assume binary-encoded string\n    salt_ = forge.util.createBuffer(salt_);\n  }\n  var sLen;\n  if ('saltLength' in options) {\n    sLen = options.saltLength;\n  } else if (salt_ !== null) {\n    sLen = salt_.length();\n  } else {\n    throw new Error('Salt length not specified or specific salt not given.');\n  }\n  if (salt_ !== null && salt_.length() !== sLen) {\n    throw new Error('Given salt length does not match length of given salt.');\n  }\n  var prng = options.prng || forge.random;\n  var pssobj = {};\n\n  /**\n   * Encodes a PSS signature.\n   *\n   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.\n   *\n   * @param md the message digest object with the hash to sign.\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return the encoded message as a binary-encoded string of length\n   *           ceil((modBits - 1) / 8).\n   */\n  pssobj.encode = function (md, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n\n    /* 2. Let mHash = Hash(M), an octet string of length hLen. */\n    var mHash = md.digest().getBytes();\n\n    /* 3. If emLen < hLen + sLen + 2, output \"encoding error\" and stop. */\n    if (emLen < hLen + sLen + 2) {\n      throw new Error('Message is too long to encrypt.');\n    }\n\n    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,\n     *    then salt is the empty string. */\n    var salt;\n    if (salt_ === null) {\n      salt = prng.getBytesSync(sLen);\n    } else {\n      salt = salt_.bytes();\n    }\n\n    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n\n    /* 6. Let H = Hash(M'), an octet string of length hLen. */\n    hash.start();\n    hash.update(m_.getBytes());\n    var h = hash.digest().getBytes();\n\n    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2\n     *    zero octets.  The length of PS may be 0. */\n    var ps = new forge.util.ByteBuffer();\n    ps.fillWithByte(0, emLen - sLen - hLen - 2);\n\n    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length\n     *    emLen - hLen - 1. */\n    ps.putByte(0x01);\n    ps.putBytes(salt);\n    var db = ps.getBytes();\n\n    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */\n    var maskLen = emLen - hLen - 1;\n    var dbMask = mgf.generate(h, maskLen);\n\n    /* 10. Let maskedDB = DB \\xor dbMask. */\n    var maskedDB = '';\n    for (i = 0; i < maskLen; i++) {\n      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n\n    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in\n     *     maskedDB to zero. */\n    var mask = 0xFF00 >> 8 * emLen - emBits & 0xFF;\n    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);\n\n    /* 12. Let EM = maskedDB || H || 0xbc.\n     * 13. Output EM. */\n    return maskedDB + h + String.fromCharCode(0xbc);\n  };\n\n  /**\n   * Verifies a PSS signature.\n   *\n   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.\n   *\n   * @param mHash the message digest hash, as a binary-encoded string, to\n   *         compare against the signature.\n   * @param em the encoded message, as a binary-encoded string\n   *          (RSA decryption result).\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return true if the signature was verified, false if not.\n   */\n  pssobj.verify = function (mHash, em, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n\n    /* c. Convert the message representative m to an encoded message EM\n     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits\n     *    is the length in bits of the RSA modulus n */\n    em = em.substr(-emLen);\n\n    /* 3. If emLen < hLen + sLen + 2, output \"inconsistent\" and stop. */\n    if (emLen < hLen + sLen + 2) {\n      throw new Error('Inconsistent parameters to PSS signature verification.');\n    }\n\n    /* 4. If the rightmost octet of EM does not have hexadecimal value\n     *    0xbc, output \"inconsistent\" and stop. */\n    if (em.charCodeAt(emLen - 1) !== 0xbc) {\n      throw new Error('Encoded message does not end in 0xBC.');\n    }\n\n    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\n     *    let H be the next hLen octets. */\n    var maskLen = emLen - hLen - 1;\n    var maskedDB = em.substr(0, maskLen);\n    var h = em.substr(maskLen, hLen);\n\n    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in\n     *    maskedDB are not all equal to zero, output \"inconsistent\" and stop. */\n    var mask = 0xFF00 >> 8 * emLen - emBits & 0xFF;\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n      throw new Error('Bits beyond keysize not zero as expected.');\n    }\n\n    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */\n    var dbMask = mgf.generate(h, maskLen);\n\n    /* 8. Let DB = maskedDB \\xor dbMask. */\n    var db = '';\n    for (i = 0; i < maskLen; i++) {\n      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n\n    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet\n     * in DB to zero. */\n    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);\n\n    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\n     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost\n     * position is \"position 1\") does not have hexadecimal value 0x01,\n     * output \"inconsistent\" and stop. */\n    var checkLen = emLen - hLen - sLen - 2;\n    for (i = 0; i < checkLen; i++) {\n      if (db.charCodeAt(i) !== 0x00) {\n        throw new Error('Leftmost octets not zero as expected');\n      }\n    }\n    if (db.charCodeAt(checkLen) !== 0x01) {\n      throw new Error('Inconsistent PSS signature, 0x01 marker not found');\n    }\n\n    /* 11. Let salt be the last sLen octets of DB. */\n    var salt = db.substr(-sLen);\n\n    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n\n    /* 13. Let H' = Hash(M'), an octet string of length hLen. */\n    hash.start();\n    hash.update(m_.getBytes());\n    var h_ = hash.digest().getBytes();\n\n    /* 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\" */\n    return h === h_;\n  };\n  return pssobj;\n};","map":{"version":3,"names":["forge","require","pss","module","exports","create","options","arguments","length","md","mgf","saltLength","hash","hLen","digestLength","salt_","salt","util","createBuffer","sLen","Error","prng","random","pssobj","encode","modBits","i","emBits","emLen","Math","ceil","mHash","digest","getBytes","getBytesSync","bytes","m_","ByteBuffer","fillWithByte","putBytes","start","update","h","ps","putByte","db","maskLen","dbMask","generate","maskedDB","String","fromCharCode","charCodeAt","mask","substr","verify","em","checkLen","h_"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/node-forge/lib/pss.js"],"sourcesContent":["/**\n * Javascript implementation of PKCS#1 PSS signature padding.\n *\n * @author Stefan Siegl\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n */\nvar forge = require('./forge');\nrequire('./random');\nrequire('./util');\n\n// shortcut for PSS API\nvar pss = module.exports = forge.pss = forge.pss || {};\n\n/**\n * Creates a PSS signature scheme object.\n *\n * There are several ways to provide a salt for encoding:\n *\n * 1. Specify the saltLength only and the built-in PRNG will generate it.\n * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that\n *   will be used.\n * 3. Specify the salt itself as a forge.util.ByteBuffer.\n *\n * @param options the options to use:\n *          md the message digest object to use, a forge md instance.\n *          mgf the mask generation function to use, a forge mgf instance.\n *          [saltLength] the length of the salt in octets.\n *          [prng] the pseudo-random number generator to use to produce a salt.\n *          [salt] the salt to use when encoding.\n *\n * @return a signature scheme object.\n */\npss.create = function(options) {\n  // backwards compatibility w/legacy args: hash, mgf, sLen\n  if(arguments.length === 3) {\n    options = {\n      md: arguments[0],\n      mgf: arguments[1],\n      saltLength: arguments[2]\n    };\n  }\n\n  var hash = options.md;\n  var mgf = options.mgf;\n  var hLen = hash.digestLength;\n\n  var salt_ = options.salt || null;\n  if(typeof salt_ === 'string') {\n    // assume binary-encoded string\n    salt_ = forge.util.createBuffer(salt_);\n  }\n\n  var sLen;\n  if('saltLength' in options) {\n    sLen = options.saltLength;\n  } else if(salt_ !== null) {\n    sLen = salt_.length();\n  } else {\n    throw new Error('Salt length not specified or specific salt not given.');\n  }\n\n  if(salt_ !== null && salt_.length() !== sLen) {\n    throw new Error('Given salt length does not match length of given salt.');\n  }\n\n  var prng = options.prng || forge.random;\n\n  var pssobj = {};\n\n  /**\n   * Encodes a PSS signature.\n   *\n   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.\n   *\n   * @param md the message digest object with the hash to sign.\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return the encoded message as a binary-encoded string of length\n   *           ceil((modBits - 1) / 8).\n   */\n  pssobj.encode = function(md, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n\n    /* 2. Let mHash = Hash(M), an octet string of length hLen. */\n    var mHash = md.digest().getBytes();\n\n    /* 3. If emLen < hLen + sLen + 2, output \"encoding error\" and stop. */\n    if(emLen < hLen + sLen + 2) {\n      throw new Error('Message is too long to encrypt.');\n    }\n\n    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,\n     *    then salt is the empty string. */\n    var salt;\n    if(salt_ === null) {\n      salt = prng.getBytesSync(sLen);\n    } else {\n      salt = salt_.bytes();\n    }\n\n    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n\n    /* 6. Let H = Hash(M'), an octet string of length hLen. */\n    hash.start();\n    hash.update(m_.getBytes());\n    var h = hash.digest().getBytes();\n\n    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2\n     *    zero octets.  The length of PS may be 0. */\n    var ps = new forge.util.ByteBuffer();\n    ps.fillWithByte(0, emLen - sLen - hLen - 2);\n\n    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length\n     *    emLen - hLen - 1. */\n    ps.putByte(0x01);\n    ps.putBytes(salt);\n    var db = ps.getBytes();\n\n    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */\n    var maskLen = emLen - hLen - 1;\n    var dbMask = mgf.generate(h, maskLen);\n\n    /* 10. Let maskedDB = DB \\xor dbMask. */\n    var maskedDB = '';\n    for(i = 0; i < maskLen; i++) {\n      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n\n    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in\n     *     maskedDB to zero. */\n    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\n    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) +\n      maskedDB.substr(1);\n\n    /* 12. Let EM = maskedDB || H || 0xbc.\n     * 13. Output EM. */\n    return maskedDB + h + String.fromCharCode(0xbc);\n  };\n\n  /**\n   * Verifies a PSS signature.\n   *\n   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.\n   *\n   * @param mHash the message digest hash, as a binary-encoded string, to\n   *         compare against the signature.\n   * @param em the encoded message, as a binary-encoded string\n   *          (RSA decryption result).\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return true if the signature was verified, false if not.\n   */\n  pssobj.verify = function(mHash, em, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n\n    /* c. Convert the message representative m to an encoded message EM\n     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits\n     *    is the length in bits of the RSA modulus n */\n    em = em.substr(-emLen);\n\n    /* 3. If emLen < hLen + sLen + 2, output \"inconsistent\" and stop. */\n    if(emLen < hLen + sLen + 2) {\n      throw new Error('Inconsistent parameters to PSS signature verification.');\n    }\n\n    /* 4. If the rightmost octet of EM does not have hexadecimal value\n     *    0xbc, output \"inconsistent\" and stop. */\n    if(em.charCodeAt(emLen - 1) !== 0xbc) {\n      throw new Error('Encoded message does not end in 0xBC.');\n    }\n\n    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\n     *    let H be the next hLen octets. */\n    var maskLen = emLen - hLen - 1;\n    var maskedDB = em.substr(0, maskLen);\n    var h = em.substr(maskLen, hLen);\n\n    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in\n     *    maskedDB are not all equal to zero, output \"inconsistent\" and stop. */\n    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\n    if((maskedDB.charCodeAt(0) & mask) !== 0) {\n      throw new Error('Bits beyond keysize not zero as expected.');\n    }\n\n    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */\n    var dbMask = mgf.generate(h, maskLen);\n\n    /* 8. Let DB = maskedDB \\xor dbMask. */\n    var db = '';\n    for(i = 0; i < maskLen; i++) {\n      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n\n    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet\n     * in DB to zero. */\n    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);\n\n    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\n     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost\n     * position is \"position 1\") does not have hexadecimal value 0x01,\n     * output \"inconsistent\" and stop. */\n    var checkLen = emLen - hLen - sLen - 2;\n    for(i = 0; i < checkLen; i++) {\n      if(db.charCodeAt(i) !== 0x00) {\n        throw new Error('Leftmost octets not zero as expected');\n      }\n    }\n\n    if(db.charCodeAt(checkLen) !== 0x01) {\n      throw new Error('Inconsistent PSS signature, 0x01 marker not found');\n    }\n\n    /* 11. Let salt be the last sLen octets of DB. */\n    var salt = db.substr(-sLen);\n\n    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n\n    /* 13. Let H' = Hash(M'), an octet string of length hLen. */\n    hash.start();\n    hash.update(m_.getBytes());\n    var h_ = hash.digest().getBytes();\n\n    /* 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\" */\n    return h === h_;\n  };\n\n  return pssobj;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}