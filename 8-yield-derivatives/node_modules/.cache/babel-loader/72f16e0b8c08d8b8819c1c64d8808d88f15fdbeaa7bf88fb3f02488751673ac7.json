{"ast":null,"code":"import { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { OperatorSubscriber } from './OperatorSubscriber';\nexport function repeat(count) {\n  if (count === void 0) {\n    count = Infinity;\n  }\n  return count <= 0 ? function () {\n    return EMPTY;\n  } : operate(function (source, subscriber) {\n    var soFar = 0;\n    var innerSub;\n    var subscribeForRepeat = function () {\n      var syncUnsub = false;\n      innerSub = source.subscribe(new OperatorSubscriber(subscriber, undefined, function () {\n        if (++soFar < count) {\n          if (innerSub) {\n            innerSub.unsubscribe();\n            innerSub = null;\n            subscribeForRepeat();\n          } else {\n            syncUnsub = true;\n          }\n        } else {\n          subscriber.complete();\n        }\n      }));\n      if (syncUnsub) {\n        innerSub.unsubscribe();\n        innerSub = null;\n        subscribeForRepeat();\n      }\n    };\n    subscribeForRepeat();\n  });\n}","map":{"version":3,"names":["EMPTY","operate","OperatorSubscriber","repeat","count","Infinity","source","subscriber","soFar","innerSub","subscribeForRepeat","syncUnsub","subscribe","undefined","unsubscribe","complete"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/rxjs/src/internal/operators/repeat.ts"],"sourcesContent":["import { Subscription } from '../Subscription';\nimport { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { OperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Returns an Observable that will resubscribe to the source stream when the source stream completes, at most count times.\n *\n * <span class=\"informal\">Repeats all values emitted on the source. It's like {@link retry}, but for non error cases.</span>\n *\n * ![](repeat.png)\n *\n * Similar to {@link retry}, this operator repeats the stream of items emitted by the source for non error cases.\n * Repeat can be useful for creating observables that are meant to have some repeated pattern or rhythm.\n *\n * Note: `repeat(0)` returns an empty observable and `repeat()` will repeat forever\n *\n * ## Example\n * Repeat a message stream\n * ```ts\n * import { of } from 'rxjs';\n * import { repeat, delay } from 'rxjs/operators';\n *\n * const source = of('Repeat message');\n * const example = source.pipe(repeat(3));\n * example.subscribe(x => console.log(x));\n *\n * // Results\n * // Repeat message\n * // Repeat message\n * // Repeat message\n * ```\n *\n * Repeat 3 values, 2 times\n * ```ts\n * import { interval } from 'rxjs';\n * import { repeat, take } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(take(3), repeat(2));\n * example.subscribe(x => console.log(x));\n *\n * // Results every second\n * // 0\n * // 1\n * // 2\n * // 0\n * // 1\n * // 2\n * ```\n *\n * @see {@link repeatWhen}\n * @see {@link retry}\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return A function that returns an Observable that will resubscribe to the\n * source stream when the source stream completes, at most `count` times.\n */\nexport function repeat<T>(count = Infinity): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? () => EMPTY\n    : operate((source, subscriber) => {\n        let soFar = 0;\n        let innerSub: Subscription | null;\n        const subscribeForRepeat = () => {\n          let syncUnsub = false;\n          innerSub = source.subscribe(\n            new OperatorSubscriber(subscriber, undefined, () => {\n              if (++soFar < count) {\n                if (innerSub) {\n                  innerSub.unsubscribe();\n                  innerSub = null;\n                  subscribeForRepeat();\n                } else {\n                  syncUnsub = true;\n                }\n              } else {\n                subscriber.complete();\n              }\n            })\n          );\n\n          if (syncUnsub) {\n            innerSub.unsubscribe();\n            innerSub = null;\n            subscribeForRepeat();\n          }\n        };\n        subscribeForRepeat();\n      });\n}\n"],"mappings":"AACA,SAASA,KAAK,QAAQ,qBAAqB;AAC3C,SAASC,OAAO,QAAQ,cAAc;AAEtC,SAASC,kBAAkB,QAAQ,sBAAsB;AAwDzD,OAAM,SAAUC,MAAMA,CAAIC,KAAgB;EAAhB,IAAAA,KAAA;IAAAA,KAAA,GAAAC,QAAgB;EAAA;EACxC,OAAOD,KAAK,IAAI,CAAC,GACb;IAAM,OAAAJ,KAAK;EAAL,CAAK,GACXC,OAAO,CAAC,UAACK,MAAM,EAAEC,UAAU;IACzB,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,QAA6B;IACjC,IAAMC,kBAAkB,GAAG,SAAAA,CAAA;MACzB,IAAIC,SAAS,GAAG,KAAK;MACrBF,QAAQ,GAAGH,MAAM,CAACM,SAAS,CACzB,IAAIV,kBAAkB,CAACK,UAAU,EAAEM,SAAS,EAAE;QAC5C,IAAI,EAAEL,KAAK,GAAGJ,KAAK,EAAE;UACnB,IAAIK,QAAQ,EAAE;YACZA,QAAQ,CAACK,WAAW,EAAE;YACtBL,QAAQ,GAAG,IAAI;YACfC,kBAAkB,EAAE;WACrB,MAAM;YACLC,SAAS,GAAG,IAAI;;SAEnB,MAAM;UACLJ,UAAU,CAACQ,QAAQ,EAAE;;MAEzB,CAAC,CAAC,CACH;MAED,IAAIJ,SAAS,EAAE;QACbF,QAAQ,CAACK,WAAW,EAAE;QACtBL,QAAQ,GAAG,IAAI;QACfC,kBAAkB,EAAE;;IAExB,CAAC;IACDA,kBAAkB,EAAE;EACtB,CAAC,CAAC;AACR","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}