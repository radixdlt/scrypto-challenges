{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar branchingFactor = 32;\nvar branchBits = 5;\nvar mask = 31;\nfunction isSetoid(a) {\n  return a && typeof a[\"fantasy-land/equals\"] === \"function\";\n}\nfunction elementEquals(a, b) {\n  if (a === b) {\n    return true;\n  } else if (isSetoid(a)) {\n    return a[\"fantasy-land/equals\"](b);\n  } else {\n    return false;\n  }\n}\nfunction createPath(depth, value) {\n  var current = value;\n  for (var i = 0; i < depth; ++i) {\n    current = new Node(undefined, [current]);\n  }\n  return current;\n}\nfunction copyArray(source) {\n  var array = [];\n  for (var i = 0; i < source.length; ++i) {\n    array[i] = source[i];\n  }\n  return array;\n}\nfunction pushElements(source, target, offset, amount) {\n  for (var i = offset; i < offset + amount; ++i) {\n    target.push(source[i]);\n  }\n}\nfunction copyIndices(source, sourceStart, target, targetStart, length) {\n  for (var i = 0; i < length; ++i) {\n    target[targetStart + i] = source[sourceStart + i];\n  }\n}\nfunction arrayPrepend(value, array) {\n  var newLength = array.length + 1;\n  var result = new Array(newLength);\n  result[0] = value;\n  for (var i = 1; i < newLength; ++i) {\n    result[i] = array[i - 1];\n  }\n  return result;\n}\nfunction reverseArray(array) {\n  return array.slice().reverse();\n}\nfunction arrayFirst(array) {\n  return array[0];\n}\nfunction arrayLast(array) {\n  return array[array.length - 1];\n}\nvar pathResult = {\n  path: 0,\n  index: 0,\n  updatedOffset: 0\n};\nfunction getPath(index, offset, depth, sizes) {\n  if (sizes === undefined && offset !== 0) {\n    pathResult.updatedOffset = 0;\n    index = handleOffset(depth, offset, index);\n  }\n  var path = index >> depth * branchBits & mask;\n  if (sizes !== undefined) {\n    while (sizes[path] <= index) {\n      path++;\n    }\n    var traversed = path === 0 ? 0 : sizes[path - 1];\n    index -= traversed;\n    pathResult.updatedOffset = offset;\n  }\n  pathResult.path = path;\n  pathResult.index = index;\n  return pathResult;\n}\nfunction updateNode(node, depth, index, offset, value) {\n  var _a = getPath(index, offset, depth, node.sizes),\n    path = _a.path,\n    newIndex = _a.index,\n    updatedOffset = _a.updatedOffset;\n  var array = copyArray(node.array);\n  array[path] = depth > 0 ? updateNode(array[path], depth - 1, newIndex, updatedOffset, value) : value;\n  return new Node(node.sizes, array);\n}\nvar Node = function () {\n  function Node(sizes, array) {\n    this.sizes = sizes;\n    this.array = array;\n  }\n  return Node;\n}();\nexport { Node };\nfunction cloneNode(_a) {\n  var sizes = _a.sizes,\n    array = _a.array;\n  return new Node(sizes === undefined ? undefined : copyArray(sizes), copyArray(array));\n}\nvar emptyAffix = [0];\nvar affixBits = 6;\nvar affixMask = 63;\nfunction getSuffixSize(l) {\n  return l.bits & affixMask;\n}\nfunction getPrefixSize(l) {\n  return l.bits >> affixBits & affixMask;\n}\nfunction getDepth(l) {\n  return l.bits >> affixBits * 2;\n}\nfunction setPrefix(size, bits) {\n  return size << affixBits | bits & ~(affixMask << affixBits);\n}\nfunction setSuffix(size, bits) {\n  return size | bits & ~affixMask;\n}\nfunction setDepth(depth, bits) {\n  return depth << affixBits * 2 | bits & (affixMask | affixMask << affixBits);\n}\nfunction incrementPrefix(bits) {\n  return bits + (1 << affixBits);\n}\nfunction incrementSuffix(bits) {\n  return bits + 1;\n}\nfunction incrementDepth(bits) {\n  return bits + (1 << affixBits * 2);\n}\nfunction decrementDepth(bits) {\n  return bits - (1 << affixBits * 2);\n}\nvar List = function () {\n  function List(bits, offset, length, prefix, root, suffix) {\n    this.bits = bits;\n    this.offset = offset;\n    this.length = length;\n    this.prefix = prefix;\n    this.root = root;\n    this.suffix = suffix;\n  }\n  List.prototype[Symbol.iterator] = function () {\n    return new ForwardListIterator(this);\n  };\n  List.prototype.toJSON = function () {\n    return toArray(this);\n  };\n  return List;\n}();\nexport { List };\nfunction cloneList(l) {\n  return new List(l.bits, l.offset, l.length, l.prefix, l.root, l.suffix);\n}\nvar ListIterator = function () {\n  function ListIterator(l, direction) {\n    this.l = l;\n    this.result = {\n      done: false,\n      value: undefined\n    };\n    this.idx = direction === 1 ? -1 : l.length;\n    this.prefixSize = getPrefixSize(l);\n    this.middleSize = l.length - getSuffixSize(l);\n    if (l.root !== undefined) {\n      var depth = getDepth(l);\n      this.stack = new Array(depth + 1);\n      this.indices = new Array(depth + 1);\n      var currentNode = l.root.array;\n      for (var i = depth; 0 <= i; --i) {\n        this.stack[i] = currentNode;\n        var idx = direction === 1 ? 0 : currentNode.length - 1;\n        this.indices[i] = idx;\n        currentNode = currentNode[idx].array;\n      }\n      this.indices[0] -= direction;\n    }\n  }\n  return ListIterator;\n}();\nvar ForwardListIterator = function (_super) {\n  __extends(ForwardListIterator, _super);\n  function ForwardListIterator(l) {\n    return _super.call(this, l, 1) || this;\n  }\n  ForwardListIterator.prototype.nextInTree = function () {\n    for (var i = 0; ++this.indices[i] === this.stack[i].length; ++i) {\n      this.indices[i] = 0;\n    }\n    for (; 0 < i; --i) {\n      this.stack[i - 1] = this.stack[i][this.indices[i]].array;\n    }\n  };\n  ForwardListIterator.prototype.next = function () {\n    var newVal;\n    var idx = ++this.idx;\n    if (idx < this.prefixSize) {\n      newVal = this.l.prefix[this.prefixSize - idx - 1];\n    } else if (idx < this.middleSize) {\n      this.nextInTree();\n      newVal = this.stack[0][this.indices[0]];\n    } else if (idx < this.l.length) {\n      newVal = this.l.suffix[idx - this.middleSize];\n    } else {\n      this.result.done = true;\n    }\n    this.result.value = newVal;\n    return this.result;\n  };\n  return ForwardListIterator;\n}(ListIterator);\nvar BackwardsListIterator = function (_super) {\n  __extends(BackwardsListIterator, _super);\n  function BackwardsListIterator(l) {\n    return _super.call(this, l, -1) || this;\n  }\n  BackwardsListIterator.prototype.prevInTree = function () {\n    for (var i = 0; this.indices[i] === 0; ++i) {}\n    --this.indices[i];\n    for (; 0 < i; --i) {\n      var n = this.stack[i][this.indices[i]].array;\n      this.stack[i - 1] = n;\n      this.indices[i - 1] = n.length - 1;\n    }\n  };\n  BackwardsListIterator.prototype.next = function () {\n    var newVal;\n    var idx = --this.idx;\n    if (this.middleSize <= idx) {\n      newVal = this.l.suffix[idx - this.middleSize];\n    } else if (this.prefixSize <= idx) {\n      this.prevInTree();\n      newVal = this.stack[0][this.indices[0]];\n    } else if (0 <= idx) {\n      newVal = this.l.prefix[this.prefixSize - idx - 1];\n    } else {\n      this.result.done = true;\n    }\n    this.result.value = newVal;\n    return this.result;\n  };\n  return BackwardsListIterator;\n}(ListIterator);\nexport function backwards(l) {\n  var _a;\n  return _a = {}, _a[Symbol.iterator] = function () {\n    return new BackwardsListIterator(l);\n  }, _a;\n}\nfunction emptyPushable() {\n  return new List(0, 0, 0, [], undefined, []);\n}\nfunction push(value, l) {\n  var suffixSize = getSuffixSize(l);\n  if (l.length === 0) {\n    l.bits = setPrefix(1, l.bits);\n    l.prefix = [value];\n  } else if (suffixSize < 32) {\n    l.bits = incrementSuffix(l.bits);\n    l.suffix.push(value);\n  } else if (l.root === undefined) {\n    l.root = new Node(undefined, l.suffix);\n    l.suffix = [value];\n    l.bits = setSuffix(1, l.bits);\n  } else {\n    var newNode = new Node(undefined, l.suffix);\n    var index = l.length - 1 - 32 + 1;\n    var current = l.root;\n    var depth = getDepth(l);\n    l.suffix = [value];\n    l.bits = setSuffix(1, l.bits);\n    if (index - 1 < Math.pow(branchingFactor, depth + 1)) {\n      for (; depth >= 0; --depth) {\n        var path = index >> depth * branchBits & mask;\n        if (path < current.array.length) {\n          current = current.array[path];\n        } else {\n          current.array.push(createPath(depth - 1, newNode));\n          break;\n        }\n      }\n    } else {\n      l.bits = incrementDepth(l.bits);\n      l.root = new Node(undefined, [l.root, createPath(depth, newNode)]);\n    }\n  }\n  l.length++;\n  return l;\n}\nexport function list() {\n  var elements = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    elements[_i] = arguments[_i];\n  }\n  var l = emptyPushable();\n  for (var _a = 0, elements_1 = elements; _a < elements_1.length; _a++) {\n    var element = elements_1[_a];\n    push(element, l);\n  }\n  return l;\n}\nexport function empty() {\n  return new List(0, 0, 0, emptyAffix, undefined, emptyAffix);\n}\nexport function of(a) {\n  return list(a);\n}\nexport function pair(first, second) {\n  return new List(2, 0, 2, emptyAffix, undefined, [first, second]);\n}\nexport function from(sequence) {\n  var l = emptyPushable();\n  if (sequence.length > 0 && (sequence[0] !== undefined || 0 in sequence)) {\n    for (var i = 0; i < sequence.length; ++i) {\n      push(sequence[i], l);\n    }\n  } else if (Symbol.iterator in sequence) {\n    var iterator = sequence[Symbol.iterator]();\n    var cur = void 0;\n    while (!(cur = iterator.next()).done) {\n      push(cur.value, l);\n    }\n  }\n  return l;\n}\nexport function range(start, end) {\n  var list = emptyPushable();\n  for (var i = start; i < end; ++i) {\n    push(i, list);\n  }\n  return list;\n}\nexport function repeat(value, times) {\n  var l = emptyPushable();\n  while (--times >= 0) {\n    push(value, l);\n  }\n  return l;\n}\nexport function times(func, times) {\n  var l = emptyPushable();\n  for (var i = 0; i < times; i++) {\n    push(func(i), l);\n  }\n  return l;\n}\nfunction nodeNthDense(node, depth, index) {\n  var current = node;\n  for (; depth >= 0; --depth) {\n    current = current.array[index >> depth * branchBits & mask];\n  }\n  return current;\n}\nfunction handleOffset(depth, offset, index) {\n  index += offset;\n  for (; depth >= 0; --depth) {\n    index = index - (offset & mask << depth * branchBits);\n    if ((index >> depth * branchBits & mask) !== 0) {\n      break;\n    }\n  }\n  return index;\n}\nfunction nodeNth(node, depth, offset, index) {\n  var path;\n  var current = node;\n  while (current.sizes !== undefined) {\n    path = index >> depth * branchBits & mask;\n    while (current.sizes[path] <= index) {\n      path++;\n    }\n    if (path !== 0) {\n      index -= current.sizes[path - 1];\n      offset = 0;\n    }\n    depth--;\n    current = current.array[path];\n  }\n  return nodeNthDense(current, depth, offset === 0 ? index : handleOffset(depth, offset, index));\n}\nexport function nth(index, l) {\n  if (index < 0 || l.length <= index) {\n    return undefined;\n  }\n  var prefixSize = getPrefixSize(l);\n  var suffixSize = getSuffixSize(l);\n  if (index < prefixSize) {\n    return l.prefix[prefixSize - index - 1];\n  } else if (index >= l.length - suffixSize) {\n    return l.suffix[index - (l.length - suffixSize)];\n  }\n  var offset = l.offset;\n  var depth = getDepth(l);\n  return l.root.sizes === undefined ? nodeNthDense(l.root, depth, offset === 0 ? index - prefixSize : handleOffset(depth, offset, index - prefixSize)) : nodeNth(l.root, depth, offset, index - prefixSize);\n}\nfunction setSizes(node, height) {\n  var sum = 0;\n  var sizeTable = [];\n  for (var i = 0; i < node.array.length; ++i) {\n    sum += sizeOfSubtree(node.array[i], height - 1);\n    sizeTable[i] = sum;\n  }\n  node.sizes = sizeTable;\n  return node;\n}\nfunction sizeOfSubtree(node, height) {\n  if (height !== 0) {\n    if (node.sizes !== undefined) {\n      return arrayLast(node.sizes);\n    } else {\n      var lastSize = sizeOfSubtree(arrayLast(node.array), height - 1);\n      return (node.array.length - 1 << height * branchBits) + lastSize;\n    }\n  } else {\n    return node.array.length;\n  }\n}\nfunction affixPush(a, array, length) {\n  if (array.length === length) {\n    array.push(a);\n    return array;\n  } else {\n    var newArray = [];\n    copyIndices(array, 0, newArray, 0, length);\n    newArray.push(a);\n    return newArray;\n  }\n}\nexport function prepend(value, l) {\n  var prefixSize = getPrefixSize(l);\n  if (prefixSize < 32) {\n    return new List(incrementPrefix(l.bits), l.offset, l.length + 1, affixPush(value, l.prefix, prefixSize), l.root, l.suffix);\n  } else {\n    var newList = cloneList(l);\n    prependNodeToTree(newList, reverseArray(l.prefix));\n    var newPrefix = [value];\n    newList.prefix = newPrefix;\n    newList.length++;\n    newList.bits = setPrefix(1, newList.bits);\n    return newList;\n  }\n}\nfunction copyLeft(l, k) {\n  var currentNode = cloneNode(l.root);\n  l.root = currentNode;\n  for (var i = 1; i < k; ++i) {\n    var index = 0;\n    if (currentNode.sizes !== undefined) {\n      for (var i_1 = 0; i_1 < currentNode.sizes.length; ++i_1) {\n        currentNode.sizes[i_1] += 32;\n      }\n    }\n    var newNode = cloneNode(currentNode.array[index]);\n    currentNode.array[index] = newNode;\n    currentNode = newNode;\n  }\n  return currentNode;\n}\nfunction nodePrepend(value, size, node) {\n  var array = arrayPrepend(value, node.array);\n  var sizes = undefined;\n  if (node.sizes !== undefined) {\n    sizes = new Array(node.sizes.length + 1);\n    sizes[0] = size;\n    for (var i = 0; i < node.sizes.length; ++i) {\n      sizes[i + 1] = node.sizes[i] + size;\n    }\n  }\n  return new Node(sizes, array);\n}\nfunction prependTopTree(l, depth, node) {\n  var newOffset;\n  if (l.root.array.length < branchingFactor) {\n    newOffset = Math.pow(32, depth) - 32;\n    l.root = new Node(undefined, arrayPrepend(createPath(depth - 1, node), l.root.array));\n  } else {\n    l.bits = incrementDepth(l.bits);\n    var sizes = l.root.sizes === undefined ? undefined : [32, arrayLast(l.root.sizes) + 32];\n    newOffset = depth === 0 ? 0 : Math.pow(32, depth + 1) - 32;\n    l.root = new Node(sizes, [createPath(depth, node), l.root]);\n  }\n  return newOffset;\n}\nfunction prependNodeToTree(l, array) {\n  if (l.root === undefined) {\n    if (getSuffixSize(l) === 0) {\n      l.bits = setSuffix(array.length, l.bits);\n      l.suffix = array;\n    } else {\n      l.root = new Node(undefined, array);\n    }\n    return l;\n  } else {\n    var node = new Node(undefined, array);\n    var depth = getDepth(l);\n    var newOffset_1 = 0;\n    if (l.root.sizes === undefined) {\n      if (l.offset !== 0) {\n        newOffset_1 = l.offset - branchingFactor;\n        l.root = prependDense(l.root, depth, l.offset, node);\n      } else {\n        newOffset_1 = prependTopTree(l, depth, node);\n      }\n    } else {\n      var copyableCount = 0;\n      var nodesTraversed = 0;\n      var currentNode = l.root;\n      while (currentNode.sizes !== undefined && nodesTraversed < depth) {\n        ++nodesTraversed;\n        if (currentNode.array.length < 32) {\n          copyableCount = nodesTraversed;\n        }\n        currentNode = currentNode.array[0];\n      }\n      if (l.offset !== 0) {\n        var copiedNode = copyLeft(l, nodesTraversed);\n        for (var i = 0; i < copiedNode.sizes.length; ++i) {\n          copiedNode.sizes[i] += branchingFactor;\n        }\n        copiedNode.array[0] = prependDense(copiedNode.array[0], depth - nodesTraversed, l.offset, node);\n        l.offset = l.offset - branchingFactor;\n        return l;\n      } else {\n        if (copyableCount === 0) {\n          l.offset = prependTopTree(l, depth, node);\n        } else {\n          var parent_1;\n          var prependableNode = void 0;\n          if (copyableCount > 1) {\n            parent_1 = copyLeft(l, copyableCount - 1);\n            prependableNode = parent_1.array[0];\n          } else {\n            parent_1 = undefined;\n            prependableNode = l.root;\n          }\n          var path = createPath(depth - copyableCount, node);\n          l.offset = Math.pow(32, depth - copyableCount + 1) - 32;\n          var prepended = nodePrepend(path, 32, prependableNode);\n          if (parent_1 === undefined) {\n            l.root = prepended;\n          } else {\n            parent_1.array[0] = prepended;\n          }\n        }\n        return l;\n      }\n    }\n    l.offset = newOffset_1;\n    return l;\n  }\n}\nfunction prependDense(node, depth, offset, value) {\n  var curOffset = offset >> depth * branchBits & mask;\n  var path = (offset - 1 >> depth * branchBits & mask) - curOffset;\n  if (path < 0) {\n    return new Node(undefined, arrayPrepend(createPath(depth - 1, value), node.array));\n  } else {\n    var array = copyArray(node.array);\n    array[0] = prependDense(array[0], depth - 1, offset, value);\n    return new Node(undefined, array);\n  }\n}\nexport function append(value, l) {\n  var suffixSize = getSuffixSize(l);\n  if (suffixSize < 32) {\n    return new List(incrementSuffix(l.bits), l.offset, l.length + 1, l.prefix, l.root, affixPush(value, l.suffix, suffixSize));\n  }\n  var newSuffix = [value];\n  var newList = cloneList(l);\n  appendNodeToTree(newList, l.suffix);\n  newList.suffix = newSuffix;\n  newList.length++;\n  newList.bits = setSuffix(1, newList.bits);\n  return newList;\n}\nexport function length(l) {\n  return l.length;\n}\nexport function first(l) {\n  var prefixSize = getPrefixSize(l);\n  return prefixSize !== 0 ? l.prefix[prefixSize - 1] : l.length !== 0 ? l.suffix[0] : undefined;\n}\nexport var head = first;\nexport function last(l) {\n  var suffixSize = getSuffixSize(l);\n  return suffixSize !== 0 ? l.suffix[suffixSize - 1] : l.length !== 0 ? l.prefix[0] : undefined;\n}\nfunction mapArray(f, array) {\n  var result = new Array(array.length);\n  for (var i = 0; i < array.length; ++i) {\n    result[i] = f(array[i]);\n  }\n  return result;\n}\nfunction mapNode(f, node, depth) {\n  if (depth !== 0) {\n    var array = node.array;\n    var result = new Array(array.length);\n    for (var i = 0; i < array.length; ++i) {\n      result[i] = mapNode(f, array[i], depth - 1);\n    }\n    return new Node(node.sizes, result);\n  } else {\n    return new Node(undefined, mapArray(f, node.array));\n  }\n}\nfunction mapPrefix(f, prefix, length) {\n  var newPrefix = new Array(length);\n  for (var i = length - 1; 0 <= i; --i) {\n    newPrefix[i] = f(prefix[i]);\n  }\n  return newPrefix;\n}\nfunction mapAffix(f, suffix, length) {\n  var newSuffix = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    newSuffix[i] = f(suffix[i]);\n  }\n  return newSuffix;\n}\nexport function map(f, l) {\n  return new List(l.bits, l.offset, l.length, mapPrefix(f, l.prefix, getPrefixSize(l)), l.root === undefined ? undefined : mapNode(f, l.root, getDepth(l)), mapAffix(f, l.suffix, getSuffixSize(l)));\n}\nexport function pluck(key, l) {\n  return map(function (a) {\n    return a[key];\n  }, l);\n}\nfunction foldlSuffix(f, acc, array, length) {\n  for (var i = 0; i < length; ++i) {\n    acc = f(acc, array[i]);\n  }\n  return acc;\n}\nfunction foldlPrefix(f, acc, array, length) {\n  for (var i = length - 1; 0 <= i; --i) {\n    acc = f(acc, array[i]);\n  }\n  return acc;\n}\nfunction foldlNode(f, acc, node, depth) {\n  var array = node.array;\n  if (depth === 0) {\n    return foldlSuffix(f, acc, array, array.length);\n  }\n  for (var i = 0; i < array.length; ++i) {\n    acc = foldlNode(f, acc, array[i], depth - 1);\n  }\n  return acc;\n}\nexport function foldl(f, initial, l) {\n  var suffixSize = getSuffixSize(l);\n  var prefixSize = getPrefixSize(l);\n  initial = foldlPrefix(f, initial, l.prefix, prefixSize);\n  if (l.root !== undefined) {\n    initial = foldlNode(f, initial, l.root, getDepth(l));\n  }\n  return foldlSuffix(f, initial, l.suffix, suffixSize);\n}\nexport var reduce = foldl;\nexport function traverse(of, f, l) {\n  return foldr(function (a, fl) {\n    return fl[\"fantasy-land/ap\"](f(a)[\"fantasy-land/map\"](function (a) {\n      return function (l) {\n        return prepend(a, l);\n      };\n    }));\n  }, of[\"fantasy-land/of\"](empty()), l);\n}\nexport function sequence(ofObj, l) {\n  return traverse(ofObj, function (a) {\n    return a;\n  }, l);\n}\nexport function scan(f, initial, l) {\n  return foldl(function (l2, a) {\n    return push(f(last(l2), a), l2);\n  }, push(initial, emptyPushable()), l);\n}\nexport function forEach(callback, l) {\n  foldl(function (_, element) {\n    return callback(element);\n  }, undefined, l);\n}\nexport function filter(predicate, l) {\n  return foldl(function (acc, a) {\n    return predicate(a) ? push(a, acc) : acc;\n  }, emptyPushable(), l);\n}\nexport function reject(predicate, l) {\n  return foldl(function (acc, a) {\n    return predicate(a) ? acc : push(a, acc);\n  }, emptyPushable(), l);\n}\nexport function partition(predicate, l) {\n  return foldl(function (arr, a) {\n    return predicate(a) ? push(a, arr[0]) : push(a, arr[1]), arr;\n  }, [emptyPushable(), emptyPushable()], l);\n}\nexport function join(separator, l) {\n  return foldl(function (a, b) {\n    return a.length === 0 ? b : a + separator + b;\n  }, \"\", l);\n}\nfunction foldrSuffix(f, initial, array, length) {\n  var acc = initial;\n  for (var i = length - 1; 0 <= i; --i) {\n    acc = f(array[i], acc);\n  }\n  return acc;\n}\nfunction foldrPrefix(f, initial, array, length) {\n  var acc = initial;\n  for (var i = 0; i < length; ++i) {\n    acc = f(array[i], acc);\n  }\n  return acc;\n}\nfunction foldrNode(f, initial, _a, depth) {\n  var array = _a.array;\n  if (depth === 0) {\n    return foldrSuffix(f, initial, array, array.length);\n  }\n  var acc = initial;\n  for (var i = array.length - 1; 0 <= i; --i) {\n    acc = foldrNode(f, acc, array[i], depth - 1);\n  }\n  return acc;\n}\nexport function foldr(f, initial, l) {\n  var suffixSize = getSuffixSize(l);\n  var prefixSize = getPrefixSize(l);\n  var acc = foldrSuffix(f, initial, l.suffix, suffixSize);\n  if (l.root !== undefined) {\n    acc = foldrNode(f, acc, l.root, getDepth(l));\n  }\n  return foldrPrefix(f, acc, l.prefix, prefixSize);\n}\nexport var reduceRight = foldr;\nexport function ap(listF, l) {\n  return flatten(map(function (f) {\n    return map(f, l);\n  }, listF));\n}\nexport function flatten(nested) {\n  return foldl(concat, empty(), nested);\n}\nexport function flatMap(f, l) {\n  return flatten(map(f, l));\n}\nexport var chain = flatMap;\nfunction foldlArrayCb(cb, state, array, from, to) {\n  for (var i = from; i < to && cb(array[i], state); ++i) {}\n  return i === to;\n}\nfunction foldrArrayCb(cb, state, array, from, to) {\n  for (var i = from - 1; to <= i && cb(array[i], state); --i) {}\n  return i === to - 1;\n}\nfunction foldlNodeCb(cb, state, node, depth) {\n  var array = node.array;\n  if (depth === 0) {\n    return foldlArrayCb(cb, state, array, 0, array.length);\n  }\n  var to = array.length;\n  for (var i = 0; i < to; ++i) {\n    if (!foldlNodeCb(cb, state, array[i], depth - 1)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction foldlCb(cb, state, l) {\n  var prefixSize = getPrefixSize(l);\n  if (!foldrArrayCb(cb, state, l.prefix, prefixSize, 0) || l.root !== undefined && !foldlNodeCb(cb, state, l.root, getDepth(l))) {\n    return state;\n  }\n  var suffixSize = getSuffixSize(l);\n  foldlArrayCb(cb, state, l.suffix, 0, suffixSize);\n  return state;\n}\nfunction foldrNodeCb(cb, state, node, depth) {\n  var array = node.array;\n  if (depth === 0) {\n    return foldrArrayCb(cb, state, array, array.length, 0);\n  }\n  for (var i = array.length - 1; 0 <= i; --i) {\n    if (!foldrNodeCb(cb, state, array[i], depth - 1)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction foldrCb(cb, state, l) {\n  var suffixSize = getSuffixSize(l);\n  var prefixSize = getPrefixSize(l);\n  if (!foldrArrayCb(cb, state, l.suffix, suffixSize, 0) || l.root !== undefined && !foldrNodeCb(cb, state, l.root, getDepth(l))) {\n    return state;\n  }\n  var prefix = l.prefix;\n  foldlArrayCb(cb, state, l.prefix, prefix.length - prefixSize, prefix.length);\n  return state;\n}\nfunction foldlWhileCb(a, state) {\n  if (state.predicate(state.result, a) === false) {\n    return false;\n  }\n  state.result = state.f(state.result, a);\n  return true;\n}\nexport function foldlWhile(predicate, f, initial, l) {\n  return foldlCb(foldlWhileCb, {\n    predicate: predicate,\n    f: f,\n    result: initial\n  }, l).result;\n}\nexport var reduceWhile = foldlWhile;\nfunction everyCb(value, state) {\n  return state.result = state.predicate(value);\n}\nexport function every(predicate, l) {\n  return foldlCb(everyCb, {\n    predicate: predicate,\n    result: true\n  }, l).result;\n}\nexport var all = every;\nfunction someCb(value, state) {\n  return !(state.result = state.predicate(value));\n}\nexport function some(predicate, l) {\n  return foldlCb(someCb, {\n    predicate: predicate,\n    result: false\n  }, l).result;\n}\nexport var any = some;\nexport function none(predicate, l) {\n  return !some(predicate, l);\n}\nfunction findCb(value, state) {\n  if (state.predicate(value)) {\n    state.result = value;\n    return false;\n  } else {\n    return true;\n  }\n}\nexport function find(predicate, l) {\n  return foldlCb(findCb, {\n    predicate: predicate,\n    result: undefined\n  }, l).result;\n}\nexport function findLast(predicate, l) {\n  return foldrCb(findCb, {\n    predicate: predicate,\n    result: undefined\n  }, l).result;\n}\nfunction indexOfCb(value, state) {\n  ++state.index;\n  return !(state.found = elementEquals(value, state.element));\n}\nexport function indexOf(element, l) {\n  var state = {\n    element: element,\n    found: false,\n    index: -1\n  };\n  foldlCb(indexOfCb, state, l);\n  return state.found ? state.index : -1;\n}\nexport function lastIndexOf(element, l) {\n  var state = {\n    element: element,\n    found: false,\n    index: 0\n  };\n  foldrCb(indexOfCb, state, l);\n  return state.found ? l.length - state.index : -1;\n}\nfunction findIndexCb(value, state) {\n  ++state.index;\n  return !(state.found = state.predicate(value));\n}\nexport function findIndex(predicate, l) {\n  var _a = foldlCb(findIndexCb, {\n      predicate: predicate,\n      found: false,\n      index: -1\n    }, l),\n    found = _a.found,\n    index = _a.index;\n  return found ? index : -1;\n}\nvar containsState = {\n  element: undefined,\n  result: false\n};\nfunction containsCb(value, state) {\n  return !(state.result = value === state.element);\n}\nexport function includes(element, l) {\n  containsState.element = element;\n  containsState.result = false;\n  return foldlCb(containsCb, containsState, l).result;\n}\nexport var contains = includes;\nfunction equalsCb(value2, state) {\n  var value = state.iterator.next().value;\n  return state.equals = state.f(value, value2);\n}\nexport function equals(l1, l2) {\n  return equalsWith(elementEquals, l1, l2);\n}\nexport function equalsWith(f, l1, l2) {\n  if (l1 === l2) {\n    return true;\n  } else if (l1.length !== l2.length) {\n    return false;\n  } else {\n    var s = {\n      iterator: l2[Symbol.iterator](),\n      equals: true,\n      f: f\n    };\n    return foldlCb(equalsCb, s, l1).equals;\n  }\n}\nvar eMax = 2;\nfunction createConcatPlan(array) {\n  var sizes = [];\n  var sum = 0;\n  for (var i_2 = 0; i_2 < array.length; ++i_2) {\n    sum += array[i_2].array.length;\n    sizes[i_2] = array[i_2].array.length;\n  }\n  var optimalLength = Math.ceil(sum / branchingFactor);\n  var n = array.length;\n  var i = 0;\n  if (optimalLength + eMax >= n) {\n    return undefined;\n  }\n  while (optimalLength + eMax < n) {\n    while (sizes[i] > branchingFactor - eMax / 2) {\n      ++i;\n    }\n    var remaining = sizes[i];\n    do {\n      var size = Math.min(remaining + sizes[i + 1], branchingFactor);\n      sizes[i] = size;\n      remaining = remaining - (size - sizes[i + 1]);\n      ++i;\n    } while (remaining > 0);\n    for (var j = i; j <= n - 1; ++j) {\n      sizes[j] = sizes[j + 1];\n    }\n    --i;\n    --n;\n  }\n  sizes.length = n;\n  return sizes;\n}\nfunction concatNodeMerge(left, center, right) {\n  var array = [];\n  if (left !== undefined) {\n    for (var i = 0; i < left.array.length - 1; ++i) {\n      array.push(left.array[i]);\n    }\n  }\n  for (var i = 0; i < center.array.length; ++i) {\n    array.push(center.array[i]);\n  }\n  if (right !== undefined) {\n    for (var i = 1; i < right.array.length; ++i) {\n      array.push(right.array[i]);\n    }\n  }\n  return array;\n}\nfunction executeConcatPlan(merged, plan, height) {\n  var result = [];\n  var sourceIdx = 0;\n  var offset = 0;\n  for (var _i = 0, plan_1 = plan; _i < plan_1.length; _i++) {\n    var toMove = plan_1[_i];\n    var source = merged[sourceIdx].array;\n    if (toMove === source.length && offset === 0) {\n      result.push(merged[sourceIdx]);\n      ++sourceIdx;\n    } else {\n      var node = new Node(undefined, []);\n      while (toMove > 0) {\n        var available = source.length - offset;\n        var itemsToCopy = Math.min(toMove, available);\n        pushElements(source, node.array, offset, itemsToCopy);\n        if (toMove >= available) {\n          ++sourceIdx;\n          source = merged[sourceIdx].array;\n          offset = 0;\n        } else {\n          offset += itemsToCopy;\n        }\n        toMove -= itemsToCopy;\n      }\n      if (height > 1) {\n        setSizes(node, height - 1);\n      }\n      result.push(node);\n    }\n  }\n  return result;\n}\nfunction rebalance(left, center, right, height, top) {\n  var merged = concatNodeMerge(left, center, right);\n  var plan = createConcatPlan(merged);\n  var balanced = plan !== undefined ? executeConcatPlan(merged, plan, height) : merged;\n  if (balanced.length <= branchingFactor) {\n    if (top === true) {\n      return new Node(undefined, balanced);\n    } else {\n      return new Node(undefined, [setSizes(new Node(undefined, balanced), height)]);\n    }\n  } else {\n    return new Node(undefined, [setSizes(new Node(undefined, balanced.slice(0, branchingFactor)), height), setSizes(new Node(undefined, balanced.slice(branchingFactor)), height)]);\n  }\n}\nfunction concatSubTree(left, lDepth, right, rDepth, isTop) {\n  if (lDepth > rDepth) {\n    var c = concatSubTree(arrayLast(left.array), lDepth - 1, right, rDepth, false);\n    return rebalance(left, c, undefined, lDepth, isTop);\n  } else if (lDepth < rDepth) {\n    var c = concatSubTree(left, lDepth, arrayFirst(right.array), rDepth - 1, false);\n    return rebalance(undefined, c, right, rDepth, isTop);\n  } else if (lDepth === 0) {\n    return new Node(undefined, [left, right]);\n  } else {\n    var c = concatSubTree(arrayLast(left.array), lDepth - 1, arrayFirst(right.array), rDepth - 1, false);\n    return rebalance(left, c, right, lDepth, isTop);\n  }\n}\nfunction getHeight(node) {\n  if (node.array[0] instanceof Node) {\n    return 1 + getHeight(node.array[0]);\n  } else {\n    return 0;\n  }\n}\nfunction appendNodeToTree(l, array) {\n  if (l.root === undefined) {\n    if (getPrefixSize(l) === 0) {\n      l.bits = setPrefix(array.length, l.bits);\n      l.prefix = reverseArray(array);\n    } else {\n      l.root = new Node(undefined, array);\n    }\n    return l;\n  }\n  var depth = getDepth(l);\n  var index = handleOffset(depth, l.offset, l.length - 1 - getPrefixSize(l));\n  var nodesToCopy = 0;\n  var nodesVisited = 0;\n  var shift = depth * 5;\n  var currentNode = l.root;\n  if (Math.pow(32, depth + 1) < index) {\n    shift = 0;\n    nodesVisited = depth;\n  }\n  while (shift > 5) {\n    var childIndex = void 0;\n    if (currentNode.sizes === undefined) {\n      childIndex = index >> shift & mask;\n      index &= ~(mask << shift);\n    } else {\n      childIndex = currentNode.array.length - 1;\n      index -= currentNode.sizes[childIndex - 1];\n    }\n    nodesVisited++;\n    if (childIndex < mask) {\n      nodesToCopy = nodesVisited;\n    }\n    currentNode = currentNode.array[childIndex];\n    if (currentNode === undefined) {\n      nodesToCopy = nodesVisited;\n      shift = 5;\n    }\n    shift -= 5;\n  }\n  if (shift !== 0) {\n    nodesVisited++;\n    if (currentNode.array.length < branchingFactor) {\n      nodesToCopy = nodesVisited;\n    }\n  }\n  var node = new Node(undefined, array);\n  if (nodesToCopy === 0) {\n    var newPath = nodesVisited === 0 ? node : createPath(nodesVisited, node);\n    var newRoot = new Node(undefined, [l.root, newPath]);\n    l.root = newRoot;\n    l.bits = incrementDepth(l.bits);\n  } else {\n    var copiedNode = copyFirstK(l, nodesToCopy, array.length);\n    copiedNode.array.push(createPath(depth - nodesToCopy, node));\n  }\n  return l;\n}\nfunction copyFirstK(newList, k, leafSize) {\n  var currentNode = cloneNode(newList.root);\n  newList.root = currentNode;\n  for (var i = 1; i < k; ++i) {\n    var index = currentNode.array.length - 1;\n    if (currentNode.sizes !== undefined) {\n      currentNode.sizes[index] += leafSize;\n    }\n    var newNode = cloneNode(currentNode.array[index]);\n    currentNode.array[index] = newNode;\n    currentNode = newNode;\n  }\n  if (currentNode.sizes !== undefined) {\n    currentNode.sizes.push(arrayLast(currentNode.sizes) + leafSize);\n  }\n  return currentNode;\n}\nvar concatBuffer = new Array(3);\nfunction concatAffixes(left, right) {\n  var nr = 0;\n  var arrIdx = 0;\n  var i = 0;\n  var length = getSuffixSize(left);\n  concatBuffer[nr] = [];\n  for (i = 0; i < length; ++i) {\n    concatBuffer[nr][arrIdx++] = left.suffix[i];\n  }\n  length = getPrefixSize(right);\n  for (i = 0; i < length; ++i) {\n    if (arrIdx === 32) {\n      arrIdx = 0;\n      ++nr;\n      concatBuffer[nr] = [];\n    }\n    concatBuffer[nr][arrIdx++] = right.prefix[length - 1 - i];\n  }\n  length = getSuffixSize(right);\n  for (i = 0; i < length; ++i) {\n    if (arrIdx === 32) {\n      arrIdx = 0;\n      ++nr;\n      concatBuffer[nr] = [];\n    }\n    concatBuffer[nr][arrIdx++] = right.suffix[i];\n  }\n  return nr;\n}\nexport function concat(left, right) {\n  if (left.length === 0) {\n    return right;\n  } else if (right.length === 0) {\n    return left;\n  }\n  var newSize = left.length + right.length;\n  var rightSuffixSize = getSuffixSize(right);\n  var newList = cloneList(left);\n  if (right.root === undefined) {\n    var nrOfAffixes = concatAffixes(left, right);\n    for (var i = 0; i < nrOfAffixes; ++i) {\n      newList = appendNodeToTree(newList, concatBuffer[i]);\n      newList.length += concatBuffer[i].length;\n      concatBuffer[i] = undefined;\n    }\n    newList.length = newSize;\n    newList.suffix = concatBuffer[nrOfAffixes];\n    newList.bits = setSuffix(concatBuffer[nrOfAffixes].length, newList.bits);\n    concatBuffer[nrOfAffixes] = undefined;\n    return newList;\n  } else {\n    var leftSuffixSize = getSuffixSize(left);\n    if (leftSuffixSize > 0) {\n      newList = appendNodeToTree(newList, left.suffix.slice(0, leftSuffixSize));\n      newList.length += leftSuffixSize;\n    }\n    newList = appendNodeToTree(newList, right.prefix.slice(0, getPrefixSize(right)).reverse());\n    var newNode = concatSubTree(newList.root, getDepth(newList), right.root, getDepth(right), true);\n    var newDepth = getHeight(newNode);\n    setSizes(newNode, newDepth);\n    newList.root = newNode;\n    newList.offset &= ~(mask << getDepth(left) * branchBits);\n    newList.length = newSize;\n    newList.bits = setSuffix(rightSuffixSize, setDepth(newDepth, newList.bits));\n    newList.suffix = right.suffix;\n    return newList;\n  }\n}\nexport function update(index, a, l) {\n  if (index < 0 || l.length <= index) {\n    return l;\n  }\n  var prefixSize = getPrefixSize(l);\n  var suffixSize = getSuffixSize(l);\n  var newList = cloneList(l);\n  if (index < prefixSize) {\n    var newPrefix = copyArray(newList.prefix);\n    newPrefix[newPrefix.length - index - 1] = a;\n    newList.prefix = newPrefix;\n  } else if (index >= l.length - suffixSize) {\n    var newSuffix = copyArray(newList.suffix);\n    newSuffix[index - (l.length - suffixSize)] = a;\n    newList.suffix = newSuffix;\n  } else {\n    newList.root = updateNode(l.root, getDepth(l), index - prefixSize, l.offset, a);\n  }\n  return newList;\n}\nexport function adjust(index, f, l) {\n  if (index < 0 || l.length <= index) {\n    return l;\n  }\n  return update(index, f(nth(index, l)), l);\n}\nvar newAffix;\nfunction sliceNode(node, index, depth, pathLeft, pathRight, childLeft, childRight) {\n  var array = node.array.slice(pathLeft, pathRight + 1);\n  if (childLeft !== undefined) {\n    array[0] = childLeft;\n  }\n  if (childRight !== undefined) {\n    array[array.length - 1] = childRight;\n  }\n  var sizes = node.sizes;\n  if (sizes !== undefined) {\n    sizes = sizes.slice(pathLeft, pathRight + 1);\n    var slicedOffLeft = pathLeft !== 0 ? node.sizes[pathLeft - 1] : 0;\n    if (childLeft !== undefined) {\n      if (childLeft.sizes !== undefined) {\n        var oldChild = node.array[pathLeft];\n        slicedOffLeft += arrayLast(oldChild.sizes) - arrayLast(childLeft.sizes);\n      } else {\n        slicedOffLeft += (index - slicedOffLeft & ~31) + 32;\n      }\n    }\n    for (var i = 0; i < sizes.length; ++i) {\n      sizes[i] -= slicedOffLeft;\n    }\n    if (childRight !== undefined) {\n      var slicedOffRight = sizeOfSubtree(node.array[pathRight], depth - 1) - sizeOfSubtree(childRight, depth - 1);\n      sizes[sizes.length - 1] -= slicedOffRight;\n    }\n  }\n  return new Node(sizes, array);\n}\nvar newOffset = 0;\nfunction sliceLeft(tree, depth, index, offset, top) {\n  var _a = getPath(index, offset, depth, tree.sizes),\n    path = _a.path,\n    newIndex = _a.index,\n    updatedOffset = _a.updatedOffset;\n  if (depth === 0) {\n    newAffix = tree.array.slice(path).reverse();\n    return undefined;\n  } else {\n    var child = sliceLeft(tree.array[path], depth - 1, newIndex, updatedOffset, false);\n    if (child === undefined) {\n      ++path;\n      if (path === tree.array.length) {\n        return undefined;\n      }\n    }\n    if (tree.sizes === undefined && top === false) {\n      newOffset |= 32 - (tree.array.length - path) << depth * branchBits;\n    }\n    return sliceNode(tree, index, depth, path, tree.array.length - 1, child, undefined);\n  }\n}\nfunction sliceRight(node, depth, index, offset) {\n  var _a = getPath(index, offset, depth, node.sizes),\n    path = _a.path,\n    newIndex = _a.index;\n  if (depth === 0) {\n    newAffix = node.array.slice(0, path + 1);\n    return undefined;\n  } else {\n    var child = sliceRight(node.array[path], depth - 1, newIndex, path === 0 ? offset : 0);\n    if (child === undefined) {\n      --path;\n      if (path === -1) {\n        return undefined;\n      }\n    }\n    var array = node.array.slice(0, path + 1);\n    if (child !== undefined) {\n      array[array.length - 1] = child;\n    }\n    var sizes = node.sizes;\n    if (sizes !== undefined) {\n      sizes = sizes.slice(0, path + 1);\n      if (child !== undefined) {\n        var slicedOff = sizeOfSubtree(node.array[path], depth - 1) - sizeOfSubtree(child, depth - 1);\n        sizes[sizes.length - 1] -= slicedOff;\n      }\n    }\n    return new Node(sizes, array);\n  }\n}\nfunction sliceTreeList(from, to, tree, depth, offset, l) {\n  var sizes = tree.sizes;\n  var _a = getPath(from, offset, depth, sizes),\n    pathLeft = _a.path,\n    newFrom = _a.index;\n  var _b = getPath(to, offset, depth, sizes),\n    pathRight = _b.path,\n    newTo = _b.index;\n  if (depth === 0) {\n    l.prefix = emptyAffix;\n    l.suffix = tree.array.slice(pathLeft, pathRight + 1);\n    l.root = undefined;\n    l.bits = setSuffix(pathRight - pathLeft + 1, 0);\n    return l;\n  } else if (pathLeft === pathRight) {\n    l.bits = decrementDepth(l.bits);\n    return sliceTreeList(newFrom, newTo, tree.array[pathLeft], depth - 1, pathLeft === 0 ? offset : 0, l);\n  } else {\n    var childRight = sliceRight(tree.array[pathRight], depth - 1, newTo, 0);\n    l.bits = setSuffix(newAffix.length, l.bits);\n    l.suffix = newAffix;\n    if (childRight === undefined) {\n      --pathRight;\n    }\n    newOffset = 0;\n    var childLeft = sliceLeft(tree.array[pathLeft], depth - 1, newFrom, pathLeft === 0 ? offset : 0, pathLeft === pathRight);\n    l.offset = newOffset;\n    l.bits = setPrefix(newAffix.length, l.bits);\n    l.prefix = newAffix;\n    if (childLeft === undefined) {\n      ++pathLeft;\n    }\n    if (pathLeft >= pathRight) {\n      if (pathLeft > pathRight) {\n        l.bits = setDepth(0, l.bits);\n        l.root = undefined;\n      } else {\n        l.bits = decrementDepth(l.bits);\n        var newRoot = childRight !== undefined ? childRight : childLeft !== undefined ? childLeft : tree.array[pathLeft];\n        l.root = new Node(newRoot.sizes, newRoot.array);\n      }\n    } else {\n      l.root = sliceNode(tree, from, depth, pathLeft, pathRight, childLeft, childRight);\n    }\n    return l;\n  }\n}\nexport function slice(from, to, l) {\n  var bits = l.bits,\n    length = l.length;\n  to = Math.min(length, to);\n  if (from < 0) {\n    from = length + from;\n  }\n  if (to < 0) {\n    to = length + to;\n  }\n  if (to <= from || to <= 0 || length <= from) {\n    return empty();\n  }\n  if (from <= 0 && length <= to) {\n    return l;\n  }\n  var newLength = to - from;\n  var prefixSize = getPrefixSize(l);\n  var suffixSize = getSuffixSize(l);\n  if (to <= prefixSize) {\n    return new List(setPrefix(newLength, 0), 0, newLength, l.prefix.slice(prefixSize - to, prefixSize - from), undefined, emptyAffix);\n  }\n  var suffixStart = length - suffixSize;\n  if (suffixStart <= from) {\n    return new List(setSuffix(newLength, 0), 0, newLength, emptyAffix, undefined, l.suffix.slice(from - suffixStart, to - suffixStart));\n  }\n  var newList = cloneList(l);\n  newList.length = newLength;\n  if (prefixSize <= from && to <= suffixStart) {\n    sliceTreeList(from - prefixSize + l.offset, to - prefixSize + l.offset - 1, l.root, getDepth(l), l.offset, newList);\n    return newList;\n  }\n  if (0 < from) {\n    if (from < prefixSize) {\n      newList.prefix = l.prefix.slice(0, prefixSize - from);\n      bits = setPrefix(prefixSize - from, bits);\n    } else {\n      newOffset = 0;\n      newList.root = sliceLeft(newList.root, getDepth(l), from - prefixSize, l.offset, true);\n      newList.offset = newOffset;\n      if (newList.root === undefined) {\n        bits = setDepth(0, bits);\n      }\n      bits = setPrefix(newAffix.length, bits);\n      prefixSize = newAffix.length;\n      newList.prefix = newAffix;\n    }\n  }\n  if (to < length) {\n    if (length - to < suffixSize) {\n      bits = setSuffix(suffixSize - (length - to), bits);\n      newList.suffix = l.suffix.slice(0, suffixSize - (length - to));\n    } else {\n      newList.root = sliceRight(newList.root, getDepth(l), to - prefixSize - 1, newList.offset);\n      if (newList.root === undefined) {\n        bits = setDepth(0, bits);\n        newList.offset = 0;\n      }\n      bits = setSuffix(newAffix.length, bits);\n      newList.suffix = newAffix;\n    }\n  }\n  newList.bits = bits;\n  return newList;\n}\nexport function take(n, l) {\n  return slice(0, n, l);\n}\nfunction findNotIndexCb(value, state) {\n  if (state.predicate(value)) {\n    ++state.index;\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function takeWhile(predicate, l) {\n  var index = foldlCb(findNotIndexCb, {\n    predicate: predicate,\n    index: 0\n  }, l).index;\n  return slice(0, index, l);\n}\nexport function takeLastWhile(predicate, l) {\n  var index = foldrCb(findNotIndexCb, {\n    predicate: predicate,\n    index: 0\n  }, l).index;\n  return slice(l.length - index, l.length, l);\n}\nexport function dropWhile(predicate, l) {\n  var index = foldlCb(findNotIndexCb, {\n    predicate: predicate,\n    index: 0\n  }, l).index;\n  return slice(index, l.length, l);\n}\nexport function dropRepeats(l) {\n  return dropRepeatsWith(elementEquals, l);\n}\nexport function dropRepeatsWith(predicate, l) {\n  return foldl(function (acc, a) {\n    return acc.length !== 0 && predicate(last(acc), a) ? acc : push(a, acc);\n  }, emptyPushable(), l);\n}\nexport function takeLast(n, l) {\n  return slice(l.length - n, l.length, l);\n}\nexport function splitAt(index, l) {\n  return [slice(0, index, l), slice(index, l.length, l)];\n}\nexport function splitWhen(predicate, l) {\n  var idx = findIndex(predicate, l);\n  return idx === -1 ? [l, empty()] : splitAt(idx, l);\n}\nexport function splitEvery(size, l) {\n  var _a = foldl(function (_a, elm) {\n      var l2 = _a.l2,\n        buffer = _a.buffer;\n      push(elm, buffer);\n      if (buffer.length === size) {\n        return {\n          l2: push(buffer, l2),\n          buffer: emptyPushable()\n        };\n      } else {\n        return {\n          l2: l2,\n          buffer: buffer\n        };\n      }\n    }, {\n      l2: emptyPushable(),\n      buffer: emptyPushable()\n    }, l),\n    l2 = _a.l2,\n    buffer = _a.buffer;\n  return buffer.length === 0 ? l2 : push(buffer, l2);\n}\nexport function remove(from, amount, l) {\n  return concat(slice(0, from, l), slice(from + amount, l.length, l));\n}\nexport function drop(n, l) {\n  return slice(n, l.length, l);\n}\nexport function dropLast(n, l) {\n  return slice(0, l.length - n, l);\n}\nexport function pop(l) {\n  return slice(0, -1, l);\n}\nexport var init = pop;\nexport function tail(l) {\n  return slice(1, l.length, l);\n}\nfunction arrayPush(array, a) {\n  array.push(a);\n  return array;\n}\nexport function toArray(l) {\n  return foldl(arrayPush, [], l);\n}\nexport function insert(index, element, l) {\n  return concat(append(element, slice(0, index, l)), slice(index, l.length, l));\n}\nexport function insertAll(index, elements, l) {\n  return concat(concat(slice(0, index, l), elements), slice(index, l.length, l));\n}\nexport function reverse(l) {\n  return foldl(function (newL, element) {\n    return prepend(element, newL);\n  }, empty(), l);\n}\nexport function isList(l) {\n  return typeof l === \"object\" && Array.isArray(l.suffix);\n}\nexport function zip(as, bs) {\n  return zipWith(function (a, b) {\n    return [a, b];\n  }, as, bs);\n}\nexport function zipWith(f, as, bs) {\n  var swapped = bs.length < as.length;\n  var iterator = (swapped ? as : bs)[Symbol.iterator]();\n  return map(function (a) {\n    var b = iterator.next().value;\n    return swapped ? f(b, a) : f(a, b);\n  }, swapped ? bs : as);\n}\nfunction isPrimitive(value) {\n  return typeof value === \"number\" || typeof value === \"string\";\n}\nfunction comparePrimitive(a, b) {\n  return a === b ? 0 : a < b ? -1 : 1;\n}\nvar ord = \"fantasy-land/lte\";\nfunction compareOrd(a, b) {\n  return a[ord](b) ? b[ord](a) ? 0 : -1 : 1;\n}\nexport function sort(l) {\n  if (l.length === 0) {\n    return l;\n  } else if (isPrimitive(first(l))) {\n    return from(toArray(l).sort(comparePrimitive));\n  } else {\n    return sortWith(compareOrd, l);\n  }\n}\nexport function sortWith(comparator, l) {\n  var arr = [];\n  var i = 0;\n  forEach(function (elm) {\n    return arr.push({\n      idx: i++,\n      elm: elm\n    });\n  }, l);\n  arr.sort(function (_a, _b) {\n    var a = _a.elm,\n      i = _a.idx;\n    var b = _b.elm,\n      j = _b.idx;\n    var c = comparator(a, b);\n    return c !== 0 ? c : i < j ? -1 : 1;\n  });\n  var newL = emptyPushable();\n  for (var i_3 = 0; i_3 < arr.length; ++i_3) {\n    push(arr[i_3].elm, newL);\n  }\n  return newL;\n}\nexport function sortBy(f, l) {\n  if (l.length === 0) {\n    return l;\n  }\n  var arr = [];\n  var i = 0;\n  forEach(function (elm) {\n    return arr.push({\n      idx: i++,\n      elm: elm,\n      prop: f(elm)\n    });\n  }, l);\n  var comparator = isPrimitive(arr[0].prop) ? comparePrimitive : compareOrd;\n  arr.sort(function (_a, _b) {\n    var a = _a.prop,\n      i = _a.idx;\n    var b = _b.prop,\n      j = _b.idx;\n    var c = comparator(a, b);\n    return c !== 0 ? c : i < j ? -1 : 1;\n  });\n  var newL = emptyPushable();\n  for (var i_4 = 0; i_4 < arr.length; ++i_4) {\n    push(arr[i_4].elm, newL);\n  }\n  return newL;\n}\nexport function group(l) {\n  return groupWith(elementEquals, l);\n}\nexport function groupWith(f, l) {\n  var result = emptyPushable();\n  var buffer = emptyPushable();\n  forEach(function (a) {\n    if (buffer.length !== 0 && !f(last(buffer), a)) {\n      push(buffer, result);\n      buffer = emptyPushable();\n    }\n    push(a, buffer);\n  }, l);\n  return buffer.length === 0 ? result : push(buffer, result);\n}\nexport function intersperse(separator, l) {\n  return pop(foldl(function (l2, a) {\n    return push(separator, push(a, l2));\n  }, emptyPushable(), l));\n}\nexport function isEmpty(l) {\n  return l.length === 0;\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","branchingFactor","branchBits","mask","isSetoid","a","elementEquals","createPath","depth","value","current","i","Node","undefined","copyArray","source","array","length","pushElements","target","offset","amount","push","copyIndices","sourceStart","targetStart","arrayPrepend","newLength","result","reverseArray","slice","reverse","arrayFirst","arrayLast","pathResult","path","index","updatedOffset","getPath","sizes","handleOffset","traversed","updateNode","node","_a","newIndex","cloneNode","emptyAffix","affixBits","affixMask","getSuffixSize","l","bits","getPrefixSize","getDepth","setPrefix","size","setSuffix","setDepth","incrementPrefix","incrementSuffix","incrementDepth","decrementDepth","List","prefix","root","suffix","Symbol","iterator","ForwardListIterator","toJSON","toArray","cloneList","ListIterator","direction","done","idx","prefixSize","middleSize","stack","indices","currentNode","_super","call","nextInTree","next","newVal","BackwardsListIterator","prevInTree","n","backwards","emptyPushable","suffixSize","newNode","Math","pow","list","elements","_i","arguments","elements_1","element","empty","of","pair","first","second","from","sequence","cur","range","start","end","repeat","times","func","nodeNthDense","nodeNth","nth","setSizes","height","sum","sizeTable","sizeOfSubtree","lastSize","affixPush","newArray","prepend","newList","prependNodeToTree","newPrefix","copyLeft","k","i_1","nodePrepend","prependTopTree","newOffset","newOffset_1","prependDense","copyableCount","nodesTraversed","copiedNode","parent_1","prependableNode","prepended","curOffset","append","newSuffix","appendNodeToTree","head","last","mapArray","f","mapNode","mapPrefix","mapAffix","map","pluck","key","foldlSuffix","acc","foldlPrefix","foldlNode","foldl","initial","reduce","traverse","foldr","fl","ofObj","scan","l2","forEach","callback","_","filter","predicate","reject","partition","arr","join","separator","foldrSuffix","foldrPrefix","foldrNode","reduceRight","ap","listF","flatten","nested","concat","flatMap","chain","foldlArrayCb","cb","state","to","foldrArrayCb","foldlNodeCb","foldlCb","foldrNodeCb","foldrCb","foldlWhileCb","foldlWhile","reduceWhile","everyCb","every","all","someCb","some","any","none","findCb","find","findLast","indexOfCb","found","indexOf","lastIndexOf","findIndexCb","findIndex","containsState","containsCb","includes","contains","equalsCb","value2","equals","l1","equalsWith","s","eMax","createConcatPlan","i_2","optimalLength","ceil","remaining","min","j","concatNodeMerge","left","center","right","executeConcatPlan","merged","plan","sourceIdx","plan_1","toMove","available","itemsToCopy","rebalance","top","balanced","concatSubTree","lDepth","rDepth","isTop","c","getHeight","nodesToCopy","nodesVisited","shift","childIndex","newPath","newRoot","copyFirstK","leafSize","concatBuffer","concatAffixes","nr","arrIdx","newSize","rightSuffixSize","nrOfAffixes","leftSuffixSize","newDepth","update","adjust","newAffix","sliceNode","pathLeft","pathRight","childLeft","childRight","slicedOffLeft","oldChild","slicedOffRight","sliceLeft","tree","child","sliceRight","slicedOff","sliceTreeList","newFrom","_b","newTo","suffixStart","take","findNotIndexCb","takeWhile","takeLastWhile","dropWhile","dropRepeats","dropRepeatsWith","takeLast","splitAt","splitWhen","splitEvery","elm","buffer","remove","drop","dropLast","pop","init","tail","arrayPush","insert","insertAll","newL","isList","isArray","zip","as","bs","zipWith","swapped","isPrimitive","comparePrimitive","ord","compareOrd","sort","sortWith","comparator","i_3","sortBy","prop","i_4","group","groupWith","intersperse","isEmpty"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/list/dist/es/index.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar branchingFactor = 32;\nvar branchBits = 5;\nvar mask = 31;\nfunction isSetoid(a) {\n    return a && typeof a[\"fantasy-land/equals\"] === \"function\";\n}\nfunction elementEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else if (isSetoid(a)) {\n        return a[\"fantasy-land/equals\"](b);\n    }\n    else {\n        return false;\n    }\n}\nfunction createPath(depth, value) {\n    var current = value;\n    for (var i = 0; i < depth; ++i) {\n        current = new Node(undefined, [current]);\n    }\n    return current;\n}\nfunction copyArray(source) {\n    var array = [];\n    for (var i = 0; i < source.length; ++i) {\n        array[i] = source[i];\n    }\n    return array;\n}\nfunction pushElements(source, target, offset, amount) {\n    for (var i = offset; i < offset + amount; ++i) {\n        target.push(source[i]);\n    }\n}\nfunction copyIndices(source, sourceStart, target, targetStart, length) {\n    for (var i = 0; i < length; ++i) {\n        target[targetStart + i] = source[sourceStart + i];\n    }\n}\nfunction arrayPrepend(value, array) {\n    var newLength = array.length + 1;\n    var result = new Array(newLength);\n    result[0] = value;\n    for (var i = 1; i < newLength; ++i) {\n        result[i] = array[i - 1];\n    }\n    return result;\n}\nfunction reverseArray(array) {\n    return array.slice().reverse();\n}\nfunction arrayFirst(array) {\n    return array[0];\n}\nfunction arrayLast(array) {\n    return array[array.length - 1];\n}\nvar pathResult = { path: 0, index: 0, updatedOffset: 0 };\nfunction getPath(index, offset, depth, sizes) {\n    if (sizes === undefined && offset !== 0) {\n        pathResult.updatedOffset = 0;\n        index = handleOffset(depth, offset, index);\n    }\n    var path = (index >> (depth * branchBits)) & mask;\n    if (sizes !== undefined) {\n        while (sizes[path] <= index) {\n            path++;\n        }\n        var traversed = path === 0 ? 0 : sizes[path - 1];\n        index -= traversed;\n        pathResult.updatedOffset = offset;\n    }\n    pathResult.path = path;\n    pathResult.index = index;\n    return pathResult;\n}\nfunction updateNode(node, depth, index, offset, value) {\n    var _a = getPath(index, offset, depth, node.sizes), path = _a.path, newIndex = _a.index, updatedOffset = _a.updatedOffset;\n    var array = copyArray(node.array);\n    array[path] =\n        depth > 0\n            ? updateNode(array[path], depth - 1, newIndex, updatedOffset, value)\n            : value;\n    return new Node(node.sizes, array);\n}\nvar Node = (function () {\n    function Node(sizes, array) {\n        this.sizes = sizes;\n        this.array = array;\n    }\n    return Node;\n}());\nexport { Node };\nfunction cloneNode(_a) {\n    var sizes = _a.sizes, array = _a.array;\n    return new Node(sizes === undefined ? undefined : copyArray(sizes), copyArray(array));\n}\nvar emptyAffix = [0];\nvar affixBits = 6;\nvar affixMask = 63;\nfunction getSuffixSize(l) {\n    return l.bits & affixMask;\n}\nfunction getPrefixSize(l) {\n    return (l.bits >> affixBits) & affixMask;\n}\nfunction getDepth(l) {\n    return l.bits >> (affixBits * 2);\n}\nfunction setPrefix(size, bits) {\n    return (size << affixBits) | (bits & ~(affixMask << affixBits));\n}\nfunction setSuffix(size, bits) {\n    return size | (bits & ~affixMask);\n}\nfunction setDepth(depth, bits) {\n    return ((depth << (affixBits * 2)) | (bits & (affixMask | (affixMask << affixBits))));\n}\nfunction incrementPrefix(bits) {\n    return bits + (1 << affixBits);\n}\nfunction incrementSuffix(bits) {\n    return bits + 1;\n}\nfunction incrementDepth(bits) {\n    return bits + (1 << (affixBits * 2));\n}\nfunction decrementDepth(bits) {\n    return bits - (1 << (affixBits * 2));\n}\nvar List = (function () {\n    function List(bits, offset, length, prefix, root, suffix) {\n        this.bits = bits;\n        this.offset = offset;\n        this.length = length;\n        this.prefix = prefix;\n        this.root = root;\n        this.suffix = suffix;\n    }\n    List.prototype[Symbol.iterator] = function () {\n        return new ForwardListIterator(this);\n    };\n    List.prototype.toJSON = function () {\n        return toArray(this);\n    };\n    return List;\n}());\nexport { List };\nfunction cloneList(l) {\n    return new List(l.bits, l.offset, l.length, l.prefix, l.root, l.suffix);\n}\nvar ListIterator = (function () {\n    function ListIterator(l, direction) {\n        this.l = l;\n        this.result = { done: false, value: undefined };\n        this.idx = direction === 1 ? -1 : l.length;\n        this.prefixSize = getPrefixSize(l);\n        this.middleSize = l.length - getSuffixSize(l);\n        if (l.root !== undefined) {\n            var depth = getDepth(l);\n            this.stack = new Array(depth + 1);\n            this.indices = new Array(depth + 1);\n            var currentNode = l.root.array;\n            for (var i = depth; 0 <= i; --i) {\n                this.stack[i] = currentNode;\n                var idx = direction === 1 ? 0 : currentNode.length - 1;\n                this.indices[i] = idx;\n                currentNode = currentNode[idx].array;\n            }\n            this.indices[0] -= direction;\n        }\n    }\n    return ListIterator;\n}());\nvar ForwardListIterator = (function (_super) {\n    __extends(ForwardListIterator, _super);\n    function ForwardListIterator(l) {\n        return _super.call(this, l, 1) || this;\n    }\n    ForwardListIterator.prototype.nextInTree = function () {\n        for (var i = 0; ++this.indices[i] === this.stack[i].length; ++i) {\n            this.indices[i] = 0;\n        }\n        for (; 0 < i; --i) {\n            this.stack[i - 1] = this.stack[i][this.indices[i]].array;\n        }\n    };\n    ForwardListIterator.prototype.next = function () {\n        var newVal;\n        var idx = ++this.idx;\n        if (idx < this.prefixSize) {\n            newVal = this.l.prefix[this.prefixSize - idx - 1];\n        }\n        else if (idx < this.middleSize) {\n            this.nextInTree();\n            newVal = this.stack[0][this.indices[0]];\n        }\n        else if (idx < this.l.length) {\n            newVal = this.l.suffix[idx - this.middleSize];\n        }\n        else {\n            this.result.done = true;\n        }\n        this.result.value = newVal;\n        return this.result;\n    };\n    return ForwardListIterator;\n}(ListIterator));\nvar BackwardsListIterator = (function (_super) {\n    __extends(BackwardsListIterator, _super);\n    function BackwardsListIterator(l) {\n        return _super.call(this, l, -1) || this;\n    }\n    BackwardsListIterator.prototype.prevInTree = function () {\n        for (var i = 0; this.indices[i] === 0; ++i) { }\n        --this.indices[i];\n        for (; 0 < i; --i) {\n            var n = this.stack[i][this.indices[i]].array;\n            this.stack[i - 1] = n;\n            this.indices[i - 1] = n.length - 1;\n        }\n    };\n    BackwardsListIterator.prototype.next = function () {\n        var newVal;\n        var idx = --this.idx;\n        if (this.middleSize <= idx) {\n            newVal = this.l.suffix[idx - this.middleSize];\n        }\n        else if (this.prefixSize <= idx) {\n            this.prevInTree();\n            newVal = this.stack[0][this.indices[0]];\n        }\n        else if (0 <= idx) {\n            newVal = this.l.prefix[this.prefixSize - idx - 1];\n        }\n        else {\n            this.result.done = true;\n        }\n        this.result.value = newVal;\n        return this.result;\n    };\n    return BackwardsListIterator;\n}(ListIterator));\nexport function backwards(l) {\n    var _a;\n    return _a = {},\n        _a[Symbol.iterator] = function () {\n            return new BackwardsListIterator(l);\n        },\n        _a;\n}\nfunction emptyPushable() {\n    return new List(0, 0, 0, [], undefined, []);\n}\nfunction push(value, l) {\n    var suffixSize = getSuffixSize(l);\n    if (l.length === 0) {\n        l.bits = setPrefix(1, l.bits);\n        l.prefix = [value];\n    }\n    else if (suffixSize < 32) {\n        l.bits = incrementSuffix(l.bits);\n        l.suffix.push(value);\n    }\n    else if (l.root === undefined) {\n        l.root = new Node(undefined, l.suffix);\n        l.suffix = [value];\n        l.bits = setSuffix(1, l.bits);\n    }\n    else {\n        var newNode = new Node(undefined, l.suffix);\n        var index = l.length - 1 - 32 + 1;\n        var current = l.root;\n        var depth = getDepth(l);\n        l.suffix = [value];\n        l.bits = setSuffix(1, l.bits);\n        if (index - 1 < Math.pow(branchingFactor, (depth + 1))) {\n            for (; depth >= 0; --depth) {\n                var path = (index >> (depth * branchBits)) & mask;\n                if (path < current.array.length) {\n                    current = current.array[path];\n                }\n                else {\n                    current.array.push(createPath(depth - 1, newNode));\n                    break;\n                }\n            }\n        }\n        else {\n            l.bits = incrementDepth(l.bits);\n            l.root = new Node(undefined, [l.root, createPath(depth, newNode)]);\n        }\n    }\n    l.length++;\n    return l;\n}\nexport function list() {\n    var elements = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        elements[_i] = arguments[_i];\n    }\n    var l = emptyPushable();\n    for (var _a = 0, elements_1 = elements; _a < elements_1.length; _a++) {\n        var element = elements_1[_a];\n        push(element, l);\n    }\n    return l;\n}\nexport function empty() {\n    return new List(0, 0, 0, emptyAffix, undefined, emptyAffix);\n}\nexport function of(a) {\n    return list(a);\n}\nexport function pair(first, second) {\n    return new List(2, 0, 2, emptyAffix, undefined, [first, second]);\n}\nexport function from(sequence) {\n    var l = emptyPushable();\n    if (sequence.length > 0 && (sequence[0] !== undefined || 0 in sequence)) {\n        for (var i = 0; i < sequence.length; ++i) {\n            push(sequence[i], l);\n        }\n    }\n    else if (Symbol.iterator in sequence) {\n        var iterator = sequence[Symbol.iterator]();\n        var cur = void 0;\n        while (!(cur = iterator.next()).done) {\n            push(cur.value, l);\n        }\n    }\n    return l;\n}\nexport function range(start, end) {\n    var list = emptyPushable();\n    for (var i = start; i < end; ++i) {\n        push(i, list);\n    }\n    return list;\n}\nexport function repeat(value, times) {\n    var l = emptyPushable();\n    while (--times >= 0) {\n        push(value, l);\n    }\n    return l;\n}\nexport function times(func, times) {\n    var l = emptyPushable();\n    for (var i = 0; i < times; i++) {\n        push(func(i), l);\n    }\n    return l;\n}\nfunction nodeNthDense(node, depth, index) {\n    var current = node;\n    for (; depth >= 0; --depth) {\n        current = current.array[(index >> (depth * branchBits)) & mask];\n    }\n    return current;\n}\nfunction handleOffset(depth, offset, index) {\n    index += offset;\n    for (; depth >= 0; --depth) {\n        index = index - (offset & (mask << (depth * branchBits)));\n        if (((index >> (depth * branchBits)) & mask) !== 0) {\n            break;\n        }\n    }\n    return index;\n}\nfunction nodeNth(node, depth, offset, index) {\n    var path;\n    var current = node;\n    while (current.sizes !== undefined) {\n        path = (index >> (depth * branchBits)) & mask;\n        while (current.sizes[path] <= index) {\n            path++;\n        }\n        if (path !== 0) {\n            index -= current.sizes[path - 1];\n            offset = 0;\n        }\n        depth--;\n        current = current.array[path];\n    }\n    return nodeNthDense(current, depth, offset === 0 ? index : handleOffset(depth, offset, index));\n}\nexport function nth(index, l) {\n    if (index < 0 || l.length <= index) {\n        return undefined;\n    }\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    if (index < prefixSize) {\n        return l.prefix[prefixSize - index - 1];\n    }\n    else if (index >= l.length - suffixSize) {\n        return l.suffix[index - (l.length - suffixSize)];\n    }\n    var offset = l.offset;\n    var depth = getDepth(l);\n    return l.root.sizes === undefined\n        ? nodeNthDense(l.root, depth, offset === 0\n            ? index - prefixSize\n            : handleOffset(depth, offset, index - prefixSize))\n        : nodeNth(l.root, depth, offset, index - prefixSize);\n}\nfunction setSizes(node, height) {\n    var sum = 0;\n    var sizeTable = [];\n    for (var i = 0; i < node.array.length; ++i) {\n        sum += sizeOfSubtree(node.array[i], height - 1);\n        sizeTable[i] = sum;\n    }\n    node.sizes = sizeTable;\n    return node;\n}\nfunction sizeOfSubtree(node, height) {\n    if (height !== 0) {\n        if (node.sizes !== undefined) {\n            return arrayLast(node.sizes);\n        }\n        else {\n            var lastSize = sizeOfSubtree(arrayLast(node.array), height - 1);\n            return ((node.array.length - 1) << (height * branchBits)) + lastSize;\n        }\n    }\n    else {\n        return node.array.length;\n    }\n}\nfunction affixPush(a, array, length) {\n    if (array.length === length) {\n        array.push(a);\n        return array;\n    }\n    else {\n        var newArray = [];\n        copyIndices(array, 0, newArray, 0, length);\n        newArray.push(a);\n        return newArray;\n    }\n}\nexport function prepend(value, l) {\n    var prefixSize = getPrefixSize(l);\n    if (prefixSize < 32) {\n        return new List(incrementPrefix(l.bits), l.offset, l.length + 1, affixPush(value, l.prefix, prefixSize), l.root, l.suffix);\n    }\n    else {\n        var newList = cloneList(l);\n        prependNodeToTree(newList, reverseArray(l.prefix));\n        var newPrefix = [value];\n        newList.prefix = newPrefix;\n        newList.length++;\n        newList.bits = setPrefix(1, newList.bits);\n        return newList;\n    }\n}\nfunction copyLeft(l, k) {\n    var currentNode = cloneNode(l.root);\n    l.root = currentNode;\n    for (var i = 1; i < k; ++i) {\n        var index = 0;\n        if (currentNode.sizes !== undefined) {\n            for (var i_1 = 0; i_1 < currentNode.sizes.length; ++i_1) {\n                currentNode.sizes[i_1] += 32;\n            }\n        }\n        var newNode = cloneNode(currentNode.array[index]);\n        currentNode.array[index] = newNode;\n        currentNode = newNode;\n    }\n    return currentNode;\n}\nfunction nodePrepend(value, size, node) {\n    var array = arrayPrepend(value, node.array);\n    var sizes = undefined;\n    if (node.sizes !== undefined) {\n        sizes = new Array(node.sizes.length + 1);\n        sizes[0] = size;\n        for (var i = 0; i < node.sizes.length; ++i) {\n            sizes[i + 1] = node.sizes[i] + size;\n        }\n    }\n    return new Node(sizes, array);\n}\nfunction prependTopTree(l, depth, node) {\n    var newOffset;\n    if (l.root.array.length < branchingFactor) {\n        newOffset = Math.pow(32, depth) - 32;\n        l.root = new Node(undefined, arrayPrepend(createPath(depth - 1, node), l.root.array));\n    }\n    else {\n        l.bits = incrementDepth(l.bits);\n        var sizes = l.root.sizes === undefined\n            ? undefined\n            : [32, arrayLast(l.root.sizes) + 32];\n        newOffset = depth === 0 ? 0 : Math.pow(32, (depth + 1)) - 32;\n        l.root = new Node(sizes, [createPath(depth, node), l.root]);\n    }\n    return newOffset;\n}\nfunction prependNodeToTree(l, array) {\n    if (l.root === undefined) {\n        if (getSuffixSize(l) === 0) {\n            l.bits = setSuffix(array.length, l.bits);\n            l.suffix = array;\n        }\n        else {\n            l.root = new Node(undefined, array);\n        }\n        return l;\n    }\n    else {\n        var node = new Node(undefined, array);\n        var depth = getDepth(l);\n        var newOffset_1 = 0;\n        if (l.root.sizes === undefined) {\n            if (l.offset !== 0) {\n                newOffset_1 = l.offset - branchingFactor;\n                l.root = prependDense(l.root, depth, l.offset, node);\n            }\n            else {\n                newOffset_1 = prependTopTree(l, depth, node);\n            }\n        }\n        else {\n            var copyableCount = 0;\n            var nodesTraversed = 0;\n            var currentNode = l.root;\n            while (currentNode.sizes !== undefined && nodesTraversed < depth) {\n                ++nodesTraversed;\n                if (currentNode.array.length < 32) {\n                    copyableCount = nodesTraversed;\n                }\n                currentNode = currentNode.array[0];\n            }\n            if (l.offset !== 0) {\n                var copiedNode = copyLeft(l, nodesTraversed);\n                for (var i = 0; i < copiedNode.sizes.length; ++i) {\n                    copiedNode.sizes[i] += branchingFactor;\n                }\n                copiedNode.array[0] = prependDense(copiedNode.array[0], depth - nodesTraversed, l.offset, node);\n                l.offset = l.offset - branchingFactor;\n                return l;\n            }\n            else {\n                if (copyableCount === 0) {\n                    l.offset = prependTopTree(l, depth, node);\n                }\n                else {\n                    var parent_1;\n                    var prependableNode = void 0;\n                    if (copyableCount > 1) {\n                        parent_1 = copyLeft(l, copyableCount - 1);\n                        prependableNode = parent_1.array[0];\n                    }\n                    else {\n                        parent_1 = undefined;\n                        prependableNode = l.root;\n                    }\n                    var path = createPath(depth - copyableCount, node);\n                    l.offset = Math.pow(32, (depth - copyableCount + 1)) - 32;\n                    var prepended = nodePrepend(path, 32, prependableNode);\n                    if (parent_1 === undefined) {\n                        l.root = prepended;\n                    }\n                    else {\n                        parent_1.array[0] = prepended;\n                    }\n                }\n                return l;\n            }\n        }\n        l.offset = newOffset_1;\n        return l;\n    }\n}\nfunction prependDense(node, depth, offset, value) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var path = (((offset - 1) >> (depth * branchBits)) & mask) - curOffset;\n    if (path < 0) {\n        return new Node(undefined, arrayPrepend(createPath(depth - 1, value), node.array));\n    }\n    else {\n        var array = copyArray(node.array);\n        array[0] = prependDense(array[0], depth - 1, offset, value);\n        return new Node(undefined, array);\n    }\n}\nexport function append(value, l) {\n    var suffixSize = getSuffixSize(l);\n    if (suffixSize < 32) {\n        return new List(incrementSuffix(l.bits), l.offset, l.length + 1, l.prefix, l.root, affixPush(value, l.suffix, suffixSize));\n    }\n    var newSuffix = [value];\n    var newList = cloneList(l);\n    appendNodeToTree(newList, l.suffix);\n    newList.suffix = newSuffix;\n    newList.length++;\n    newList.bits = setSuffix(1, newList.bits);\n    return newList;\n}\nexport function length(l) {\n    return l.length;\n}\nexport function first(l) {\n    var prefixSize = getPrefixSize(l);\n    return prefixSize !== 0\n        ? l.prefix[prefixSize - 1]\n        : l.length !== 0\n            ? l.suffix[0]\n            : undefined;\n}\nexport var head = first;\nexport function last(l) {\n    var suffixSize = getSuffixSize(l);\n    return suffixSize !== 0\n        ? l.suffix[suffixSize - 1]\n        : l.length !== 0\n            ? l.prefix[0]\n            : undefined;\n}\nfunction mapArray(f, array) {\n    var result = new Array(array.length);\n    for (var i = 0; i < array.length; ++i) {\n        result[i] = f(array[i]);\n    }\n    return result;\n}\nfunction mapNode(f, node, depth) {\n    if (depth !== 0) {\n        var array = node.array;\n        var result = new Array(array.length);\n        for (var i = 0; i < array.length; ++i) {\n            result[i] = mapNode(f, array[i], depth - 1);\n        }\n        return new Node(node.sizes, result);\n    }\n    else {\n        return new Node(undefined, mapArray(f, node.array));\n    }\n}\nfunction mapPrefix(f, prefix, length) {\n    var newPrefix = new Array(length);\n    for (var i = length - 1; 0 <= i; --i) {\n        newPrefix[i] = f(prefix[i]);\n    }\n    return newPrefix;\n}\nfunction mapAffix(f, suffix, length) {\n    var newSuffix = new Array(length);\n    for (var i = 0; i < length; ++i) {\n        newSuffix[i] = f(suffix[i]);\n    }\n    return newSuffix;\n}\nexport function map(f, l) {\n    return new List(l.bits, l.offset, l.length, mapPrefix(f, l.prefix, getPrefixSize(l)), l.root === undefined ? undefined : mapNode(f, l.root, getDepth(l)), mapAffix(f, l.suffix, getSuffixSize(l)));\n}\nexport function pluck(key, l) {\n    return map(function (a) { return a[key]; }, l);\n}\nfunction foldlSuffix(f, acc, array, length) {\n    for (var i = 0; i < length; ++i) {\n        acc = f(acc, array[i]);\n    }\n    return acc;\n}\nfunction foldlPrefix(f, acc, array, length) {\n    for (var i = length - 1; 0 <= i; --i) {\n        acc = f(acc, array[i]);\n    }\n    return acc;\n}\nfunction foldlNode(f, acc, node, depth) {\n    var array = node.array;\n    if (depth === 0) {\n        return foldlSuffix(f, acc, array, array.length);\n    }\n    for (var i = 0; i < array.length; ++i) {\n        acc = foldlNode(f, acc, array[i], depth - 1);\n    }\n    return acc;\n}\nexport function foldl(f, initial, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    initial = foldlPrefix(f, initial, l.prefix, prefixSize);\n    if (l.root !== undefined) {\n        initial = foldlNode(f, initial, l.root, getDepth(l));\n    }\n    return foldlSuffix(f, initial, l.suffix, suffixSize);\n}\nexport var reduce = foldl;\nexport function traverse(of, f, l) {\n    return foldr(function (a, fl) {\n        return fl[\"fantasy-land/ap\"](f(a)[\"fantasy-land/map\"](function (a) { return function (l) { return prepend(a, l); }; }));\n    }, of[\"fantasy-land/of\"](empty()), l);\n}\nexport function sequence(ofObj, l) {\n    return traverse(ofObj, function (a) { return a; }, l);\n}\nexport function scan(f, initial, l) {\n    return foldl(function (l2, a) { return push(f(last(l2), a), l2); }, push(initial, emptyPushable()), l);\n}\nexport function forEach(callback, l) {\n    foldl(function (_, element) { return callback(element); }, undefined, l);\n}\nexport function filter(predicate, l) {\n    return foldl(function (acc, a) { return (predicate(a) ? push(a, acc) : acc); }, emptyPushable(), l);\n}\nexport function reject(predicate, l) {\n    return foldl(function (acc, a) { return (predicate(a) ? acc : push(a, acc)); }, emptyPushable(), l);\n}\nexport function partition(predicate, l) {\n    return foldl(function (arr, a) { return (predicate(a) ? push(a, arr[0]) : push(a, arr[1]), arr); }, [emptyPushable(), emptyPushable()], l);\n}\nexport function join(separator, l) {\n    return foldl(function (a, b) { return (a.length === 0 ? b : a + separator + b); }, \"\", l);\n}\nfunction foldrSuffix(f, initial, array, length) {\n    var acc = initial;\n    for (var i = length - 1; 0 <= i; --i) {\n        acc = f(array[i], acc);\n    }\n    return acc;\n}\nfunction foldrPrefix(f, initial, array, length) {\n    var acc = initial;\n    for (var i = 0; i < length; ++i) {\n        acc = f(array[i], acc);\n    }\n    return acc;\n}\nfunction foldrNode(f, initial, _a, depth) {\n    var array = _a.array;\n    if (depth === 0) {\n        return foldrSuffix(f, initial, array, array.length);\n    }\n    var acc = initial;\n    for (var i = array.length - 1; 0 <= i; --i) {\n        acc = foldrNode(f, acc, array[i], depth - 1);\n    }\n    return acc;\n}\nexport function foldr(f, initial, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    var acc = foldrSuffix(f, initial, l.suffix, suffixSize);\n    if (l.root !== undefined) {\n        acc = foldrNode(f, acc, l.root, getDepth(l));\n    }\n    return foldrPrefix(f, acc, l.prefix, prefixSize);\n}\nexport var reduceRight = foldr;\nexport function ap(listF, l) {\n    return flatten(map(function (f) { return map(f, l); }, listF));\n}\nexport function flatten(nested) {\n    return foldl(concat, empty(), nested);\n}\nexport function flatMap(f, l) {\n    return flatten(map(f, l));\n}\nexport var chain = flatMap;\nfunction foldlArrayCb(cb, state, array, from, to) {\n    for (var i = from; i < to && cb(array[i], state); ++i) { }\n    return i === to;\n}\nfunction foldrArrayCb(cb, state, array, from, to) {\n    for (var i = from - 1; to <= i && cb(array[i], state); --i) { }\n    return i === to - 1;\n}\nfunction foldlNodeCb(cb, state, node, depth) {\n    var array = node.array;\n    if (depth === 0) {\n        return foldlArrayCb(cb, state, array, 0, array.length);\n    }\n    var to = array.length;\n    for (var i = 0; i < to; ++i) {\n        if (!foldlNodeCb(cb, state, array[i], depth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction foldlCb(cb, state, l) {\n    var prefixSize = getPrefixSize(l);\n    if (!foldrArrayCb(cb, state, l.prefix, prefixSize, 0) ||\n        (l.root !== undefined && !foldlNodeCb(cb, state, l.root, getDepth(l)))) {\n        return state;\n    }\n    var suffixSize = getSuffixSize(l);\n    foldlArrayCb(cb, state, l.suffix, 0, suffixSize);\n    return state;\n}\nfunction foldrNodeCb(cb, state, node, depth) {\n    var array = node.array;\n    if (depth === 0) {\n        return foldrArrayCb(cb, state, array, array.length, 0);\n    }\n    for (var i = array.length - 1; 0 <= i; --i) {\n        if (!foldrNodeCb(cb, state, array[i], depth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction foldrCb(cb, state, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    if (!foldrArrayCb(cb, state, l.suffix, suffixSize, 0) ||\n        (l.root !== undefined && !foldrNodeCb(cb, state, l.root, getDepth(l)))) {\n        return state;\n    }\n    var prefix = l.prefix;\n    foldlArrayCb(cb, state, l.prefix, prefix.length - prefixSize, prefix.length);\n    return state;\n}\nfunction foldlWhileCb(a, state) {\n    if (state.predicate(state.result, a) === false) {\n        return false;\n    }\n    state.result = state.f(state.result, a);\n    return true;\n}\nexport function foldlWhile(predicate, f, initial, l) {\n    return foldlCb(foldlWhileCb, { predicate: predicate, f: f, result: initial }, l).result;\n}\nexport var reduceWhile = foldlWhile;\nfunction everyCb(value, state) {\n    return (state.result = state.predicate(value));\n}\nexport function every(predicate, l) {\n    return foldlCb(everyCb, { predicate: predicate, result: true }, l).result;\n}\nexport var all = every;\nfunction someCb(value, state) {\n    return !(state.result = state.predicate(value));\n}\nexport function some(predicate, l) {\n    return foldlCb(someCb, { predicate: predicate, result: false }, l).result;\n}\nexport var any = some;\nexport function none(predicate, l) {\n    return !some(predicate, l);\n}\nfunction findCb(value, state) {\n    if (state.predicate(value)) {\n        state.result = value;\n        return false;\n    }\n    else {\n        return true;\n    }\n}\nexport function find(predicate, l) {\n    return foldlCb(findCb, { predicate: predicate, result: undefined }, l)\n        .result;\n}\nexport function findLast(predicate, l) {\n    return foldrCb(findCb, { predicate: predicate, result: undefined }, l)\n        .result;\n}\nfunction indexOfCb(value, state) {\n    ++state.index;\n    return !(state.found = elementEquals(value, state.element));\n}\nexport function indexOf(element, l) {\n    var state = { element: element, found: false, index: -1 };\n    foldlCb(indexOfCb, state, l);\n    return state.found ? state.index : -1;\n}\nexport function lastIndexOf(element, l) {\n    var state = { element: element, found: false, index: 0 };\n    foldrCb(indexOfCb, state, l);\n    return state.found ? l.length - state.index : -1;\n}\nfunction findIndexCb(value, state) {\n    ++state.index;\n    return !(state.found = state.predicate(value));\n}\nexport function findIndex(predicate, l) {\n    var _a = foldlCb(findIndexCb, { predicate: predicate, found: false, index: -1 }, l), found = _a.found, index = _a.index;\n    return found ? index : -1;\n}\nvar containsState = {\n    element: undefined,\n    result: false\n};\nfunction containsCb(value, state) {\n    return !(state.result = value === state.element);\n}\nexport function includes(element, l) {\n    containsState.element = element;\n    containsState.result = false;\n    return foldlCb(containsCb, containsState, l).result;\n}\nexport var contains = includes;\nfunction equalsCb(value2, state) {\n    var value = state.iterator.next().value;\n    return (state.equals = state.f(value, value2));\n}\nexport function equals(l1, l2) {\n    return equalsWith(elementEquals, l1, l2);\n}\nexport function equalsWith(f, l1, l2) {\n    if (l1 === l2) {\n        return true;\n    }\n    else if (l1.length !== l2.length) {\n        return false;\n    }\n    else {\n        var s = { iterator: l2[Symbol.iterator](), equals: true, f: f };\n        return foldlCb(equalsCb, s, l1).equals;\n    }\n}\nvar eMax = 2;\nfunction createConcatPlan(array) {\n    var sizes = [];\n    var sum = 0;\n    for (var i_2 = 0; i_2 < array.length; ++i_2) {\n        sum += array[i_2].array.length;\n        sizes[i_2] = array[i_2].array.length;\n    }\n    var optimalLength = Math.ceil(sum / branchingFactor);\n    var n = array.length;\n    var i = 0;\n    if (optimalLength + eMax >= n) {\n        return undefined;\n    }\n    while (optimalLength + eMax < n) {\n        while (sizes[i] > branchingFactor - eMax / 2) {\n            ++i;\n        }\n        var remaining = sizes[i];\n        do {\n            var size = Math.min(remaining + sizes[i + 1], branchingFactor);\n            sizes[i] = size;\n            remaining = remaining - (size - sizes[i + 1]);\n            ++i;\n        } while (remaining > 0);\n        for (var j = i; j <= n - 1; ++j) {\n            sizes[j] = sizes[j + 1];\n        }\n        --i;\n        --n;\n    }\n    sizes.length = n;\n    return sizes;\n}\nfunction concatNodeMerge(left, center, right) {\n    var array = [];\n    if (left !== undefined) {\n        for (var i = 0; i < left.array.length - 1; ++i) {\n            array.push(left.array[i]);\n        }\n    }\n    for (var i = 0; i < center.array.length; ++i) {\n        array.push(center.array[i]);\n    }\n    if (right !== undefined) {\n        for (var i = 1; i < right.array.length; ++i) {\n            array.push(right.array[i]);\n        }\n    }\n    return array;\n}\nfunction executeConcatPlan(merged, plan, height) {\n    var result = [];\n    var sourceIdx = 0;\n    var offset = 0;\n    for (var _i = 0, plan_1 = plan; _i < plan_1.length; _i++) {\n        var toMove = plan_1[_i];\n        var source = merged[sourceIdx].array;\n        if (toMove === source.length && offset === 0) {\n            result.push(merged[sourceIdx]);\n            ++sourceIdx;\n        }\n        else {\n            var node = new Node(undefined, []);\n            while (toMove > 0) {\n                var available = source.length - offset;\n                var itemsToCopy = Math.min(toMove, available);\n                pushElements(source, node.array, offset, itemsToCopy);\n                if (toMove >= available) {\n                    ++sourceIdx;\n                    source = merged[sourceIdx].array;\n                    offset = 0;\n                }\n                else {\n                    offset += itemsToCopy;\n                }\n                toMove -= itemsToCopy;\n            }\n            if (height > 1) {\n                setSizes(node, height - 1);\n            }\n            result.push(node);\n        }\n    }\n    return result;\n}\nfunction rebalance(left, center, right, height, top) {\n    var merged = concatNodeMerge(left, center, right);\n    var plan = createConcatPlan(merged);\n    var balanced = plan !== undefined ? executeConcatPlan(merged, plan, height) : merged;\n    if (balanced.length <= branchingFactor) {\n        if (top === true) {\n            return new Node(undefined, balanced);\n        }\n        else {\n            return new Node(undefined, [\n                setSizes(new Node(undefined, balanced), height)\n            ]);\n        }\n    }\n    else {\n        return new Node(undefined, [\n            setSizes(new Node(undefined, balanced.slice(0, branchingFactor)), height),\n            setSizes(new Node(undefined, balanced.slice(branchingFactor)), height)\n        ]);\n    }\n}\nfunction concatSubTree(left, lDepth, right, rDepth, isTop) {\n    if (lDepth > rDepth) {\n        var c = concatSubTree(arrayLast(left.array), lDepth - 1, right, rDepth, false);\n        return rebalance(left, c, undefined, lDepth, isTop);\n    }\n    else if (lDepth < rDepth) {\n        var c = concatSubTree(left, lDepth, arrayFirst(right.array), rDepth - 1, false);\n        return rebalance(undefined, c, right, rDepth, isTop);\n    }\n    else if (lDepth === 0) {\n        return new Node(undefined, [left, right]);\n    }\n    else {\n        var c = concatSubTree(arrayLast(left.array), lDepth - 1, arrayFirst(right.array), rDepth - 1, false);\n        return rebalance(left, c, right, lDepth, isTop);\n    }\n}\nfunction getHeight(node) {\n    if (node.array[0] instanceof Node) {\n        return 1 + getHeight(node.array[0]);\n    }\n    else {\n        return 0;\n    }\n}\nfunction appendNodeToTree(l, array) {\n    if (l.root === undefined) {\n        if (getPrefixSize(l) === 0) {\n            l.bits = setPrefix(array.length, l.bits);\n            l.prefix = reverseArray(array);\n        }\n        else {\n            l.root = new Node(undefined, array);\n        }\n        return l;\n    }\n    var depth = getDepth(l);\n    var index = handleOffset(depth, l.offset, l.length - 1 - getPrefixSize(l));\n    var nodesToCopy = 0;\n    var nodesVisited = 0;\n    var shift = depth * 5;\n    var currentNode = l.root;\n    if (Math.pow(32, (depth + 1)) < index) {\n        shift = 0;\n        nodesVisited = depth;\n    }\n    while (shift > 5) {\n        var childIndex = void 0;\n        if (currentNode.sizes === undefined) {\n            childIndex = (index >> shift) & mask;\n            index &= ~(mask << shift);\n        }\n        else {\n            childIndex = currentNode.array.length - 1;\n            index -= currentNode.sizes[childIndex - 1];\n        }\n        nodesVisited++;\n        if (childIndex < mask) {\n            nodesToCopy = nodesVisited;\n        }\n        currentNode = currentNode.array[childIndex];\n        if (currentNode === undefined) {\n            nodesToCopy = nodesVisited;\n            shift = 5;\n        }\n        shift -= 5;\n    }\n    if (shift !== 0) {\n        nodesVisited++;\n        if (currentNode.array.length < branchingFactor) {\n            nodesToCopy = nodesVisited;\n        }\n    }\n    var node = new Node(undefined, array);\n    if (nodesToCopy === 0) {\n        var newPath = nodesVisited === 0 ? node : createPath(nodesVisited, node);\n        var newRoot = new Node(undefined, [l.root, newPath]);\n        l.root = newRoot;\n        l.bits = incrementDepth(l.bits);\n    }\n    else {\n        var copiedNode = copyFirstK(l, nodesToCopy, array.length);\n        copiedNode.array.push(createPath(depth - nodesToCopy, node));\n    }\n    return l;\n}\nfunction copyFirstK(newList, k, leafSize) {\n    var currentNode = cloneNode(newList.root);\n    newList.root = currentNode;\n    for (var i = 1; i < k; ++i) {\n        var index = currentNode.array.length - 1;\n        if (currentNode.sizes !== undefined) {\n            currentNode.sizes[index] += leafSize;\n        }\n        var newNode = cloneNode(currentNode.array[index]);\n        currentNode.array[index] = newNode;\n        currentNode = newNode;\n    }\n    if (currentNode.sizes !== undefined) {\n        currentNode.sizes.push(arrayLast(currentNode.sizes) + leafSize);\n    }\n    return currentNode;\n}\nvar concatBuffer = new Array(3);\nfunction concatAffixes(left, right) {\n    var nr = 0;\n    var arrIdx = 0;\n    var i = 0;\n    var length = getSuffixSize(left);\n    concatBuffer[nr] = [];\n    for (i = 0; i < length; ++i) {\n        concatBuffer[nr][arrIdx++] = left.suffix[i];\n    }\n    length = getPrefixSize(right);\n    for (i = 0; i < length; ++i) {\n        if (arrIdx === 32) {\n            arrIdx = 0;\n            ++nr;\n            concatBuffer[nr] = [];\n        }\n        concatBuffer[nr][arrIdx++] = right.prefix[length - 1 - i];\n    }\n    length = getSuffixSize(right);\n    for (i = 0; i < length; ++i) {\n        if (arrIdx === 32) {\n            arrIdx = 0;\n            ++nr;\n            concatBuffer[nr] = [];\n        }\n        concatBuffer[nr][arrIdx++] = right.suffix[i];\n    }\n    return nr;\n}\nexport function concat(left, right) {\n    if (left.length === 0) {\n        return right;\n    }\n    else if (right.length === 0) {\n        return left;\n    }\n    var newSize = left.length + right.length;\n    var rightSuffixSize = getSuffixSize(right);\n    var newList = cloneList(left);\n    if (right.root === undefined) {\n        var nrOfAffixes = concatAffixes(left, right);\n        for (var i = 0; i < nrOfAffixes; ++i) {\n            newList = appendNodeToTree(newList, concatBuffer[i]);\n            newList.length += concatBuffer[i].length;\n            concatBuffer[i] = undefined;\n        }\n        newList.length = newSize;\n        newList.suffix = concatBuffer[nrOfAffixes];\n        newList.bits = setSuffix(concatBuffer[nrOfAffixes].length, newList.bits);\n        concatBuffer[nrOfAffixes] = undefined;\n        return newList;\n    }\n    else {\n        var leftSuffixSize = getSuffixSize(left);\n        if (leftSuffixSize > 0) {\n            newList = appendNodeToTree(newList, left.suffix.slice(0, leftSuffixSize));\n            newList.length += leftSuffixSize;\n        }\n        newList = appendNodeToTree(newList, right.prefix.slice(0, getPrefixSize(right)).reverse());\n        var newNode = concatSubTree(newList.root, getDepth(newList), right.root, getDepth(right), true);\n        var newDepth = getHeight(newNode);\n        setSizes(newNode, newDepth);\n        newList.root = newNode;\n        newList.offset &= ~(mask << (getDepth(left) * branchBits));\n        newList.length = newSize;\n        newList.bits = setSuffix(rightSuffixSize, setDepth(newDepth, newList.bits));\n        newList.suffix = right.suffix;\n        return newList;\n    }\n}\nexport function update(index, a, l) {\n    if (index < 0 || l.length <= index) {\n        return l;\n    }\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    var newList = cloneList(l);\n    if (index < prefixSize) {\n        var newPrefix = copyArray(newList.prefix);\n        newPrefix[newPrefix.length - index - 1] = a;\n        newList.prefix = newPrefix;\n    }\n    else if (index >= l.length - suffixSize) {\n        var newSuffix = copyArray(newList.suffix);\n        newSuffix[index - (l.length - suffixSize)] = a;\n        newList.suffix = newSuffix;\n    }\n    else {\n        newList.root = updateNode(l.root, getDepth(l), index - prefixSize, l.offset, a);\n    }\n    return newList;\n}\nexport function adjust(index, f, l) {\n    if (index < 0 || l.length <= index) {\n        return l;\n    }\n    return update(index, f(nth(index, l)), l);\n}\nvar newAffix;\nfunction sliceNode(node, index, depth, pathLeft, pathRight, childLeft, childRight) {\n    var array = node.array.slice(pathLeft, pathRight + 1);\n    if (childLeft !== undefined) {\n        array[0] = childLeft;\n    }\n    if (childRight !== undefined) {\n        array[array.length - 1] = childRight;\n    }\n    var sizes = node.sizes;\n    if (sizes !== undefined) {\n        sizes = sizes.slice(pathLeft, pathRight + 1);\n        var slicedOffLeft = pathLeft !== 0 ? node.sizes[pathLeft - 1] : 0;\n        if (childLeft !== undefined) {\n            if (childLeft.sizes !== undefined) {\n                var oldChild = node.array[pathLeft];\n                slicedOffLeft +=\n                    arrayLast(oldChild.sizes) - arrayLast(childLeft.sizes);\n            }\n            else {\n                slicedOffLeft += ((index - slicedOffLeft) & ~31) + 32;\n            }\n        }\n        for (var i = 0; i < sizes.length; ++i) {\n            sizes[i] -= slicedOffLeft;\n        }\n        if (childRight !== undefined) {\n            var slicedOffRight = sizeOfSubtree(node.array[pathRight], depth - 1) -\n                sizeOfSubtree(childRight, depth - 1);\n            sizes[sizes.length - 1] -= slicedOffRight;\n        }\n    }\n    return new Node(sizes, array);\n}\nvar newOffset = 0;\nfunction sliceLeft(tree, depth, index, offset, top) {\n    var _a = getPath(index, offset, depth, tree.sizes), path = _a.path, newIndex = _a.index, updatedOffset = _a.updatedOffset;\n    if (depth === 0) {\n        newAffix = tree.array.slice(path).reverse();\n        return undefined;\n    }\n    else {\n        var child = sliceLeft(tree.array[path], depth - 1, newIndex, updatedOffset, false);\n        if (child === undefined) {\n            ++path;\n            if (path === tree.array.length) {\n                return undefined;\n            }\n        }\n        if (tree.sizes === undefined && top === false) {\n            newOffset |= (32 - (tree.array.length - path)) << (depth * branchBits);\n        }\n        return sliceNode(tree, index, depth, path, tree.array.length - 1, child, undefined);\n    }\n}\nfunction sliceRight(node, depth, index, offset) {\n    var _a = getPath(index, offset, depth, node.sizes), path = _a.path, newIndex = _a.index;\n    if (depth === 0) {\n        newAffix = node.array.slice(0, path + 1);\n        return undefined;\n    }\n    else {\n        var child = sliceRight(node.array[path], depth - 1, newIndex, path === 0 ? offset : 0);\n        if (child === undefined) {\n            --path;\n            if (path === -1) {\n                return undefined;\n            }\n        }\n        var array = node.array.slice(0, path + 1);\n        if (child !== undefined) {\n            array[array.length - 1] = child;\n        }\n        var sizes = node.sizes;\n        if (sizes !== undefined) {\n            sizes = sizes.slice(0, path + 1);\n            if (child !== undefined) {\n                var slicedOff = sizeOfSubtree(node.array[path], depth - 1) -\n                    sizeOfSubtree(child, depth - 1);\n                sizes[sizes.length - 1] -= slicedOff;\n            }\n        }\n        return new Node(sizes, array);\n    }\n}\nfunction sliceTreeList(from, to, tree, depth, offset, l) {\n    var sizes = tree.sizes;\n    var _a = getPath(from, offset, depth, sizes), pathLeft = _a.path, newFrom = _a.index;\n    var _b = getPath(to, offset, depth, sizes), pathRight = _b.path, newTo = _b.index;\n    if (depth === 0) {\n        l.prefix = emptyAffix;\n        l.suffix = tree.array.slice(pathLeft, pathRight + 1);\n        l.root = undefined;\n        l.bits = setSuffix(pathRight - pathLeft + 1, 0);\n        return l;\n    }\n    else if (pathLeft === pathRight) {\n        l.bits = decrementDepth(l.bits);\n        return sliceTreeList(newFrom, newTo, tree.array[pathLeft], depth - 1, pathLeft === 0 ? offset : 0, l);\n    }\n    else {\n        var childRight = sliceRight(tree.array[pathRight], depth - 1, newTo, 0);\n        l.bits = setSuffix(newAffix.length, l.bits);\n        l.suffix = newAffix;\n        if (childRight === undefined) {\n            --pathRight;\n        }\n        newOffset = 0;\n        var childLeft = sliceLeft(tree.array[pathLeft], depth - 1, newFrom, pathLeft === 0 ? offset : 0, pathLeft === pathRight);\n        l.offset = newOffset;\n        l.bits = setPrefix(newAffix.length, l.bits);\n        l.prefix = newAffix;\n        if (childLeft === undefined) {\n            ++pathLeft;\n        }\n        if (pathLeft >= pathRight) {\n            if (pathLeft > pathRight) {\n                l.bits = setDepth(0, l.bits);\n                l.root = undefined;\n            }\n            else {\n                l.bits = decrementDepth(l.bits);\n                var newRoot = childRight !== undefined\n                    ? childRight\n                    : childLeft !== undefined\n                        ? childLeft\n                        : tree.array[pathLeft];\n                l.root = new Node(newRoot.sizes, newRoot.array);\n            }\n        }\n        else {\n            l.root = sliceNode(tree, from, depth, pathLeft, pathRight, childLeft, childRight);\n        }\n        return l;\n    }\n}\nexport function slice(from, to, l) {\n    var bits = l.bits, length = l.length;\n    to = Math.min(length, to);\n    if (from < 0) {\n        from = length + from;\n    }\n    if (to < 0) {\n        to = length + to;\n    }\n    if (to <= from || to <= 0 || length <= from) {\n        return empty();\n    }\n    if (from <= 0 && length <= to) {\n        return l;\n    }\n    var newLength = to - from;\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    if (to <= prefixSize) {\n        return new List(setPrefix(newLength, 0), 0, newLength, l.prefix.slice(prefixSize - to, prefixSize - from), undefined, emptyAffix);\n    }\n    var suffixStart = length - suffixSize;\n    if (suffixStart <= from) {\n        return new List(setSuffix(newLength, 0), 0, newLength, emptyAffix, undefined, l.suffix.slice(from - suffixStart, to - suffixStart));\n    }\n    var newList = cloneList(l);\n    newList.length = newLength;\n    if (prefixSize <= from && to <= suffixStart) {\n        sliceTreeList(from - prefixSize + l.offset, to - prefixSize + l.offset - 1, l.root, getDepth(l), l.offset, newList);\n        return newList;\n    }\n    if (0 < from) {\n        if (from < prefixSize) {\n            newList.prefix = l.prefix.slice(0, prefixSize - from);\n            bits = setPrefix(prefixSize - from, bits);\n        }\n        else {\n            newOffset = 0;\n            newList.root = sliceLeft(newList.root, getDepth(l), from - prefixSize, l.offset, true);\n            newList.offset = newOffset;\n            if (newList.root === undefined) {\n                bits = setDepth(0, bits);\n            }\n            bits = setPrefix(newAffix.length, bits);\n            prefixSize = newAffix.length;\n            newList.prefix = newAffix;\n        }\n    }\n    if (to < length) {\n        if (length - to < suffixSize) {\n            bits = setSuffix(suffixSize - (length - to), bits);\n            newList.suffix = l.suffix.slice(0, suffixSize - (length - to));\n        }\n        else {\n            newList.root = sliceRight(newList.root, getDepth(l), to - prefixSize - 1, newList.offset);\n            if (newList.root === undefined) {\n                bits = setDepth(0, bits);\n                newList.offset = 0;\n            }\n            bits = setSuffix(newAffix.length, bits);\n            newList.suffix = newAffix;\n        }\n    }\n    newList.bits = bits;\n    return newList;\n}\nexport function take(n, l) {\n    return slice(0, n, l);\n}\nfunction findNotIndexCb(value, state) {\n    if (state.predicate(value)) {\n        ++state.index;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function takeWhile(predicate, l) {\n    var index = foldlCb(findNotIndexCb, { predicate: predicate, index: 0 }, l).index;\n    return slice(0, index, l);\n}\nexport function takeLastWhile(predicate, l) {\n    var index = foldrCb(findNotIndexCb, { predicate: predicate, index: 0 }, l).index;\n    return slice(l.length - index, l.length, l);\n}\nexport function dropWhile(predicate, l) {\n    var index = foldlCb(findNotIndexCb, { predicate: predicate, index: 0 }, l).index;\n    return slice(index, l.length, l);\n}\nexport function dropRepeats(l) {\n    return dropRepeatsWith(elementEquals, l);\n}\nexport function dropRepeatsWith(predicate, l) {\n    return foldl(function (acc, a) {\n        return acc.length !== 0 && predicate(last(acc), a) ? acc : push(a, acc);\n    }, emptyPushable(), l);\n}\nexport function takeLast(n, l) {\n    return slice(l.length - n, l.length, l);\n}\nexport function splitAt(index, l) {\n    return [slice(0, index, l), slice(index, l.length, l)];\n}\nexport function splitWhen(predicate, l) {\n    var idx = findIndex(predicate, l);\n    return idx === -1 ? [l, empty()] : splitAt(idx, l);\n}\nexport function splitEvery(size, l) {\n    var _a = foldl(function (_a, elm) {\n        var l2 = _a.l2, buffer = _a.buffer;\n        push(elm, buffer);\n        if (buffer.length === size) {\n            return { l2: push(buffer, l2), buffer: emptyPushable() };\n        }\n        else {\n            return { l2: l2, buffer: buffer };\n        }\n    }, { l2: emptyPushable(), buffer: emptyPushable() }, l), l2 = _a.l2, buffer = _a.buffer;\n    return buffer.length === 0 ? l2 : push(buffer, l2);\n}\nexport function remove(from, amount, l) {\n    return concat(slice(0, from, l), slice(from + amount, l.length, l));\n}\nexport function drop(n, l) {\n    return slice(n, l.length, l);\n}\nexport function dropLast(n, l) {\n    return slice(0, l.length - n, l);\n}\nexport function pop(l) {\n    return slice(0, -1, l);\n}\nexport var init = pop;\nexport function tail(l) {\n    return slice(1, l.length, l);\n}\nfunction arrayPush(array, a) {\n    array.push(a);\n    return array;\n}\nexport function toArray(l) {\n    return foldl(arrayPush, [], l);\n}\nexport function insert(index, element, l) {\n    return concat(append(element, slice(0, index, l)), slice(index, l.length, l));\n}\nexport function insertAll(index, elements, l) {\n    return concat(concat(slice(0, index, l), elements), slice(index, l.length, l));\n}\nexport function reverse(l) {\n    return foldl(function (newL, element) { return prepend(element, newL); }, empty(), l);\n}\nexport function isList(l) {\n    return typeof l === \"object\" && Array.isArray(l.suffix);\n}\nexport function zip(as, bs) {\n    return zipWith(function (a, b) { return [a, b]; }, as, bs);\n}\nexport function zipWith(f, as, bs) {\n    var swapped = bs.length < as.length;\n    var iterator = (swapped ? as : bs)[Symbol.iterator]();\n    return map(function (a) {\n        var b = iterator.next().value;\n        return swapped ? f(b, a) : f(a, b);\n    }, (swapped ? bs : as));\n}\nfunction isPrimitive(value) {\n    return typeof value === \"number\" || typeof value === \"string\";\n}\nfunction comparePrimitive(a, b) {\n    return a === b ? 0 : a < b ? -1 : 1;\n}\nvar ord = \"fantasy-land/lte\";\nfunction compareOrd(a, b) {\n    return a[ord](b) ? (b[ord](a) ? 0 : -1) : 1;\n}\nexport function sort(l) {\n    if (l.length === 0) {\n        return l;\n    }\n    else if (isPrimitive(first(l))) {\n        return from(toArray(l).sort(comparePrimitive));\n    }\n    else {\n        return sortWith(compareOrd, l);\n    }\n}\nexport function sortWith(comparator, l) {\n    var arr = [];\n    var i = 0;\n    forEach(function (elm) { return arr.push({ idx: i++, elm: elm }); }, l);\n    arr.sort(function (_a, _b) {\n        var a = _a.elm, i = _a.idx;\n        var b = _b.elm, j = _b.idx;\n        var c = comparator(a, b);\n        return c !== 0 ? c : i < j ? -1 : 1;\n    });\n    var newL = emptyPushable();\n    for (var i_3 = 0; i_3 < arr.length; ++i_3) {\n        push(arr[i_3].elm, newL);\n    }\n    return newL;\n}\nexport function sortBy(f, l) {\n    if (l.length === 0) {\n        return l;\n    }\n    var arr = [];\n    var i = 0;\n    forEach(function (elm) { return arr.push({ idx: i++, elm: elm, prop: f(elm) }); }, l);\n    var comparator = isPrimitive(arr[0].prop)\n        ? comparePrimitive\n        : compareOrd;\n    arr.sort(function (_a, _b) {\n        var a = _a.prop, i = _a.idx;\n        var b = _b.prop, j = _b.idx;\n        var c = comparator(a, b);\n        return c !== 0 ? c : i < j ? -1 : 1;\n    });\n    var newL = emptyPushable();\n    for (var i_4 = 0; i_4 < arr.length; ++i_4) {\n        push(arr[i_4].elm, newL);\n    }\n    return newL;\n}\nexport function group(l) {\n    return groupWith(elementEquals, l);\n}\nexport function groupWith(f, l) {\n    var result = emptyPushable();\n    var buffer = emptyPushable();\n    forEach(function (a) {\n        if (buffer.length !== 0 && !f(last(buffer), a)) {\n            push(buffer, result);\n            buffer = emptyPushable();\n        }\n        push(a, buffer);\n    }, l);\n    return buffer.length === 0 ? result : push(buffer, result);\n}\nexport function intersperse(separator, l) {\n    return pop(foldl(function (l2, a) { return push(separator, push(a, l2)); }, emptyPushable(), l));\n}\nexport function isEmpty(l) {\n    return l.length === 0;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}