{"ast":null,"code":"/**\n * Handle every persistence-related task\n * The interface Datastore expects to be implemented is\n * * Persistence.loadDatabase(callback) and callback has signature err\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\n */\n\nvar storage = require('./storage'),\n  path = require('path'),\n  model = require('./model'),\n  async = require('async'),\n  customUtils = require('./customUtils'),\n  Index = require('./indexes');\n\n/**\n * Create a new Persistence object for database options.db\n * @param {Datastore} options.db\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n */\nfunction Persistence(options) {\n  var i, j, randomString;\n  this.db = options.db;\n  this.inMemoryOnly = this.db.inMemoryOnly;\n  this.filename = this.db.filename;\n  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;\n  if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === '~') {\n    throw new Error(\"The datafile name can't end with a ~, which is reserved for crash safe backup files\");\n  }\n\n  // After serialization and before deserialization hooks with some basic sanity checks\n  if (options.afterSerialization && !options.beforeDeserialization) {\n    throw new Error(\"Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  if (!options.afterSerialization && options.beforeDeserialization) {\n    throw new Error(\"Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  this.afterSerialization = options.afterSerialization || function (s) {\n    return s;\n  };\n  this.beforeDeserialization = options.beforeDeserialization || function (s) {\n    return s;\n  };\n  for (i = 1; i < 30; i += 1) {\n    for (j = 0; j < 10; j += 1) {\n      randomString = customUtils.uid(i);\n      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {\n        throw new Error(\"beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss\");\n      }\n    }\n  }\n\n  // For NW apps, store data in the same directory where NW stores application data\n  if (this.filename && options.nodeWebkitAppName) {\n    console.log(\"==================================================================\");\n    console.log(\"WARNING: The nodeWebkitAppName option is deprecated\");\n    console.log(\"To get the path to the directory where Node Webkit stores the data\");\n    console.log(\"for your app, use the internal nw.gui module like this\");\n    console.log(\"require('nw.gui').App.dataPath\");\n    console.log(\"See https://github.com/rogerwang/node-webkit/issues/500\");\n    console.log(\"==================================================================\");\n    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);\n  }\n}\n;\n\n/**\n * Check if a directory exists and create it on the fly if it is not the case\n * cb is optional, signature: err\n */\nPersistence.ensureDirectoryExists = function (dir, cb) {\n  var callback = cb || function () {};\n  storage.mkdirp(dir, function (err) {\n    return callback(err);\n  });\n};\n\n/**\n * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores\n * data for this application. Probably the best place to store data\n */\nPersistence.getNWAppFilename = function (appName, relativeFilename) {\n  var home;\n  switch (process.platform) {\n    case 'win32':\n    case 'win64':\n      home = process.env.LOCALAPPDATA || process.env.APPDATA;\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data folder\");\n      }\n      home = path.join(home, appName);\n      break;\n    case 'darwin':\n      home = process.env.HOME;\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data directory\");\n      }\n      home = path.join(home, 'Library', 'Application Support', appName);\n      break;\n    case 'linux':\n      home = process.env.HOME;\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data directory\");\n      }\n      home = path.join(home, '.config', appName);\n      break;\n    default:\n      throw new Error(\"Can't use the Node Webkit relative path for platform \" + process.platform);\n      break;\n  }\n  return path.join(home, 'nedb-data', relativeFilename);\n};\n\n/**\n * Persist cached database\n * This serves as a compaction function since the cache always contains only the number of documents in the collection\n * while the data file is append-only so it may grow larger\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.persistCachedDatabase = function (cb) {\n  var callback = cb || function () {},\n    toPersist = '',\n    self = this;\n  if (this.inMemoryOnly) {\n    return callback(null);\n  }\n  this.db.getAllData().forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n  Object.keys(this.db.indexes).forEach(function (fieldName) {\n    if (fieldName != \"_id\") {\n      // The special _id index is managed by datastore.js, the others need to be persisted\n      toPersist += self.afterSerialization(model.serialize({\n        $$indexCreated: {\n          fieldName: fieldName,\n          unique: self.db.indexes[fieldName].unique,\n          sparse: self.db.indexes[fieldName].sparse\n        }\n      })) + '\\n';\n    }\n  });\n  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    self.db.emit('compaction.done');\n    return callback(null);\n  });\n};\n\n/**\n * Queue a rewrite of the datafile\n */\nPersistence.prototype.compactDatafile = function () {\n  this.db.executor.push({\n    this: this,\n    fn: this.persistCachedDatabase,\n    arguments: []\n  });\n};\n\n/**\n * Set automatic compaction every interval ms\n * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds\n */\nPersistence.prototype.setAutocompactionInterval = function (interval) {\n  var self = this,\n    minInterval = 5000,\n    realInterval = Math.max(interval || 0, minInterval);\n  this.stopAutocompaction();\n  this.autocompactionIntervalId = setInterval(function () {\n    self.compactDatafile();\n  }, realInterval);\n};\n\n/**\n * Stop autocompaction (do nothing if autocompaction was not running)\n */\nPersistence.prototype.stopAutocompaction = function () {\n  if (this.autocompactionIntervalId) {\n    clearInterval(this.autocompactionIntervalId);\n  }\n};\n\n/**\n * Persist new state for the given newDocs (can be insertion, update or removal)\n * Use an append-only format\n * @param {Array} newDocs Can be empty if no doc was updated/removed\n * @param {Function} cb Optional, signature: err\n */\nPersistence.prototype.persistNewState = function (newDocs, cb) {\n  var self = this,\n    toPersist = '',\n    callback = cb || function () {};\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) {\n    return callback(null);\n  }\n  newDocs.forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n  if (toPersist.length === 0) {\n    return callback(null);\n  }\n  storage.appendFile(self.filename, toPersist, 'utf8', function (err) {\n    return callback(err);\n  });\n};\n\n/**\n * From a database's raw data, return the corresponding\n * machine understandable collection\n */\nPersistence.prototype.treatRawData = function (rawData) {\n  var data = rawData.split('\\n'),\n    dataById = {},\n    tdata = [],\n    i,\n    indexes = {},\n    corruptItems = -1 // Last line of every data file is usually blank so not really corrupt\n  ;\n  for (i = 0; i < data.length; i += 1) {\n    var doc;\n    try {\n      doc = model.deserialize(this.beforeDeserialization(data[i]));\n      if (doc._id) {\n        if (doc.$$deleted === true) {\n          delete dataById[doc._id];\n        } else {\n          dataById[doc._id] = doc;\n        }\n      } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != undefined) {\n        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;\n      } else if (typeof doc.$$indexRemoved === \"string\") {\n        delete indexes[doc.$$indexRemoved];\n      }\n    } catch (e) {\n      corruptItems += 1;\n    }\n  }\n\n  // A bit lenient on corruption\n  if (data.length > 0 && corruptItems / data.length > this.corruptAlertThreshold) {\n    throw new Error(\"More than \" + Math.floor(100 * this.corruptAlertThreshold) + \"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  Object.keys(dataById).forEach(function (k) {\n    tdata.push(dataById[k]);\n  });\n  return {\n    data: tdata,\n    indexes: indexes\n  };\n};\n\n/**\n * Load the database\n * 1) Create all indexes\n * 2) Insert all data\n * 3) Compact the database\n * This means pulling data out of the data file or creating it if it doesn't exist\n * Also, all data is persisted right away, which has the effect of compacting the database file\n * This operation is very quick at startup for a big collection (60ms for ~10k docs)\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.loadDatabase = function (cb) {\n  var callback = cb || function () {},\n    self = this;\n  self.db.resetIndexes();\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) {\n    return callback(null);\n  }\n  async.waterfall([function (cb) {\n    Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {\n      storage.ensureDatafileIntegrity(self.filename, function (err) {\n        storage.readFile(self.filename, 'utf8', function (err, rawData) {\n          if (err) {\n            return cb(err);\n          }\n          try {\n            var treatedData = self.treatRawData(rawData);\n          } catch (e) {\n            return cb(e);\n          }\n\n          // Recreate all indexes in the datafile\n          Object.keys(treatedData.indexes).forEach(function (key) {\n            self.db.indexes[key] = new Index(treatedData.indexes[key]);\n          });\n\n          // Fill cached database (i.e. all indexes) with data\n          try {\n            self.db.resetIndexes(treatedData.data);\n          } catch (e) {\n            self.db.resetIndexes(); // Rollback any index which didn't fail\n            return cb(e);\n          }\n          self.db.persistence.persistCachedDatabase(cb);\n        });\n      });\n    });\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    self.db.executor.processBuffer();\n    return callback(null);\n  });\n};\n\n// Interface\nmodule.exports = Persistence;","map":{"version":3,"names":["storage","require","path","model","async","customUtils","Index","Persistence","options","i","j","randomString","db","inMemoryOnly","filename","corruptAlertThreshold","undefined","charAt","length","Error","afterSerialization","beforeDeserialization","s","uid","nodeWebkitAppName","console","log","getNWAppFilename","ensureDirectoryExists","dir","cb","callback","mkdirp","err","appName","relativeFilename","home","process","platform","env","LOCALAPPDATA","APPDATA","join","HOME","prototype","persistCachedDatabase","toPersist","self","getAllData","forEach","doc","serialize","Object","keys","indexes","fieldName","$$indexCreated","unique","sparse","crashSafeWriteFile","emit","compactDatafile","executor","push","this","fn","arguments","setAutocompactionInterval","interval","minInterval","realInterval","Math","max","stopAutocompaction","autocompactionIntervalId","setInterval","clearInterval","persistNewState","newDocs","appendFile","treatRawData","rawData","data","split","dataById","tdata","corruptItems","deserialize","_id","$$deleted","$$indexRemoved","e","floor","k","loadDatabase","resetIndexes","waterfall","dirname","ensureDatafileIntegrity","readFile","treatedData","key","persistence","processBuffer","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/nedb/lib/persistence.js"],"sourcesContent":["/**\n * Handle every persistence-related task\n * The interface Datastore expects to be implemented is\n * * Persistence.loadDatabase(callback) and callback has signature err\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\n */\n\nvar storage = require('./storage')\n  , path = require('path')\n  , model = require('./model')\n  , async = require('async')\n  , customUtils = require('./customUtils')\n  , Index = require('./indexes')\n  ;\n\n\n/**\n * Create a new Persistence object for database options.db\n * @param {Datastore} options.db\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n */\nfunction Persistence (options) {\n  var i, j, randomString;\n\n  this.db = options.db;\n  this.inMemoryOnly = this.db.inMemoryOnly;\n  this.filename = this.db.filename;\n  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;\n\n  if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === '~') {\n    throw new Error(\"The datafile name can't end with a ~, which is reserved for crash safe backup files\");\n  }\n\n  // After serialization and before deserialization hooks with some basic sanity checks\n  if (options.afterSerialization && !options.beforeDeserialization) {\n    throw new Error(\"Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  if (!options.afterSerialization && options.beforeDeserialization) {\n    throw new Error(\"Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  this.afterSerialization = options.afterSerialization || function (s) { return s; };\n  this.beforeDeserialization = options.beforeDeserialization || function (s) { return s; };\n  for (i = 1; i < 30; i += 1) {\n    for (j = 0; j < 10; j += 1) {\n      randomString = customUtils.uid(i);\n      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {\n        throw new Error(\"beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss\");\n      }\n    }\n  }\n\n  // For NW apps, store data in the same directory where NW stores application data\n  if (this.filename && options.nodeWebkitAppName) {\n    console.log(\"==================================================================\");\n    console.log(\"WARNING: The nodeWebkitAppName option is deprecated\");\n    console.log(\"To get the path to the directory where Node Webkit stores the data\");\n    console.log(\"for your app, use the internal nw.gui module like this\");\n    console.log(\"require('nw.gui').App.dataPath\");\n    console.log(\"See https://github.com/rogerwang/node-webkit/issues/500\");\n    console.log(\"==================================================================\");\n    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);\n  }\n};\n\n\n/**\n * Check if a directory exists and create it on the fly if it is not the case\n * cb is optional, signature: err\n */\nPersistence.ensureDirectoryExists = function (dir, cb) {\n  var callback = cb || function () {}\n    ;\n\n  storage.mkdirp(dir, function (err) { return callback(err); });\n};\n\n\n\n\n/**\n * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores\n * data for this application. Probably the best place to store data\n */\nPersistence.getNWAppFilename = function (appName, relativeFilename) {\n  var home;\n\n  switch (process.platform) {\n    case 'win32':\n    case 'win64':\n      home = process.env.LOCALAPPDATA || process.env.APPDATA;\n      if (!home) { throw new Error(\"Couldn't find the base application data folder\"); }\n      home = path.join(home, appName);\n      break;\n    case 'darwin':\n      home = process.env.HOME;\n      if (!home) { throw new Error(\"Couldn't find the base application data directory\"); }\n      home = path.join(home, 'Library', 'Application Support', appName);\n      break;\n    case 'linux':\n      home = process.env.HOME;\n      if (!home) { throw new Error(\"Couldn't find the base application data directory\"); }\n      home = path.join(home, '.config', appName);\n      break;\n    default:\n      throw new Error(\"Can't use the Node Webkit relative path for platform \" + process.platform);\n      break;\n  }\n\n  return path.join(home, 'nedb-data', relativeFilename);\n}\n\n\n/**\n * Persist cached database\n * This serves as a compaction function since the cache always contains only the number of documents in the collection\n * while the data file is append-only so it may grow larger\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.persistCachedDatabase = function (cb) {\n  var callback = cb || function () {}\n    , toPersist = ''\n    , self = this\n    ;\n\n  if (this.inMemoryOnly) { return callback(null); }\n\n  this.db.getAllData().forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n  Object.keys(this.db.indexes).forEach(function (fieldName) {\n    if (fieldName != \"_id\") {   // The special _id index is managed by datastore.js, the others need to be persisted\n      toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName].unique, sparse: self.db.indexes[fieldName].sparse }})) + '\\n';\n    }\n  });\n\n  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {\n    if (err) { return callback(err); }\n    self.db.emit('compaction.done');\n    return callback(null);\n  });\n};\n\n\n/**\n * Queue a rewrite of the datafile\n */\nPersistence.prototype.compactDatafile = function () {\n  this.db.executor.push({ this: this, fn: this.persistCachedDatabase, arguments: [] });\n};\n\n\n/**\n * Set automatic compaction every interval ms\n * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds\n */\nPersistence.prototype.setAutocompactionInterval = function (interval) {\n  var self = this\n    , minInterval = 5000\n    , realInterval = Math.max(interval || 0, minInterval)\n    ;\n\n  this.stopAutocompaction();\n\n  this.autocompactionIntervalId = setInterval(function () {\n    self.compactDatafile();\n  }, realInterval);\n};\n\n\n/**\n * Stop autocompaction (do nothing if autocompaction was not running)\n */\nPersistence.prototype.stopAutocompaction = function () {\n  if (this.autocompactionIntervalId) { clearInterval(this.autocompactionIntervalId); }\n};\n\n\n/**\n * Persist new state for the given newDocs (can be insertion, update or removal)\n * Use an append-only format\n * @param {Array} newDocs Can be empty if no doc was updated/removed\n * @param {Function} cb Optional, signature: err\n */\nPersistence.prototype.persistNewState = function (newDocs, cb) {\n  var self = this\n    , toPersist = ''\n    , callback = cb || function () {}\n    ;\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) { return callback(null); }\n\n  newDocs.forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n\n  if (toPersist.length === 0) { return callback(null); }\n\n  storage.appendFile(self.filename, toPersist, 'utf8', function (err) {\n    return callback(err);\n  });\n};\n\n\n/**\n * From a database's raw data, return the corresponding\n * machine understandable collection\n */\nPersistence.prototype.treatRawData = function (rawData) {\n  var data = rawData.split('\\n')\n    , dataById = {}\n    , tdata = []\n    , i\n    , indexes = {}\n    , corruptItems = -1   // Last line of every data file is usually blank so not really corrupt\n    ;\n\n  for (i = 0; i < data.length; i += 1) {\n    var doc;\n\n    try {\n      doc = model.deserialize(this.beforeDeserialization(data[i]));\n      if (doc._id) {\n        if (doc.$$deleted === true) {\n          delete dataById[doc._id];\n        } else {\n          dataById[doc._id] = doc;\n        }\n      } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != undefined) {\n        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;\n      } else if (typeof doc.$$indexRemoved === \"string\") {\n        delete indexes[doc.$$indexRemoved];\n      }\n    } catch (e) {\n      corruptItems += 1;\n    }\n  }\n\n  // A bit lenient on corruption\n  if (data.length > 0 && corruptItems / data.length > this.corruptAlertThreshold) {\n    throw new Error(\"More than \" + Math.floor(100 * this.corruptAlertThreshold) + \"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  Object.keys(dataById).forEach(function (k) {\n    tdata.push(dataById[k]);\n  });\n\n  return { data: tdata, indexes: indexes };\n};\n\n\n/**\n * Load the database\n * 1) Create all indexes\n * 2) Insert all data\n * 3) Compact the database\n * This means pulling data out of the data file or creating it if it doesn't exist\n * Also, all data is persisted right away, which has the effect of compacting the database file\n * This operation is very quick at startup for a big collection (60ms for ~10k docs)\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.loadDatabase = function (cb) {\n  var callback = cb || function () {}\n    , self = this\n    ;\n\n  self.db.resetIndexes();\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) { return callback(null); }\n\n  async.waterfall([\n    function (cb) {\n      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {\n        storage.ensureDatafileIntegrity(self.filename, function (err) {\n          storage.readFile(self.filename, 'utf8', function (err, rawData) {\n            if (err) { return cb(err); }\n\n            try {\n              var treatedData = self.treatRawData(rawData);\n            } catch (e) {\n              return cb(e);\n            }\n\n            // Recreate all indexes in the datafile\n            Object.keys(treatedData.indexes).forEach(function (key) {\n              self.db.indexes[key] = new Index(treatedData.indexes[key]);\n            });\n\n            // Fill cached database (i.e. all indexes) with data\n            try {\n              self.db.resetIndexes(treatedData.data);\n            } catch (e) {\n              self.db.resetIndexes();   // Rollback any index which didn't fail\n              return cb(e);\n            }\n\n            self.db.persistence.persistCachedDatabase(cb);\n          });\n        });\n      });\n    }\n  ], function (err) {\n       if (err) { return callback(err); }\n\n       self.db.executor.processBuffer();\n       return callback(null);\n     });\n};\n\n\n// Interface\nmodule.exports = Persistence;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}