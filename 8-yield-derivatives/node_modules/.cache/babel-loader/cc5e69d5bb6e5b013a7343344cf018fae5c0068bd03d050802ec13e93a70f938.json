{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Message = exports.__validateEncryptedMessageLength = void 0;\nconst _types_1 = require(\"./_types\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst util_1 = require(\"@radixdlt/util\");\nconst sealedMessage_1 = require(\"./sealedMessage\");\nconst utils_1 = require(\"../utils\");\nconst elliptic_curve_1 = require(\"../elliptic-curve\");\nconst messageEncryption_1 = require(\"./messageEncryption\");\nconst maxLengthEncryptedMessage = 255;\nconst minLengthEncryptedMessage = sealedMessage_1.SealedMessage.authTagByteCount + sealedMessage_1.SealedMessage.nonceByteCount + elliptic_curve_1.PublicKey.compressedByteCount + _types_1.ENCRYPTION_SCHEME_BYTES + _types_1.MESSAGE_TYPE_BYTES;\nconst maxLengthOfCipherTextOfSealedMsg = maxLengthEncryptedMessage - minLengthEncryptedMessage;\nconst isPlaintext = rawHex => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.PLAINTEXT;\nconst isEncrypted = rawHex => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.ENCRYPTED;\nconst isHexEncoded = rawHex => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.HEX;\nconst __validateEncryptedMessageMaxLength = utils_1.validateMaxLength.bind(null, maxLengthEncryptedMessage, 'encryptedMessage');\nconst __validateEncryptedMessageMinLength = utils_1.validateMinLength.bind(null, minLengthEncryptedMessage, 'encryptedMessage');\nconst __validateEncryptedMessageLength = buffer => (0, neverthrow_1.combine)([__validateEncryptedMessageMaxLength(buffer), __validateEncryptedMessageMinLength(buffer)]).map(_ => buffer);\nexports.__validateEncryptedMessageLength = __validateEncryptedMessageLength;\nconst createEncrypted = (encryptionScheme, sealedMessage) => (0, exports.__validateEncryptedMessageLength)(Buffer.concat([Buffer.from([_types_1.MessageType.ENCRYPTED]), Buffer.from([encryptionScheme]), sealedMessage.combined()])).map(combinedBuffer => ({\n  kind: 'ENCRYPTED',\n  messageType: _types_1.MessageType.ENCRYPTED,\n  encryptionScheme,\n  sealedMessage,\n  combined: () => combinedBuffer\n}));\nconst createPlaintext = message => ({\n  kind: 'PLAINTEXT',\n  plaintext: (0, util_1.isString)(message) ? message : message.toString('utf8'),\n  bytes: Buffer.concat([Buffer.from([_types_1.MessageType.PLAINTEXT]), Buffer.from([_types_1.EncryptionScheme.NONE]), messageEncryption_1.MessageEncryption.encodePlaintext(message)])\n});\nconst plaintextToString = (plaintext, startAt = 2) => Buffer.from(plaintext.slice(startAt).toString('hex'), 'hex').toString('utf-8');\nconst fromBuffer = buf => (0, exports.__validateEncryptedMessageLength)(buf).andThen(buffer => {\n  const readNextBuffer = (0, util_1.readBuffer)(buf);\n  const messageTypeResult = readNextBuffer(_types_1.MESSAGE_TYPE_BYTES);\n  if (messageTypeResult.isErr()) return (0, neverthrow_1.err)(messageTypeResult.error);\n  const messageType = messageTypeResult.value.readUIntBE(0, 1);\n  if (!(messageType in _types_1.MessageType)) return (0, neverthrow_1.err)(Error(`Unknown message type: ${messageType}`));\n  const schemeResult = readNextBuffer(_types_1.ENCRYPTION_SCHEME_BYTES);\n  if (schemeResult.isErr()) return (0, neverthrow_1.err)(schemeResult.error);\n  const scheme = schemeResult.value.readUIntBE(0, 1);\n  if (!(scheme in _types_1.EncryptionScheme)) return (0, neverthrow_1.err)(Error(`Unknown encryption scheme: ${scheme}`));\n  const payloadResult = readNextBuffer(buffer.length - _types_1.ENCRYPTION_SCHEME_BYTES - _types_1.MESSAGE_TYPE_BYTES);\n  if (payloadResult.isErr()) return (0, neverthrow_1.err)(payloadResult.error);\n  const payload = payloadResult.value;\n  if (messageType === _types_1.MessageType.ENCRYPTED && scheme !== _types_1.EncryptionScheme.NONE) {\n    const sealedMessageResult = sealedMessage_1.SealedMessage.fromBuffer(payload);\n    if (sealedMessageResult.isErr()) return (0, neverthrow_1.err)(sealedMessageResult.error);\n    return createEncrypted(scheme, sealedMessageResult.value);\n  }\n  if (messageType === _types_1.MessageType.PLAINTEXT && scheme === _types_1.EncryptionScheme.NONE) {\n    return (0, neverthrow_1.ok)(createPlaintext(payload));\n  }\n  return (0, neverthrow_1.err)(Error(`Invalid combination of message type ${messageType} and encryption scheme ${scheme}.`));\n});\nexports.Message = {\n  maxLength: maxLengthEncryptedMessage,\n  maxLengthOfCipherTextOfSealedMsg,\n  minLengthEncryptedMessage,\n  createEncrypted,\n  createPlaintext,\n  fromBuffer,\n  plaintextToString,\n  isPlaintext,\n  isEncrypted,\n  isHexEncoded\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","Message","__validateEncryptedMessageLength","_types_1","require","neverthrow_1","util_1","sealedMessage_1","utils_1","elliptic_curve_1","messageEncryption_1","maxLengthEncryptedMessage","minLengthEncryptedMessage","SealedMessage","authTagByteCount","nonceByteCount","PublicKey","compressedByteCount","ENCRYPTION_SCHEME_BYTES","MESSAGE_TYPE_BYTES","maxLengthOfCipherTextOfSealedMsg","isPlaintext","rawHex","parseInt","slice","MessageType","PLAINTEXT","isEncrypted","ENCRYPTED","isHexEncoded","HEX","__validateEncryptedMessageMaxLength","validateMaxLength","bind","__validateEncryptedMessageMinLength","validateMinLength","buffer","combine","map","_","createEncrypted","encryptionScheme","sealedMessage","Buffer","concat","from","combined","combinedBuffer","kind","messageType","createPlaintext","message","plaintext","isString","toString","bytes","EncryptionScheme","NONE","MessageEncryption","encodePlaintext","plaintextToString","startAt","fromBuffer","buf","andThen","readNextBuffer","readBuffer","messageTypeResult","isErr","err","error","readUIntBE","Error","schemeResult","scheme","payloadResult","length","payload","sealedMessageResult","ok","maxLength"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/dist/encryption/message.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Message = exports.__validateEncryptedMessageLength = void 0;\nconst _types_1 = require(\"./_types\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst util_1 = require(\"@radixdlt/util\");\nconst sealedMessage_1 = require(\"./sealedMessage\");\nconst utils_1 = require(\"../utils\");\nconst elliptic_curve_1 = require(\"../elliptic-curve\");\nconst messageEncryption_1 = require(\"./messageEncryption\");\nconst maxLengthEncryptedMessage = 255;\nconst minLengthEncryptedMessage = sealedMessage_1.SealedMessage.authTagByteCount +\n    sealedMessage_1.SealedMessage.nonceByteCount +\n    elliptic_curve_1.PublicKey.compressedByteCount +\n    _types_1.ENCRYPTION_SCHEME_BYTES +\n    _types_1.MESSAGE_TYPE_BYTES;\nconst maxLengthOfCipherTextOfSealedMsg = maxLengthEncryptedMessage - minLengthEncryptedMessage;\nconst isPlaintext = (rawHex) => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.PLAINTEXT;\nconst isEncrypted = (rawHex) => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.ENCRYPTED;\nconst isHexEncoded = (rawHex) => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.HEX;\nconst __validateEncryptedMessageMaxLength = utils_1.validateMaxLength.bind(null, maxLengthEncryptedMessage, 'encryptedMessage');\nconst __validateEncryptedMessageMinLength = utils_1.validateMinLength.bind(null, minLengthEncryptedMessage, 'encryptedMessage');\nconst __validateEncryptedMessageLength = (buffer) => (0, neverthrow_1.combine)([\n    __validateEncryptedMessageMaxLength(buffer),\n    __validateEncryptedMessageMinLength(buffer),\n]).map(_ => buffer);\nexports.__validateEncryptedMessageLength = __validateEncryptedMessageLength;\nconst createEncrypted = (encryptionScheme, sealedMessage) => (0, exports.__validateEncryptedMessageLength)(Buffer.concat([\n    Buffer.from([_types_1.MessageType.ENCRYPTED]),\n    Buffer.from([encryptionScheme]),\n    sealedMessage.combined(),\n])).map(combinedBuffer => ({\n    kind: 'ENCRYPTED',\n    messageType: _types_1.MessageType.ENCRYPTED,\n    encryptionScheme,\n    sealedMessage,\n    combined: () => combinedBuffer,\n}));\nconst createPlaintext = (message) => ({\n    kind: 'PLAINTEXT',\n    plaintext: (0, util_1.isString)(message) ? message : message.toString('utf8'),\n    bytes: Buffer.concat([\n        Buffer.from([_types_1.MessageType.PLAINTEXT]),\n        Buffer.from([_types_1.EncryptionScheme.NONE]),\n        messageEncryption_1.MessageEncryption.encodePlaintext(message),\n    ]),\n});\nconst plaintextToString = (plaintext, startAt = 2) => Buffer.from(plaintext.slice(startAt).toString('hex'), 'hex').toString('utf-8');\nconst fromBuffer = (buf) => (0, exports.__validateEncryptedMessageLength)(buf).andThen((buffer) => {\n    const readNextBuffer = (0, util_1.readBuffer)(buf);\n    const messageTypeResult = readNextBuffer(_types_1.MESSAGE_TYPE_BYTES);\n    if (messageTypeResult.isErr())\n        return (0, neverthrow_1.err)(messageTypeResult.error);\n    const messageType = messageTypeResult.value.readUIntBE(0, 1);\n    if (!(messageType in _types_1.MessageType))\n        return (0, neverthrow_1.err)(Error(`Unknown message type: ${messageType}`));\n    const schemeResult = readNextBuffer(_types_1.ENCRYPTION_SCHEME_BYTES);\n    if (schemeResult.isErr())\n        return (0, neverthrow_1.err)(schemeResult.error);\n    const scheme = schemeResult.value.readUIntBE(0, 1);\n    if (!(scheme in _types_1.EncryptionScheme))\n        return (0, neverthrow_1.err)(Error(`Unknown encryption scheme: ${scheme}`));\n    const payloadResult = readNextBuffer(buffer.length - _types_1.ENCRYPTION_SCHEME_BYTES - _types_1.MESSAGE_TYPE_BYTES);\n    if (payloadResult.isErr())\n        return (0, neverthrow_1.err)(payloadResult.error);\n    const payload = payloadResult.value;\n    if (messageType === _types_1.MessageType.ENCRYPTED &&\n        scheme !== _types_1.EncryptionScheme.NONE) {\n        const sealedMessageResult = sealedMessage_1.SealedMessage.fromBuffer(payload);\n        if (sealedMessageResult.isErr())\n            return (0, neverthrow_1.err)(sealedMessageResult.error);\n        return createEncrypted(scheme, sealedMessageResult.value);\n    }\n    if (messageType === _types_1.MessageType.PLAINTEXT &&\n        scheme === _types_1.EncryptionScheme.NONE) {\n        return (0, neverthrow_1.ok)(createPlaintext(payload));\n    }\n    return (0, neverthrow_1.err)(Error(`Invalid combination of message type ${messageType} and encryption scheme ${scheme}.`));\n});\nexports.Message = {\n    maxLength: maxLengthEncryptedMessage,\n    maxLengthOfCipherTextOfSealedMsg,\n    minLengthEncryptedMessage,\n    createEncrypted,\n    createPlaintext,\n    fromBuffer,\n    plaintextToString,\n    isPlaintext,\n    isEncrypted,\n    isHexEncoded,\n};\n//# sourceMappingURL=message.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}