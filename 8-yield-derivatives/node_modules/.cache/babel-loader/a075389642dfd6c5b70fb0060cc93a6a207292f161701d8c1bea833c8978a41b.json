{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HDNode = exports.HDMasterSeed = void 0;\nconst tslib_1 = require(\"tslib\");\nconst bip39_1 = require(\"bip39\");\nconst hdkey_1 = (0, tslib_1.__importDefault)(require(\"hdkey\"));\nconst neverthrow_1 = require(\"neverthrow\");\nconst privateKey_1 = require(\"../../privateKey\");\nconst hdNodeFromHDNodeThirdParty = hdNodeThirdParty => {\n  const privateKeyResult = privateKey_1.PrivateKey.fromBuffer(hdNodeThirdParty.privateKey);\n  if (privateKeyResult.isErr()) throw new Error(\"Incorrect implementation, failed to get private key from HDNode, third party lib 'hdkey' might be buggy?\");\n  const privateKey = privateKeyResult.value;\n  return {\n    privateKey,\n    publicKey: privateKey.publicKey(),\n    chainCode: hdNodeThirdParty.chainCode,\n    derive: path => hdNodeFromHDNodeThirdParty(hdNodeThirdParty.derive(path.toString())),\n    toJSON: () => hdNodeThirdParty.toJSON()\n  };\n};\nconst fromMnemonic = input => {\n  const seed = (0, bip39_1.mnemonicToSeedSync)(input.mnemonic.phrase, input.passphrase);\n  return fromSeed(seed);\n};\nconst fromSeed = seed => {\n  const hdNodeMaster = hdkey_1.default.fromMasterSeed(seed);\n  return {\n    seed,\n    masterNode: () => hdNodeFromHDNodeThirdParty(hdNodeMaster)\n  };\n};\nexports.HDMasterSeed = {\n  fromMnemonic,\n  fromSeed\n};\nconst fromExtendedPrivateKey = xpriv => {\n  try {\n    const hdKey = hdkey_1.default.fromJSON({\n      xpriv,\n      xpub: 'not used'\n    });\n    return (0, neverthrow_1.ok)(hdNodeFromHDNodeThirdParty(hdKey));\n  } catch (_a) {\n    return (0, neverthrow_1.err)(new Error('Failed to create HDNode from extended private key'));\n  }\n};\nexports.HDNode = {\n  fromExtendedPrivateKey\n};","map":{"version":3,"names":["bip39_1","require","hdkey_1","tslib_1","__importDefault","neverthrow_1","privateKey_1","hdNodeFromHDNodeThirdParty","hdNodeThirdParty","privateKeyResult","PrivateKey","fromBuffer","privateKey","isErr","Error","value","publicKey","chainCode","derive","path","toString","toJSON","fromMnemonic","input","seed","mnemonicToSeedSync","mnemonic","phrase","passphrase","fromSeed","hdNodeMaster","default","fromMasterSeed","masterNode","exports","HDMasterSeed","fromExtendedPrivateKey","xpriv","hdKey","fromJSON","xpub","ok","_a","err","HDNode"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/src/elliptic-curve/hd/bip39/hdMasterSeed.ts"],"sourcesContent":["import { HDMasterSeedT, HDNodeT, MnemomicT } from './_types'\nimport { mnemonicToSeedSync } from 'bip39'\nimport HDNodeThirdParty from 'hdkey'\nimport { BIP32T } from '../bip32'\nimport { Result, err, ok } from 'neverthrow'\nimport { PrivateKey } from '../../privateKey'\n\nconst hdNodeFromHDNodeThirdParty = (\n\thdNodeThirdParty: HDNodeThirdParty,\n): HDNodeT => {\n\tconst privateKeyResult = PrivateKey.fromBuffer(hdNodeThirdParty.privateKey)\n\tif (privateKeyResult.isErr())\n\t\tthrow new Error(\n\t\t\t`Incorrect implementation, failed to get private key from HDNode, third party lib 'hdkey' might be buggy?`,\n\t\t)\n\tconst privateKey = privateKeyResult.value\n\n\treturn {\n\t\tprivateKey,\n\t\tpublicKey: privateKey.publicKey(),\n\t\tchainCode: hdNodeThirdParty.chainCode,\n\t\tderive: (path: BIP32T): HDNodeT =>\n\t\t\thdNodeFromHDNodeThirdParty(\n\t\t\t\thdNodeThirdParty.derive(path.toString()),\n\t\t\t),\n\t\ttoJSON: () => hdNodeThirdParty.toJSON(),\n\t}\n}\n\nconst fromMnemonic = (\n\tinput: Readonly<{\n\t\tmnemonic: MnemomicT\n\t\tpassphrase?: string\n\t}>,\n): HDMasterSeedT => {\n\tconst seed = mnemonicToSeedSync(input.mnemonic.phrase, input.passphrase)\n\treturn fromSeed(seed)\n}\n\nconst fromSeed = (seed: Buffer): HDMasterSeedT => {\n\tconst hdNodeMaster = HDNodeThirdParty.fromMasterSeed(seed)\n\n\treturn {\n\t\tseed,\n\t\tmasterNode: (): HDNodeT => hdNodeFromHDNodeThirdParty(hdNodeMaster),\n\t}\n}\n\nexport const HDMasterSeed = {\n\tfromMnemonic,\n\tfromSeed,\n}\n\nconst fromExtendedPrivateKey = (xpriv: string): Result<HDNodeT, Error> => {\n\ttry {\n\t\tconst hdKey = HDNodeThirdParty.fromJSON({ xpriv, xpub: 'not used' })\n\t\treturn ok(hdNodeFromHDNodeThirdParty(hdKey))\n\t} catch {\n\t\treturn err(\n\t\t\tnew Error('Failed to create HDNode from extended private key'),\n\t\t)\n\t}\n}\n\nexport const HDNode = {\n\tfromExtendedPrivateKey,\n}\n"],"mappings":";;;;;;;AACA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,OAAA,OAAAC,OAAA,CAAAC,eAAA,EAAAH,OAAA;AAEA,MAAAI,YAAA,GAAAJ,OAAA;AACA,MAAAK,YAAA,GAAAL,OAAA;AAEA,MAAMM,0BAA0B,GAC/BC,gBAAkC,IACtB;EACZ,MAAMC,gBAAgB,GAAGH,YAAA,CAAAI,UAAU,CAACC,UAAU,CAACH,gBAAgB,CAACI,UAAU,CAAC;EAC3E,IAAIH,gBAAgB,CAACI,KAAK,EAAE,EAC3B,MAAM,IAAIC,KAAK,2GAC4F,CAC1G;EACF,MAAMF,UAAU,GAAGH,gBAAgB,CAACM,KAAK;EAEzC,OAAO;IACNH,UAAU;IACVI,SAAS,EAAEJ,UAAU,CAACI,SAAS,EAAE;IACjCC,SAAS,EAAET,gBAAgB,CAACS,SAAS;IACrCC,MAAM,EAAGC,IAAY,IACpBZ,0BAA0B,CACzBC,gBAAgB,CAACU,MAAM,CAACC,IAAI,CAACC,QAAQ,EAAE,CAAC,CACxC;IACFC,MAAM,EAAEA,CAAA,KAAMb,gBAAgB,CAACa,MAAM;GACrC;AACF,CAAC;AAED,MAAMC,YAAY,GACjBC,KAGE,IACgB;EAClB,MAAMC,IAAI,GAAG,IAAAxB,OAAA,CAAAyB,kBAAkB,EAACF,KAAK,CAACG,QAAQ,CAACC,MAAM,EAAEJ,KAAK,CAACK,UAAU,CAAC;EACxE,OAAOC,QAAQ,CAACL,IAAI,CAAC;AACtB,CAAC;AAED,MAAMK,QAAQ,GAAIL,IAAY,IAAmB;EAChD,MAAMM,YAAY,GAAG5B,OAAA,CAAA6B,OAAgB,CAACC,cAAc,CAACR,IAAI,CAAC;EAE1D,OAAO;IACNA,IAAI;IACJS,UAAU,EAAEA,CAAA,KAAe1B,0BAA0B,CAACuB,YAAY;GAClE;AACF,CAAC;AAEYI,OAAA,CAAAC,YAAY,GAAG;EAC3Bb,YAAY;EACZO;CACA;AAED,MAAMO,sBAAsB,GAAIC,KAAa,IAA4B;EACxE,IAAI;IACH,MAAMC,KAAK,GAAGpC,OAAA,CAAA6B,OAAgB,CAACQ,QAAQ,CAAC;MAAEF,KAAK;MAAEG,IAAI,EAAE;IAAU,CAAE,CAAC;IACpE,OAAO,IAAAnC,YAAA,CAAAoC,EAAE,EAAClC,0BAA0B,CAAC+B,KAAK,CAAC,CAAC;GAC5C,CAAC,OAAAI,EAAA,EAAM;IACP,OAAO,IAAArC,YAAA,CAAAsC,GAAG,EACT,IAAI7B,KAAK,CAAC,mDAAmD,CAAC,CAC9D;;AAEH,CAAC;AAEYoB,OAAA,CAAAU,MAAM,GAAG;EACrBR;CACA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}