{"ast":null,"code":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n/**\n    @fileOverview Hash Array Mapped Trie.\n\n    Code based on: https://github.com/exclipy/pdata\n*/\nvar hamt = {}; // export\n\n/* Configuration\n ******************************************************************************/\nvar SIZE = 5;\nvar BUCKET_SIZE = Math.pow(2, SIZE);\nvar MASK = BUCKET_SIZE - 1;\nvar MAX_INDEX_NODE = BUCKET_SIZE / 2;\nvar MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n\n/*\n ******************************************************************************/\nvar nothing = {};\nvar constant = function constant(x) {\n  return function () {\n    return x;\n  };\n};\n\n/**\n    Get 32 bit hash of string.\n\n    Based on:\n    http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n*/\nvar hash = hamt.hash = function (str) {\n  var type = typeof str === 'undefined' ? 'undefined' : _typeof(str);\n  if (type === 'number') return str;\n  if (type !== 'string') str += '';\n  var hash = 0;\n  for (var i = 0, len = str.length; i < len; ++i) {\n    var c = str.charCodeAt(i);\n    hash = (hash << 5) - hash + c | 0;\n  }\n  return hash;\n};\n\n/* Bit Ops\n ******************************************************************************/\n/**\n    Hamming weight.\n\n    Taken from: http://jsperf.com/hamming-weight\n*/\nvar popcount = function popcount(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n};\nvar hashFragment = function hashFragment(shift, h) {\n  return h >>> shift & MASK;\n};\nvar toBitmap = function toBitmap(x) {\n  return 1 << x;\n};\nvar fromBitmap = function fromBitmap(bitmap, bit) {\n  return popcount(bitmap & bit - 1);\n};\n\n/* Array Ops\n ******************************************************************************/\n/**\n    Set a value in an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to change.\n    @param v New value\n    @param arr Array.\n*/\nvar arrayUpdate = function arrayUpdate(mutate, at, v, arr) {\n  var out = arr;\n  if (!mutate) {\n    var len = arr.length;\n    out = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      out[i] = arr[i];\n    }\n  }\n  out[at] = v;\n  return out;\n};\n\n/**\n    Remove a value from an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to remove.\n    @param arr Array.\n*/\nvar arraySpliceOut = function arraySpliceOut(mutate, at, arr) {\n  var newLen = arr.length - 1;\n  var i = 0;\n  var g = 0;\n  var out = arr;\n  if (mutate) {\n    i = g = at;\n  } else {\n    out = new Array(newLen);\n    while (i < at) {\n      out[g++] = arr[i++];\n    }\n  }\n  ++i;\n  while (i <= newLen) {\n    out[g++] = arr[i++];\n  }\n  if (mutate) {\n    out.length = newLen;\n  }\n  return out;\n};\n\n/**\n    Insert a value into an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to insert at.\n    @param v Value to insert,\n    @param arr Array.\n*/\nvar arraySpliceIn = function arraySpliceIn(mutate, at, v, arr) {\n  var len = arr.length;\n  if (mutate) {\n    var _i = len;\n    while (_i >= at) {\n      arr[_i--] = arr[_i];\n    }\n    arr[at] = v;\n    return arr;\n  }\n  var i = 0,\n    g = 0;\n  var out = new Array(len + 1);\n  while (i < at) {\n    out[g++] = arr[i++];\n  }\n  out[at] = v;\n  while (i < len) {\n    out[++g] = arr[i++];\n  }\n  return out;\n};\n\n/* Node Structures\n ******************************************************************************/\nvar LEAF = 1;\nvar COLLISION = 2;\nvar INDEX = 3;\nvar ARRAY = 4;\n\n/**\n    Empty node.\n*/\nvar empty = {\n  __hamt_isEmpty: true\n};\nvar isEmptyNode = function isEmptyNode(x) {\n  return x === empty || x && x.__hamt_isEmpty;\n};\n\n/**\n    Leaf holding a value.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member key Key.\n    @member value Value stored.\n*/\nvar Leaf = function Leaf(edit, hash, key, value) {\n  return {\n    type: LEAF,\n    edit: edit,\n    hash: hash,\n    key: key,\n    value: value,\n    _modify: Leaf__modify\n  };\n};\n\n/**\n    Leaf holding multiple values with the same hash but different keys.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member children Array of collision children node.\n*/\nvar Collision = function Collision(edit, hash, children) {\n  return {\n    type: COLLISION,\n    edit: edit,\n    hash: hash,\n    children: children,\n    _modify: Collision__modify\n  };\n};\n\n/**\n    Internal node with a sparse set of children.\n\n    Uses a bitmap and array to pack children.\n\n  @member edit Edit of the node.\n    @member mask Bitmap that encode the positions of children in the array.\n    @member children Array of child nodes.\n*/\nvar IndexedNode = function IndexedNode(edit, mask, children) {\n  return {\n    type: INDEX,\n    edit: edit,\n    mask: mask,\n    children: children,\n    _modify: IndexedNode__modify\n  };\n};\n\n/**\n    Internal node with many children.\n\n    @member edit Edit of the node.\n    @member size Number of children.\n    @member children Array of child nodes.\n*/\nvar ArrayNode = function ArrayNode(edit, size, children) {\n  return {\n    type: ARRAY,\n    edit: edit,\n    size: size,\n    children: children,\n    _modify: ArrayNode__modify\n  };\n};\n\n/**\n    Is `node` a leaf node?\n*/\nvar isLeaf = function isLeaf(node) {\n  return node === empty || node.type === LEAF || node.type === COLLISION;\n};\n\n/* Internal node operations.\n ******************************************************************************/\n/**\n    Expand an indexed node into an array node.\n\n  @param edit Current edit.\n    @param frag Index of added child.\n    @param child Added child.\n    @param mask Index node mask before child added.\n    @param subNodes Index node children before child added.\n*/\nvar expand = function expand(edit, frag, child, bitmap, subNodes) {\n  var arr = [];\n  var bit = bitmap;\n  var count = 0;\n  for (var i = 0; bit; ++i) {\n    if (bit & 1) arr[i] = subNodes[count++];\n    bit >>>= 1;\n  }\n  arr[frag] = child;\n  return ArrayNode(edit, count + 1, arr);\n};\n\n/**\n    Collapse an array node into a indexed node.\n\n  @param edit Current edit.\n    @param count Number of elements in new array.\n    @param removed Index of removed element.\n    @param elements Array node children before remove.\n*/\nvar pack = function pack(edit, count, removed, elements) {\n  var children = new Array(count - 1);\n  var g = 0;\n  var bitmap = 0;\n  for (var i = 0, len = elements.length; i < len; ++i) {\n    if (i !== removed) {\n      var elem = elements[i];\n      if (elem && !isEmptyNode(elem)) {\n        children[g++] = elem;\n        bitmap |= 1 << i;\n      }\n    }\n  }\n  return IndexedNode(edit, bitmap, children);\n};\n\n/**\n    Merge two leaf nodes.\n\n    @param shift Current shift.\n    @param h1 Node 1 hash.\n    @param n1 Node 1.\n    @param h2 Node 2 hash.\n    @param n2 Node 2.\n*/\nvar mergeLeaves = function mergeLeaves(edit, shift, h1, n1, h2, n2) {\n  if (h1 === h2) return Collision(edit, h1, [n2, n1]);\n  var subH1 = hashFragment(shift, h1);\n  var subH2 = hashFragment(shift, h2);\n  return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);\n};\n\n/**\n    Update an entry in a collision list.\n\n    @param mutate Should mutation be used?\n    @param edit Current edit.\n    @param keyEq Key compare function.\n    @param hash Hash of collision.\n    @param list Collision list.\n    @param f Update function.\n    @param k Key to update.\n    @param size Size ref.\n*/\nvar updateCollisionList = function updateCollisionList(mutate, edit, keyEq, h, list, f, k, size) {\n  var len = list.length;\n  for (var i = 0; i < len; ++i) {\n    var child = list[i];\n    if (keyEq(k, child.key)) {\n      var value = child.value;\n      var _newValue = f(value);\n      if (_newValue === value) return list;\n      if (_newValue === nothing) {\n        --size.value;\n        return arraySpliceOut(mutate, i, list);\n      }\n      return arrayUpdate(mutate, i, Leaf(edit, h, k, _newValue), list);\n    }\n  }\n  var newValue = f();\n  if (newValue === nothing) return list;\n  ++size.value;\n  return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);\n};\nvar canEditNode = function canEditNode(edit, node) {\n  return edit === node.edit;\n};\n\n/* Editing\n ******************************************************************************/\nvar Leaf__modify = function Leaf__modify(edit, keyEq, shift, f, h, k, size) {\n  if (keyEq(k, this.key)) {\n    var _v = f(this.value);\n    if (_v === this.value) return this;else if (_v === nothing) {\n      --size.value;\n      return empty;\n    }\n    if (canEditNode(edit, this)) {\n      this.value = _v;\n      return this;\n    }\n    return Leaf(edit, h, k, _v);\n  }\n  var v = f();\n  if (v === nothing) return this;\n  ++size.value;\n  return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n};\nvar Collision__modify = function Collision__modify(edit, keyEq, shift, f, h, k, size) {\n  if (h === this.hash) {\n    var canEdit = canEditNode(edit, this);\n    var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);\n    if (list === this.children) return this;\n    return list.length > 1 ? Collision(edit, this.hash, list) : list[0]; // collapse single element collision list\n  }\n  var v = f();\n  if (v === nothing) return this;\n  ++size.value;\n  return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n};\nvar IndexedNode__modify = function IndexedNode__modify(edit, keyEq, shift, f, h, k, size) {\n  var mask = this.mask;\n  var children = this.children;\n  var frag = hashFragment(shift, h);\n  var bit = toBitmap(frag);\n  var indx = fromBitmap(mask, bit);\n  var exists = mask & bit;\n  var current = exists ? children[indx] : empty;\n  var child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n  if (current === child) return this;\n  var canEdit = canEditNode(edit, this);\n  var bitmap = mask;\n  var newChildren = void 0;\n  if (exists && isEmptyNode(child)) {\n    // remove\n    bitmap &= ~bit;\n    if (!bitmap) return empty;\n    if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1]; // collapse\n\n    newChildren = arraySpliceOut(canEdit, indx, children);\n  } else if (!exists && !isEmptyNode(child)) {\n    // add\n    if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);\n    bitmap |= bit;\n    newChildren = arraySpliceIn(canEdit, indx, child, children);\n  } else {\n    // modify\n    newChildren = arrayUpdate(canEdit, indx, child, children);\n  }\n  if (canEdit) {\n    this.mask = bitmap;\n    this.children = newChildren;\n    return this;\n  }\n  return IndexedNode(edit, bitmap, newChildren);\n};\nvar ArrayNode__modify = function ArrayNode__modify(edit, keyEq, shift, f, h, k, size) {\n  var count = this.size;\n  var children = this.children;\n  var frag = hashFragment(shift, h);\n  var child = children[frag];\n  var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n  if (child === newChild) return this;\n  var canEdit = canEditNode(edit, this);\n  var newChildren = void 0;\n  if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n    // add\n    ++count;\n    newChildren = arrayUpdate(canEdit, frag, newChild, children);\n  } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n    // remove\n    --count;\n    if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children);\n    newChildren = arrayUpdate(canEdit, frag, empty, children);\n  } else {\n    // modify\n    newChildren = arrayUpdate(canEdit, frag, newChild, children);\n  }\n  if (canEdit) {\n    this.size = count;\n    this.children = newChildren;\n    return this;\n  }\n  return ArrayNode(edit, count, newChildren);\n};\nempty._modify = function (edit, keyEq, shift, f, h, k, size) {\n  var v = f();\n  if (v === nothing) return empty;\n  ++size.value;\n  return Leaf(edit, h, k, v);\n};\n\n/*\n ******************************************************************************/\nfunction Map(editable, edit, config, root, size) {\n  this._editable = editable;\n  this._edit = edit;\n  this._config = config;\n  this._root = root;\n  this._size = size;\n}\n;\nMap.prototype.setTree = function (newRoot, newSize) {\n  if (this._editable) {\n    this._root = newRoot;\n    this._size = newSize;\n    return this;\n  }\n  return newRoot === this._root ? this : new Map(this._editable, this._edit, this._config, newRoot, newSize);\n};\n\n/* Queries\n ******************************************************************************/\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `alt` if none.\n*/\nvar tryGetHash = hamt.tryGetHash = function (alt, hash, key, map) {\n  var node = map._root;\n  var shift = 0;\n  var keyEq = map._config.keyEq;\n  while (true) {\n    switch (node.type) {\n      case LEAF:\n        {\n          return keyEq(key, node.key) ? node.value : alt;\n        }\n      case COLLISION:\n        {\n          if (hash === node.hash) {\n            var children = node.children;\n            for (var i = 0, len = children.length; i < len; ++i) {\n              var child = children[i];\n              if (keyEq(key, child.key)) return child.value;\n            }\n          }\n          return alt;\n        }\n      case INDEX:\n        {\n          var frag = hashFragment(shift, hash);\n          var bit = toBitmap(frag);\n          if (node.mask & bit) {\n            node = node.children[fromBitmap(node.mask, bit)];\n            shift += SIZE;\n            break;\n          }\n          return alt;\n        }\n      case ARRAY:\n        {\n          node = node.children[hashFragment(shift, hash)];\n          if (node) {\n            shift += SIZE;\n            break;\n          }\n          return alt;\n        }\n      default:\n        return alt;\n    }\n  }\n};\nMap.prototype.tryGetHash = function (alt, hash, key) {\n  return tryGetHash(alt, hash, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `tryGetHash`\n*/\nvar tryGet = hamt.tryGet = function (alt, key, map) {\n  return tryGetHash(alt, map._config.hash(key), key, map);\n};\nMap.prototype.tryGet = function (alt, key) {\n  return tryGet(alt, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `undefined` if none.\n*/\nvar getHash = hamt.getHash = function (hash, key, map) {\n  return tryGetHash(undefined, hash, key, map);\n};\nMap.prototype.getHash = function (hash, key) {\n  return getHash(hash, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `get`\n*/\nvar get = hamt.get = function (key, map) {\n  return tryGetHash(undefined, map._config.hash(key), key, map);\n};\nMap.prototype.get = function (key, alt) {\n  return tryGet(alt, key, this);\n};\n\n/**\n    Does an entry exist for `key` in `map`? Uses custom `hash`.\n*/\nvar hasHash = hamt.has = function (hash, key, map) {\n  return tryGetHash(nothing, hash, key, map) !== nothing;\n};\nMap.prototype.hasHash = function (hash, key) {\n  return hasHash(hash, key, this);\n};\n\n/**\n    Does an entry exist for `key` in `map`? Uses internal hash function.\n*/\nvar has = hamt.has = function (key, map) {\n  return hasHash(map._config.hash(key), key, map);\n};\nMap.prototype.has = function (key) {\n  return has(key, this);\n};\nvar defKeyCompare = function defKeyCompare(x, y) {\n  return x === y;\n};\n\n/**\n    Create an empty map.\n\n    @param config Configuration.\n*/\nhamt.make = function (config) {\n  return new Map(0, 0, {\n    keyEq: config && config.keyEq || defKeyCompare,\n    hash: config && config.hash || hash\n  }, empty, 0);\n};\n\n/**\n    Empty map.\n*/\nhamt.empty = hamt.make();\n\n/**\n    Does `map` contain any elements?\n*/\nvar isEmpty = hamt.isEmpty = function (map) {\n  return map && !!isEmptyNode(map._root);\n};\nMap.prototype.isEmpty = function () {\n  return isEmpty(this);\n};\n\n/* Updates\n ******************************************************************************/\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    custom hash.\n\n    `f` is invoked with the current value for `k` if it exists,\n    or no arguments if no such value exists. `modify` will always either\n    update or insert a value into the map.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\nvar modifyHash = hamt.modifyHash = function (f, hash, key, map) {\n  var size = {\n    value: map._size\n  };\n  var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash, key, size);\n  return map.setTree(newRoot, size.value);\n};\nMap.prototype.modifyHash = function (hash, key, f) {\n  return modifyHash(f, hash, key, this);\n};\n\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    internal hash function.\n\n    @see `modifyHash`\n*/\nvar modify = hamt.modify = function (f, key, map) {\n  return modifyHash(f, map._config.hash(key), key, map);\n};\nMap.prototype.modify = function (key, f) {\n  return modify(f, key, this);\n};\n\n/**\n    Store `value` for `key` in `map` using custom `hash`.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\nvar setHash = hamt.setHash = function (hash, key, value, map) {\n  return modifyHash(constant(value), hash, key, map);\n};\nMap.prototype.setHash = function (hash, key, value) {\n  return setHash(hash, key, value, this);\n};\n\n/**\n    Store `value` for `key` in `map` using internal hash function.\n\n    @see `setHash`\n*/\nvar set = hamt.set = function (key, value, map) {\n  return setHash(map._config.hash(key), key, value, map);\n};\nMap.prototype.set = function (key, value) {\n  return set(key, value, this);\n};\n\n/**\n    Remove the entry for `key` in `map`.\n\n    Returns a map with the value removed. Does not alter `map`.\n*/\nvar del = constant(nothing);\nvar removeHash = hamt.removeHash = function (hash, key, map) {\n  return modifyHash(del, hash, key, map);\n};\nMap.prototype.removeHash = Map.prototype.deleteHash = function (hash, key) {\n  return removeHash(hash, key, this);\n};\n\n/**\n    Remove the entry for `key` in `map` using internal hash function.\n\n    @see `removeHash`\n*/\nvar remove = hamt.remove = function (key, map) {\n  return removeHash(map._config.hash(key), key, map);\n};\nMap.prototype.remove = Map.prototype.delete = function (key) {\n  return remove(key, this);\n};\n\n/* Mutation\n ******************************************************************************/\n/**\n    Mark `map` as mutable.\n */\nvar beginMutation = hamt.beginMutation = function (map) {\n  return new Map(map._editable + 1, map._edit + 1, map._config, map._root, map._size);\n};\nMap.prototype.beginMutation = function () {\n  return beginMutation(this);\n};\n\n/**\n    Mark `map` as immutable.\n */\nvar endMutation = hamt.endMutation = function (map) {\n  map._editable = map._editable && map._editable - 1;\n  return map;\n};\nMap.prototype.endMutation = function () {\n  return endMutation(this);\n};\n\n/**\n    Mutate `map` within the context of `f`.\n    @param f\n    @param map HAMT\n*/\nvar mutate = hamt.mutate = function (f, map) {\n  var transient = beginMutation(map);\n  f(transient);\n  return endMutation(transient);\n};\nMap.prototype.mutate = function (f) {\n  return mutate(f, this);\n};\n\n/* Traversal\n ******************************************************************************/\n/**\n    Apply a continuation.\n*/\nvar appk = function appk(k) {\n  return k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);\n};\n\n/**\n    Recursively visit all values stored in an array of nodes lazily.\n*/\nvar lazyVisitChildren = function lazyVisitChildren(len, children, i, f, k) {\n  while (i < len) {\n    var child = children[i++];\n    if (child && !isEmptyNode(child)) return lazyVisit(child, f, [len, children, i, f, k]);\n  }\n  return appk(k);\n};\n\n/**\n    Recursively visit all values stored in `node` lazily.\n*/\nvar lazyVisit = function lazyVisit(node, f, k) {\n  switch (node.type) {\n    case LEAF:\n      return {\n        value: f(node),\n        rest: k\n      };\n    case COLLISION:\n    case ARRAY:\n    case INDEX:\n      var children = node.children;\n      return lazyVisitChildren(children.length, children, 0, f, k);\n    default:\n      return appk(k);\n  }\n};\nvar DONE = {\n  done: true\n};\n\n/**\n    Javascript iterator over a map.\n*/\nfunction MapIterator(v) {\n  this.v = v;\n}\n;\nMapIterator.prototype.next = function () {\n  if (!this.v) return DONE;\n  var v0 = this.v;\n  this.v = appk(v0.rest);\n  return v0;\n};\nMapIterator.prototype[Symbol.iterator] = function () {\n  return this;\n};\n\n/**\n    Lazily visit each value in map with function `f`.\n*/\nvar visit = function visit(map, f) {\n  return new MapIterator(lazyVisit(map._root, f));\n};\n\n/**\n    Get a Javascsript iterator of `map`.\n\n    Iterates over `[key, value]` arrays.\n*/\nvar buildPairs = function buildPairs(x) {\n  return [x.key, x.value];\n};\nvar entries = hamt.entries = function (map) {\n  return visit(map, buildPairs);\n};\nMap.prototype.entries = Map.prototype[Symbol.iterator] = function () {\n  return entries(this);\n};\n\n/**\n    Get array of all keys in `map`.\n\n    Order is not guaranteed.\n*/\nvar buildKeys = function buildKeys(x) {\n  return x.key;\n};\nvar keys = hamt.keys = function (map) {\n  return visit(map, buildKeys);\n};\nMap.prototype.keys = function () {\n  return keys(this);\n};\n\n/**\n    Get array of all values in `map`.\n\n    Order is not guaranteed, duplicates are preserved.\n*/\nvar buildValues = function buildValues(x) {\n  return x.value;\n};\nvar values = hamt.values = Map.prototype.values = function (map) {\n  return visit(map, buildValues);\n};\nMap.prototype.values = function () {\n  return values(this);\n};\n\n/* Fold\n ******************************************************************************/\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function mapping accumulated value, value, and key to new value.\n    @param z Starting value.\n    @param m HAMT\n*/\nvar fold = hamt.fold = function (f, z, m) {\n  var root = m._root;\n  if (root.type === LEAF) return f(z, root.value, root.key);\n  var toVisit = [root.children];\n  var children = void 0;\n  while (children = toVisit.pop()) {\n    for (var i = 0, len = children.length; i < len;) {\n      var child = children[i++];\n      if (child && child.type) {\n        if (child.type === LEAF) z = f(z, child.value, child.key);else toVisit.push(child.children);\n      }\n    }\n  }\n  return z;\n};\nMap.prototype.fold = function (f, z) {\n  return fold(f, z, this);\n};\n\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function invoked with value and key\n    @param map HAMT\n*/\nvar forEach = hamt.forEach = function (f, map) {\n  return fold(function (_, value, key) {\n    return f(value, key, map);\n  }, null, map);\n};\nMap.prototype.forEach = function (f) {\n  return forEach(f, this);\n};\n\n/* Aggregate\n ******************************************************************************/\n/**\n    Get the number of entries in `map`.\n*/\nvar count = hamt.count = function (map) {\n  return map._size;\n};\nMap.prototype.count = function () {\n  return count(this);\n};\nObject.defineProperty(Map.prototype, 'size', {\n  get: Map.prototype.count\n});\n\n/* Export\n ******************************************************************************/\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = hamt;\n} else if (typeof define === 'function' && define.amd) {\n  define('hamt', [], function () {\n    return hamt;\n  });\n} else {\n  undefined.hamt = hamt;\n}","map":{"version":3,"names":["hamt","SIZE","BUCKET_SIZE","Math","pow","MASK","MAX_INDEX_NODE","MIN_ARRAY_NODE","nothing","constant","x","hash","str","type","_typeof","i","len","length","c","charCodeAt","popcount","hashFragment","shift","h","toBitmap","fromBitmap","bitmap","bit","arrayUpdate","mutate","at","v","arr","out","Array","arraySpliceOut","newLen","g","arraySpliceIn","_i","LEAF","COLLISION","INDEX","ARRAY","empty","__hamt_isEmpty","isEmptyNode","Leaf","edit","key","value","_modify","Leaf__modify","Collision","children","Collision__modify","IndexedNode","mask","IndexedNode__modify","ArrayNode","size","ArrayNode__modify","isLeaf","node","expand","frag","child","subNodes","count","pack","removed","elements","elem","mergeLeaves","h1","n1","h2","n2","subH1","subH2","updateCollisionList","keyEq","list","f","k","_newValue","newValue","canEditNode","_v","canEdit","indx","exists","current","newChildren","newChild","Map","editable","config","root","_editable","_edit","_config","_root","_size","prototype","setTree","newRoot","newSize","tryGetHash","alt","map","tryGet","getHash","undefined","get","hasHash","has","defKeyCompare","y","make","isEmpty","modifyHash","NaN","modify","setHash","set","del","removeHash","deleteHash","remove","delete","beginMutation","endMutation","transient","appk","lazyVisitChildren","lazyVisit","rest","DONE","done","MapIterator","next","v0","Symbol","iterator","visit","buildPairs","entries","buildKeys","keys","buildValues","values","fold","z","m","toVisit","pop","push","forEach","_","Object","defineProperty","module","exports","define","amd"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/hamt_plus/hamt.js"],"sourcesContent":["/**\n    @fileOverview Hash Array Mapped Trie.\n\n    Code based on: https://github.com/exclipy/pdata\n*/\nconst hamt = {}; // export\n\n/* Configuration\n ******************************************************************************/\nconst SIZE = 5;\n\nconst BUCKET_SIZE = Math.pow(2, SIZE);\n\nconst MASK = BUCKET_SIZE - 1;\n\nconst MAX_INDEX_NODE = BUCKET_SIZE / 2;\n\nconst MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n\n/*\n ******************************************************************************/\nconst nothing = ({});\n\nconst constant = x => () => x;\n\n/**\n    Get 32 bit hash of string.\n\n    Based on:\n    http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n*/\nconst hash = hamt.hash = str => {\n    const type = typeof str;\n    if (type === 'number')\n        return str;\n    if (type !== 'string')\n        str += '';\n\n    let hash = 0;\n    for (let i = 0, len = str.length; i < len; ++i) {\n        const c = str.charCodeAt(i);\n        hash = (((hash << 5) - hash) + c) | 0;\n    }\n    return hash;\n};\n\n/* Bit Ops\n ******************************************************************************/\n/**\n    Hamming weight.\n\n    Taken from: http://jsperf.com/hamming-weight\n*/\nconst popcount = (x) => {\n    x -= ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x += (x >> 8);\n    x += (x >> 16);\n    return (x & 0x7f);\n};\n\nconst hashFragment = (shift, h) =>\n    (h >>> shift) & MASK;\n\nconst toBitmap = x =>\n    1 << x;\n\nconst fromBitmap = (bitmap, bit) =>\n    popcount(bitmap & (bit - 1));\n\n/* Array Ops\n ******************************************************************************/\n/**\n    Set a value in an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to change.\n    @param v New value\n    @param arr Array.\n*/\nconst arrayUpdate = (mutate, at, v, arr) => {\n    let out = arr;\n    if (!mutate) {\n        const len = arr.length;\n        out = new Array(len);\n        for (let i = 0; i < len; ++i)\n            out[i] = arr[i];\n    }\n    out[at] = v;\n    return out;\n};\n\n/**\n    Remove a value from an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to remove.\n    @param arr Array.\n*/\nconst arraySpliceOut = (mutate, at, arr) => {\n    const newLen = arr.length - 1;\n    let i = 0;\n    let g = 0;\n    let out = arr;\n    if (mutate) {\n        i = g = at;\n    } else {\n        out = new Array(newLen);\n        while (i < at)\n            out[g++] = arr[i++];\n    }\n    ++i;\n    while (i <= newLen)\n        out[g++] = arr[i++];\n    if (mutate) {\n        out.length = newLen;\n    }\n    return out;\n};\n\n/**\n    Insert a value into an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to insert at.\n    @param v Value to insert,\n    @param arr Array.\n*/\nconst arraySpliceIn = (mutate, at, v, arr) => {\n    const len = arr.length;\n    if (mutate) {\n        let i = len;\n        while (i >= at)\n            arr[i--] = arr[i];\n        arr[at] = v;\n        return arr;\n    }\n    let i = 0, g = 0;\n    const out = new Array(len + 1);\n    while (i < at)\n        out[g++] = arr[i++];\n    out[at] = v;\n    while (i < len)\n        out[++g] = arr[i++];\n    return out;\n};\n\n/* Node Structures\n ******************************************************************************/\nconst LEAF = 1;\nconst COLLISION = 2;\nconst INDEX = 3;\nconst ARRAY = 4;\n\n/**\n    Empty node.\n*/\nconst empty = ({\n    __hamt_isEmpty: true\n});\n\nconst isEmptyNode = x =>\n    x === empty || (x && x.__hamt_isEmpty);\n\n/**\n    Leaf holding a value.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member key Key.\n    @member value Value stored.\n*/\nconst Leaf = (edit, hash, key, value) => ({\n    type: LEAF,\n    edit: edit,\n    hash: hash,\n    key: key,\n    value: value,\n    _modify: Leaf__modify\n});\n\n/**\n    Leaf holding multiple values with the same hash but different keys.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member children Array of collision children node.\n*/\nconst Collision = (edit, hash, children) => ({\n    type: COLLISION,\n    edit: edit,\n    hash: hash,\n    children: children,\n    _modify: Collision__modify\n});\n\n/**\n    Internal node with a sparse set of children.\n\n    Uses a bitmap and array to pack children.\n\n  @member edit Edit of the node.\n    @member mask Bitmap that encode the positions of children in the array.\n    @member children Array of child nodes.\n*/\nconst IndexedNode = (edit, mask, children) => ({\n    type: INDEX,\n    edit: edit,\n    mask: mask,\n    children: children,\n    _modify: IndexedNode__modify\n});\n\n/**\n    Internal node with many children.\n\n    @member edit Edit of the node.\n    @member size Number of children.\n    @member children Array of child nodes.\n*/\nconst ArrayNode = (edit, size, children) => ({\n    type: ARRAY,\n    edit: edit,\n    size: size,\n    children: children,\n    _modify: ArrayNode__modify\n});\n\n/**\n    Is `node` a leaf node?\n*/\nconst isLeaf = node =>\n    (node === empty || node.type === LEAF || node.type === COLLISION);\n\n/* Internal node operations.\n ******************************************************************************/\n/**\n    Expand an indexed node into an array node.\n\n  @param edit Current edit.\n    @param frag Index of added child.\n    @param child Added child.\n    @param mask Index node mask before child added.\n    @param subNodes Index node children before child added.\n*/\nconst expand = (edit, frag, child, bitmap, subNodes) => {\n    const arr = [];\n    let bit = bitmap;\n    let count = 0;\n    for (let i = 0; bit; ++i) {\n        if (bit & 1)\n            arr[i] = subNodes[count++];\n        bit >>>= 1;\n    }\n    arr[frag] = child;\n    return ArrayNode(edit, count + 1, arr);\n};\n\n/**\n    Collapse an array node into a indexed node.\n\n  @param edit Current edit.\n    @param count Number of elements in new array.\n    @param removed Index of removed element.\n    @param elements Array node children before remove.\n*/\nconst pack = (edit, count, removed, elements) => {\n    const children = new Array(count - 1);\n    let g = 0;\n    let bitmap = 0;\n    for (let i = 0, len = elements.length; i < len; ++i) {\n        if (i !== removed) {\n            const elem = elements[i];\n            if (elem && !isEmptyNode(elem)) {\n                children[g++] = elem;\n                bitmap |= 1 << i;\n            }\n        }\n    }\n    return IndexedNode(edit, bitmap, children);\n};\n\n/**\n    Merge two leaf nodes.\n\n    @param shift Current shift.\n    @param h1 Node 1 hash.\n    @param n1 Node 1.\n    @param h2 Node 2 hash.\n    @param n2 Node 2.\n*/\nconst mergeLeaves = (edit, shift, h1, n1, h2, n2) => {\n    if (h1 === h2)\n        return Collision(edit, h1, [n2, n1]);\n\n    const subH1 = hashFragment(shift, h1);\n    const subH2 = hashFragment(shift, h2);\n    return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2),\n        subH1 === subH2\n            ? [mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)]\n            : subH1 < subH2 ? [n1, n2] : [n2, n1]);\n};\n\n/**\n    Update an entry in a collision list.\n\n    @param mutate Should mutation be used?\n    @param edit Current edit.\n    @param keyEq Key compare function.\n    @param hash Hash of collision.\n    @param list Collision list.\n    @param f Update function.\n    @param k Key to update.\n    @param size Size ref.\n*/\nconst updateCollisionList = (mutate, edit, keyEq, h, list, f, k, size) => {\n    const len = list.length;\n    for (let i = 0; i < len; ++i) {\n        const child = list[i];\n        if (keyEq(k, child.key)) {\n            const value = child.value;\n            const newValue = f(value);\n            if (newValue === value)\n                return list;\n\n            if (newValue === nothing) {\n                --size.value;\n                return arraySpliceOut(mutate, i, list);\n            }\n            return arrayUpdate(mutate, i, Leaf(edit, h, k, newValue), list);\n        }\n    }\n\n    const newValue = f();\n    if (newValue === nothing)\n        return list;\n    ++size.value;\n    return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);\n};\n\nconst canEditNode = (edit, node) => edit === node.edit;\n\n/* Editing\n ******************************************************************************/\nconst Leaf__modify = function (edit, keyEq, shift, f, h, k, size) {\n    if (keyEq(k, this.key)) {\n        const v = f(this.value);\n        if (v === this.value)\n            return this;\n        else if (v === nothing) {\n            --size.value;\n            return empty;\n        }\n        if (canEditNode(edit, this)) {\n            this.value = v;\n            return this;\n        }\n        return Leaf(edit, h, k, v);\n    }\n    const v = f();\n    if (v === nothing)\n        return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n};\n\nconst Collision__modify = function (edit, keyEq, shift, f, h, k, size) {\n    if (h === this.hash) {\n        const canEdit = canEditNode(edit, this);\n        const list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);\n        if (list === this.children)\n            return this;\n\n        return list.length > 1\n            ? Collision(edit, this.hash, list)\n            : list[0]; // collapse single element collision list\n    }\n    const v = f();\n    if (v === nothing)\n        return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n};\n\nconst IndexedNode__modify = function (edit, keyEq, shift, f, h, k, size) {\n    const mask = this.mask;\n    const children = this.children;\n    const frag = hashFragment(shift, h);\n    const bit = toBitmap(frag);\n    const indx = fromBitmap(mask, bit);\n    const exists = mask & bit;\n    const current = exists ? children[indx] : empty;\n    const child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (current === child)\n        return this;\n\n    const canEdit = canEditNode(edit, this);\n    let bitmap = mask;\n    let newChildren;\n    if (exists && isEmptyNode(child)) { // remove\n        bitmap &= ~bit;\n        if (!bitmap)\n            return empty;\n        if (children.length <= 2 && isLeaf(children[indx ^ 1]))\n            return children[indx ^ 1] // collapse\n\n        newChildren = arraySpliceOut(canEdit, indx, children);\n    } else if (!exists && !isEmptyNode(child)) { // add\n        if (children.length >= MAX_INDEX_NODE)\n            return expand(edit, frag, child, mask, children);\n\n        bitmap |= bit;\n        newChildren = arraySpliceIn(canEdit, indx, child, children);\n    } else { // modify\n        newChildren = arrayUpdate(canEdit, indx, child, children);\n    }\n\n    if (canEdit) {\n        this.mask = bitmap;\n        this.children = newChildren;\n        return this;\n    }\n    return IndexedNode(edit, bitmap, newChildren);\n};\n\nconst ArrayNode__modify = function (edit, keyEq, shift, f, h, k, size) {\n    let count = this.size;\n    const children = this.children;\n    const frag = hashFragment(shift, h);\n    const child = children[frag];\n    const newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (child === newChild)\n        return this;\n\n    const canEdit = canEditNode(edit, this);\n    let newChildren;\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) { // add\n        ++count;\n        newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) { // remove\n        --count;\n        if (count <= MIN_ARRAY_NODE)\n            return pack(edit, count, frag, children);\n        newChildren = arrayUpdate(canEdit, frag, empty, children);\n    } else { // modify\n        newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    }\n\n    if (canEdit) {\n        this.size = count;\n        this.children = newChildren;\n        return this;\n    }\n    return ArrayNode(edit, count, newChildren);\n};\n\nempty._modify = (edit, keyEq, shift, f, h, k, size) => {\n    const v = f();\n    if (v === nothing)\n        return empty;\n    ++size.value;\n    return Leaf(edit, h, k, v);\n};\n\n/*\n ******************************************************************************/\nfunction Map(editable, edit, config, root, size) {\n    this._editable = editable;\n    this._edit = edit;\n    this._config = config;\n    this._root = root;\n    this._size = size;\n};\n\nMap.prototype.setTree = function (newRoot, newSize) {\n    if (this._editable) {\n        this._root = newRoot;\n        this._size = newSize;\n        return this;\n    }\n    return newRoot === this._root\n        ? this\n        : new Map(this._editable, this._edit, this._config, newRoot, newSize);\n};\n\n/* Queries\n ******************************************************************************/\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `alt` if none.\n*/\nconst tryGetHash = hamt.tryGetHash = (alt, hash, key, map) => {\n    let node = map._root;\n    let shift = 0;\n    const keyEq = map._config.keyEq;\n    while (true) switch (node.type) {\n        case LEAF:\n            {\n                return keyEq(key, node.key) ? node.value : alt;\n            }\n        case COLLISION:\n            {\n                if (hash === node.hash) {\n                    const children = node.children;\n                    for (let i = 0, len = children.length; i < len; ++i) {\n                        const child = children[i];\n                        if (keyEq(key, child.key))\n                            return child.value;\n                    }\n                }\n                return alt;\n            }\n        case INDEX:\n            {\n                const frag = hashFragment(shift, hash);\n                const bit = toBitmap(frag);\n                if (node.mask & bit) {\n                    node = node.children[fromBitmap(node.mask, bit)]\n                    shift += SIZE;\n                    break;\n                }\n                return alt;\n            }\n        case ARRAY:\n            {\n                node = node.children[hashFragment(shift, hash)];\n                if (node) {\n                    shift += SIZE;\n                    break;\n                }\n                return alt;\n            }\n        default:\n            return alt;\n    }\n};\n\nMap.prototype.tryGetHash = function (alt, hash, key) {\n    return tryGetHash(alt, hash, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `tryGetHash`\n*/\nconst tryGet = hamt.tryGet = (alt, key, map) =>\n    tryGetHash(alt, map._config.hash(key), key, map);\n\nMap.prototype.tryGet = function (alt, key) {\n    return tryGet(alt, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `undefined` if none.\n*/\nconst getHash = hamt.getHash = (hash, key, map) =>\n    tryGetHash(undefined, hash, key, map);\n\nMap.prototype.getHash = function (hash, key) {\n    return getHash(hash, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `get`\n*/\nconst get = hamt.get = (key, map) =>\n    tryGetHash(undefined, map._config.hash(key), key, map);\n\nMap.prototype.get = function (key, alt) {\n    return tryGet(alt, key, this);\n};\n\n/**\n    Does an entry exist for `key` in `map`? Uses custom `hash`.\n*/\nconst hasHash = hamt.has = (hash, key, map) =>\n    tryGetHash(nothing, hash, key, map) !== nothing;\n\nMap.prototype.hasHash = function (hash, key) {\n    return hasHash(hash, key, this);\n};\n\n/**\n    Does an entry exist for `key` in `map`? Uses internal hash function.\n*/\nconst has = hamt.has = (key, map) =>\n    hasHash(map._config.hash(key), key, map);\n\nMap.prototype.has = function (key) {\n    return has(key, this);\n};\n\nconst defKeyCompare = (x, y) => x === y;\n\n/**\n    Create an empty map.\n\n    @param config Configuration.\n*/\nhamt.make = (config) =>\n    new Map(0, 0, {\n        keyEq: (config && config.keyEq) || defKeyCompare,\n        hash: (config && config.hash) || hash\n    }, empty, 0);\n\n/**\n    Empty map.\n*/\nhamt.empty = hamt.make();\n\n/**\n    Does `map` contain any elements?\n*/\nconst isEmpty = hamt.isEmpty = (map) =>\n    map && !!isEmptyNode(map._root);\n\nMap.prototype.isEmpty = function () {\n    return isEmpty(this);\n};\n\n/* Updates\n ******************************************************************************/\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    custom hash.\n\n    `f` is invoked with the current value for `k` if it exists,\n    or no arguments if no such value exists. `modify` will always either\n    update or insert a value into the map.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\nconst modifyHash = hamt.modifyHash = (f, hash, key, map) => {\n    const size = { value: map._size };\n    const newRoot = map._root._modify(\n        map._editable ? map._edit : NaN,\n        map._config.keyEq,\n        0,\n        f,\n        hash,\n        key,\n        size);\n    return map.setTree(newRoot, size.value);\n};\n\nMap.prototype.modifyHash = function (hash, key, f) {\n    return modifyHash(f, hash, key, this);\n};\n\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    internal hash function.\n\n    @see `modifyHash`\n*/\nconst modify = hamt.modify = (f, key, map) =>\n    modifyHash(f, map._config.hash(key), key, map);\n\nMap.prototype.modify = function (key, f) {\n    return modify(f, key, this);\n};\n\n/**\n    Store `value` for `key` in `map` using custom `hash`.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\nconst setHash = hamt.setHash = (hash, key, value, map) =>\n    modifyHash(constant(value), hash, key, map);\n\nMap.prototype.setHash = function (hash, key, value) {\n    return setHash(hash, key, value, this);\n};\n\n/**\n    Store `value` for `key` in `map` using internal hash function.\n\n    @see `setHash`\n*/\nconst set = hamt.set = (key, value, map) =>\n    setHash(map._config.hash(key), key, value, map);\n\nMap.prototype.set = function (key, value) {\n    return set(key, value, this);\n};\n\n/**\n    Remove the entry for `key` in `map`.\n\n    Returns a map with the value removed. Does not alter `map`.\n*/\nconst del = constant(nothing);\nconst removeHash = hamt.removeHash = (hash, key, map) =>\n    modifyHash(del, hash, key, map);\n\nMap.prototype.removeHash = Map.prototype.deleteHash = function (hash, key) {\n    return removeHash(hash, key, this);\n};\n\n/**\n    Remove the entry for `key` in `map` using internal hash function.\n\n    @see `removeHash`\n*/\nconst remove = hamt.remove = (key, map) =>\n    removeHash(map._config.hash(key), key, map);\n\nMap.prototype.remove = Map.prototype.delete = function (key) {\n    return remove(key, this);\n};\n\n/* Mutation\n ******************************************************************************/\n/**\n    Mark `map` as mutable.\n */\nconst beginMutation = hamt.beginMutation = (map) =>\n    new Map(\n        map._editable + 1,\n        map._edit + 1,\n        map._config,\n        map._root,\n        map._size);\n\nMap.prototype.beginMutation = function () {\n    return beginMutation(this);\n};\n\n/**\n    Mark `map` as immutable.\n */\nconst endMutation = hamt.endMutation = (map) => {\n    map._editable = map._editable && map._editable - 1;\n    return map;\n};\n\nMap.prototype.endMutation = function () {\n    return endMutation(this);\n};\n\n/**\n    Mutate `map` within the context of `f`.\n    @param f\n    @param map HAMT\n*/\nconst mutate = hamt.mutate = (f, map) => {\n    const transient = beginMutation(map);\n    f(transient);\n    return endMutation(transient);\n};\n\nMap.prototype.mutate = function (f) {\n    return mutate(f, this);\n};\n\n/* Traversal\n ******************************************************************************/\n/**\n    Apply a continuation.\n*/\nconst appk = k =>\n    k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);\n\n/**\n    Recursively visit all values stored in an array of nodes lazily.\n*/\nvar lazyVisitChildren = (len, children, i, f, k) => {\n    while (i < len) {\n        const child = children[i++];\n        if (child && !isEmptyNode(child))\n            return lazyVisit(child, f, [len, children, i, f, k]);\n    }\n    return appk(k);\n};\n\n/**\n    Recursively visit all values stored in `node` lazily.\n*/\nconst lazyVisit = (node, f, k) => {\n    switch (node.type) {\n        case LEAF:\n            return {\n                value: f(node),\n                rest: k\n            };\n\n        case COLLISION:\n        case ARRAY:\n        case INDEX:\n            const children = node.children;\n            return lazyVisitChildren(children.length, children, 0, f, k);\n\n        default:\n            return appk(k);\n    }\n};\n\nconst DONE = {\n    done: true\n};\n\n/**\n    Javascript iterator over a map.\n*/\nfunction MapIterator(v) {\n    this.v = v;\n};\n\nMapIterator.prototype.next = function () {\n    if (!this.v)\n        return DONE;\n    const v0 = this.v;\n    this.v = appk(v0.rest);\n    return v0;\n};\n\nMapIterator.prototype[Symbol.iterator] = function () {\n    return this;\n};\n\n/**\n    Lazily visit each value in map with function `f`.\n*/\nconst visit = (map, f) =>\n    new MapIterator(lazyVisit(map._root, f));\n\n/**\n    Get a Javascsript iterator of `map`.\n\n    Iterates over `[key, value]` arrays.\n*/\nconst buildPairs = (x) => [x.key, x.value];\nconst entries = hamt.entries = (map) =>\n    visit(map, buildPairs);\n\nMap.prototype.entries = Map.prototype[Symbol.iterator] = function () {\n    return entries(this);\n};\n\n/**\n    Get array of all keys in `map`.\n\n    Order is not guaranteed.\n*/\nconst buildKeys = (x) => x.key;\nconst keys = hamt.keys = (map) =>\n    visit(map, buildKeys);\n\nMap.prototype.keys = function () {\n    return keys(this);\n}\n\n/**\n    Get array of all values in `map`.\n\n    Order is not guaranteed, duplicates are preserved.\n*/\nconst buildValues = x => x.value;\nconst values = hamt.values = Map.prototype.values = map =>\n    visit(map, buildValues);\n\nMap.prototype.values = function () {\n    return values(this);\n};\n\n/* Fold\n ******************************************************************************/\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function mapping accumulated value, value, and key to new value.\n    @param z Starting value.\n    @param m HAMT\n*/\nconst fold = hamt.fold = (f, z, m) => {\n    const root = m._root;\n    if (root.type === LEAF)\n        return f(z, root.value, root.key);\n\n    const toVisit = [root.children];\n    let children;\n    while (children = toVisit.pop()) {\n        for (let i = 0, len = children.length; i < len;) {\n            const child = children[i++];\n            if (child && child.type) {\n                if (child.type === LEAF)\n                    z = f(z, child.value, child.key);\n                else\n                    toVisit.push(child.children);\n            }\n        }\n    }\n    return z;\n};\n\nMap.prototype.fold = function (f, z) {\n    return fold(f, z, this);\n};\n\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function invoked with value and key\n    @param map HAMT\n*/\nconst forEach = hamt.forEach = (f, map) =>\n    fold((_, value, key) => f(value, key, map), null, map);\n\nMap.prototype.forEach = function (f) {\n    return forEach(f, this);\n};\n\n/* Aggregate\n ******************************************************************************/\n/**\n    Get the number of entries in `map`.\n*/\nconst count = hamt.count = map =>\n    map._size;\n\nMap.prototype.count = function () {\n    return count(this);\n};\n\nObject.defineProperty(Map.prototype, 'size', {\n    get: Map.prototype.count\n});\n\n/* Export\n ******************************************************************************/\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = hamt;\n} else if (typeof define === 'function' && define.amd) {\n    define('hamt', [], () => hamt);\n} else {\n    this.hamt = hamt;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}