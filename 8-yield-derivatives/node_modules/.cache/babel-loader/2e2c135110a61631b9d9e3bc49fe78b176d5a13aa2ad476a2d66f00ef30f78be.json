{"ast":null,"code":"\"use strict\";\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Radix Gateway API\n * This API is designed to enable clients to efficiently query information on the RadixDLT ledger, and allow clients to simply build and submit transactions to the network.  The API is designed for use by the Radix Foundation\\'s [Desktop Wallet](https://wallet.radixdlt.com/) and [Explorer](https://explorer.radixdlt.com/), and replaces the original Olympia \\\"Archive Node API\\\".  # Gateway API Overview  The Gateway API is separated into distinct groupings:  * `/gateway` - Information about the Gateway API status * `/account/_*` - To query account-related information * `/token/_*` - To query token-related information * `/validator/_*` and `/validators` - To query validator-related information * `/transaction/_*` - To build, finalize and submit transactions, and to read the status and content of submitted and on-ledger transactions.  The Gateway API is implemented by the [Network Gateway](https://github.com/radixdlt/radixdlt-network-gateway), which is configured to read from full node/s to extract and index data from the network.  # Gateway API Format  The API is designed in a JSON-RPC style, using HTTP as a transport layer, which means that:  * All requests are POST requests. * Any error is returned with an HTTP status code of 500, with a returned error object.   * The error object contains an HTTP-like `code`   * The error object also contains a structured/typed `details` sub-object, with a `type` discriminator, allowing for structured error interpretation in clients.  # Comparison to other Radix APIs  * [Core API](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/radixdlt/radixdlt/main/radixdlt-core/radixdlt/src/main/java/com/radixdlt/api/core/api.yaml) - The Core API is a low level API exposed by full nodes, and designed for use on internal networks. It is primarily designed for network integrations such as exchanges, ledger analytics providers, or hosted ledger data dashboards. The Core API provides endpoints for reading the mempool, constructing transactions and also exposes a stream of committed transactions.  * [System API](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/radixdlt/radixdlt/main/radixdlt-core/radixdlt/src/main/java/com/radixdlt/api/system/api.yaml) - The System API is a private API exposed by full nodes to read system status.  The Gateway API offers a much wider range of query options and is more performant than the Core API. It is built on top of the Core API, ingesting data via the Core API transaction stream into a relational database.  The Gateway API transaction/construction endpoints operate with the concept of \\\"actions\\\" - these are higher-levels of intent compared with the Core API, which makes it easier for clients to use. The Core API should be used if you require more power/flexiblity for managing UTXOs, or submitting transactions which can\\'t be mapped to a Gateway API action.\n *\n * The version of the OpenAPI document: 1.1.6\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValidatorApi = exports.ValidatorApiFactory = exports.ValidatorApiFp = exports.ValidatorApiAxiosParamCreator = exports.TransactionApi = exports.TransactionApiFactory = exports.TransactionApiFp = exports.TransactionApiAxiosParamCreator = exports.TokenApi = exports.TokenApiFactory = exports.TokenApiFp = exports.TokenApiAxiosParamCreator = exports.StatusApi = exports.StatusApiFactory = exports.StatusApiFp = exports.StatusApiAxiosParamCreator = exports.AccountApi = exports.AccountApiFactory = exports.AccountApiFp = exports.AccountApiAxiosParamCreator = exports.TransactionStatusStatusEnum = void 0;\nconst tslib_1 = require(\"tslib\");\nconst axios_1 = (0, tslib_1.__importDefault)(require(\"axios\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = require(\"./common\");\n// @ts-ignore\nconst base_1 = require(\"./base\");\n/**\n * @export\n * @enum {string}\n */\nvar TransactionStatusStatusEnum;\n(function (TransactionStatusStatusEnum) {\n  TransactionStatusStatusEnum[\"Pending\"] = \"PENDING\";\n  TransactionStatusStatusEnum[\"Confirmed\"] = \"CONFIRMED\";\n  TransactionStatusStatusEnum[\"Failed\"] = \"FAILED\";\n})(TransactionStatusStatusEnum = exports.TransactionStatusStatusEnum || (exports.TransactionStatusStatusEnum = {}));\n/**\n * AccountApi - axios parameter creator\n * @export\n */\nconst AccountApiAxiosParamCreator = function (configuration) {\n  return {\n    /**\n     * Returns an account\\'s available and staked token balances, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Account Balances\n     * @param {AccountBalancesRequest} accountBalancesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountBalancesPost: (accountBalancesRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'accountBalancesRequest' is not null or undefined\n      (0, common_1.assertParamExists)('accountBalancesPost', 'accountBalancesRequest', accountBalancesRequest);\n      const localVarPath = `/account/balances`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountBalancesRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns the account address associated with the given public key.\n     * @summary Derive Account Identifier\n     * @param {AccountDeriveRequest} accountDeriveRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountDerivePost: (accountDeriveRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'accountDeriveRequest' is not null or undefined\n      (0, common_1.assertParamExists)('accountDerivePost', 'accountDeriveRequest', accountDeriveRequest);\n      const localVarPath = `/account/derive`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountDeriveRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Stake Positions\n     * @param {AccountStakesRequest} accountStakesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountStakesPost: (accountStakesRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'accountStakesRequest' is not null or undefined\n      (0, common_1.assertParamExists)('accountStakesPost', 'accountStakesRequest', accountStakesRequest);\n      const localVarPath = `/account/stakes`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountStakesRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Account Transactions\n     * @param {AccountTransactionsRequest} accountTransactionsRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountTransactionsPost: (accountTransactionsRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'accountTransactionsRequest' is not null or undefined\n      (0, common_1.assertParamExists)('accountTransactionsPost', 'accountTransactionsRequest', accountTransactionsRequest);\n      const localVarPath = `/account/transactions`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountTransactionsRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Unstake Positions\n     * @param {AccountUnstakesRequest} accountUnstakesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountUnstakesPost: (accountUnstakesRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'accountUnstakesRequest' is not null or undefined\n      (0, common_1.assertParamExists)('accountUnstakesPost', 'accountUnstakesRequest', accountUnstakesRequest);\n      const localVarPath = `/account/unstakes`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountUnstakesRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    })\n  };\n};\nexports.AccountApiAxiosParamCreator = AccountApiAxiosParamCreator;\n/**\n * AccountApi - functional programming interface\n * @export\n */\nconst AccountApiFp = function (configuration) {\n  const localVarAxiosParamCreator = (0, exports.AccountApiAxiosParamCreator)(configuration);\n  return {\n    /**\n     * Returns an account\\'s available and staked token balances, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Account Balances\n     * @param {AccountBalancesRequest} accountBalancesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountBalancesPost(accountBalancesRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.accountBalancesPost(accountBalancesRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns the account address associated with the given public key.\n     * @summary Derive Account Identifier\n     * @param {AccountDeriveRequest} accountDeriveRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountDerivePost(accountDeriveRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.accountDerivePost(accountDeriveRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Stake Positions\n     * @param {AccountStakesRequest} accountStakesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountStakesPost(accountStakesRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.accountStakesPost(accountStakesRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Account Transactions\n     * @param {AccountTransactionsRequest} accountTransactionsRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountTransactionsPost(accountTransactionsRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.accountTransactionsPost(accountTransactionsRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Unstake Positions\n     * @param {AccountUnstakesRequest} accountUnstakesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountUnstakesPost(accountUnstakesRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.accountUnstakesPost(accountUnstakesRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    }\n  };\n};\nexports.AccountApiFp = AccountApiFp;\n/**\n * AccountApi - factory interface\n * @export\n */\nconst AccountApiFactory = function (configuration, basePath, axios) {\n  const localVarFp = (0, exports.AccountApiFp)(configuration);\n  return {\n    /**\n     * Returns an account\\'s available and staked token balances, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Account Balances\n     * @param {AccountBalancesRequest} accountBalancesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountBalancesPost(accountBalancesRequest, options) {\n      return localVarFp.accountBalancesPost(accountBalancesRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns the account address associated with the given public key.\n     * @summary Derive Account Identifier\n     * @param {AccountDeriveRequest} accountDeriveRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountDerivePost(accountDeriveRequest, options) {\n      return localVarFp.accountDerivePost(accountDeriveRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Stake Positions\n     * @param {AccountStakesRequest} accountStakesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountStakesPost(accountStakesRequest, options) {\n      return localVarFp.accountStakesPost(accountStakesRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Account Transactions\n     * @param {AccountTransactionsRequest} accountTransactionsRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountTransactionsPost(accountTransactionsRequest, options) {\n      return localVarFp.accountTransactionsPost(accountTransactionsRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n     * @summary Get Unstake Positions\n     * @param {AccountUnstakesRequest} accountUnstakesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    accountUnstakesPost(accountUnstakesRequest, options) {\n      return localVarFp.accountUnstakesPost(accountUnstakesRequest, options).then(request => request(axios, basePath));\n    }\n  };\n};\nexports.AccountApiFactory = AccountApiFactory;\n/**\n * AccountApi - object-oriented interface\n * @export\n * @class AccountApi\n * @extends {BaseAPI}\n */\nclass AccountApi extends base_1.BaseAPI {\n  /**\n   * Returns an account\\'s available and staked token balances, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n   * @summary Get Account Balances\n   * @param {AccountBalancesRequest} accountBalancesRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof AccountApi\n   */\n  accountBalancesPost(accountBalancesRequest, options) {\n    return (0, exports.AccountApiFp)(this.configuration).accountBalancesPost(accountBalancesRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns the account address associated with the given public key.\n   * @summary Derive Account Identifier\n   * @param {AccountDeriveRequest} accountDeriveRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof AccountApi\n   */\n  accountDerivePost(accountDeriveRequest, options) {\n    return (0, exports.AccountApiFp)(this.configuration).accountDerivePost(accountDeriveRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n   * @summary Get Stake Positions\n   * @param {AccountStakesRequest} accountStakesRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof AccountApi\n   */\n  accountStakesPost(accountStakesRequest, options) {\n    return (0, exports.AccountApiFp)(this.configuration).accountStakesPost(accountStakesRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n   * @summary Get Account Transactions\n   * @param {AccountTransactionsRequest} accountTransactionsRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof AccountApi\n   */\n  accountTransactionsPost(accountTransactionsRequest, options) {\n    return (0, exports.AccountApiFp)(this.configuration).accountTransactionsPost(accountTransactionsRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n   * @summary Get Unstake Positions\n   * @param {AccountUnstakesRequest} accountUnstakesRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof AccountApi\n   */\n  accountUnstakesPost(accountUnstakesRequest, options) {\n    return (0, exports.AccountApiFp)(this.configuration).accountUnstakesPost(accountUnstakesRequest, options).then(request => request(this.axios, this.basePath));\n  }\n}\nexports.AccountApi = AccountApi;\n/**\n * StatusApi - axios parameter creator\n * @export\n */\nconst StatusApiAxiosParamCreator = function (configuration) {\n  return {\n    /**\n     * Returns the Gateway API version, network and current ledger state.\n     * @summary Get Gateway Info\n     * @param {object} body\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    gatewayPost: (body, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'body' is not null or undefined\n      (0, common_1.assertParamExists)('gatewayPost', 'body', body);\n      const localVarPath = `/gateway`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    })\n  };\n};\nexports.StatusApiAxiosParamCreator = StatusApiAxiosParamCreator;\n/**\n * StatusApi - functional programming interface\n * @export\n */\nconst StatusApiFp = function (configuration) {\n  const localVarAxiosParamCreator = (0, exports.StatusApiAxiosParamCreator)(configuration);\n  return {\n    /**\n     * Returns the Gateway API version, network and current ledger state.\n     * @summary Get Gateway Info\n     * @param {object} body\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    gatewayPost(body, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.gatewayPost(body, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    }\n  };\n};\nexports.StatusApiFp = StatusApiFp;\n/**\n * StatusApi - factory interface\n * @export\n */\nconst StatusApiFactory = function (configuration, basePath, axios) {\n  const localVarFp = (0, exports.StatusApiFp)(configuration);\n  return {\n    /**\n     * Returns the Gateway API version, network and current ledger state.\n     * @summary Get Gateway Info\n     * @param {object} body\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    gatewayPost(body, options) {\n      return localVarFp.gatewayPost(body, options).then(request => request(axios, basePath));\n    }\n  };\n};\nexports.StatusApiFactory = StatusApiFactory;\n/**\n * StatusApi - object-oriented interface\n * @export\n * @class StatusApi\n * @extends {BaseAPI}\n */\nclass StatusApi extends base_1.BaseAPI {\n  /**\n   * Returns the Gateway API version, network and current ledger state.\n   * @summary Get Gateway Info\n   * @param {object} body\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof StatusApi\n   */\n  gatewayPost(body, options) {\n    return (0, exports.StatusApiFp)(this.configuration).gatewayPost(body, options).then(request => request(this.axios, this.basePath));\n  }\n}\nexports.StatusApi = StatusApi;\n/**\n * TokenApi - axios parameter creator\n * @export\n */\nconst TokenApiAxiosParamCreator = function (configuration) {\n  return {\n    /**\n     * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.\n     * @summary Derive Token Identifier\n     * @param {TokenDeriveRequest} tokenDeriveRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    tokenDerivePost: (tokenDeriveRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'tokenDeriveRequest' is not null or undefined\n      (0, common_1.assertParamExists)('tokenDerivePost', 'tokenDeriveRequest', tokenDeriveRequest);\n      const localVarPath = `/token/derive`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tokenDeriveRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns information about XRD, including its Radix Resource Identifier.\n     * @summary Get Native Token Info\n     * @param {TokenNativeRequest} tokenNativeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    tokenNativePost: (tokenNativeRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'tokenNativeRequest' is not null or undefined\n      (0, common_1.assertParamExists)('tokenNativePost', 'tokenNativeRequest', tokenNativeRequest);\n      const localVarPath = `/token/native`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tokenNativeRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns information about any token, given its Radix Resource Identifier.\n     * @summary Get Token Info\n     * @param {TokenRequest} tokenRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    tokenPost: (tokenRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'tokenRequest' is not null or undefined\n      (0, common_1.assertParamExists)('tokenPost', 'tokenRequest', tokenRequest);\n      const localVarPath = `/token`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tokenRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    })\n  };\n};\nexports.TokenApiAxiosParamCreator = TokenApiAxiosParamCreator;\n/**\n * TokenApi - functional programming interface\n * @export\n */\nconst TokenApiFp = function (configuration) {\n  const localVarAxiosParamCreator = (0, exports.TokenApiAxiosParamCreator)(configuration);\n  return {\n    /**\n     * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.\n     * @summary Derive Token Identifier\n     * @param {TokenDeriveRequest} tokenDeriveRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    tokenDerivePost(tokenDeriveRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenDerivePost(tokenDeriveRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns information about XRD, including its Radix Resource Identifier.\n     * @summary Get Native Token Info\n     * @param {TokenNativeRequest} tokenNativeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    tokenNativePost(tokenNativeRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenNativePost(tokenNativeRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns information about any token, given its Radix Resource Identifier.\n     * @summary Get Token Info\n     * @param {TokenRequest} tokenRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    tokenPost(tokenRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenPost(tokenRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    }\n  };\n};\nexports.TokenApiFp = TokenApiFp;\n/**\n * TokenApi - factory interface\n * @export\n */\nconst TokenApiFactory = function (configuration, basePath, axios) {\n  const localVarFp = (0, exports.TokenApiFp)(configuration);\n  return {\n    /**\n     * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.\n     * @summary Derive Token Identifier\n     * @param {TokenDeriveRequest} tokenDeriveRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    tokenDerivePost(tokenDeriveRequest, options) {\n      return localVarFp.tokenDerivePost(tokenDeriveRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns information about XRD, including its Radix Resource Identifier.\n     * @summary Get Native Token Info\n     * @param {TokenNativeRequest} tokenNativeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    tokenNativePost(tokenNativeRequest, options) {\n      return localVarFp.tokenNativePost(tokenNativeRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns information about any token, given its Radix Resource Identifier.\n     * @summary Get Token Info\n     * @param {TokenRequest} tokenRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    tokenPost(tokenRequest, options) {\n      return localVarFp.tokenPost(tokenRequest, options).then(request => request(axios, basePath));\n    }\n  };\n};\nexports.TokenApiFactory = TokenApiFactory;\n/**\n * TokenApi - object-oriented interface\n * @export\n * @class TokenApi\n * @extends {BaseAPI}\n */\nclass TokenApi extends base_1.BaseAPI {\n  /**\n   * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.\n   * @summary Derive Token Identifier\n   * @param {TokenDeriveRequest} tokenDeriveRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof TokenApi\n   */\n  tokenDerivePost(tokenDeriveRequest, options) {\n    return (0, exports.TokenApiFp)(this.configuration).tokenDerivePost(tokenDeriveRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns information about XRD, including its Radix Resource Identifier.\n   * @summary Get Native Token Info\n   * @param {TokenNativeRequest} tokenNativeRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof TokenApi\n   */\n  tokenNativePost(tokenNativeRequest, options) {\n    return (0, exports.TokenApiFp)(this.configuration).tokenNativePost(tokenNativeRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns information about any token, given its Radix Resource Identifier.\n   * @summary Get Token Info\n   * @param {TokenRequest} tokenRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof TokenApi\n   */\n  tokenPost(tokenRequest, options) {\n    return (0, exports.TokenApiFp)(this.configuration).tokenPost(tokenRequest, options).then(request => request(this.axios, this.basePath));\n  }\n}\nexports.TokenApi = TokenApi;\n/**\n * TransactionApi - axios parameter creator\n * @export\n */\nconst TransactionApiAxiosParamCreator = function (configuration) {\n  return {\n    /**\n     * Returns a built unsigned transaction payload, from a set of intended actions.\n     * @summary Build Transaction\n     * @param {TransactionBuildRequest} transactionBuildRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionBuildPost: (transactionBuildRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'transactionBuildRequest' is not null or undefined\n      (0, common_1.assertParamExists)('transactionBuildPost', 'transactionBuildRequest', transactionBuildRequest);\n      const localVarPath = `/transaction/build`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionBuildRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.\n     * @summary Finalize Transaction\n     * @param {TransactionFinalizeRequest} transactionFinalizeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionFinalizePost: (transactionFinalizeRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'transactionFinalizeRequest' is not null or undefined\n      (0, common_1.assertParamExists)('transactionFinalizePost', 'transactionFinalizeRequest', transactionFinalizeRequest);\n      const localVarPath = `/transaction/finalize`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionFinalizeRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.\n     * @summary Get Recent Transactions\n     * @param {RecentTransactionsRequest} recentTransactionsRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionRecentPost: (recentTransactionsRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'recentTransactionsRequest' is not null or undefined\n      (0, common_1.assertParamExists)('transactionRecentPost', 'recentTransactionsRequest', recentTransactionsRequest);\n      const localVarPath = `/transaction/recent`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(recentTransactionsRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns the current rules used to build and validate transactions in the Radix Engine.\n     * @summary Get Transaction Rules\n     * @param {TransactionRulesRequest} transactionRulesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionRulesPost: (transactionRulesRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'transactionRulesRequest' is not null or undefined\n      (0, common_1.assertParamExists)('transactionRulesPost', 'transactionRulesRequest', transactionRulesRequest);\n      const localVarPath = `/transaction/rules`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionRulesRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.\n     * @summary Transaction Status\n     * @param {TransactionStatusRequest} transactionStatusRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionStatusPost: (transactionStatusRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'transactionStatusRequest' is not null or undefined\n      (0, common_1.assertParamExists)('transactionStatusPost', 'transactionStatusRequest', transactionStatusRequest);\n      const localVarPath = `/transaction/status`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionStatusRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.\n     * @summary Submit Transaction\n     * @param {TransactionSubmitRequest} transactionSubmitRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionSubmitPost: (transactionSubmitRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'transactionSubmitRequest' is not null or undefined\n      (0, common_1.assertParamExists)('transactionSubmitPost', 'transactionSubmitRequest', transactionSubmitRequest);\n      const localVarPath = `/transaction/submit`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionSubmitRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    })\n  };\n};\nexports.TransactionApiAxiosParamCreator = TransactionApiAxiosParamCreator;\n/**\n * TransactionApi - functional programming interface\n * @export\n */\nconst TransactionApiFp = function (configuration) {\n  const localVarAxiosParamCreator = (0, exports.TransactionApiAxiosParamCreator)(configuration);\n  return {\n    /**\n     * Returns a built unsigned transaction payload, from a set of intended actions.\n     * @summary Build Transaction\n     * @param {TransactionBuildRequest} transactionBuildRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionBuildPost(transactionBuildRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionBuildPost(transactionBuildRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.\n     * @summary Finalize Transaction\n     * @param {TransactionFinalizeRequest} transactionFinalizeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionFinalizePost(transactionFinalizeRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionFinalizePost(transactionFinalizeRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.\n     * @summary Get Recent Transactions\n     * @param {RecentTransactionsRequest} recentTransactionsRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionRecentPost(recentTransactionsRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionRecentPost(recentTransactionsRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns the current rules used to build and validate transactions in the Radix Engine.\n     * @summary Get Transaction Rules\n     * @param {TransactionRulesRequest} transactionRulesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionRulesPost(transactionRulesRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionRulesPost(transactionRulesRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.\n     * @summary Transaction Status\n     * @param {TransactionStatusRequest} transactionStatusRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionStatusPost(transactionStatusRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionStatusPost(transactionStatusRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.\n     * @summary Submit Transaction\n     * @param {TransactionSubmitRequest} transactionSubmitRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionSubmitPost(transactionSubmitRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.transactionSubmitPost(transactionSubmitRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    }\n  };\n};\nexports.TransactionApiFp = TransactionApiFp;\n/**\n * TransactionApi - factory interface\n * @export\n */\nconst TransactionApiFactory = function (configuration, basePath, axios) {\n  const localVarFp = (0, exports.TransactionApiFp)(configuration);\n  return {\n    /**\n     * Returns a built unsigned transaction payload, from a set of intended actions.\n     * @summary Build Transaction\n     * @param {TransactionBuildRequest} transactionBuildRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionBuildPost(transactionBuildRequest, options) {\n      return localVarFp.transactionBuildPost(transactionBuildRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.\n     * @summary Finalize Transaction\n     * @param {TransactionFinalizeRequest} transactionFinalizeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionFinalizePost(transactionFinalizeRequest, options) {\n      return localVarFp.transactionFinalizePost(transactionFinalizeRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.\n     * @summary Get Recent Transactions\n     * @param {RecentTransactionsRequest} recentTransactionsRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionRecentPost(recentTransactionsRequest, options) {\n      return localVarFp.transactionRecentPost(recentTransactionsRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns the current rules used to build and validate transactions in the Radix Engine.\n     * @summary Get Transaction Rules\n     * @param {TransactionRulesRequest} transactionRulesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionRulesPost(transactionRulesRequest, options) {\n      return localVarFp.transactionRulesPost(transactionRulesRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.\n     * @summary Transaction Status\n     * @param {TransactionStatusRequest} transactionStatusRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionStatusPost(transactionStatusRequest, options) {\n      return localVarFp.transactionStatusPost(transactionStatusRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.\n     * @summary Submit Transaction\n     * @param {TransactionSubmitRequest} transactionSubmitRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    transactionSubmitPost(transactionSubmitRequest, options) {\n      return localVarFp.transactionSubmitPost(transactionSubmitRequest, options).then(request => request(axios, basePath));\n    }\n  };\n};\nexports.TransactionApiFactory = TransactionApiFactory;\n/**\n * TransactionApi - object-oriented interface\n * @export\n * @class TransactionApi\n * @extends {BaseAPI}\n */\nclass TransactionApi extends base_1.BaseAPI {\n  /**\n   * Returns a built unsigned transaction payload, from a set of intended actions.\n   * @summary Build Transaction\n   * @param {TransactionBuildRequest} transactionBuildRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof TransactionApi\n   */\n  transactionBuildPost(transactionBuildRequest, options) {\n    return (0, exports.TransactionApiFp)(this.configuration).transactionBuildPost(transactionBuildRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.\n   * @summary Finalize Transaction\n   * @param {TransactionFinalizeRequest} transactionFinalizeRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof TransactionApi\n   */\n  transactionFinalizePost(transactionFinalizeRequest, options) {\n    return (0, exports.TransactionApiFp)(this.configuration).transactionFinalizePost(transactionFinalizeRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.\n   * @summary Get Recent Transactions\n   * @param {RecentTransactionsRequest} recentTransactionsRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof TransactionApi\n   */\n  transactionRecentPost(recentTransactionsRequest, options) {\n    return (0, exports.TransactionApiFp)(this.configuration).transactionRecentPost(recentTransactionsRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns the current rules used to build and validate transactions in the Radix Engine.\n   * @summary Get Transaction Rules\n   * @param {TransactionRulesRequest} transactionRulesRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof TransactionApi\n   */\n  transactionRulesPost(transactionRulesRequest, options) {\n    return (0, exports.TransactionApiFp)(this.configuration).transactionRulesPost(transactionRulesRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.\n   * @summary Transaction Status\n   * @param {TransactionStatusRequest} transactionStatusRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof TransactionApi\n   */\n  transactionStatusPost(transactionStatusRequest, options) {\n    return (0, exports.TransactionApiFp)(this.configuration).transactionStatusPost(transactionStatusRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.\n   * @summary Submit Transaction\n   * @param {TransactionSubmitRequest} transactionSubmitRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof TransactionApi\n   */\n  transactionSubmitPost(transactionSubmitRequest, options) {\n    return (0, exports.TransactionApiFp)(this.configuration).transactionSubmitPost(transactionSubmitRequest, options).then(request => request(this.axios, this.basePath));\n  }\n}\nexports.TransactionApi = TransactionApi;\n/**\n * ValidatorApi - axios parameter creator\n * @export\n */\nconst ValidatorApiAxiosParamCreator = function (configuration) {\n  return {\n    /**\n     * Returns the validator address associated with the given public key.\n     * @summary Get Validator Identifier\n     * @param {ValidatorDeriveRequest} validatorDeriveRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorDerivePost: (validatorDeriveRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'validatorDeriveRequest' is not null or undefined\n      (0, common_1.assertParamExists)('validatorDerivePost', 'validatorDeriveRequest', validatorDeriveRequest);\n      const localVarPath = `/validator/derive`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validatorDeriveRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.\n     * @summary Get Validator\n     * @param {ValidatorRequest} validatorRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorPost: (validatorRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'validatorRequest' is not null or undefined\n      (0, common_1.assertParamExists)('validatorPost', 'validatorRequest', validatorRequest);\n      const localVarPath = `/validator`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validatorRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).\n     * @summary Get Validator Stakes\n     * @param {ValidatorStakesRequest} validatorStakesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorStakesPost: (validatorStakesRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'validatorStakesRequest' is not null or undefined\n      (0, common_1.assertParamExists)('validatorStakesPost', 'validatorStakesRequest', validatorStakesRequest);\n      const localVarPath = `/validator/stakes`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validatorStakesRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    }),\n    /**\n     * Returns information about all validators.\n     * @summary Get Validators\n     * @param {ValidatorsRequest} validatorsRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorsPost: (validatorsRequest, options = {}) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      // verify required parameter 'validatorsRequest' is not null or undefined\n      (0, common_1.assertParamExists)('validatorsPost', 'validatorsRequest', validatorsRequest);\n      const localVarPath = `/validators`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n      const localVarRequestOptions = Object.assign(Object.assign({\n        method: 'POST'\n      }, baseOptions), options);\n      const localVarHeaderParameter = {};\n      const localVarQueryParameter = {};\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n      (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validatorsRequest, localVarRequestOptions, configuration);\n      return {\n        url: (0, common_1.toPathString)(localVarUrlObj),\n        options: localVarRequestOptions\n      };\n    })\n  };\n};\nexports.ValidatorApiAxiosParamCreator = ValidatorApiAxiosParamCreator;\n/**\n * ValidatorApi - functional programming interface\n * @export\n */\nconst ValidatorApiFp = function (configuration) {\n  const localVarAxiosParamCreator = (0, exports.ValidatorApiAxiosParamCreator)(configuration);\n  return {\n    /**\n     * Returns the validator address associated with the given public key.\n     * @summary Get Validator Identifier\n     * @param {ValidatorDeriveRequest} validatorDeriveRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorDerivePost(validatorDeriveRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.validatorDerivePost(validatorDeriveRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.\n     * @summary Get Validator\n     * @param {ValidatorRequest} validatorRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorPost(validatorRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.validatorPost(validatorRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).\n     * @summary Get Validator Stakes\n     * @param {ValidatorStakesRequest} validatorStakesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorStakesPost(validatorStakesRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.validatorStakesPost(validatorStakesRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    },\n    /**\n     * Returns information about all validators.\n     * @summary Get Validators\n     * @param {ValidatorsRequest} validatorsRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorsPost(validatorsRequest, options) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const localVarAxiosArgs = yield localVarAxiosParamCreator.validatorsPost(validatorsRequest, options);\n        return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n      });\n    }\n  };\n};\nexports.ValidatorApiFp = ValidatorApiFp;\n/**\n * ValidatorApi - factory interface\n * @export\n */\nconst ValidatorApiFactory = function (configuration, basePath, axios) {\n  const localVarFp = (0, exports.ValidatorApiFp)(configuration);\n  return {\n    /**\n     * Returns the validator address associated with the given public key.\n     * @summary Get Validator Identifier\n     * @param {ValidatorDeriveRequest} validatorDeriveRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorDerivePost(validatorDeriveRequest, options) {\n      return localVarFp.validatorDerivePost(validatorDeriveRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.\n     * @summary Get Validator\n     * @param {ValidatorRequest} validatorRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorPost(validatorRequest, options) {\n      return localVarFp.validatorPost(validatorRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).\n     * @summary Get Validator Stakes\n     * @param {ValidatorStakesRequest} validatorStakesRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorStakesPost(validatorStakesRequest, options) {\n      return localVarFp.validatorStakesPost(validatorStakesRequest, options).then(request => request(axios, basePath));\n    },\n    /**\n     * Returns information about all validators.\n     * @summary Get Validators\n     * @param {ValidatorsRequest} validatorsRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    validatorsPost(validatorsRequest, options) {\n      return localVarFp.validatorsPost(validatorsRequest, options).then(request => request(axios, basePath));\n    }\n  };\n};\nexports.ValidatorApiFactory = ValidatorApiFactory;\n/**\n * ValidatorApi - object-oriented interface\n * @export\n * @class ValidatorApi\n * @extends {BaseAPI}\n */\nclass ValidatorApi extends base_1.BaseAPI {\n  /**\n   * Returns the validator address associated with the given public key.\n   * @summary Get Validator Identifier\n   * @param {ValidatorDeriveRequest} validatorDeriveRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof ValidatorApi\n   */\n  validatorDerivePost(validatorDeriveRequest, options) {\n    return (0, exports.ValidatorApiFp)(this.configuration).validatorDerivePost(validatorDeriveRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.\n   * @summary Get Validator\n   * @param {ValidatorRequest} validatorRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof ValidatorApi\n   */\n  validatorPost(validatorRequest, options) {\n    return (0, exports.ValidatorApiFp)(this.configuration).validatorPost(validatorRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).\n   * @summary Get Validator Stakes\n   * @param {ValidatorStakesRequest} validatorStakesRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof ValidatorApi\n   */\n  validatorStakesPost(validatorStakesRequest, options) {\n    return (0, exports.ValidatorApiFp)(this.configuration).validatorStakesPost(validatorStakesRequest, options).then(request => request(this.axios, this.basePath));\n  }\n  /**\n   * Returns information about all validators.\n   * @summary Get Validators\n   * @param {ValidatorsRequest} validatorsRequest\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof ValidatorApi\n   */\n  validatorsPost(validatorsRequest, options) {\n    return (0, exports.ValidatorApiFp)(this.configuration).validatorsPost(validatorsRequest, options).then(request => request(this.axios, this.basePath));\n  }\n}\nexports.ValidatorApi = ValidatorApi;","map":{"version":3,"names":["axios_1","tslib_1","__importDefault","require","common_1","base_1","TransactionStatusStatusEnum","exports","AccountApiAxiosParamCreator","configuration","accountBalancesPost","accountBalancesRequest","options","__awaiter","assertParamExists","localVarPath","localVarUrlObj","URL","DUMMY_BASE_URL","baseOptions","localVarRequestOptions","Object","assign","method","localVarHeaderParameter","localVarQueryParameter","setSearchParams","headersFromBaseOptions","headers","data","serializeDataIfNeeded","url","toPathString","accountDerivePost","accountDeriveRequest","accountStakesPost","accountStakesRequest","accountTransactionsPost","accountTransactionsRequest","accountUnstakesPost","accountUnstakesRequest","AccountApiFp","localVarAxiosParamCreator","localVarAxiosArgs","createRequestFunction","default","BASE_PATH","AccountApiFactory","basePath","axios","localVarFp","then","request","AccountApi","BaseAPI","StatusApiAxiosParamCreator","gatewayPost","body","StatusApiFp","StatusApiFactory","StatusApi","TokenApiAxiosParamCreator","tokenDerivePost","tokenDeriveRequest","tokenNativePost","tokenNativeRequest","tokenPost","tokenRequest","TokenApiFp","TokenApiFactory","TokenApi","TransactionApiAxiosParamCreator","transactionBuildPost","transactionBuildRequest","transactionFinalizePost","transactionFinalizeRequest","transactionRecentPost","recentTransactionsRequest","transactionRulesPost","transactionRulesRequest","transactionStatusPost","transactionStatusRequest","transactionSubmitPost","transactionSubmitRequest","TransactionApiFp","TransactionApiFactory","TransactionApi","ValidatorApiAxiosParamCreator","validatorDerivePost","validatorDeriveRequest","validatorPost","validatorRequest","validatorStakesPost","validatorStakesRequest","validatorsPost","validatorsRequest","ValidatorApiFp","ValidatorApiFactory","ValidatorApi"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/networking/src/open-api/api.ts"],"sourcesContent":["/* tslint:disable */\n/* eslint-disable */\n/**\n * Radix Gateway API\n * This API is designed to enable clients to efficiently query information on the RadixDLT ledger, and allow clients to simply build and submit transactions to the network.  The API is designed for use by the Radix Foundation\\'s [Desktop Wallet](https://wallet.radixdlt.com/) and [Explorer](https://explorer.radixdlt.com/), and replaces the original Olympia \\\"Archive Node API\\\".  # Gateway API Overview  The Gateway API is separated into distinct groupings:  * `/gateway` - Information about the Gateway API status * `/account/_*` - To query account-related information * `/token/_*` - To query token-related information * `/validator/_*` and `/validators` - To query validator-related information * `/transaction/_*` - To build, finalize and submit transactions, and to read the status and content of submitted and on-ledger transactions.  The Gateway API is implemented by the [Network Gateway](https://github.com/radixdlt/radixdlt-network-gateway), which is configured to read from full node/s to extract and index data from the network.  # Gateway API Format  The API is designed in a JSON-RPC style, using HTTP as a transport layer, which means that:  * All requests are POST requests. * Any error is returned with an HTTP status code of 500, with a returned error object.   * The error object contains an HTTP-like `code`   * The error object also contains a structured/typed `details` sub-object, with a `type` discriminator, allowing for structured error interpretation in clients.  # Comparison to other Radix APIs  * [Core API](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/radixdlt/radixdlt/main/radixdlt-core/radixdlt/src/main/java/com/radixdlt/api/core/api.yaml) - The Core API is a low level API exposed by full nodes, and designed for use on internal networks. It is primarily designed for network integrations such as exchanges, ledger analytics providers, or hosted ledger data dashboards. The Core API provides endpoints for reading the mempool, constructing transactions and also exposes a stream of committed transactions.  * [System API](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/radixdlt/radixdlt/main/radixdlt-core/radixdlt/src/main/java/com/radixdlt/api/system/api.yaml) - The System API is a private API exposed by full nodes to read system status.  The Gateway API offers a much wider range of query options and is more performant than the Core API. It is built on top of the Core API, ingesting data via the Core API transaction stream into a relational database.  The Gateway API transaction/construction endpoints operate with the concept of \\\"actions\\\" - these are higher-levels of intent compared with the Core API, which makes it easier for clients to use. The Core API should be used if you require more power/flexiblity for managing UTXOs, or submitting transactions which can\\'t be mapped to a Gateway API action.\n *\n * The version of the OpenAPI document: 1.1.6\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { Configuration } from './configuration'\nimport globalAxios, {\n\tAxiosPromise,\n\tAxiosInstance,\n\tAxiosRequestConfig,\n} from 'axios'\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport {\n\tDUMMY_BASE_URL,\n\tassertParamExists,\n\tsetApiKeyToObject,\n\tsetBasicAuthToObject,\n\tsetBearerAuthToObject,\n\tsetOAuthToObject,\n\tsetSearchParams,\n\tserializeDataIfNeeded,\n\ttoPathString,\n\tcreateRequestFunction,\n} from './common'\n// @ts-ignore\nimport {\n\tBASE_PATH,\n\tCOLLECTION_FORMATS,\n\tRequestArgs,\n\tBaseAPI,\n\tRequiredError,\n} from './base'\n\n/**\n *\n * @export\n * @interface AccountBalances\n */\nexport interface AccountBalances {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof AccountBalances\n\t */\n\tstaked_and_unstaking_balance: TokenAmount\n\t/**\n\t * A list of all the token balances owned by the account.\n\t * @type {Array<TokenAmount>}\n\t * @memberof AccountBalances\n\t */\n\tliquid_balances: Array<TokenAmount>\n}\n/**\n *\n * @export\n * @interface AccountBalancesRequest\n */\nexport interface AccountBalancesRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof AccountBalancesRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof AccountBalancesRequest\n\t */\n\taccount_identifier: AccountIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof AccountBalancesRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n}\n/**\n *\n * @export\n * @interface AccountBalancesResponse\n */\nexport interface AccountBalancesResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof AccountBalancesResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t *\n\t * @type {AccountBalances}\n\t * @memberof AccountBalancesResponse\n\t */\n\taccount_balances: AccountBalances\n}\n/**\n *\n * @export\n * @interface AccountDeriveRequest\n */\nexport interface AccountDeriveRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof AccountDeriveRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {PublicKey}\n\t * @memberof AccountDeriveRequest\n\t */\n\tpublic_key: PublicKey\n}\n/**\n *\n * @export\n * @interface AccountDeriveResponse\n */\nexport interface AccountDeriveResponse {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof AccountDeriveResponse\n\t */\n\taccount_identifier: AccountIdentifier\n}\n/**\n *\n * @export\n * @interface AccountIdentifier\n */\nexport interface AccountIdentifier {\n\t/**\n\t * The radix address of the account.\n\t * @type {string}\n\t * @memberof AccountIdentifier\n\t */\n\taddress: string\n}\n/**\n *\n * @export\n * @interface AccountStakeEntry\n */\nexport interface AccountStakeEntry {\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof AccountStakeEntry\n\t */\n\tvalidator_identifier: ValidatorIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof AccountStakeEntry\n\t */\n\tdelegated_stake: TokenAmount\n}\n/**\n *\n * @export\n * @interface AccountStakesRequest\n */\nexport interface AccountStakesRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof AccountStakesRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof AccountStakesRequest\n\t */\n\taccount_identifier: AccountIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof AccountStakesRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n}\n/**\n *\n * @export\n * @interface AccountStakesResponse\n */\nexport interface AccountStakesResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof AccountStakesResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t * The stake positions which will become staked at the next epoch change.\n\t * @type {Array<AccountStakeEntry>}\n\t * @memberof AccountStakesResponse\n\t */\n\tpending_stakes: Array<AccountStakeEntry>\n\t/**\n\t * The stake positions which are currently staked.\n\t * @type {Array<AccountStakeEntry>}\n\t * @memberof AccountStakesResponse\n\t */\n\tstakes: Array<AccountStakeEntry>\n}\n/**\n *\n * @export\n * @interface AccountTransactionsRequest\n */\nexport interface AccountTransactionsRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof AccountTransactionsRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof AccountTransactionsRequest\n\t */\n\taccount_identifier: AccountIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof AccountTransactionsRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n\t/**\n\t * This cursor allows forward pagination, by providing the cursor from the previous request.\n\t * @type {string}\n\t * @memberof AccountTransactionsRequest\n\t */\n\tcursor?: string\n\t/**\n\t * The page size requested. The maximum value is 30 at present.\n\t * @type {number}\n\t * @memberof AccountTransactionsRequest\n\t */\n\tlimit?: number\n}\n/**\n *\n * @export\n * @interface AccountTransactionsResponse\n */\nexport interface AccountTransactionsResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof AccountTransactionsResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t * The total number of transactions under the account.\n\t * @type {number}\n\t * @memberof AccountTransactionsResponse\n\t */\n\ttotal_count?: number\n\t/**\n\t * The cursor to be provided for the next page of results. If missing, this is the last page of results.\n\t * @type {string}\n\t * @memberof AccountTransactionsResponse\n\t */\n\tnext_cursor?: string\n\t/**\n\t * The page of transactions.\n\t * @type {Array<TransactionInfo>}\n\t * @memberof AccountTransactionsResponse\n\t */\n\ttransactions: Array<TransactionInfo>\n}\n/**\n *\n * @export\n * @interface AccountUnstakeEntry\n */\nexport interface AccountUnstakeEntry {\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof AccountUnstakeEntry\n\t */\n\tvalidator_identifier: ValidatorIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof AccountUnstakeEntry\n\t */\n\tunstaking_amount: TokenAmount\n\t/**\n\t * The number of epochs until the XRD in this unstake will be released back to the account. This delay is to enable stake to be slashed, if the validator misbehaves.\n\t * @type {number}\n\t * @memberof AccountUnstakeEntry\n\t */\n\tepochs_until_unlocked: number\n}\n/**\n *\n * @export\n * @interface AccountUnstakesRequest\n */\nexport interface AccountUnstakesRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof AccountUnstakesRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof AccountUnstakesRequest\n\t */\n\taccount_identifier: AccountIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof AccountUnstakesRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n}\n/**\n *\n * @export\n * @interface AccountUnstakesResponse\n */\nexport interface AccountUnstakesResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof AccountUnstakesResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t *\n\t * @type {Array<AccountUnstakeEntry>}\n\t * @memberof AccountUnstakesResponse\n\t */\n\tpending_unstakes: Array<AccountUnstakeEntry>\n\t/**\n\t *\n\t * @type {Array<AccountUnstakeEntry>}\n\t * @memberof AccountUnstakesResponse\n\t */\n\tunstakes: Array<AccountUnstakeEntry>\n}\n/**\n *\n * @export\n * @interface Action\n */\nexport interface Action {\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof Action\n\t */\n\ttype: string\n}\n/**\n *\n * @export\n * @interface BelowMinimumStakeError\n */\nexport interface BelowMinimumStakeError extends GatewayError {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof BelowMinimumStakeError\n\t */\n\trequested_amount: TokenAmount\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof BelowMinimumStakeError\n\t */\n\tminimum_amount: TokenAmount\n}\n/**\n *\n * @export\n * @interface BelowMinimumStakeErrorAllOf\n */\nexport interface BelowMinimumStakeErrorAllOf {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof BelowMinimumStakeErrorAllOf\n\t */\n\trequested_amount: TokenAmount\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof BelowMinimumStakeErrorAllOf\n\t */\n\tminimum_amount: TokenAmount\n}\n/**\n *\n * @export\n * @interface BurnTokens\n */\nexport interface BurnTokens extends Action {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof BurnTokens\n\t */\n\tfrom_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof BurnTokens\n\t */\n\tamount: TokenAmount\n}\n/**\n *\n * @export\n * @interface BurnTokensAllOf\n */\nexport interface BurnTokensAllOf {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof BurnTokensAllOf\n\t */\n\tfrom_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof BurnTokensAllOf\n\t */\n\tamount: TokenAmount\n}\n/**\n *\n * @export\n * @interface CannotStakeError\n */\nexport interface CannotStakeError extends GatewayError {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof CannotStakeError\n\t */\n\towner: AccountIdentifier\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof CannotStakeError\n\t */\n\tuser: AccountIdentifier\n}\n/**\n *\n * @export\n * @interface CannotStakeErrorAllOf\n */\nexport interface CannotStakeErrorAllOf {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof CannotStakeErrorAllOf\n\t */\n\towner: AccountIdentifier\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof CannotStakeErrorAllOf\n\t */\n\tuser: AccountIdentifier\n}\n/**\n *\n * @export\n * @interface CouldNotConstructFeesError\n */\nexport interface CouldNotConstructFeesError extends GatewayError {\n\t/**\n\t * The number of attempts the system tried and failed to create a consistent transaction fee.\n\t * @type {number}\n\t * @memberof CouldNotConstructFeesError\n\t */\n\tattempts: number\n}\n/**\n *\n * @export\n * @interface CouldNotConstructFeesErrorAllOf\n */\nexport interface CouldNotConstructFeesErrorAllOf {\n\t/**\n\t * The number of attempts the system tried and failed to create a consistent transaction fee.\n\t * @type {number}\n\t * @memberof CouldNotConstructFeesErrorAllOf\n\t */\n\tattempts: number\n}\n/**\n *\n * @export\n * @interface CreateTokenDefinition\n */\nexport interface CreateTokenDefinition extends Action {\n\t/**\n\t *\n\t * @type {TokenProperties}\n\t * @memberof CreateTokenDefinition\n\t */\n\ttoken_properties: TokenProperties\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof CreateTokenDefinition\n\t */\n\ttoken_supply: TokenAmount\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof CreateTokenDefinition\n\t */\n\tto_account?: AccountIdentifier\n}\n/**\n *\n * @export\n * @interface CreateTokenDefinitionAllOf\n */\nexport interface CreateTokenDefinitionAllOf {\n\t/**\n\t *\n\t * @type {TokenProperties}\n\t * @memberof CreateTokenDefinitionAllOf\n\t */\n\ttoken_properties: TokenProperties\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof CreateTokenDefinitionAllOf\n\t */\n\ttoken_supply: TokenAmount\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof CreateTokenDefinitionAllOf\n\t */\n\tto_account?: AccountIdentifier\n}\n/**\n *\n * @export\n * @interface EpochRange\n */\nexport interface EpochRange {\n\t/**\n\t * The first epoch considered (inclusive).\n\t * @type {number}\n\t * @memberof EpochRange\n\t */\n\tfrom: number\n\t/**\n\t * The last epoch considered (inclusive).\n\t * @type {number}\n\t * @memberof EpochRange\n\t */\n\tto: number\n}\n/**\n *\n * @export\n * @interface ErrorResponse\n */\nexport interface ErrorResponse {\n\t/**\n\t * A numeric code corresponding to the given error type, roughly aligned with HTTP Status Code semantics (eg 400/404/500).\n\t * @type {number}\n\t * @memberof ErrorResponse\n\t */\n\tcode: number\n\t/**\n\t * A human-readable error message.\n\t * @type {string}\n\t * @memberof ErrorResponse\n\t */\n\tmessage: string\n\t/**\n\t *\n\t * @type {GatewayError}\n\t * @memberof ErrorResponse\n\t */\n\tdetails?: GatewayError\n\t/**\n\t * A GUID to be used when reporting errors, to allow correlation with the Gateway API\\'s error logs.\n\t * @type {string}\n\t * @memberof ErrorResponse\n\t */\n\ttrace_id?: string\n}\n/**\n *\n * @export\n * @interface GatewayApiVersions\n */\nexport interface GatewayApiVersions {\n\t/**\n\t * The release that is currently deployed to the Gateway API.\n\t * @type {string}\n\t * @memberof GatewayApiVersions\n\t */\n\tversion: string\n\t/**\n\t * The open api schema version that was used to generate the API models.\n\t * @type {string}\n\t * @memberof GatewayApiVersions\n\t */\n\topen_api_schema_version: string\n}\n/**\n *\n * @export\n * @interface GatewayError\n */\nexport interface GatewayError {\n\t/**\n\t * The type of error. Each subtype may have its own additional structured fields.\n\t * @type {string}\n\t * @memberof GatewayError\n\t */\n\ttype: string\n}\n/**\n *\n * @export\n * @interface GatewayResponse\n */\nexport interface GatewayResponse {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof GatewayResponse\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {GatewayApiVersions}\n\t * @memberof GatewayResponse\n\t */\n\tgateway_api: GatewayApiVersions\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof GatewayResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t *\n\t * @type {TargetLedgerState}\n\t * @memberof GatewayResponse\n\t */\n\ttarget_ledger_state?: TargetLedgerState\n}\n/**\n *\n * @export\n * @interface InternalServerError\n */\nexport interface InternalServerError extends GatewayError {\n\t/**\n\t * Gives an error type which occurred within the Gateway API when serving the request.\n\t * @type {string}\n\t * @memberof InternalServerError\n\t */\n\texception: string\n\t/**\n\t * Gives a human readable message - likely just a trace ID for reporting the error.\n\t * @type {string}\n\t * @memberof InternalServerError\n\t */\n\tcause: string\n}\n/**\n *\n * @export\n * @interface InternalServerErrorAllOf\n */\nexport interface InternalServerErrorAllOf {\n\t/**\n\t * Gives an error type which occurred within the Gateway API when serving the request.\n\t * @type {string}\n\t * @memberof InternalServerErrorAllOf\n\t */\n\texception: string\n\t/**\n\t * Gives a human readable message - likely just a trace ID for reporting the error.\n\t * @type {string}\n\t * @memberof InternalServerErrorAllOf\n\t */\n\tcause: string\n}\n/**\n *\n * @export\n * @interface InvalidAccountAddressError\n */\nexport interface InvalidAccountAddressError extends GatewayError {\n\t/**\n\t * The account address which was invalid. A descriptive reason is given in the main error message.\n\t * @type {string}\n\t * @memberof InvalidAccountAddressError\n\t */\n\tinvalid_account_address: string\n}\n/**\n *\n * @export\n * @interface InvalidAccountAddressErrorAllOf\n */\nexport interface InvalidAccountAddressErrorAllOf {\n\t/**\n\t * The account address which was invalid. A descriptive reason is given in the main error message.\n\t * @type {string}\n\t * @memberof InvalidAccountAddressErrorAllOf\n\t */\n\tinvalid_account_address: string\n}\n/**\n *\n * @export\n * @interface InvalidActionError\n */\nexport interface InvalidActionError extends GatewayError {\n\t/**\n\t *\n\t * @type {Action}\n\t * @memberof InvalidActionError\n\t */\n\tinvalid_action: Action\n}\n/**\n *\n * @export\n * @interface InvalidActionErrorAllOf\n */\nexport interface InvalidActionErrorAllOf {\n\t/**\n\t *\n\t * @type {Action}\n\t * @memberof InvalidActionErrorAllOf\n\t */\n\tinvalid_action: Action\n}\n/**\n *\n * @export\n * @interface InvalidPublicKeyError\n */\nexport interface InvalidPublicKeyError extends GatewayError {\n\t/**\n\t * The public key which was invalid. A descriptive reason is given in the main error message.\n\t * @type {string}\n\t * @memberof InvalidPublicKeyError\n\t */\n\tinvalid_public_key: string\n}\n/**\n *\n * @export\n * @interface InvalidPublicKeyErrorAllOf\n */\nexport interface InvalidPublicKeyErrorAllOf {\n\t/**\n\t * The public key which was invalid. A descriptive reason is given in the main error message.\n\t * @type {string}\n\t * @memberof InvalidPublicKeyErrorAllOf\n\t */\n\tinvalid_public_key: string\n}\n/**\n *\n * @export\n * @interface InvalidRequestError\n */\nexport interface InvalidRequestError extends GatewayError {\n\t/**\n\t * One or more validation errors which occurred when validating the request.\n\t * @type {Array<ValidationErrorsAtPath>}\n\t * @memberof InvalidRequestError\n\t */\n\tvalidation_errors: Array<ValidationErrorsAtPath>\n}\n/**\n *\n * @export\n * @interface InvalidRequestErrorAllOf\n */\nexport interface InvalidRequestErrorAllOf {\n\t/**\n\t * One or more validation errors which occurred when validating the request.\n\t * @type {Array<ValidationErrorsAtPath>}\n\t * @memberof InvalidRequestErrorAllOf\n\t */\n\tvalidation_errors: Array<ValidationErrorsAtPath>\n}\n/**\n *\n * @export\n * @interface InvalidSignatureError\n */\nexport interface InvalidSignatureError extends GatewayError {\n\t/**\n\t *\n\t * @type {Signature}\n\t * @memberof InvalidSignatureError\n\t */\n\tinvalid_signature: Signature\n}\n/**\n *\n * @export\n * @interface InvalidSignatureErrorAllOf\n */\nexport interface InvalidSignatureErrorAllOf {\n\t/**\n\t *\n\t * @type {Signature}\n\t * @memberof InvalidSignatureErrorAllOf\n\t */\n\tinvalid_signature: Signature\n}\n/**\n *\n * @export\n * @interface InvalidTokenRRIError\n */\nexport interface InvalidTokenRRIError extends GatewayError {\n\t/**\n\t * The token rri which was invalid. A descriptive reason is given in the main error message.\n\t * @type {string}\n\t * @memberof InvalidTokenRRIError\n\t */\n\tinvalid_rri: string\n}\n/**\n *\n * @export\n * @interface InvalidTokenRRIErrorAllOf\n */\nexport interface InvalidTokenRRIErrorAllOf {\n\t/**\n\t * The token rri which was invalid. A descriptive reason is given in the main error message.\n\t * @type {string}\n\t * @memberof InvalidTokenRRIErrorAllOf\n\t */\n\tinvalid_rri: string\n}\n/**\n *\n * @export\n * @interface InvalidTokenSymbolError\n */\nexport interface InvalidTokenSymbolError extends GatewayError {\n\t/**\n\t * The token symbol which was invalid. A descriptive reason is given in the main error message.\n\t * @type {string}\n\t * @memberof InvalidTokenSymbolError\n\t */\n\tinvalid_token_symbol: string\n}\n/**\n *\n * @export\n * @interface InvalidTokenSymbolErrorAllOf\n */\nexport interface InvalidTokenSymbolErrorAllOf {\n\t/**\n\t * The token symbol which was invalid. A descriptive reason is given in the main error message.\n\t * @type {string}\n\t * @memberof InvalidTokenSymbolErrorAllOf\n\t */\n\tinvalid_token_symbol: string\n}\n/**\n *\n * @export\n * @interface InvalidTransactionError\n */\nexport interface InvalidTransactionError extends GatewayError {\n\t/**\n\t * The transaction payload which was invalid.\n\t * @type {string}\n\t * @memberof InvalidTransactionError\n\t */\n\tinvalid_transaction: string\n\t/**\n\t * A descriptive reason for the invalid transaction.\n\t * @type {string}\n\t * @memberof InvalidTransactionError\n\t */\n\tmessage: string\n}\n/**\n *\n * @export\n * @interface InvalidTransactionErrorAllOf\n */\nexport interface InvalidTransactionErrorAllOf {\n\t/**\n\t * The transaction payload which was invalid.\n\t * @type {string}\n\t * @memberof InvalidTransactionErrorAllOf\n\t */\n\tinvalid_transaction: string\n\t/**\n\t * A descriptive reason for the invalid transaction.\n\t * @type {string}\n\t * @memberof InvalidTransactionErrorAllOf\n\t */\n\tmessage: string\n}\n/**\n *\n * @export\n * @interface InvalidValidatorAddressError\n */\nexport interface InvalidValidatorAddressError extends GatewayError {\n\t/**\n\t * The validator address which was invalid. A descriptive reason is given in the main error message.\n\t * @type {string}\n\t * @memberof InvalidValidatorAddressError\n\t */\n\tinvalid_account_address?: string\n}\n/**\n *\n * @export\n * @interface InvalidValidatorAddressErrorAllOf\n */\nexport interface InvalidValidatorAddressErrorAllOf {\n\t/**\n\t * The validator address which was invalid. A descriptive reason is given in the main error message.\n\t * @type {string}\n\t * @memberof InvalidValidatorAddressErrorAllOf\n\t */\n\tinvalid_account_address?: string\n}\n/**\n * The ledger state against which the response was generated. Can be used to detect if the Network Gateway is returning up-to-date information.\n * @export\n * @interface LedgerState\n */\nexport interface LedgerState {\n\t/**\n\t * The state version of the ledger. Each transaction increments the state version by 1.\n\t * @type {number}\n\t * @memberof LedgerState\n\t */\n\tversion: number\n\t/**\n\t * The round timestamp of the consensus round when this transaction was committed to ledger. This is not guaranteed to be strictly increasing, as it is computed as an average across the validator set. If this is significantly behind the current timestamp, the Network Gateway is likely reporting out-dated information, or the network has stalled.\n\t * @type {string}\n\t * @memberof LedgerState\n\t */\n\ttimestamp: string\n\t/**\n\t * The epoch number of the ledger at this state version.\n\t * @type {number}\n\t * @memberof LedgerState\n\t */\n\tepoch: number\n\t/**\n\t * The consensus round in the epoch that this state version was committed in.\n\t * @type {number}\n\t * @memberof LedgerState\n\t */\n\tround: number\n}\n/**\n *\n * @export\n * @interface MessageTooLongError\n */\nexport interface MessageTooLongError extends GatewayError {\n\t/**\n\t * The maximum byte length of the message, as per current transaction rules.\n\t * @type {number}\n\t * @memberof MessageTooLongError\n\t */\n\tlength_limit: number\n\t/**\n\t * The byte length of the message in the transaction.\n\t * @type {number}\n\t * @memberof MessageTooLongError\n\t */\n\tattempted_length: number\n}\n/**\n *\n * @export\n * @interface MessageTooLongErrorAllOf\n */\nexport interface MessageTooLongErrorAllOf {\n\t/**\n\t * The maximum byte length of the message, as per current transaction rules.\n\t * @type {number}\n\t * @memberof MessageTooLongErrorAllOf\n\t */\n\tlength_limit: number\n\t/**\n\t * The byte length of the message in the transaction.\n\t * @type {number}\n\t * @memberof MessageTooLongErrorAllOf\n\t */\n\tattempted_length: number\n}\n/**\n *\n * @export\n * @interface MintTokens\n */\nexport interface MintTokens extends Action {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof MintTokens\n\t */\n\tto_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof MintTokens\n\t */\n\tamount: TokenAmount\n}\n/**\n *\n * @export\n * @interface MintTokensAllOf\n */\nexport interface MintTokensAllOf {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof MintTokensAllOf\n\t */\n\tto_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof MintTokensAllOf\n\t */\n\tamount: TokenAmount\n}\n/**\n *\n * @export\n * @interface NetworkIdentifier\n */\nexport interface NetworkIdentifier {\n\t/**\n\t * The name of the network against which the request is made.\n\t * @type {string}\n\t * @memberof NetworkIdentifier\n\t */\n\tnetwork: string\n}\n/**\n *\n * @export\n * @interface NetworkNotSupportedError\n */\nexport interface NetworkNotSupportedError extends GatewayError {\n\t/**\n\t * The networks actually supported by the gateway - one of these needs to be used in the NetworkIdentifier of the request.\n\t * @type {Array<string>}\n\t * @memberof NetworkNotSupportedError\n\t */\n\tnetworks_supported: Array<string>\n}\n/**\n *\n * @export\n * @interface NetworkNotSupportedErrorAllOf\n */\nexport interface NetworkNotSupportedErrorAllOf {\n\t/**\n\t * The networks actually supported by the gateway - one of these needs to be used in the NetworkIdentifier of the request.\n\t * @type {Array<string>}\n\t * @memberof NetworkNotSupportedErrorAllOf\n\t */\n\tnetworks_supported: Array<string>\n}\n/**\n *\n * @export\n * @interface NotEnoughNativeTokensForFeesError\n */\nexport interface NotEnoughNativeTokensForFeesError extends GatewayError {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughNativeTokensForFeesError\n\t */\n\trequired_amount: TokenAmount\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughNativeTokensForFeesError\n\t */\n\tavailable_amount: TokenAmount\n}\n/**\n *\n * @export\n * @interface NotEnoughNativeTokensForFeesErrorAllOf\n */\nexport interface NotEnoughNativeTokensForFeesErrorAllOf {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughNativeTokensForFeesErrorAllOf\n\t */\n\trequired_amount: TokenAmount\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughNativeTokensForFeesErrorAllOf\n\t */\n\tavailable_amount: TokenAmount\n}\n/**\n *\n * @export\n * @interface NotEnoughTokensForStakeError\n */\nexport interface NotEnoughTokensForStakeError extends GatewayError {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughTokensForStakeError\n\t */\n\trequested_amount: TokenAmount\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughTokensForStakeError\n\t */\n\tavailable_amount: TokenAmount\n}\n/**\n *\n * @export\n * @interface NotEnoughTokensForTransferError\n */\nexport interface NotEnoughTokensForTransferError extends GatewayError {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughTokensForTransferError\n\t */\n\trequested_amount: TokenAmount\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughTokensForTransferError\n\t */\n\tavailable_amount: TokenAmount\n}\n/**\n *\n * @export\n * @interface NotEnoughTokensForTransferErrorAllOf\n */\nexport interface NotEnoughTokensForTransferErrorAllOf {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughTokensForTransferErrorAllOf\n\t */\n\trequested_amount: TokenAmount\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughTokensForTransferErrorAllOf\n\t */\n\tavailable_amount: TokenAmount\n}\n/**\n *\n * @export\n * @interface NotEnoughTokensForUnstakeError\n */\nexport interface NotEnoughTokensForUnstakeError extends GatewayError {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughTokensForUnstakeError\n\t */\n\trequested_amount: TokenAmount\n\t/**\n\t *\n\t * @type {AccountStakeEntry}\n\t * @memberof NotEnoughTokensForUnstakeError\n\t */\n\tstake: AccountStakeEntry\n\t/**\n\t *\n\t * @type {AccountStakeEntry}\n\t * @memberof NotEnoughTokensForUnstakeError\n\t */\n\tpending_stake: AccountStakeEntry\n}\n/**\n *\n * @export\n * @interface NotEnoughTokensForUnstakeErrorAllOf\n */\nexport interface NotEnoughTokensForUnstakeErrorAllOf {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof NotEnoughTokensForUnstakeErrorAllOf\n\t */\n\trequested_amount: TokenAmount\n\t/**\n\t *\n\t * @type {AccountStakeEntry}\n\t * @memberof NotEnoughTokensForUnstakeErrorAllOf\n\t */\n\tstake: AccountStakeEntry\n\t/**\n\t *\n\t * @type {AccountStakeEntry}\n\t * @memberof NotEnoughTokensForUnstakeErrorAllOf\n\t */\n\tpending_stake: AccountStakeEntry\n}\n/**\n *\n * @export\n * @interface NotSyncedUpError\n */\nexport interface NotSyncedUpError extends GatewayError {\n\t/**\n\t * The request type that triggered this exception.\n\t * @type {string}\n\t * @memberof NotSyncedUpError\n\t */\n\trequest_type: string\n\t/**\n\t * The current delay between the Gateway DB and the network ledger round timestamp.\n\t * @type {number}\n\t * @memberof NotSyncedUpError\n\t */\n\tcurrent_sync_delay_seconds: number\n\t/**\n\t * The maximum allowed delay between the Gateway DB and the network ledger round timestamp for this `request_type`.\n\t * @type {number}\n\t * @memberof NotSyncedUpError\n\t */\n\tmax_allowed_sync_delay_seconds: number\n}\n/**\n *\n * @export\n * @interface NotSyncedUpErrorAllOf\n */\nexport interface NotSyncedUpErrorAllOf {\n\t/**\n\t * The request type that triggered this exception.\n\t * @type {string}\n\t * @memberof NotSyncedUpErrorAllOf\n\t */\n\trequest_type: string\n\t/**\n\t * The current delay between the Gateway DB and the network ledger round timestamp.\n\t * @type {number}\n\t * @memberof NotSyncedUpErrorAllOf\n\t */\n\tcurrent_sync_delay_seconds: number\n\t/**\n\t * The maximum allowed delay between the Gateway DB and the network ledger round timestamp for this `request_type`.\n\t * @type {number}\n\t * @memberof NotSyncedUpErrorAllOf\n\t */\n\tmax_allowed_sync_delay_seconds: number\n}\n/**\n * Optional. Allows a client to request a response referencing an earlier ledger state.\n * @export\n * @interface PartialLedgerStateIdentifier\n */\nexport interface PartialLedgerStateIdentifier {\n\t/**\n\t * If the version is provided, the latest ledger state <= the given version is returned.\n\t * @type {number}\n\t * @memberof PartialLedgerStateIdentifier\n\t */\n\tversion?: number\n\t/**\n\t * If a timestamp is provided, the latest ledger state <= the given timestamp is returned.\n\t * @type {string}\n\t * @memberof PartialLedgerStateIdentifier\n\t */\n\ttimestamp?: string\n\t/**\n\t * If an epoch is provided, the ledger state at the given epoch <= the given round (else round 0) is returned.\n\t * @type {number}\n\t * @memberof PartialLedgerStateIdentifier\n\t */\n\tepoch?: number\n\t/**\n\t *\n\t * @type {number}\n\t * @memberof PartialLedgerStateIdentifier\n\t */\n\tround?: number\n}\n/**\n *\n * @export\n * @interface PublicKey\n */\nexport interface PublicKey {\n\t/**\n\t * The compressed public key (33 bytes), hex-encoded.\n\t * @type {string}\n\t * @memberof PublicKey\n\t */\n\thex: string\n}\n/**\n *\n * @export\n * @interface RecentTransactionsRequest\n */\nexport interface RecentTransactionsRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof RecentTransactionsRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof RecentTransactionsRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n\t/**\n\t * This cursor allows forward pagination, by providing the cursor from the previous request.\n\t * @type {string}\n\t * @memberof RecentTransactionsRequest\n\t */\n\tcursor?: string\n\t/**\n\t * The page size requested. The maximum value is 30 at present.\n\t * @type {number}\n\t * @memberof RecentTransactionsRequest\n\t */\n\tlimit?: number\n}\n/**\n *\n * @export\n * @interface RecentTransactionsResponse\n */\nexport interface RecentTransactionsResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof RecentTransactionsResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t * The cursor to be provided for the next page of results. If missing, this is the last page of results.\n\t * @type {string}\n\t * @memberof RecentTransactionsResponse\n\t */\n\tnext_cursor?: string\n\t/**\n\t * The page of user transactions.\n\t * @type {Array<TransactionInfo>}\n\t * @memberof RecentTransactionsResponse\n\t */\n\ttransactions: Array<TransactionInfo>\n}\n/**\n *\n * @export\n * @interface RegisterValidator\n */\nexport interface RegisterValidator extends Action {\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof RegisterValidator\n\t */\n\tvalidator: ValidatorIdentifier\n}\n/**\n *\n * @export\n * @interface RegisterValidatorAllOf\n */\nexport interface RegisterValidatorAllOf {\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof RegisterValidatorAllOf\n\t */\n\tvalidator: ValidatorIdentifier\n}\n/**\n *\n * @export\n * @interface Signature\n */\nexport interface Signature {\n\t/**\n\t *\n\t * @type {PublicKey}\n\t * @memberof Signature\n\t */\n\tpublic_key: PublicKey\n\t/**\n\t * An ECDSA signature of the payload to sign with the given `public_key`. The ECDSA signature should be created using the secp256k1 curve and should be encoded in DER format, and then encoded as a hex string.\n\t * @type {string}\n\t * @memberof Signature\n\t */\n\tbytes: string\n}\n/**\n *\n * @export\n * @interface StakeTokens\n */\nexport interface StakeTokens extends Action {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof StakeTokens\n\t */\n\tfrom_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof StakeTokens\n\t */\n\tto_validator: ValidatorIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof StakeTokens\n\t */\n\tamount: TokenAmount\n}\n/**\n *\n * @export\n * @interface StakeTokensAllOf\n */\nexport interface StakeTokensAllOf {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof StakeTokensAllOf\n\t */\n\tfrom_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof StakeTokensAllOf\n\t */\n\tto_validator: ValidatorIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof StakeTokensAllOf\n\t */\n\tamount: TokenAmount\n}\n/**\n *\n * @export\n * @interface TargetLedgerState\n */\nexport interface TargetLedgerState {\n\t/**\n\t * The latest-seen state version of the tip of the network\\'s ledger. If this is singificantly ahead of the current LedgerState version, the Network Gateway is possibly behind and may be reporting outdated information.\n\t * @type {number}\n\t * @memberof TargetLedgerState\n\t */\n\tversion: number\n}\n/**\n *\n * @export\n * @interface Token\n */\nexport interface Token {\n\t/**\n\t *\n\t * @type {TokenIdentifier}\n\t * @memberof Token\n\t */\n\ttoken_identifier: TokenIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof Token\n\t */\n\ttoken_supply: TokenAmount\n\t/**\n\t *\n\t * @type {TokenInfo}\n\t * @memberof Token\n\t */\n\tinfo: TokenInfo\n\t/**\n\t *\n\t * @type {TokenProperties}\n\t * @memberof Token\n\t */\n\ttoken_properties: TokenProperties\n}\n/**\n *\n * @export\n * @interface TokenAmount\n */\nexport interface TokenAmount {\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof TokenAmount\n\t */\n\tvalue: string\n\t/**\n\t *\n\t * @type {TokenIdentifier}\n\t * @memberof TokenAmount\n\t */\n\ttoken_identifier: TokenIdentifier\n}\n/**\n *\n * @export\n * @interface TokenDeriveRequest\n */\nexport interface TokenDeriveRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof TokenDeriveRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {PublicKey}\n\t * @memberof TokenDeriveRequest\n\t */\n\tpublic_key: PublicKey\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof TokenDeriveRequest\n\t */\n\tsymbol: string\n}\n/**\n *\n * @export\n * @interface TokenDeriveResponse\n */\nexport interface TokenDeriveResponse {\n\t/**\n\t *\n\t * @type {TokenIdentifier}\n\t * @memberof TokenDeriveResponse\n\t */\n\ttoken_identifier: TokenIdentifier\n}\n/**\n *\n * @export\n * @interface TokenIdentifier\n */\nexport interface TokenIdentifier {\n\t/**\n\t * The radix resource identifier of the token.\n\t * @type {string}\n\t * @memberof TokenIdentifier\n\t */\n\trri: string\n}\n/**\n *\n * @export\n * @interface TokenInfo\n */\nexport interface TokenInfo {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof TokenInfo\n\t */\n\ttotal_minted: TokenAmount\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof TokenInfo\n\t */\n\ttotal_burned: TokenAmount\n}\n/**\n *\n * @export\n * @interface TokenNativeRequest\n */\nexport interface TokenNativeRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof TokenNativeRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof TokenNativeRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n}\n/**\n *\n * @export\n * @interface TokenNativeResponse\n */\nexport interface TokenNativeResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof TokenNativeResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t *\n\t * @type {Token}\n\t * @memberof TokenNativeResponse\n\t */\n\ttoken: Token\n}\n/**\n *\n * @export\n * @interface TokenNotFoundError\n */\nexport interface TokenNotFoundError extends GatewayError {\n\t/**\n\t *\n\t * @type {TokenIdentifier}\n\t * @memberof TokenNotFoundError\n\t */\n\ttoken_not_found: TokenIdentifier\n}\n/**\n *\n * @export\n * @interface TokenNotFoundErrorAllOf\n */\nexport interface TokenNotFoundErrorAllOf {\n\t/**\n\t *\n\t * @type {TokenIdentifier}\n\t * @memberof TokenNotFoundErrorAllOf\n\t */\n\ttoken_not_found: TokenIdentifier\n}\n/**\n *\n * @export\n * @interface TokenProperties\n */\nexport interface TokenProperties {\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof TokenProperties\n\t */\n\tname: string\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof TokenProperties\n\t */\n\tdescription: string\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof TokenProperties\n\t */\n\ticon_url: string\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof TokenProperties\n\t */\n\turl: string\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof TokenProperties\n\t */\n\tsymbol: string\n\t/**\n\t * If true, the token is allowed to be minted/burned by the owner.\n\t * @type {boolean}\n\t * @memberof TokenProperties\n\t */\n\tis_supply_mutable: boolean\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof TokenProperties\n\t */\n\tgranularity: string\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof TokenProperties\n\t */\n\towner?: AccountIdentifier\n}\n/**\n *\n * @export\n * @interface TokenRequest\n */\nexport interface TokenRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof TokenRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {TokenIdentifier}\n\t * @memberof TokenRequest\n\t */\n\ttoken_identifier: TokenIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof TokenRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n}\n/**\n *\n * @export\n * @interface TokenResponse\n */\nexport interface TokenResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof TokenResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t *\n\t * @type {Token}\n\t * @memberof TokenResponse\n\t */\n\ttoken: Token\n}\n/**\n *\n * @export\n * @interface TransactionBuild\n */\nexport interface TransactionBuild {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof TransactionBuild\n\t */\n\tfee: TokenAmount\n\t/**\n\t * The unsigned transaction payload, hex encoded.\n\t * @type {string}\n\t * @memberof TransactionBuild\n\t */\n\tunsigned_transaction: string\n\t/**\n\t * The payload which needs signing, hex encoded. This is `SHA256(SHA256(unsigned_transaction_bytes))`.\n\t * @type {string}\n\t * @memberof TransactionBuild\n\t */\n\tpayload_to_sign: string\n}\n/**\n *\n * @export\n * @interface TransactionBuildRequest\n */\nexport interface TransactionBuildRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof TransactionBuildRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof TransactionBuildRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n\t/**\n\t *\n\t * @type {Array<Action>}\n\t * @memberof TransactionBuildRequest\n\t */\n\tactions: Array<Action>\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof TransactionBuildRequest\n\t */\n\tfee_payer: AccountIdentifier\n\t/**\n\t * The hex-encoded message bytes.\n\t * @type {string}\n\t * @memberof TransactionBuildRequest\n\t */\n\tmessage?: string\n\t/**\n\t * If true, mints and burns (aside from fee payments) are not permitted during transaction execution.\n\t * @type {boolean}\n\t * @memberof TransactionBuildRequest\n\t */\n\tdisable_token_mint_and_burn?: boolean\n}\n/**\n *\n * @export\n * @interface TransactionBuildResponse\n */\nexport interface TransactionBuildResponse {\n\t/**\n\t *\n\t * @type {TransactionBuild}\n\t * @memberof TransactionBuildResponse\n\t */\n\ttransaction_build: TransactionBuild\n}\n/**\n *\n * @export\n * @interface TransactionFinalizeRequest\n */\nexport interface TransactionFinalizeRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof TransactionFinalizeRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t * The unsigned transaction payload, hex encoded.\n\t * @type {string}\n\t * @memberof TransactionFinalizeRequest\n\t */\n\tunsigned_transaction: string\n\t/**\n\t *\n\t * @type {Signature}\n\t * @memberof TransactionFinalizeRequest\n\t */\n\tsignature: Signature\n\t/**\n\t * If true, the transaction is immediately submitted after finalization. However, we recommend that a transaction is submitted in a step after finalization. This ensures that you have a transaction identifier on hand to monitor the transaction status, even if the submission request failed with an uncertain error.\n\t * @type {boolean}\n\t * @memberof TransactionFinalizeRequest\n\t */\n\tsubmit?: boolean\n}\n/**\n *\n * @export\n * @interface TransactionFinalizeResponse\n */\nexport interface TransactionFinalizeResponse {\n\t/**\n\t * The signed transaction payload which can be submitted, hex encoded.\n\t * @type {string}\n\t * @memberof TransactionFinalizeResponse\n\t */\n\tsigned_transaction: string\n\t/**\n\t *\n\t * @type {TransactionIdentifier}\n\t * @memberof TransactionFinalizeResponse\n\t */\n\ttransaction_identifier: TransactionIdentifier\n}\n/**\n *\n * @export\n * @interface TransactionIdentifier\n */\nexport interface TransactionIdentifier {\n\t/**\n\t * The transaction identifier hash.\n\t * @type {string}\n\t * @memberof TransactionIdentifier\n\t */\n\thash: string\n}\n/**\n *\n * @export\n * @interface TransactionInfo\n */\nexport interface TransactionInfo {\n\t/**\n\t *\n\t * @type {TransactionStatus}\n\t * @memberof TransactionInfo\n\t */\n\ttransaction_status: TransactionStatus\n\t/**\n\t *\n\t * @type {TransactionIdentifier}\n\t * @memberof TransactionInfo\n\t */\n\ttransaction_identifier: TransactionIdentifier\n\t/**\n\t *\n\t * @type {Array<Action>}\n\t * @memberof TransactionInfo\n\t */\n\tactions: Array<Action>\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof TransactionInfo\n\t */\n\tfee_paid: TokenAmount\n\t/**\n\t *\n\t * @type {TransactionMetadata}\n\t * @memberof TransactionInfo\n\t */\n\tmetadata: TransactionMetadata\n}\n/**\n *\n * @export\n * @interface TransactionMetadata\n */\nexport interface TransactionMetadata {\n\t/**\n\t * The transaction payload, hex encoded.\n\t * @type {string}\n\t * @memberof TransactionMetadata\n\t */\n\thex: string\n\t/**\n\t * The message bytes, hex encoded.\n\t * @type {string}\n\t * @memberof TransactionMetadata\n\t */\n\tmessage?: string\n}\n/**\n *\n * @export\n * @interface TransactionNotFoundError\n */\nexport interface TransactionNotFoundError extends GatewayError {\n\t/**\n\t *\n\t * @type {TransactionIdentifier}\n\t * @memberof TransactionNotFoundError\n\t */\n\ttransaction_not_found: TransactionIdentifier\n}\n/**\n *\n * @export\n * @interface TransactionNotFoundErrorAllOf\n */\nexport interface TransactionNotFoundErrorAllOf {\n\t/**\n\t *\n\t * @type {TransactionIdentifier}\n\t * @memberof TransactionNotFoundErrorAllOf\n\t */\n\ttransaction_not_found: TransactionIdentifier\n}\n/**\n *\n * @export\n * @interface TransactionRules\n */\nexport interface TransactionRules {\n\t/**\n\t *\n\t * @type {number}\n\t * @memberof TransactionRules\n\t */\n\tmaximum_message_length?: number\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof TransactionRules\n\t */\n\tminimum_stake?: TokenAmount\n}\n/**\n *\n * @export\n * @interface TransactionRulesRequest\n */\nexport interface TransactionRulesRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof TransactionRulesRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof TransactionRulesRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n}\n/**\n *\n * @export\n * @interface TransactionRulesResponse\n */\nexport interface TransactionRulesResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof TransactionRulesResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t *\n\t * @type {TransactionRules}\n\t * @memberof TransactionRulesResponse\n\t */\n\ttransaction_rules: TransactionRules\n}\n/**\n *\n * @export\n * @interface TransactionStatus\n */\nexport interface TransactionStatus {\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof TransactionStatus\n\t */\n\tstatus: TransactionStatusStatusEnum\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof TransactionStatus\n\t */\n\tconfirmed_time?: string\n\t/**\n\t *\n\t * @type {number}\n\t * @memberof TransactionStatus\n\t */\n\tledger_state_version?: number\n}\n\n/**\n * @export\n * @enum {string}\n */\nexport enum TransactionStatusStatusEnum {\n\tPending = 'PENDING',\n\tConfirmed = 'CONFIRMED',\n\tFailed = 'FAILED',\n}\n\n/**\n *\n * @export\n * @interface TransactionStatusRequest\n */\nexport interface TransactionStatusRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof TransactionStatusRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {TransactionIdentifier}\n\t * @memberof TransactionStatusRequest\n\t */\n\ttransaction_identifier: TransactionIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof TransactionStatusRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n}\n/**\n *\n * @export\n * @interface TransactionStatusResponse\n */\nexport interface TransactionStatusResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof TransactionStatusResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t *\n\t * @type {TransactionInfo}\n\t * @memberof TransactionStatusResponse\n\t */\n\ttransaction: TransactionInfo\n}\n/**\n *\n * @export\n * @interface TransactionSubmitRequest\n */\nexport interface TransactionSubmitRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof TransactionSubmitRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t * The signed transaction payload which can be submitted, hex encoded.\n\t * @type {string}\n\t * @memberof TransactionSubmitRequest\n\t */\n\tsigned_transaction: string\n}\n/**\n *\n * @export\n * @interface TransactionSubmitResponse\n */\nexport interface TransactionSubmitResponse {\n\t/**\n\t *\n\t * @type {TransactionIdentifier}\n\t * @memberof TransactionSubmitResponse\n\t */\n\ttransaction_identifier: TransactionIdentifier\n}\n/**\n *\n * @export\n * @interface TransferTokens\n */\nexport interface TransferTokens extends Action {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof TransferTokens\n\t */\n\tfrom_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof TransferTokens\n\t */\n\tto_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof TransferTokens\n\t */\n\tamount: TokenAmount\n}\n/**\n *\n * @export\n * @interface TransferTokensAllOf\n */\nexport interface TransferTokensAllOf {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof TransferTokensAllOf\n\t */\n\tfrom_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof TransferTokensAllOf\n\t */\n\tto_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof TransferTokensAllOf\n\t */\n\tamount: TokenAmount\n}\n/**\n *\n * @export\n * @interface UnregisterValidator\n */\nexport interface UnregisterValidator extends Action {\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof UnregisterValidator\n\t */\n\tvalidator: ValidatorIdentifier\n}\n/**\n * An action to unstake tokens. Exactly one of amount or unstake_percentage is required.\n * @export\n * @interface UnstakeTokens\n */\nexport interface UnstakeTokens extends Action {\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof UnstakeTokens\n\t */\n\tfrom_validator: ValidatorIdentifier\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof UnstakeTokens\n\t */\n\tto_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof UnstakeTokens\n\t */\n\tamount?: TokenAmount\n\t/**\n\t * The percentage of currently staked XRD to unstake, where the proportion is a proportion of the current active stake at the given LedgerState. To be explicit, the referenced active state does not include pending stake, pending unstake or locked unstake.\n\t * @type {number}\n\t * @memberof UnstakeTokens\n\t */\n\tunstake_percentage?: number\n}\n/**\n *\n * @export\n * @interface UnstakeTokensAllOf\n */\nexport interface UnstakeTokensAllOf {\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof UnstakeTokensAllOf\n\t */\n\tfrom_validator: ValidatorIdentifier\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof UnstakeTokensAllOf\n\t */\n\tto_account: AccountIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof UnstakeTokensAllOf\n\t */\n\tamount?: TokenAmount\n\t/**\n\t * The percentage of currently staked XRD to unstake, where the proportion is a proportion of the current active stake at the given LedgerState. To be explicit, the referenced active state does not include pending stake, pending unstake or locked unstake.\n\t * @type {number}\n\t * @memberof UnstakeTokensAllOf\n\t */\n\tunstake_percentage?: number\n}\n/**\n *\n * @export\n * @interface ValidationErrorsAtPath\n */\nexport interface ValidationErrorsAtPath {\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof ValidationErrorsAtPath\n\t */\n\tpath: string\n\t/**\n\t *\n\t * @type {Array<string>}\n\t * @memberof ValidationErrorsAtPath\n\t */\n\terrors: Array<string>\n}\n/**\n *\n * @export\n * @interface Validator\n */\nexport interface Validator {\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof Validator\n\t */\n\tvalidator_identifier: ValidatorIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof Validator\n\t */\n\tstake: TokenAmount\n\t/**\n\t *\n\t * @type {ValidatorInfo}\n\t * @memberof Validator\n\t */\n\tinfo: ValidatorInfo\n\t/**\n\t *\n\t * @type {ValidatorProperties}\n\t * @memberof Validator\n\t */\n\tproperties: ValidatorProperties\n\t/**\n\t *\n\t * @type {ValidatorForkSignal}\n\t * @memberof Validator\n\t */\n\tlatest_fork_readiness_signal?: ValidatorForkSignal\n}\n/**\n *\n * @export\n * @interface ValidatorAccountStake\n */\nexport interface ValidatorAccountStake {\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof ValidatorAccountStake\n\t */\n\taccount: AccountIdentifier\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof ValidatorAccountStake\n\t */\n\tvalidator: ValidatorIdentifier\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof ValidatorAccountStake\n\t */\n\ttotal_pending_stake?: TokenAmount\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof ValidatorAccountStake\n\t */\n\ttotal_stake?: TokenAmount\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof ValidatorAccountStake\n\t */\n\ttotal_pending_unstake?: TokenAmount\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof ValidatorAccountStake\n\t */\n\ttotal_unstaking?: TokenAmount\n}\n/**\n *\n * @export\n * @interface ValidatorDeriveRequest\n */\nexport interface ValidatorDeriveRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof ValidatorDeriveRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {PublicKey}\n\t * @memberof ValidatorDeriveRequest\n\t */\n\tpublic_key: PublicKey\n}\n/**\n *\n * @export\n * @interface ValidatorDeriveResponse\n */\nexport interface ValidatorDeriveResponse {\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof ValidatorDeriveResponse\n\t */\n\taccount_identifier: ValidatorIdentifier\n}\n/**\n *\n * @export\n * @interface ValidatorForkSignal\n */\nexport interface ValidatorForkSignal {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof ValidatorForkSignal\n\t */\n\tsignalled_at: LedgerState\n\t/**\n\t * The logical fork id, which is used for counting votes. The logical id encodes the name, as well as the thresholds when the fork would activate. If a signal is cleared, this field may be empty.\n\t * @type {string}\n\t * @memberof ValidatorForkSignal\n\t */\n\tfork_id?: string\n\t/**\n\t * The human-readable fork name. If a signal is cleared, this field may be empty.\n\t * @type {string}\n\t * @memberof ValidatorForkSignal\n\t */\n\tfork_name?: string\n}\n/**\n *\n * @export\n * @interface ValidatorIdentifier\n */\nexport interface ValidatorIdentifier {\n\t/**\n\t * The radix address of the validator.\n\t * @type {string}\n\t * @memberof ValidatorIdentifier\n\t */\n\taddress: string\n}\n/**\n *\n * @export\n * @interface ValidatorInfo\n */\nexport interface ValidatorInfo {\n\t/**\n\t *\n\t * @type {TokenAmount}\n\t * @memberof ValidatorInfo\n\t */\n\towner_stake: TokenAmount\n\t/**\n\t *\n\t * @type {ValidatorUptime}\n\t * @memberof ValidatorInfo\n\t */\n\tuptime: ValidatorUptime\n}\n/**\n *\n * @export\n * @interface ValidatorProperties\n */\nexport interface ValidatorProperties {\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof ValidatorProperties\n\t */\n\turl: string\n\t/**\n\t *\n\t * @type {number}\n\t * @memberof ValidatorProperties\n\t */\n\tvalidator_fee_percentage: number\n\t/**\n\t *\n\t * @type {string}\n\t * @memberof ValidatorProperties\n\t */\n\tname: string\n\t/**\n\t *\n\t * @type {boolean}\n\t * @memberof ValidatorProperties\n\t */\n\tregistered: boolean\n\t/**\n\t *\n\t * @type {AccountIdentifier}\n\t * @memberof ValidatorProperties\n\t */\n\towner_account_identifier: AccountIdentifier\n\t/**\n\t *\n\t * @type {boolean}\n\t * @memberof ValidatorProperties\n\t */\n\texternal_stake_accepted: boolean\n}\n/**\n *\n * @export\n * @interface ValidatorRequest\n */\nexport interface ValidatorRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof ValidatorRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof ValidatorRequest\n\t */\n\tvalidator_identifier: ValidatorIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof ValidatorRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n}\n/**\n *\n * @export\n * @interface ValidatorResponse\n */\nexport interface ValidatorResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof ValidatorResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t *\n\t * @type {Validator}\n\t * @memberof ValidatorResponse\n\t */\n\tvalidator: Validator\n}\n/**\n *\n * @export\n * @interface ValidatorStakesRequest\n */\nexport interface ValidatorStakesRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof ValidatorStakesRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof ValidatorStakesRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n\t/**\n\t *\n\t * @type {ValidatorIdentifier}\n\t * @memberof ValidatorStakesRequest\n\t */\n\tvalidator_identifier: ValidatorIdentifier\n\t/**\n\t * This cursor allows forward pagination, by providing the cursor from the previous request.\n\t * @type {string}\n\t * @memberof ValidatorStakesRequest\n\t */\n\tcursor?: string\n\t/**\n\t * The page size requested. The maximum value is 30 at present.\n\t * @type {number}\n\t * @memberof ValidatorStakesRequest\n\t */\n\tlimit?: number\n}\n/**\n *\n * @export\n * @interface ValidatorStakesResponse\n */\nexport interface ValidatorStakesResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof ValidatorStakesResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t * The total number of accounts delegating stake to the validator in some state.\n\t * @type {number}\n\t * @memberof ValidatorStakesResponse\n\t */\n\ttotal_count: number\n\t/**\n\t * The cursor to be provided for the next page of results. If missing, this is the last page of results.\n\t * @type {string}\n\t * @memberof ValidatorStakesResponse\n\t */\n\tnext_cursor?: string\n\t/**\n\t * The page of account stake delegations.\n\t * @type {Array<ValidatorAccountStake>}\n\t * @memberof ValidatorStakesResponse\n\t */\n\taccount_stake_delegations: Array<ValidatorAccountStake>\n}\n/**\n *\n * @export\n * @interface ValidatorUptime\n */\nexport interface ValidatorUptime {\n\t/**\n\t *\n\t * @type {EpochRange}\n\t * @memberof ValidatorUptime\n\t */\n\tepoch_range: EpochRange\n\t/**\n\t * The percentage of proposals completed, compared with the total of proposals completed/missed, in the given epoch range.\n\t * @type {number}\n\t * @memberof ValidatorUptime\n\t */\n\tuptime_percentage: number\n\t/**\n\t * The number of proposals the validator failed to share with the network in time, in the given epoch range.\n\t * @type {number}\n\t * @memberof ValidatorUptime\n\t */\n\tproposals_missed: number\n\t/**\n\t * The number of proposals the validator completed successfully, in the given epoch range.\n\t * @type {number}\n\t * @memberof ValidatorUptime\n\t */\n\tproposals_completed: number\n}\n/**\n *\n * @export\n * @interface ValidatorsRequest\n */\nexport interface ValidatorsRequest {\n\t/**\n\t *\n\t * @type {NetworkIdentifier}\n\t * @memberof ValidatorsRequest\n\t */\n\tnetwork_identifier: NetworkIdentifier\n\t/**\n\t *\n\t * @type {PartialLedgerStateIdentifier}\n\t * @memberof ValidatorsRequest\n\t */\n\tat_state_identifier?: PartialLedgerStateIdentifier\n}\n/**\n *\n * @export\n * @interface ValidatorsResponse\n */\nexport interface ValidatorsResponse {\n\t/**\n\t *\n\t * @type {LedgerState}\n\t * @memberof ValidatorsResponse\n\t */\n\tledger_state: LedgerState\n\t/**\n\t *\n\t * @type {Array<Validator>}\n\t * @memberof ValidatorsResponse\n\t */\n\tvalidators: Array<Validator>\n}\n\n/**\n * AccountApi - axios parameter creator\n * @export\n */\nexport const AccountApiAxiosParamCreator = function (\n\tconfiguration?: Configuration,\n) {\n\treturn {\n\t\t/**\n\t\t * Returns an account\\'s available and staked token balances, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Account Balances\n\t\t * @param {AccountBalancesRequest} accountBalancesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\taccountBalancesPost: async (\n\t\t\taccountBalancesRequest: AccountBalancesRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'accountBalancesRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'accountBalancesPost',\n\t\t\t\t'accountBalancesRequest',\n\t\t\t\taccountBalancesRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/account/balances`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\taccountBalancesRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns the account address associated with the given public key.\n\t\t * @summary Derive Account Identifier\n\t\t * @param {AccountDeriveRequest} accountDeriveRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\taccountDerivePost: async (\n\t\t\taccountDeriveRequest: AccountDeriveRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'accountDeriveRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'accountDerivePost',\n\t\t\t\t'accountDeriveRequest',\n\t\t\t\taccountDeriveRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/account/derive`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\taccountDeriveRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Stake Positions\n\t\t * @param {AccountStakesRequest} accountStakesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\taccountStakesPost: async (\n\t\t\taccountStakesRequest: AccountStakesRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'accountStakesRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'accountStakesPost',\n\t\t\t\t'accountStakesRequest',\n\t\t\t\taccountStakesRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/account/stakes`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\taccountStakesRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Account Transactions\n\t\t * @param {AccountTransactionsRequest} accountTransactionsRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\taccountTransactionsPost: async (\n\t\t\taccountTransactionsRequest: AccountTransactionsRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'accountTransactionsRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'accountTransactionsPost',\n\t\t\t\t'accountTransactionsRequest',\n\t\t\t\taccountTransactionsRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/account/transactions`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\taccountTransactionsRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Unstake Positions\n\t\t * @param {AccountUnstakesRequest} accountUnstakesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\taccountUnstakesPost: async (\n\t\t\taccountUnstakesRequest: AccountUnstakesRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'accountUnstakesRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'accountUnstakesPost',\n\t\t\t\t'accountUnstakesRequest',\n\t\t\t\taccountUnstakesRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/account/unstakes`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\taccountUnstakesRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t}\n}\n\n/**\n * AccountApi - functional programming interface\n * @export\n */\nexport const AccountApiFp = function (configuration?: Configuration) {\n\tconst localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)\n\treturn {\n\t\t/**\n\t\t * Returns an account\\'s available and staked token balances, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Account Balances\n\t\t * @param {AccountBalancesRequest} accountBalancesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync accountBalancesPost(\n\t\t\taccountBalancesRequest: AccountBalancesRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<AccountBalancesResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.accountBalancesPost(\n\t\t\t\taccountBalancesRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns the account address associated with the given public key.\n\t\t * @summary Derive Account Identifier\n\t\t * @param {AccountDeriveRequest} accountDeriveRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync accountDerivePost(\n\t\t\taccountDeriveRequest: AccountDeriveRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<AccountDeriveResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.accountDerivePost(\n\t\t\t\taccountDeriveRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Stake Positions\n\t\t * @param {AccountStakesRequest} accountStakesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync accountStakesPost(\n\t\t\taccountStakesRequest: AccountStakesRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<AccountStakesResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.accountStakesPost(\n\t\t\t\taccountStakesRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Account Transactions\n\t\t * @param {AccountTransactionsRequest} accountTransactionsRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync accountTransactionsPost(\n\t\t\taccountTransactionsRequest: AccountTransactionsRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<AccountTransactionsResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.accountTransactionsPost(\n\t\t\t\taccountTransactionsRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Unstake Positions\n\t\t * @param {AccountUnstakesRequest} accountUnstakesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync accountUnstakesPost(\n\t\t\taccountUnstakesRequest: AccountUnstakesRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<AccountUnstakesResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.accountUnstakesPost(\n\t\t\t\taccountUnstakesRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t}\n}\n\n/**\n * AccountApi - factory interface\n * @export\n */\nexport const AccountApiFactory = function (\n\tconfiguration?: Configuration,\n\tbasePath?: string,\n\taxios?: AxiosInstance,\n) {\n\tconst localVarFp = AccountApiFp(configuration)\n\treturn {\n\t\t/**\n\t\t * Returns an account\\'s available and staked token balances, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Account Balances\n\t\t * @param {AccountBalancesRequest} accountBalancesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\taccountBalancesPost(\n\t\t\taccountBalancesRequest: AccountBalancesRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<AccountBalancesResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.accountBalancesPost(accountBalancesRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns the account address associated with the given public key.\n\t\t * @summary Derive Account Identifier\n\t\t * @param {AccountDeriveRequest} accountDeriveRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\taccountDerivePost(\n\t\t\taccountDeriveRequest: AccountDeriveRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<AccountDeriveResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.accountDerivePost(accountDeriveRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Stake Positions\n\t\t * @param {AccountStakesRequest} accountStakesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\taccountStakesPost(\n\t\t\taccountStakesRequest: AccountStakesRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<AccountStakesResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.accountStakesPost(accountStakesRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Account Transactions\n\t\t * @param {AccountTransactionsRequest} accountTransactionsRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\taccountTransactionsPost(\n\t\t\taccountTransactionsRequest: AccountTransactionsRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<AccountTransactionsResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.accountTransactionsPost(accountTransactionsRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t\t * @summary Get Unstake Positions\n\t\t * @param {AccountUnstakesRequest} accountUnstakesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\taccountUnstakesPost(\n\t\t\taccountUnstakesRequest: AccountUnstakesRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<AccountUnstakesResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.accountUnstakesPost(accountUnstakesRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t}\n}\n\n/**\n * AccountApi - object-oriented interface\n * @export\n * @class AccountApi\n * @extends {BaseAPI}\n */\nexport class AccountApi extends BaseAPI {\n\t/**\n\t * Returns an account\\'s available and staked token balances, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t * @summary Get Account Balances\n\t * @param {AccountBalancesRequest} accountBalancesRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof AccountApi\n\t */\n\tpublic accountBalancesPost(\n\t\taccountBalancesRequest: AccountBalancesRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn AccountApiFp(this.configuration)\n\t\t\t.accountBalancesPost(accountBalancesRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns the account address associated with the given public key.\n\t * @summary Derive Account Identifier\n\t * @param {AccountDeriveRequest} accountDeriveRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof AccountApi\n\t */\n\tpublic accountDerivePost(\n\t\taccountDeriveRequest: AccountDeriveRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn AccountApiFp(this.configuration)\n\t\t\t.accountDerivePost(accountDeriveRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns the xrd which the account has in pending and active delegated stake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t * @summary Get Stake Positions\n\t * @param {AccountStakesRequest} accountStakesRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof AccountApi\n\t */\n\tpublic accountStakesPost(\n\t\taccountStakesRequest: AccountStakesRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn AccountApiFp(this.configuration)\n\t\t\t.accountStakesPost(accountStakesRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns user-initiated transactions involving the given account address which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t * @summary Get Account Transactions\n\t * @param {AccountTransactionsRequest} accountTransactionsRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof AccountApi\n\t */\n\tpublic accountTransactionsPost(\n\t\taccountTransactionsRequest: AccountTransactionsRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn AccountApiFp(this.configuration)\n\t\t\t.accountTransactionsPost(accountTransactionsRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns the xrd which the account has in pending and temporarily-locked delegated unstake positions with validators, given an account address. If an account address is valid, but doesn\\'t have any ledger transactions against it, this endpoint still returns a successful response.\n\t * @summary Get Unstake Positions\n\t * @param {AccountUnstakesRequest} accountUnstakesRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof AccountApi\n\t */\n\tpublic accountUnstakesPost(\n\t\taccountUnstakesRequest: AccountUnstakesRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn AccountApiFp(this.configuration)\n\t\t\t.accountUnstakesPost(accountUnstakesRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n}\n\n/**\n * StatusApi - axios parameter creator\n * @export\n */\nexport const StatusApiAxiosParamCreator = function (\n\tconfiguration?: Configuration,\n) {\n\treturn {\n\t\t/**\n\t\t * Returns the Gateway API version, network and current ledger state.\n\t\t * @summary Get Gateway Info\n\t\t * @param {object} body\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tgatewayPost: async (\n\t\t\tbody: object,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'body' is not null or undefined\n\t\t\tassertParamExists('gatewayPost', 'body', body)\n\t\t\tconst localVarPath = `/gateway`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\tbody,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t}\n}\n\n/**\n * StatusApi - functional programming interface\n * @export\n */\nexport const StatusApiFp = function (configuration?: Configuration) {\n\tconst localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)\n\treturn {\n\t\t/**\n\t\t * Returns the Gateway API version, network and current ledger state.\n\t\t * @summary Get Gateway Info\n\t\t * @param {object} body\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync gatewayPost(\n\t\t\tbody: object,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<GatewayResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.gatewayPost(\n\t\t\t\tbody,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t}\n}\n\n/**\n * StatusApi - factory interface\n * @export\n */\nexport const StatusApiFactory = function (\n\tconfiguration?: Configuration,\n\tbasePath?: string,\n\taxios?: AxiosInstance,\n) {\n\tconst localVarFp = StatusApiFp(configuration)\n\treturn {\n\t\t/**\n\t\t * Returns the Gateway API version, network and current ledger state.\n\t\t * @summary Get Gateway Info\n\t\t * @param {object} body\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tgatewayPost(\n\t\t\tbody: object,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<GatewayResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.gatewayPost(body, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t}\n}\n\n/**\n * StatusApi - object-oriented interface\n * @export\n * @class StatusApi\n * @extends {BaseAPI}\n */\nexport class StatusApi extends BaseAPI {\n\t/**\n\t * Returns the Gateway API version, network and current ledger state.\n\t * @summary Get Gateway Info\n\t * @param {object} body\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof StatusApi\n\t */\n\tpublic gatewayPost(body: object, options?: AxiosRequestConfig) {\n\t\treturn StatusApiFp(this.configuration)\n\t\t\t.gatewayPost(body, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n}\n\n/**\n * TokenApi - axios parameter creator\n * @export\n */\nexport const TokenApiAxiosParamCreator = function (\n\tconfiguration?: Configuration,\n) {\n\treturn {\n\t\t/**\n\t\t * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.\n\t\t * @summary Derive Token Identifier\n\t\t * @param {TokenDeriveRequest} tokenDeriveRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttokenDerivePost: async (\n\t\t\ttokenDeriveRequest: TokenDeriveRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'tokenDeriveRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'tokenDerivePost',\n\t\t\t\t'tokenDeriveRequest',\n\t\t\t\ttokenDeriveRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/token/derive`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\ttokenDeriveRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns information about XRD, including its Radix Resource Identifier.\n\t\t * @summary Get Native Token Info\n\t\t * @param {TokenNativeRequest} tokenNativeRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttokenNativePost: async (\n\t\t\ttokenNativeRequest: TokenNativeRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'tokenNativeRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'tokenNativePost',\n\t\t\t\t'tokenNativeRequest',\n\t\t\t\ttokenNativeRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/token/native`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\ttokenNativeRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns information about any token, given its Radix Resource Identifier.\n\t\t * @summary Get Token Info\n\t\t * @param {TokenRequest} tokenRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttokenPost: async (\n\t\t\ttokenRequest: TokenRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'tokenRequest' is not null or undefined\n\t\t\tassertParamExists('tokenPost', 'tokenRequest', tokenRequest)\n\t\t\tconst localVarPath = `/token`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\ttokenRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t}\n}\n\n/**\n * TokenApi - functional programming interface\n * @export\n */\nexport const TokenApiFp = function (configuration?: Configuration) {\n\tconst localVarAxiosParamCreator = TokenApiAxiosParamCreator(configuration)\n\treturn {\n\t\t/**\n\t\t * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.\n\t\t * @summary Derive Token Identifier\n\t\t * @param {TokenDeriveRequest} tokenDeriveRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync tokenDerivePost(\n\t\t\ttokenDeriveRequest: TokenDeriveRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<TokenDeriveResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.tokenDerivePost(\n\t\t\t\ttokenDeriveRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns information about XRD, including its Radix Resource Identifier.\n\t\t * @summary Get Native Token Info\n\t\t * @param {TokenNativeRequest} tokenNativeRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync tokenNativePost(\n\t\t\ttokenNativeRequest: TokenNativeRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<TokenNativeResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.tokenNativePost(\n\t\t\t\ttokenNativeRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns information about any token, given its Radix Resource Identifier.\n\t\t * @summary Get Token Info\n\t\t * @param {TokenRequest} tokenRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync tokenPost(\n\t\t\ttokenRequest: TokenRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<TokenResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.tokenPost(\n\t\t\t\ttokenRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t}\n}\n\n/**\n * TokenApi - factory interface\n * @export\n */\nexport const TokenApiFactory = function (\n\tconfiguration?: Configuration,\n\tbasePath?: string,\n\taxios?: AxiosInstance,\n) {\n\tconst localVarFp = TokenApiFp(configuration)\n\treturn {\n\t\t/**\n\t\t * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.\n\t\t * @summary Derive Token Identifier\n\t\t * @param {TokenDeriveRequest} tokenDeriveRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttokenDerivePost(\n\t\t\ttokenDeriveRequest: TokenDeriveRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<TokenDeriveResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.tokenDerivePost(tokenDeriveRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns information about XRD, including its Radix Resource Identifier.\n\t\t * @summary Get Native Token Info\n\t\t * @param {TokenNativeRequest} tokenNativeRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttokenNativePost(\n\t\t\ttokenNativeRequest: TokenNativeRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<TokenNativeResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.tokenNativePost(tokenNativeRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns information about any token, given its Radix Resource Identifier.\n\t\t * @summary Get Token Info\n\t\t * @param {TokenRequest} tokenRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttokenPost(\n\t\t\ttokenRequest: TokenRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<TokenResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.tokenPost(tokenRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t}\n}\n\n/**\n * TokenApi - object-oriented interface\n * @export\n * @class TokenApi\n * @extends {BaseAPI}\n */\nexport class TokenApi extends BaseAPI {\n\t/**\n\t * Returns the Radix Resource Identifier of a token with the given symbol, created by an account with the given public key.\n\t * @summary Derive Token Identifier\n\t * @param {TokenDeriveRequest} tokenDeriveRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof TokenApi\n\t */\n\tpublic tokenDerivePost(\n\t\ttokenDeriveRequest: TokenDeriveRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn TokenApiFp(this.configuration)\n\t\t\t.tokenDerivePost(tokenDeriveRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns information about XRD, including its Radix Resource Identifier.\n\t * @summary Get Native Token Info\n\t * @param {TokenNativeRequest} tokenNativeRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof TokenApi\n\t */\n\tpublic tokenNativePost(\n\t\ttokenNativeRequest: TokenNativeRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn TokenApiFp(this.configuration)\n\t\t\t.tokenNativePost(tokenNativeRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns information about any token, given its Radix Resource Identifier.\n\t * @summary Get Token Info\n\t * @param {TokenRequest} tokenRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof TokenApi\n\t */\n\tpublic tokenPost(tokenRequest: TokenRequest, options?: AxiosRequestConfig) {\n\t\treturn TokenApiFp(this.configuration)\n\t\t\t.tokenPost(tokenRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n}\n\n/**\n * TransactionApi - axios parameter creator\n * @export\n */\nexport const TransactionApiAxiosParamCreator = function (\n\tconfiguration?: Configuration,\n) {\n\treturn {\n\t\t/**\n\t\t * Returns a built unsigned transaction payload, from a set of intended actions.\n\t\t * @summary Build Transaction\n\t\t * @param {TransactionBuildRequest} transactionBuildRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionBuildPost: async (\n\t\t\ttransactionBuildRequest: TransactionBuildRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'transactionBuildRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'transactionBuildPost',\n\t\t\t\t'transactionBuildRequest',\n\t\t\t\ttransactionBuildRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/transaction/build`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\ttransactionBuildRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.\n\t\t * @summary Finalize Transaction\n\t\t * @param {TransactionFinalizeRequest} transactionFinalizeRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionFinalizePost: async (\n\t\t\ttransactionFinalizeRequest: TransactionFinalizeRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'transactionFinalizeRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'transactionFinalizePost',\n\t\t\t\t'transactionFinalizeRequest',\n\t\t\t\ttransactionFinalizeRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/transaction/finalize`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\ttransactionFinalizeRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.\n\t\t * @summary Get Recent Transactions\n\t\t * @param {RecentTransactionsRequest} recentTransactionsRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionRecentPost: async (\n\t\t\trecentTransactionsRequest: RecentTransactionsRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'recentTransactionsRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'transactionRecentPost',\n\t\t\t\t'recentTransactionsRequest',\n\t\t\t\trecentTransactionsRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/transaction/recent`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\trecentTransactionsRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns the current rules used to build and validate transactions in the Radix Engine.\n\t\t * @summary Get Transaction Rules\n\t\t * @param {TransactionRulesRequest} transactionRulesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionRulesPost: async (\n\t\t\ttransactionRulesRequest: TransactionRulesRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'transactionRulesRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'transactionRulesPost',\n\t\t\t\t'transactionRulesRequest',\n\t\t\t\ttransactionRulesRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/transaction/rules`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\ttransactionRulesRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.\n\t\t * @summary Transaction Status\n\t\t * @param {TransactionStatusRequest} transactionStatusRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionStatusPost: async (\n\t\t\ttransactionStatusRequest: TransactionStatusRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'transactionStatusRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'transactionStatusPost',\n\t\t\t\t'transactionStatusRequest',\n\t\t\t\ttransactionStatusRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/transaction/status`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\ttransactionStatusRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.\n\t\t * @summary Submit Transaction\n\t\t * @param {TransactionSubmitRequest} transactionSubmitRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionSubmitPost: async (\n\t\t\ttransactionSubmitRequest: TransactionSubmitRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'transactionSubmitRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'transactionSubmitPost',\n\t\t\t\t'transactionSubmitRequest',\n\t\t\t\ttransactionSubmitRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/transaction/submit`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\ttransactionSubmitRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t}\n}\n\n/**\n * TransactionApi - functional programming interface\n * @export\n */\nexport const TransactionApiFp = function (configuration?: Configuration) {\n\tconst localVarAxiosParamCreator = TransactionApiAxiosParamCreator(\n\t\tconfiguration,\n\t)\n\treturn {\n\t\t/**\n\t\t * Returns a built unsigned transaction payload, from a set of intended actions.\n\t\t * @summary Build Transaction\n\t\t * @param {TransactionBuildRequest} transactionBuildRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync transactionBuildPost(\n\t\t\ttransactionBuildRequest: TransactionBuildRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<TransactionBuildResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.transactionBuildPost(\n\t\t\t\ttransactionBuildRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.\n\t\t * @summary Finalize Transaction\n\t\t * @param {TransactionFinalizeRequest} transactionFinalizeRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync transactionFinalizePost(\n\t\t\ttransactionFinalizeRequest: TransactionFinalizeRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<TransactionFinalizeResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.transactionFinalizePost(\n\t\t\t\ttransactionFinalizeRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.\n\t\t * @summary Get Recent Transactions\n\t\t * @param {RecentTransactionsRequest} recentTransactionsRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync transactionRecentPost(\n\t\t\trecentTransactionsRequest: RecentTransactionsRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<RecentTransactionsResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.transactionRecentPost(\n\t\t\t\trecentTransactionsRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns the current rules used to build and validate transactions in the Radix Engine.\n\t\t * @summary Get Transaction Rules\n\t\t * @param {TransactionRulesRequest} transactionRulesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync transactionRulesPost(\n\t\t\ttransactionRulesRequest: TransactionRulesRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<TransactionRulesResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.transactionRulesPost(\n\t\t\t\ttransactionRulesRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.\n\t\t * @summary Transaction Status\n\t\t * @param {TransactionStatusRequest} transactionStatusRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync transactionStatusPost(\n\t\t\ttransactionStatusRequest: TransactionStatusRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<TransactionStatusResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.transactionStatusPost(\n\t\t\t\ttransactionStatusRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.\n\t\t * @summary Submit Transaction\n\t\t * @param {TransactionSubmitRequest} transactionSubmitRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync transactionSubmitPost(\n\t\t\ttransactionSubmitRequest: TransactionSubmitRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<TransactionSubmitResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.transactionSubmitPost(\n\t\t\t\ttransactionSubmitRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t}\n}\n\n/**\n * TransactionApi - factory interface\n * @export\n */\nexport const TransactionApiFactory = function (\n\tconfiguration?: Configuration,\n\tbasePath?: string,\n\taxios?: AxiosInstance,\n) {\n\tconst localVarFp = TransactionApiFp(configuration)\n\treturn {\n\t\t/**\n\t\t * Returns a built unsigned transaction payload, from a set of intended actions.\n\t\t * @summary Build Transaction\n\t\t * @param {TransactionBuildRequest} transactionBuildRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionBuildPost(\n\t\t\ttransactionBuildRequest: TransactionBuildRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<TransactionBuildResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.transactionBuildPost(transactionBuildRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.\n\t\t * @summary Finalize Transaction\n\t\t * @param {TransactionFinalizeRequest} transactionFinalizeRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionFinalizePost(\n\t\t\ttransactionFinalizeRequest: TransactionFinalizeRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<TransactionFinalizeResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.transactionFinalizePost(transactionFinalizeRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.\n\t\t * @summary Get Recent Transactions\n\t\t * @param {RecentTransactionsRequest} recentTransactionsRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionRecentPost(\n\t\t\trecentTransactionsRequest: RecentTransactionsRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<RecentTransactionsResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.transactionRecentPost(recentTransactionsRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns the current rules used to build and validate transactions in the Radix Engine.\n\t\t * @summary Get Transaction Rules\n\t\t * @param {TransactionRulesRequest} transactionRulesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionRulesPost(\n\t\t\ttransactionRulesRequest: TransactionRulesRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<TransactionRulesResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.transactionRulesPost(transactionRulesRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.\n\t\t * @summary Transaction Status\n\t\t * @param {TransactionStatusRequest} transactionStatusRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionStatusPost(\n\t\t\ttransactionStatusRequest: TransactionStatusRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<TransactionStatusResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.transactionStatusPost(transactionStatusRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.\n\t\t * @summary Submit Transaction\n\t\t * @param {TransactionSubmitRequest} transactionSubmitRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\ttransactionSubmitPost(\n\t\t\ttransactionSubmitRequest: TransactionSubmitRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<TransactionSubmitResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.transactionSubmitPost(transactionSubmitRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t}\n}\n\n/**\n * TransactionApi - object-oriented interface\n * @export\n * @class TransactionApi\n * @extends {BaseAPI}\n */\nexport class TransactionApi extends BaseAPI {\n\t/**\n\t * Returns a built unsigned transaction payload, from a set of intended actions.\n\t * @summary Build Transaction\n\t * @param {TransactionBuildRequest} transactionBuildRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof TransactionApi\n\t */\n\tpublic transactionBuildPost(\n\t\ttransactionBuildRequest: TransactionBuildRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn TransactionApiFp(this.configuration)\n\t\t\t.transactionBuildPost(transactionBuildRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns a signed transaction payload and transaction identifier, from an unsigned transaction payload and signature.\n\t * @summary Finalize Transaction\n\t * @param {TransactionFinalizeRequest} transactionFinalizeRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof TransactionApi\n\t */\n\tpublic transactionFinalizePost(\n\t\ttransactionFinalizeRequest: TransactionFinalizeRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn TransactionApiFp(this.configuration)\n\t\t\t.transactionFinalizePost(transactionFinalizeRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns user-initiated transactions which have been succesfully committed to the ledger. The transactions are returned in a paginated format, ordered by most recent.\n\t * @summary Get Recent Transactions\n\t * @param {RecentTransactionsRequest} recentTransactionsRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof TransactionApi\n\t */\n\tpublic transactionRecentPost(\n\t\trecentTransactionsRequest: RecentTransactionsRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn TransactionApiFp(this.configuration)\n\t\t\t.transactionRecentPost(recentTransactionsRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns the current rules used to build and validate transactions in the Radix Engine.\n\t * @summary Get Transaction Rules\n\t * @param {TransactionRulesRequest} transactionRulesRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof TransactionApi\n\t */\n\tpublic transactionRulesPost(\n\t\ttransactionRulesRequest: TransactionRulesRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn TransactionApiFp(this.configuration)\n\t\t\t.transactionRulesPost(transactionRulesRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns the status and contents of the transaction with the given transaction identifier. Transaction identifiers which aren\\'t recognised as either belonging to a committed transaction or a transaction submitted through this Network Gateway may return a `TransactionNotFoundError`. Transaction identifiers relating to failed transactions will, after a delay, also be reported as a `TransactionNotFoundError`.\n\t * @summary Transaction Status\n\t * @param {TransactionStatusRequest} transactionStatusRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof TransactionApi\n\t */\n\tpublic transactionStatusPost(\n\t\ttransactionStatusRequest: TransactionStatusRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn TransactionApiFp(this.configuration)\n\t\t\t.transactionStatusPost(transactionStatusRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Submits a signed transaction payload to the network. The transaction identifier from finalize or submit can then be used to track the transaction status.\n\t * @summary Submit Transaction\n\t * @param {TransactionSubmitRequest} transactionSubmitRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof TransactionApi\n\t */\n\tpublic transactionSubmitPost(\n\t\ttransactionSubmitRequest: TransactionSubmitRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn TransactionApiFp(this.configuration)\n\t\t\t.transactionSubmitPost(transactionSubmitRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n}\n\n/**\n * ValidatorApi - axios parameter creator\n * @export\n */\nexport const ValidatorApiAxiosParamCreator = function (\n\tconfiguration?: Configuration,\n) {\n\treturn {\n\t\t/**\n\t\t * Returns the validator address associated with the given public key.\n\t\t * @summary Get Validator Identifier\n\t\t * @param {ValidatorDeriveRequest} validatorDeriveRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tvalidatorDerivePost: async (\n\t\t\tvalidatorDeriveRequest: ValidatorDeriveRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'validatorDeriveRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'validatorDerivePost',\n\t\t\t\t'validatorDeriveRequest',\n\t\t\t\tvalidatorDeriveRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/validator/derive`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\tvalidatorDeriveRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.\n\t\t * @summary Get Validator\n\t\t * @param {ValidatorRequest} validatorRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tvalidatorPost: async (\n\t\t\tvalidatorRequest: ValidatorRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'validatorRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'validatorPost',\n\t\t\t\t'validatorRequest',\n\t\t\t\tvalidatorRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/validator`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\tvalidatorRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).\n\t\t * @summary Get Validator Stakes\n\t\t * @param {ValidatorStakesRequest} validatorStakesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tvalidatorStakesPost: async (\n\t\t\tvalidatorStakesRequest: ValidatorStakesRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'validatorStakesRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'validatorStakesPost',\n\t\t\t\t'validatorStakesRequest',\n\t\t\t\tvalidatorStakesRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/validator/stakes`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\tvalidatorStakesRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns information about all validators.\n\t\t * @summary Get Validators\n\t\t * @param {ValidatorsRequest} validatorsRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tvalidatorsPost: async (\n\t\t\tvalidatorsRequest: ValidatorsRequest,\n\t\t\toptions: AxiosRequestConfig = {},\n\t\t): Promise<RequestArgs> => {\n\t\t\t// verify required parameter 'validatorsRequest' is not null or undefined\n\t\t\tassertParamExists(\n\t\t\t\t'validatorsPost',\n\t\t\t\t'validatorsRequest',\n\t\t\t\tvalidatorsRequest,\n\t\t\t)\n\t\t\tconst localVarPath = `/validators`\n\t\t\t// use dummy base URL string because the URL constructor only accepts absolute URLs.\n\t\t\tconst localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)\n\t\t\tlet baseOptions\n\t\t\tif (configuration) {\n\t\t\t\tbaseOptions = configuration.baseOptions\n\t\t\t}\n\n\t\t\tconst localVarRequestOptions = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...baseOptions,\n\t\t\t\t...options,\n\t\t\t}\n\t\t\tconst localVarHeaderParameter = {} as any\n\t\t\tconst localVarQueryParameter = {} as any\n\n\t\t\tlocalVarHeaderParameter['Content-Type'] = 'application/json'\n\n\t\t\tsetSearchParams(localVarUrlObj, localVarQueryParameter)\n\t\t\tlet headersFromBaseOptions =\n\t\t\t\tbaseOptions && baseOptions.headers ? baseOptions.headers : {}\n\t\t\tlocalVarRequestOptions.headers = {\n\t\t\t\t...localVarHeaderParameter,\n\t\t\t\t...headersFromBaseOptions,\n\t\t\t\t...options.headers,\n\t\t\t}\n\t\t\tlocalVarRequestOptions.data = serializeDataIfNeeded(\n\t\t\t\tvalidatorsRequest,\n\t\t\t\tlocalVarRequestOptions,\n\t\t\t\tconfiguration,\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\turl: toPathString(localVarUrlObj),\n\t\t\t\toptions: localVarRequestOptions,\n\t\t\t}\n\t\t},\n\t}\n}\n\n/**\n * ValidatorApi - functional programming interface\n * @export\n */\nexport const ValidatorApiFp = function (configuration?: Configuration) {\n\tconst localVarAxiosParamCreator = ValidatorApiAxiosParamCreator(\n\t\tconfiguration,\n\t)\n\treturn {\n\t\t/**\n\t\t * Returns the validator address associated with the given public key.\n\t\t * @summary Get Validator Identifier\n\t\t * @param {ValidatorDeriveRequest} validatorDeriveRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync validatorDerivePost(\n\t\t\tvalidatorDeriveRequest: ValidatorDeriveRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<ValidatorDeriveResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.validatorDerivePost(\n\t\t\t\tvalidatorDeriveRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.\n\t\t * @summary Get Validator\n\t\t * @param {ValidatorRequest} validatorRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync validatorPost(\n\t\t\tvalidatorRequest: ValidatorRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<ValidatorResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.validatorPost(\n\t\t\t\tvalidatorRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).\n\t\t * @summary Get Validator Stakes\n\t\t * @param {ValidatorStakesRequest} validatorStakesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync validatorStakesPost(\n\t\t\tvalidatorStakesRequest: ValidatorStakesRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<ValidatorStakesResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.validatorStakesPost(\n\t\t\t\tvalidatorStakesRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t\t/**\n\t\t * Returns information about all validators.\n\t\t * @summary Get Validators\n\t\t * @param {ValidatorsRequest} validatorsRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tasync validatorsPost(\n\t\t\tvalidatorsRequest: ValidatorsRequest,\n\t\t\toptions?: AxiosRequestConfig,\n\t\t): Promise<\n\t\t\t(\n\t\t\t\taxios?: AxiosInstance,\n\t\t\t\tbasePath?: string,\n\t\t\t) => AxiosPromise<ValidatorsResponse>\n\t\t> {\n\t\t\tconst localVarAxiosArgs = await localVarAxiosParamCreator.validatorsPost(\n\t\t\t\tvalidatorsRequest,\n\t\t\t\toptions,\n\t\t\t)\n\t\t\treturn createRequestFunction(\n\t\t\t\tlocalVarAxiosArgs,\n\t\t\t\tglobalAxios,\n\t\t\t\tBASE_PATH,\n\t\t\t\tconfiguration,\n\t\t\t)\n\t\t},\n\t}\n}\n\n/**\n * ValidatorApi - factory interface\n * @export\n */\nexport const ValidatorApiFactory = function (\n\tconfiguration?: Configuration,\n\tbasePath?: string,\n\taxios?: AxiosInstance,\n) {\n\tconst localVarFp = ValidatorApiFp(configuration)\n\treturn {\n\t\t/**\n\t\t * Returns the validator address associated with the given public key.\n\t\t * @summary Get Validator Identifier\n\t\t * @param {ValidatorDeriveRequest} validatorDeriveRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tvalidatorDerivePost(\n\t\t\tvalidatorDeriveRequest: ValidatorDeriveRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<ValidatorDeriveResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.validatorDerivePost(validatorDeriveRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.\n\t\t * @summary Get Validator\n\t\t * @param {ValidatorRequest} validatorRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tvalidatorPost(\n\t\t\tvalidatorRequest: ValidatorRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<ValidatorResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.validatorPost(validatorRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).\n\t\t * @summary Get Validator Stakes\n\t\t * @param {ValidatorStakesRequest} validatorStakesRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tvalidatorStakesPost(\n\t\t\tvalidatorStakesRequest: ValidatorStakesRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<ValidatorStakesResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.validatorStakesPost(validatorStakesRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t\t/**\n\t\t * Returns information about all validators.\n\t\t * @summary Get Validators\n\t\t * @param {ValidatorsRequest} validatorsRequest\n\t\t * @param {*} [options] Override http request option.\n\t\t * @throws {RequiredError}\n\t\t */\n\t\tvalidatorsPost(\n\t\t\tvalidatorsRequest: ValidatorsRequest,\n\t\t\toptions?: any,\n\t\t): AxiosPromise<ValidatorsResponse> {\n\t\t\treturn localVarFp\n\t\t\t\t.validatorsPost(validatorsRequest, options)\n\t\t\t\t.then(request => request(axios, basePath))\n\t\t},\n\t}\n}\n\n/**\n * ValidatorApi - object-oriented interface\n * @export\n * @class ValidatorApi\n * @extends {BaseAPI}\n */\nexport class ValidatorApi extends BaseAPI {\n\t/**\n\t * Returns the validator address associated with the given public key.\n\t * @summary Get Validator Identifier\n\t * @param {ValidatorDeriveRequest} validatorDeriveRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof ValidatorApi\n\t */\n\tpublic validatorDerivePost(\n\t\tvalidatorDeriveRequest: ValidatorDeriveRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn ValidatorApiFp(this.configuration)\n\t\t\t.validatorDerivePost(validatorDeriveRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns information about a validator, given a validator address. If a validator address is valid, but has not appeared on ledger as a validator, this endpoint still returns a successful response.\n\t * @summary Get Validator\n\t * @param {ValidatorRequest} validatorRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof ValidatorApi\n\t */\n\tpublic validatorPost(\n\t\tvalidatorRequest: ValidatorRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn ValidatorApiFp(this.configuration)\n\t\t\t.validatorPost(validatorRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns paginated results about the delegated stakes from accounts to a validator. The results are totalled by account, and ordered by account age (oldest to newest).\n\t * @summary Get Validator Stakes\n\t * @param {ValidatorStakesRequest} validatorStakesRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof ValidatorApi\n\t */\n\tpublic validatorStakesPost(\n\t\tvalidatorStakesRequest: ValidatorStakesRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn ValidatorApiFp(this.configuration)\n\t\t\t.validatorStakesPost(validatorStakesRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n\n\t/**\n\t * Returns information about all validators.\n\t * @summary Get Validators\n\t * @param {ValidatorsRequest} validatorsRequest\n\t * @param {*} [options] Override http request option.\n\t * @throws {RequiredError}\n\t * @memberof ValidatorApi\n\t */\n\tpublic validatorsPost(\n\t\tvalidatorsRequest: ValidatorsRequest,\n\t\toptions?: AxiosRequestConfig,\n\t) {\n\t\treturn ValidatorApiFp(this.configuration)\n\t\t\t.validatorsPost(validatorsRequest, options)\n\t\t\t.then(request => request(this.axios, this.basePath))\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}