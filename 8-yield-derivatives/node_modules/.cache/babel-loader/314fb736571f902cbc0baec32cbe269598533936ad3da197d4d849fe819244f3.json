{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigningKeychain = exports.isSwitchToIndex = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst signingKey_1 = require(\"./signingKey\");\nconst operators_1 = require(\"rxjs/operators\");\nconst crypto_1 = require(\"@radixdlt/crypto\");\nconst prelude_ts_1 = require(\"prelude-ts\");\nconst util_1 = require(\"@radixdlt/util\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst stringifySigningKeysArray = signingKeys => signingKeys.map(a => a.toString()).join(',\\n');\nconst stringifySigningKeys = signingKeys => {\n  const allSigningKeysString = stringifySigningKeysArray(signingKeys.all);\n  return `\n\t\tsize: ${signingKeys.size()},\n\t\t#hdSigningKeys: ${signingKeys.hdSigningKeys().length},\n\t\t#nonHDSigningKeys: ${signingKeys.nonHDSigningKeys().length},\n\t\t#localHDSigningKeys: ${signingKeys.localHDSigningKeys().length},\n\t\t#hardwareHDSigningKeys: ${signingKeys.hardwareHDSigningKeys().length},\n\t\t\n\t\tall: ${allSigningKeysString}\n\t`;\n};\nconst createSigningKeys = _all => {\n  const all = [];\n  const getHDSigningKeyByHDPath = hdPath => {\n    const signingKey = all.filter(a => a.isHDSigningKey).find(a => a.hdPath.equals(hdPath));\n    return prelude_ts_1.Option.of(signingKey);\n  };\n  const getAnySigningKeyByPublicKey = publicKey => {\n    const signingKey = all.find(a => a.publicKey.equals(publicKey));\n    return prelude_ts_1.Option.of(signingKey);\n  };\n  const localHDSigningKeys = () => all.filter(a => a.isLocalHDSigningKey);\n  const hardwareHDSigningKeys = () => all.filter(a => a.isHardwareSigningKey);\n  const nonHDSigningKeys = () => all.filter(a => !a.isHDSigningKey);\n  const hdSigningKeys = () => all.filter(a => a.isHDSigningKey);\n  const add = signingKey => {\n    if (all.find(a => a.type.uniqueKey === signingKey.type.uniqueKey) !== undefined) {\n      // already there\n      return;\n    }\n    // new\n    all.push(signingKey);\n  };\n  const signingKeys = {\n    toString: () => {\n      throw new Error('Overriden below');\n    },\n    equals: other => (0, util_1.arraysEqual)(other.all, all),\n    add,\n    localHDSigningKeys,\n    hardwareHDSigningKeys,\n    nonHDSigningKeys,\n    hdSigningKeys,\n    all,\n    size: () => all.length,\n    getHDSigningKeyByHDPath,\n    getAnySigningKeyByPublicKey\n  };\n  return Object.assign(Object.assign({}, signingKeys), {\n    toString: () => stringifySigningKeys(signingKeys)\n  });\n};\nconst isSwitchToIndex = something => {\n  const inspection = something;\n  return inspection.toIndex !== undefined;\n};\nexports.isSwitchToIndex = isSwitchToIndex;\nconst MutableSigningKeys = {\n  create: createSigningKeys\n};\nconst create = input => {\n  var _a;\n  const subs = new rxjs_1.Subscription();\n  const {\n    mnemonic\n  } = input;\n  const startWithInitialSigningKey = (_a = input.startWithInitialSigningKey) !== null && _a !== void 0 ? _a : true;\n  const masterSeed = crypto_1.HDMasterSeed.fromMnemonic({\n    mnemonic\n  });\n  const hdNodeDeriverWithBip32Path = masterSeed.masterNode().derive;\n  let unsafeActiveSigningKey = undefined;\n  const activeSigningKeySubject = new rxjs_1.ReplaySubject();\n  const setActiveSigningKey = newSigningKey => {\n    activeSigningKeySubject.next(newSigningKey);\n    unsafeActiveSigningKey = newSigningKey;\n  };\n  const signingKeysSubject = new rxjs_1.BehaviorSubject(MutableSigningKeys.create([]));\n  const revealMnemonic = () => mnemonic;\n  const numberOfAllSigningKeys = () => signingKeysSubject.getValue().size();\n  const numberOfLocalHDSigningKeys = () => signingKeysSubject.getValue().localHDSigningKeys().length;\n  const numberOfHWSigningKeys = () => signingKeysSubject.getValue().hardwareHDSigningKeys().length;\n  const _addAndMaybeSwitchToNewSigningKey = (newSigningKey, alsoSwitchTo) => {\n    const alsoSwitchTo_ = alsoSwitchTo !== null && alsoSwitchTo !== void 0 ? alsoSwitchTo : false;\n    const signingKeys = signingKeysSubject.getValue();\n    signingKeys.add(newSigningKey);\n    signingKeysSubject.next(signingKeys);\n    if (alsoSwitchTo_) {\n      setActiveSigningKey(newSigningKey);\n    }\n    return newSigningKey;\n  };\n  const deriveHWSigningKey = input => {\n    const nextPath = () => {\n      const index = numberOfHWSigningKeys();\n      return crypto_1.HDPathRadix.create({\n        address: {\n          index,\n          isHardened: true\n        }\n      });\n    };\n    const hdPath = input.keyDerivation === 'next' ? nextPath() : input.keyDerivation;\n    return input.hardwareWalletConnection.pipe((0, operators_1.take)(1), (0, operators_1.mergeMap)(hardwareWallet => hardwareWallet.makeSigningKey(hdPath, input.verificationPrompt)), (0, operators_1.map)(hardwareSigningKey => {\n      const signingKey = signingKey_1.SigningKey.fromHDPathWithHWSigningKey({\n        hdPath,\n        hardwareSigningKey\n      });\n      _addAndMaybeSwitchToNewSigningKey(signingKey, input.alsoSwitchTo);\n      return signingKey;\n    }));\n  };\n  const _deriveLocalHDSigningKeyWithPath = input => {\n    const {\n      hdPath\n    } = input;\n    const newSigningKey = _addAndMaybeSwitchToNewSigningKey(signingKey_1.SigningKey.byDerivingNodeAtPath({\n      hdPath,\n      deriveNodeAtPath: () => hdNodeDeriverWithBip32Path(hdPath)\n    }), input.alsoSwitchTo);\n    return (0, rxjs_1.of)(newSigningKey);\n  };\n  const _deriveNextLocalHDSigningKeyAtIndex = input => _deriveLocalHDSigningKeyWithPath({\n    hdPath: crypto_1.HDPathRadix.create({\n      address: input.addressIndex\n    }),\n    alsoSwitchTo: input.alsoSwitchTo\n  });\n  const deriveNextLocalHDSigningKey = input => {\n    var _a;\n    const index = numberOfLocalHDSigningKeys();\n    return _deriveNextLocalHDSigningKeyAtIndex({\n      addressIndex: {\n        index,\n        isHardened: (_a = input === null || input === void 0 ? void 0 : input.isHardened) !== null && _a !== void 0 ? _a : true\n      },\n      alsoSwitchTo: input === null || input === void 0 ? void 0 : input.alsoSwitchTo\n    });\n  };\n  const switchSigningKey = input => {\n    const isSwitchToSigningKey = something => {\n      const inspection = input;\n      return inspection.toSigningKey !== undefined && (0, signingKey_1.isSigningKey)(inspection.toSigningKey);\n    };\n    if (input === 'last') {\n      const lastIndex = numberOfAllSigningKeys() - 1;\n      return switchSigningKey({\n        toIndex: lastIndex\n      });\n    } else if (input === 'first') {\n      return switchSigningKey({\n        toIndex: 0\n      });\n    } else if (isSwitchToSigningKey(input)) {\n      const toSigningKey = input.toSigningKey;\n      setActiveSigningKey(toSigningKey);\n      util_1.log.info(`Active signingKey switched to: ${toSigningKey.toString()}`);\n      return toSigningKey;\n    } else if ((0, exports.isSwitchToIndex)(input)) {\n      const unsafeTargetIndex = input.toIndex;\n      const signingKeys = signingKeysSubject.getValue();\n      const safeTargetIndex = Math.min(unsafeTargetIndex, signingKeys.size());\n      const firstSigningKey = Array.from(signingKeys.all)[safeTargetIndex];\n      if (!firstSigningKey) {\n        const err = `No signingKeys.`;\n        util_1.log.error(err);\n        throw new Error(err);\n      }\n      return switchSigningKey({\n        toSigningKey: firstSigningKey\n      });\n    } else {\n      const err = `Incorrect implementation, failed to type check 'input' of switchSigningKey. Probably is 'isSigningKey' typeguard wrong.`;\n      util_1.log.error(err);\n      throw new Error(err);\n    }\n  };\n  if (startWithInitialSigningKey) {\n    subs.add(deriveNextLocalHDSigningKey({\n      alsoSwitchTo: true\n    }).subscribe());\n  }\n  const activeSigningKey$ = activeSigningKeySubject.asObservable();\n  const signingKeys$ = signingKeysSubject.asObservable().pipe((0, operators_1.shareReplay)());\n  const restoreLocalHDSigningKeysUpToIndex = index => {\n    if (index < 0) {\n      const errMsg = `targetIndex must not be negative`;\n      console.error(errMsg);\n      return (0, rxjs_1.throwError)(new Error(errMsg));\n    }\n    const localHDSigningKeysSize = numberOfLocalHDSigningKeys();\n    const numberOfSigningKeysToCreate = index - localHDSigningKeysSize;\n    if (numberOfSigningKeysToCreate < 0) {\n      return signingKeys$;\n    }\n    const signingKeysObservableList = Array(numberOfSigningKeysToCreate).fill(undefined).map((_, index) => _deriveNextLocalHDSigningKeyAtIndex({\n      addressIndex: {\n        index: localHDSigningKeysSize + index\n      }\n    }));\n    return (0, rxjs_1.combineLatest)(signingKeysObservableList).pipe((0, operators_1.mergeMap)(_ => signingKeys$), (0, operators_1.take)(1));\n  };\n  const addSigningKeyFromPrivateKey = input => {\n    const signingKey = signingKey_1.SigningKey.fromPrivateKey(input);\n    _addAndMaybeSwitchToNewSigningKey(signingKey, input.alsoSwitchTo);\n    return signingKey;\n  };\n  return {\n    revealMnemonic,\n    // should only be used for testing\n    __unsafeGetSigningKey: () => unsafeActiveSigningKey,\n    deriveNextLocalHDSigningKey,\n    deriveHWSigningKey,\n    switchSigningKey,\n    restoreLocalHDSigningKeysUpToIndex,\n    addSigningKeyFromPrivateKey,\n    observeSigningKeys: () => signingKeys$,\n    observeActiveSigningKey: () => activeSigningKey$,\n    sign: (tx, nonXrdHRP) => activeSigningKey$.pipe((0, operators_1.mergeMap)(a => a.sign(tx, nonXrdHRP))),\n    signHash: hashedMessage => activeSigningKey$.pipe((0, operators_1.mergeMap)(a => a.signHash(hashedMessage)))\n  };\n};\nconst byLoadingAndDecryptingKeystore = input => {\n  const loadKeystore = () => neverthrow_1.ResultAsync.fromPromise(input.load(), e => {\n    const underlyingError = (0, util_1.msgFromError)(e);\n    const errMsg = `Failed to load keystore, underlying error: '${underlyingError}'`;\n    util_1.log.error(errMsg);\n    return new Error(errMsg);\n  });\n  return loadKeystore().map(keystore => {\n    util_1.log.info('Keystore successfully loaded.');\n    return Object.assign(Object.assign({}, input), {\n      keystore\n    });\n  }).andThen(exports.SigningKeychain.fromKeystore);\n};\nconst fromKeystore = input => crypto_1.Keystore.decrypt(input).map(entropy => ({\n  entropy\n})).andThen(crypto_1.Mnemonic.fromEntropy).map(mnemonic => ({\n  mnemonic,\n  startWithInitialSigningKey: input.startWithInitialSigningKey\n})).map(create);\nconst byEncryptingMnemonicAndSavingKeystore = input => {\n  const {\n    mnemonic,\n    password,\n    startWithInitialSigningKey\n  } = input;\n  const save = keystoreToSave => neverthrow_1.ResultAsync.fromPromise(input.save(keystoreToSave), e => {\n    const underlyingError = (0, util_1.msgFromError)(e);\n    const errMsg = `Failed to save keystore, underlying error: '${underlyingError}'`;\n    util_1.log.error(errMsg);\n    return new Error(errMsg);\n  }).map(() => {\n    util_1.log.info('Keystore successfully saved.');\n    return keystoreToSave;\n  });\n  return crypto_1.Keystore.encryptSecret({\n    secret: mnemonic.entropy,\n    password\n  }).andThen(save).map(keystore => ({\n    keystore,\n    password,\n    startWithInitialSigningKey\n  })).andThen(exports.SigningKeychain.fromKeystore);\n};\nexports.SigningKeychain = {\n  create,\n  fromKeystore,\n  byLoadingAndDecryptingKeystore,\n  byEncryptingMnemonicAndSavingKeystore\n};","map":{"version":3,"names":["rxjs_1","require","signingKey_1","operators_1","crypto_1","prelude_ts_1","util_1","neverthrow_1","stringifySigningKeysArray","signingKeys","map","a","toString","join","stringifySigningKeys","allSigningKeysString","all","size","hdSigningKeys","length","nonHDSigningKeys","localHDSigningKeys","hardwareHDSigningKeys","createSigningKeys","_all","getHDSigningKeyByHDPath","hdPath","signingKey","filter","isHDSigningKey","find","equals","Option","of","getAnySigningKeyByPublicKey","publicKey","isLocalHDSigningKey","isHardwareSigningKey","add","type","uniqueKey","undefined","push","Error","other","arraysEqual","Object","assign","isSwitchToIndex","something","inspection","toIndex","exports","MutableSigningKeys","create","input","subs","Subscription","mnemonic","startWithInitialSigningKey","_a","masterSeed","HDMasterSeed","fromMnemonic","hdNodeDeriverWithBip32Path","masterNode","derive","unsafeActiveSigningKey","activeSigningKeySubject","ReplaySubject","setActiveSigningKey","newSigningKey","next","signingKeysSubject","BehaviorSubject","revealMnemonic","numberOfAllSigningKeys","getValue","numberOfLocalHDSigningKeys","numberOfHWSigningKeys","_addAndMaybeSwitchToNewSigningKey","alsoSwitchTo","alsoSwitchTo_","deriveHWSigningKey","nextPath","index","HDPathRadix","address","isHardened","keyDerivation","hardwareWalletConnection","pipe","take","mergeMap","hardwareWallet","makeSigningKey","verificationPrompt","hardwareSigningKey","SigningKey","fromHDPathWithHWSigningKey","_deriveLocalHDSigningKeyWithPath","byDerivingNodeAtPath","deriveNodeAtPath","_deriveNextLocalHDSigningKeyAtIndex","addressIndex","deriveNextLocalHDSigningKey","switchSigningKey","isSwitchToSigningKey","toSigningKey","isSigningKey","lastIndex","log","info","unsafeTargetIndex","safeTargetIndex","Math","min","firstSigningKey","Array","from","err","error","subscribe","activeSigningKey$","asObservable","signingKeys$","shareReplay","restoreLocalHDSigningKeysUpToIndex","errMsg","console","throwError","localHDSigningKeysSize","numberOfSigningKeysToCreate","signingKeysObservableList","fill","_","combineLatest","addSigningKeyFromPrivateKey","fromPrivateKey","__unsafeGetSigningKey","observeSigningKeys","observeActiveSigningKey","sign","tx","nonXrdHRP","signHash","hashedMessage","byLoadingAndDecryptingKeystore","loadKeystore","ResultAsync","fromPromise","load","e","underlyingError","msgFromError","keystore","andThen","SigningKeychain","fromKeystore","Keystore","decrypt","entropy","Mnemonic","fromEntropy","byEncryptingMnemonicAndSavingKeystore","password","save","keystoreToSave","encryptSecret","secret"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/account/src/signingKeychain.ts"],"sourcesContent":["import {\n\tBehaviorSubject,\n\tcombineLatest,\n\tObservable,\n\tof,\n\tReplaySubject,\n\tSubscription,\n\tthrowError,\n} from 'rxjs'\nimport { SigningKey, isSigningKey } from './signingKey'\nimport {\n\tSigningKeysT,\n\tSigningKeyT,\n\tDeriveNextInput,\n\tSwitchSigningKeyInput,\n\tSwitchToSigningKey,\n\tSwitchToIndex,\n\tAddSigningKeyByPrivateKeyInput,\n\tSigningKeychainT,\n\tDeriveHWSigningKeyInput,\n\tSigning,\n} from './_types'\nimport { map, mergeMap, shareReplay, take, tap } from 'rxjs/operators'\nimport {\n\tKeystore,\n\tKeystoreT,\n\tPublicKeyT,\n\tSignatureT,\n\tHDPathRadix,\n\tHDPathRadixT,\n\tInt32,\n\tHDMasterSeed,\n\tMnemomicT,\n\tMnemonic,\n} from '@radixdlt/crypto'\nimport { Option } from 'prelude-ts'\nimport { arraysEqual, log, msgFromError } from '@radixdlt/util'\nimport { ResultAsync } from 'neverthrow'\nimport { HardwareSigningKeyT, HardwareWalletT } from '@radixdlt/hardware-wallet'\nimport { BuiltTransactionReadyToSign } from '@radixdlt/primitives'\n\nconst stringifySigningKeysArray = (signingKeys: SigningKeyT[]): string =>\n\tsigningKeys.map(a => a.toString()).join(',\\n')\n\nconst stringifySigningKeys = (signingKeys: SigningKeysT): string => {\n\tconst allSigningKeysString = stringifySigningKeysArray(signingKeys.all)\n\n\treturn `\n\t\tsize: ${signingKeys.size()},\n\t\t#hdSigningKeys: ${signingKeys.hdSigningKeys().length},\n\t\t#nonHDSigningKeys: ${signingKeys.nonHDSigningKeys().length},\n\t\t#localHDSigningKeys: ${signingKeys.localHDSigningKeys().length},\n\t\t#hardwareHDSigningKeys: ${signingKeys.hardwareHDSigningKeys().length},\n\t\t\n\t\tall: ${allSigningKeysString}\n\t`\n}\n\ntype MutableSigningKeysT = SigningKeysT &\n\tReadonly<{\n\t\tadd: (signingKey: SigningKeyT) => void\n\t}>\n\nconst createSigningKeys = (_all: SigningKeyT[]): MutableSigningKeysT => {\n\tconst all: SigningKeyT[] = []\n\n\tconst getHDSigningKeyByHDPath = (\n\t\thdPath: HDPathRadixT,\n\t): Option<SigningKeyT> => {\n\t\tconst signingKey = all\n\t\t\t.filter(a => a.isHDSigningKey)\n\t\t\t.find(a => a.hdPath!.equals(hdPath))\n\t\treturn Option.of(signingKey)\n\t}\n\n\tconst getAnySigningKeyByPublicKey = (\n\t\tpublicKey: PublicKeyT,\n\t): Option<SigningKeyT> => {\n\t\tconst signingKey = all.find(a => a.publicKey.equals(publicKey))\n\t\treturn Option.of(signingKey)\n\t}\n\n\tconst localHDSigningKeys = () => all.filter(a => a.isLocalHDSigningKey)\n\tconst hardwareHDSigningKeys = () => all.filter(a => a.isHardwareSigningKey)\n\tconst nonHDSigningKeys = () => all.filter(a => !a.isHDSigningKey)\n\tconst hdSigningKeys = () => all.filter(a => a.isHDSigningKey)\n\n\tconst add = (signingKey: SigningKeyT): void => {\n\t\tif (\n\t\t\tall.find(a => a.type.uniqueKey === signingKey.type.uniqueKey) !==\n\t\t\tundefined\n\t\t) {\n\t\t\t// already there\n\t\t\treturn\n\t\t}\n\t\t// new\n\t\tall.push(signingKey)\n\t}\n\n\tconst signingKeys: MutableSigningKeysT = {\n\t\ttoString: (): string => {\n\t\t\tthrow new Error('Overriden below')\n\t\t},\n\t\tequals: (other: SigningKeysT): boolean => arraysEqual(other.all, all),\n\t\tadd,\n\t\tlocalHDSigningKeys,\n\t\thardwareHDSigningKeys,\n\t\tnonHDSigningKeys,\n\t\thdSigningKeys,\n\t\tall,\n\t\tsize: () => all.length,\n\t\tgetHDSigningKeyByHDPath,\n\t\tgetAnySigningKeyByPublicKey,\n\t}\n\n\treturn {\n\t\t...signingKeys,\n\t\ttoString: (): string => stringifySigningKeys(signingKeys),\n\t}\n}\n\nexport const isSwitchToIndex = (\n\tsomething: unknown,\n): something is SwitchToIndex => {\n\tconst inspection = something as SwitchToIndex\n\treturn inspection.toIndex !== undefined\n}\n\nconst MutableSigningKeys = {\n\tcreate: createSigningKeys,\n}\n\nconst create = (\n\tinput: Readonly<{\n\t\tmnemonic: MnemomicT\n\t\tstartWithInitialSigningKey?: boolean\n\t}>,\n): SigningKeychainT => {\n\tconst subs = new Subscription()\n\tconst { mnemonic } = input\n\tconst startWithInitialSigningKey = input.startWithInitialSigningKey ?? true\n\tconst masterSeed = HDMasterSeed.fromMnemonic({ mnemonic })\n\tconst hdNodeDeriverWithBip32Path = masterSeed.masterNode().derive\n\n\tlet unsafeActiveSigningKey: SigningKeyT = (undefined as unknown) as SigningKeyT\n\tconst activeSigningKeySubject = new ReplaySubject<SigningKeyT>()\n\tconst setActiveSigningKey = (newSigningKey: SigningKeyT): void => {\n\t\tactiveSigningKeySubject.next(newSigningKey)\n\t\tunsafeActiveSigningKey = newSigningKey\n\t}\n\n\tconst signingKeysSubject = new BehaviorSubject<MutableSigningKeysT>(\n\t\tMutableSigningKeys.create([]),\n\t)\n\n\tconst revealMnemonic = (): MnemomicT => mnemonic\n\n\tconst numberOfAllSigningKeys = (): number =>\n\t\tsigningKeysSubject.getValue().size()\n\tconst numberOfLocalHDSigningKeys = (): number =>\n\t\tsigningKeysSubject.getValue().localHDSigningKeys().length\n\n\tconst numberOfHWSigningKeys = (): number =>\n\t\tsigningKeysSubject.getValue().hardwareHDSigningKeys().length\n\n\tconst _addAndMaybeSwitchToNewSigningKey = (\n\t\tnewSigningKey: SigningKeyT,\n\t\talsoSwitchTo?: boolean,\n\t): SigningKeyT => {\n\t\tconst alsoSwitchTo_ = alsoSwitchTo ?? false\n\t\tconst signingKeys = signingKeysSubject.getValue()\n\t\tsigningKeys.add(newSigningKey)\n\t\tsigningKeysSubject.next(signingKeys)\n\t\tif (alsoSwitchTo_) {\n\t\t\tsetActiveSigningKey(newSigningKey)\n\t\t}\n\t\treturn newSigningKey\n\t}\n\n\tconst deriveHWSigningKey = (\n\t\tinput: DeriveHWSigningKeyInput,\n\t): Observable<SigningKeyT> => {\n\t\tconst nextPath = (): HDPathRadixT => {\n\t\t\tconst index = numberOfHWSigningKeys()\n\t\t\treturn HDPathRadix.create({\n\t\t\t\taddress: { index, isHardened: true },\n\t\t\t})\n\t\t}\n\t\tconst hdPath: HDPathRadixT =\n\t\t\tinput.keyDerivation === 'next' ? nextPath() : input.keyDerivation\n\n\t\treturn input.hardwareWalletConnection.pipe(\n\t\t\ttake(1),\n\t\t\tmergeMap(\n\t\t\t\t(\n\t\t\t\t\thardwareWallet: HardwareWalletT,\n\t\t\t\t): Observable<HardwareSigningKeyT> =>\n\t\t\t\t\thardwareWallet.makeSigningKey(\n\t\t\t\t\t\thdPath,\n\t\t\t\t\t\tinput.verificationPrompt,\n\t\t\t\t\t),\n\t\t\t),\n\t\t\tmap((hardwareSigningKey: HardwareSigningKeyT) => {\n\t\t\t\tconst signingKey = SigningKey.fromHDPathWithHWSigningKey({\n\t\t\t\t\thdPath,\n\t\t\t\t\thardwareSigningKey,\n\t\t\t\t})\n\t\t\t\t_addAndMaybeSwitchToNewSigningKey(\n\t\t\t\t\tsigningKey,\n\t\t\t\t\tinput.alsoSwitchTo,\n\t\t\t\t)\n\t\t\t\treturn signingKey\n\t\t\t}),\n\t\t)\n\t}\n\n\tconst _deriveLocalHDSigningKeyWithPath = (\n\t\tinput: Readonly<{\n\t\t\thdPath: HDPathRadixT\n\t\t\talsoSwitchTo?: boolean // defaults to false\n\t\t}>,\n\t): Observable<SigningKeyT> => {\n\t\tconst { hdPath } = input\n\n\t\tconst newSigningKey = _addAndMaybeSwitchToNewSigningKey(\n\t\t\tSigningKey.byDerivingNodeAtPath({\n\t\t\t\thdPath,\n\t\t\t\tderiveNodeAtPath: () => hdNodeDeriverWithBip32Path(hdPath),\n\t\t\t}),\n\t\t\tinput.alsoSwitchTo,\n\t\t)\n\n\t\treturn of(newSigningKey)\n\t}\n\n\tconst _deriveNextLocalHDSigningKeyAtIndex = (\n\t\tinput: Readonly<{\n\t\t\taddressIndex: Readonly<{\n\t\t\t\tindex: Int32\n\t\t\t\tisHardened?: boolean // defaults to true\n\t\t\t}>\n\t\t\talsoSwitchTo?: boolean // defaults to false\n\t\t}>,\n\t): Observable<SigningKeyT> =>\n\t\t_deriveLocalHDSigningKeyWithPath({\n\t\t\thdPath: HDPathRadix.create({\n\t\t\t\taddress: input.addressIndex,\n\t\t\t}),\n\t\t\talsoSwitchTo: input.alsoSwitchTo,\n\t\t})\n\n\tconst deriveNextLocalHDSigningKey = (\n\t\tinput?: DeriveNextInput,\n\t): Observable<SigningKeyT> => {\n\t\tconst index = numberOfLocalHDSigningKeys()\n\t\treturn _deriveNextLocalHDSigningKeyAtIndex({\n\t\t\taddressIndex: {\n\t\t\t\tindex,\n\t\t\t\tisHardened: input?.isHardened ?? true,\n\t\t\t},\n\t\t\talsoSwitchTo: input?.alsoSwitchTo,\n\t\t})\n\t}\n\n\tconst switchSigningKey = (input: SwitchSigningKeyInput): SigningKeyT => {\n\t\tconst isSwitchToSigningKey = (\n\t\t\tsomething: unknown,\n\t\t): something is SwitchToSigningKey => {\n\t\t\tconst inspection = input as SwitchToSigningKey\n\t\t\treturn (\n\t\t\t\tinspection.toSigningKey !== undefined &&\n\t\t\t\tisSigningKey(inspection.toSigningKey)\n\t\t\t)\n\t\t}\n\n\t\tif (input === 'last') {\n\t\t\tconst lastIndex = numberOfAllSigningKeys() - 1\n\t\t\treturn switchSigningKey({ toIndex: lastIndex })\n\t\t} else if (input === 'first') {\n\t\t\treturn switchSigningKey({ toIndex: 0 })\n\t\t} else if (isSwitchToSigningKey(input)) {\n\t\t\tconst toSigningKey = input.toSigningKey\n\t\t\tsetActiveSigningKey(toSigningKey)\n\t\t\tlog.info(\n\t\t\t\t`Active signingKey switched to: ${toSigningKey.toString()}`,\n\t\t\t)\n\t\t\treturn toSigningKey\n\t\t} else if (isSwitchToIndex(input)) {\n\t\t\tconst unsafeTargetIndex = input.toIndex\n\t\t\tconst signingKeys = signingKeysSubject.getValue()\n\n\t\t\tconst safeTargetIndex = Math.min(\n\t\t\t\tunsafeTargetIndex,\n\t\t\t\tsigningKeys.size(),\n\t\t\t)\n\n\t\t\tconst firstSigningKey = Array.from(signingKeys.all)[safeTargetIndex]\n\t\t\tif (!firstSigningKey) {\n\t\t\t\tconst err = `No signingKeys.`\n\t\t\t\tlog.error(err)\n\t\t\t\tthrow new Error(err)\n\t\t\t}\n\t\t\treturn switchSigningKey({ toSigningKey: firstSigningKey })\n\t\t} else {\n\t\t\tconst err = `Incorrect implementation, failed to type check 'input' of switchSigningKey. Probably is 'isSigningKey' typeguard wrong.`\n\t\t\tlog.error(err)\n\t\t\tthrow new Error(err)\n\t\t}\n\t}\n\n\tif (startWithInitialSigningKey) {\n\t\tsubs.add(\n\t\t\tderiveNextLocalHDSigningKey({\n\t\t\t\talsoSwitchTo: true,\n\t\t\t}).subscribe(),\n\t\t)\n\t}\n\n\tconst activeSigningKey$ = activeSigningKeySubject.asObservable()\n\n\tconst signingKeys$ = signingKeysSubject.asObservable().pipe(shareReplay())\n\n\tconst restoreLocalHDSigningKeysUpToIndex = (\n\t\tindex: number,\n\t): Observable<SigningKeysT> => {\n\t\tif (index < 0) {\n\t\t\tconst errMsg = `targetIndex must not be negative`\n\t\t\tconsole.error(errMsg)\n\t\t\treturn throwError(new Error(errMsg))\n\t\t}\n\n\t\tconst localHDSigningKeysSize = numberOfLocalHDSigningKeys()\n\t\tconst numberOfSigningKeysToCreate = index - localHDSigningKeysSize\n\t\tif (numberOfSigningKeysToCreate < 0) {\n\t\t\treturn signingKeys$\n\t\t}\n\n\t\tconst signingKeysObservableList: Observable<SigningKeyT>[] = Array(\n\t\t\tnumberOfSigningKeysToCreate,\n\t\t)\n\t\t\t.fill(undefined)\n\t\t\t.map((_, index) =>\n\t\t\t\t_deriveNextLocalHDSigningKeyAtIndex({\n\t\t\t\t\taddressIndex: { index: localHDSigningKeysSize + index },\n\t\t\t\t}),\n\t\t\t)\n\n\t\treturn combineLatest(signingKeysObservableList).pipe(\n\t\t\tmergeMap(_ => signingKeys$),\n\t\t\ttake(1),\n\t\t)\n\t}\n\n\tconst addSigningKeyFromPrivateKey = (\n\t\tinput: AddSigningKeyByPrivateKeyInput,\n\t): SigningKeyT => {\n\t\tconst signingKey = SigningKey.fromPrivateKey(input)\n\t\t_addAndMaybeSwitchToNewSigningKey(signingKey, input.alsoSwitchTo)\n\t\treturn signingKey\n\t}\n\n\treturn {\n\t\trevealMnemonic,\n\t\t// should only be used for testing\n\t\t__unsafeGetSigningKey: (): SigningKeyT => unsafeActiveSigningKey,\n\t\tderiveNextLocalHDSigningKey,\n\t\tderiveHWSigningKey,\n\t\tswitchSigningKey,\n\t\trestoreLocalHDSigningKeysUpToIndex,\n\t\taddSigningKeyFromPrivateKey,\n\t\tobserveSigningKeys: (): Observable<SigningKeysT> => signingKeys$,\n\t\tobserveActiveSigningKey: (): Observable<SigningKeyT> =>\n\t\t\tactiveSigningKey$,\n\t\tsign: (\n\t\t\ttx: BuiltTransactionReadyToSign,\n\t\t\tnonXrdHRP?: string,\n\t\t): Observable<SignatureT> =>\n\t\t\tactiveSigningKey$.pipe(mergeMap(a => a.sign(tx, nonXrdHRP))),\n\t\tsignHash: (hashedMessage: Buffer): Observable<SignatureT> =>\n\t\t\tactiveSigningKey$.pipe(mergeMap(a => a.signHash(hashedMessage))),\n\t}\n}\n\nconst byLoadingAndDecryptingKeystore = (\n\tinput: Readonly<{\n\t\tpassword: string\n\t\tload: () => Promise<KeystoreT>\n\t\tstartWithInitialSigningKey?: boolean\n\t}>,\n): ResultAsync<SigningKeychainT, Error> => {\n\tconst loadKeystore = (): ResultAsync<KeystoreT, Error> =>\n\t\tResultAsync.fromPromise(input.load(), (e: unknown) => {\n\t\t\tconst underlyingError = msgFromError(e)\n\t\t\tconst errMsg = `Failed to load keystore, underlying error: '${underlyingError}'`\n\t\t\tlog.error(errMsg)\n\t\t\treturn new Error(errMsg)\n\t\t})\n\treturn loadKeystore()\n\t\t.map((keystore: KeystoreT) => {\n\t\t\tlog.info('Keystore successfully loaded.')\n\t\t\treturn { ...input, keystore }\n\t\t})\n\t\t.andThen(SigningKeychain.fromKeystore)\n}\n\nconst fromKeystore = (\n\tinput: Readonly<{\n\t\tkeystore: KeystoreT\n\t\tpassword: string\n\t\tstartWithInitialSigningKey?: boolean\n\t}>,\n): ResultAsync<SigningKeychainT, Error> =>\n\tKeystore.decrypt(input)\n\t\t.map(entropy => ({ entropy }))\n\t\t.andThen(Mnemonic.fromEntropy)\n\t\t.map(mnemonic => ({\n\t\t\tmnemonic,\n\t\t\tstartWithInitialSigningKey: input.startWithInitialSigningKey,\n\t\t}))\n\t\t.map(create)\n\nconst byEncryptingMnemonicAndSavingKeystore = (\n\tinput: Readonly<{\n\t\tmnemonic: MnemomicT\n\t\tpassword: string\n\t\tsave: (keystoreToSave: KeystoreT) => Promise<void>\n\t\tstartWithInitialSigningKey?: boolean\n\t}>,\n): ResultAsync<SigningKeychainT, Error> => {\n\tconst { mnemonic, password, startWithInitialSigningKey } = input\n\n\tconst save = (keystoreToSave: KeystoreT): ResultAsync<KeystoreT, Error> =>\n\t\tResultAsync.fromPromise(input.save(keystoreToSave), (e: unknown) => {\n\t\t\tconst underlyingError = msgFromError(e)\n\t\t\tconst errMsg = `Failed to save keystore, underlying error: '${underlyingError}'`\n\t\t\tlog.error(errMsg)\n\t\t\treturn new Error(errMsg)\n\t\t}).map(() => {\n\t\t\tlog.info('Keystore successfully saved.')\n\t\t\treturn keystoreToSave\n\t\t})\n\n\treturn Keystore.encryptSecret({\n\t\tsecret: mnemonic.entropy,\n\t\tpassword,\n\t})\n\t\t.andThen(save)\n\t\t.map((keystore: KeystoreT) => ({\n\t\t\tkeystore,\n\t\t\tpassword,\n\t\t\tstartWithInitialSigningKey,\n\t\t}))\n\t\t.andThen(SigningKeychain.fromKeystore)\n}\n\nexport const SigningKeychain = {\n\tcreate,\n\tfromKeystore,\n\tbyLoadingAndDecryptingKeystore,\n\tbyEncryptingMnemonicAndSavingKeystore,\n}\n"],"mappings":";;;;;;AAAA,MAAAA,MAAA,GAAAC,OAAA;AASA,MAAAC,YAAA,GAAAD,OAAA;AAaA,MAAAE,WAAA,GAAAF,OAAA;AACA,MAAAG,QAAA,GAAAH,OAAA;AAYA,MAAAI,YAAA,GAAAJ,OAAA;AACA,MAAAK,MAAA,GAAAL,OAAA;AACA,MAAAM,YAAA,GAAAN,OAAA;AAIA,MAAMO,yBAAyB,GAAIC,WAA0B,IAC5DA,WAAW,CAACC,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,EAAE,CAAC,CAACC,IAAI,CAAC,KAAK,CAAC;AAE/C,MAAMC,oBAAoB,GAAIL,WAAyB,IAAY;EAClE,MAAMM,oBAAoB,GAAGP,yBAAyB,CAACC,WAAW,CAACO,GAAG,CAAC;EAEvE,OAAO;UACEP,WAAW,CAACQ,IAAI,EAAE;oBACRR,WAAW,CAACS,aAAa,EAAE,CAACC,MAAM;uBAC/BV,WAAW,CAACW,gBAAgB,EAAE,CAACD,MAAM;yBACnCV,WAAW,CAACY,kBAAkB,EAAE,CAACF,MAAM;4BACpCV,WAAW,CAACa,qBAAqB,EAAE,CAACH,MAAM;;SAE7DJ,oBAAoB;EAC3B;AACF,CAAC;AAOD,MAAMQ,iBAAiB,GAAIC,IAAmB,IAAyB;EACtE,MAAMR,GAAG,GAAkB,EAAE;EAE7B,MAAMS,uBAAuB,GAC5BC,MAAoB,IACI;IACxB,MAAMC,UAAU,GAAGX,GAAG,CACpBY,MAAM,CAACjB,CAAC,IAAIA,CAAC,CAACkB,cAAc,CAAC,CAC7BC,IAAI,CAACnB,CAAC,IAAIA,CAAC,CAACe,MAAO,CAACK,MAAM,CAACL,MAAM,CAAC,CAAC;IACrC,OAAOrB,YAAA,CAAA2B,MAAM,CAACC,EAAE,CAACN,UAAU,CAAC;EAC7B,CAAC;EAED,MAAMO,2BAA2B,GAChCC,SAAqB,IACG;IACxB,MAAMR,UAAU,GAAGX,GAAG,CAACc,IAAI,CAACnB,CAAC,IAAIA,CAAC,CAACwB,SAAS,CAACJ,MAAM,CAACI,SAAS,CAAC,CAAC;IAC/D,OAAO9B,YAAA,CAAA2B,MAAM,CAACC,EAAE,CAACN,UAAU,CAAC;EAC7B,CAAC;EAED,MAAMN,kBAAkB,GAAGA,CAAA,KAAML,GAAG,CAACY,MAAM,CAACjB,CAAC,IAAIA,CAAC,CAACyB,mBAAmB,CAAC;EACvE,MAAMd,qBAAqB,GAAGA,CAAA,KAAMN,GAAG,CAACY,MAAM,CAACjB,CAAC,IAAIA,CAAC,CAAC0B,oBAAoB,CAAC;EAC3E,MAAMjB,gBAAgB,GAAGA,CAAA,KAAMJ,GAAG,CAACY,MAAM,CAACjB,CAAC,IAAI,CAACA,CAAC,CAACkB,cAAc,CAAC;EACjE,MAAMX,aAAa,GAAGA,CAAA,KAAMF,GAAG,CAACY,MAAM,CAACjB,CAAC,IAAIA,CAAC,CAACkB,cAAc,CAAC;EAE7D,MAAMS,GAAG,GAAIX,UAAuB,IAAU;IAC7C,IACCX,GAAG,CAACc,IAAI,CAACnB,CAAC,IAAIA,CAAC,CAAC4B,IAAI,CAACC,SAAS,KAAKb,UAAU,CAACY,IAAI,CAACC,SAAS,CAAC,KAC7DC,SAAS,EACR;MACD;MACA;;IAED;IACAzB,GAAG,CAAC0B,IAAI,CAACf,UAAU,CAAC;EACrB,CAAC;EAED,MAAMlB,WAAW,GAAwB;IACxCG,QAAQ,EAAEA,CAAA,KAAa;MACtB,MAAM,IAAI+B,KAAK,CAAC,iBAAiB,CAAC;IACnC,CAAC;IACDZ,MAAM,EAAGa,KAAmB,IAAc,IAAAtC,MAAA,CAAAuC,WAAW,EAACD,KAAK,CAAC5B,GAAG,EAAEA,GAAG,CAAC;IACrEsB,GAAG;IACHjB,kBAAkB;IAClBC,qBAAqB;IACrBF,gBAAgB;IAChBF,aAAa;IACbF,GAAG;IACHC,IAAI,EAAEA,CAAA,KAAMD,GAAG,CAACG,MAAM;IACtBM,uBAAuB;IACvBS;GACA;EAED,OAAAY,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACItC,WAAW;IACdG,QAAQ,EAAEA,CAAA,KAAcE,oBAAoB,CAACL,WAAW;EAAC;AAE3D,CAAC;AAEM,MAAMuC,eAAe,GAC3BC,SAAkB,IACa;EAC/B,MAAMC,UAAU,GAAGD,SAA0B;EAC7C,OAAOC,UAAU,CAACC,OAAO,KAAKV,SAAS;AACxC,CAAC;AALYW,OAAA,CAAAJ,eAAe,GAAAA,eAAA;AAO5B,MAAMK,kBAAkB,GAAG;EAC1BC,MAAM,EAAE/B;CACR;AAED,MAAM+B,MAAM,GACXC,KAGE,IACmB;;EACrB,MAAMC,IAAI,GAAG,IAAIxD,MAAA,CAAAyD,YAAY,EAAE;EAC/B,MAAM;IAAEC;EAAQ,CAAE,GAAGH,KAAK;EAC1B,MAAMI,0BAA0B,GAAG,CAAAC,EAAA,GAAAL,KAAK,CAACI,0BAA0B,cAAAC,EAAA,cAAAA,EAAA,GAAI,IAAI;EAC3E,MAAMC,UAAU,GAAGzD,QAAA,CAAA0D,YAAY,CAACC,YAAY,CAAC;IAAEL;EAAQ,CAAE,CAAC;EAC1D,MAAMM,0BAA0B,GAAGH,UAAU,CAACI,UAAU,EAAE,CAACC,MAAM;EAEjE,IAAIC,sBAAsB,GAAiB1B,SAAoC;EAC/E,MAAM2B,uBAAuB,GAAG,IAAIpE,MAAA,CAAAqE,aAAa,EAAe;EAChE,MAAMC,mBAAmB,GAAIC,aAA0B,IAAU;IAChEH,uBAAuB,CAACI,IAAI,CAACD,aAAa,CAAC;IAC3CJ,sBAAsB,GAAGI,aAAa;EACvC,CAAC;EAED,MAAME,kBAAkB,GAAG,IAAIzE,MAAA,CAAA0E,eAAe,CAC7CrB,kBAAkB,CAACC,MAAM,CAAC,EAAE,CAAC,CAC7B;EAED,MAAMqB,cAAc,GAAGA,CAAA,KAAiBjB,QAAQ;EAEhD,MAAMkB,sBAAsB,GAAGA,CAAA,KAC9BH,kBAAkB,CAACI,QAAQ,EAAE,CAAC5D,IAAI,EAAE;EACrC,MAAM6D,0BAA0B,GAAGA,CAAA,KAClCL,kBAAkB,CAACI,QAAQ,EAAE,CAACxD,kBAAkB,EAAE,CAACF,MAAM;EAE1D,MAAM4D,qBAAqB,GAAGA,CAAA,KAC7BN,kBAAkB,CAACI,QAAQ,EAAE,CAACvD,qBAAqB,EAAE,CAACH,MAAM;EAE7D,MAAM6D,iCAAiC,GAAGA,CACzCT,aAA0B,EAC1BU,YAAsB,KACN;IAChB,MAAMC,aAAa,GAAGD,YAAY,aAAZA,YAAY,cAAZA,YAAY,GAAI,KAAK;IAC3C,MAAMxE,WAAW,GAAGgE,kBAAkB,CAACI,QAAQ,EAAE;IACjDpE,WAAW,CAAC6B,GAAG,CAACiC,aAAa,CAAC;IAC9BE,kBAAkB,CAACD,IAAI,CAAC/D,WAAW,CAAC;IACpC,IAAIyE,aAAa,EAAE;MAClBZ,mBAAmB,CAACC,aAAa,CAAC;;IAEnC,OAAOA,aAAa;EACrB,CAAC;EAED,MAAMY,kBAAkB,GACvB5B,KAA8B,IACF;IAC5B,MAAM6B,QAAQ,GAAGA,CAAA,KAAmB;MACnC,MAAMC,KAAK,GAAGN,qBAAqB,EAAE;MACrC,OAAO3E,QAAA,CAAAkF,WAAW,CAAChC,MAAM,CAAC;QACzBiC,OAAO,EAAE;UAAEF,KAAK;UAAEG,UAAU,EAAE;QAAI;OAClC,CAAC;IACH,CAAC;IACD,MAAM9D,MAAM,GACX6B,KAAK,CAACkC,aAAa,KAAK,MAAM,GAAGL,QAAQ,EAAE,GAAG7B,KAAK,CAACkC,aAAa;IAElE,OAAOlC,KAAK,CAACmC,wBAAwB,CAACC,IAAI,CACzC,IAAAxF,WAAA,CAAAyF,IAAI,EAAC,CAAC,CAAC,EACP,IAAAzF,WAAA,CAAA0F,QAAQ,EAENC,cAA+B,IAE/BA,cAAc,CAACC,cAAc,CAC5BrE,MAAM,EACN6B,KAAK,CAACyC,kBAAkB,CACxB,CACF,EACD,IAAA7F,WAAA,CAAAO,GAAG,EAAEuF,kBAAuC,IAAI;MAC/C,MAAMtE,UAAU,GAAGzB,YAAA,CAAAgG,UAAU,CAACC,0BAA0B,CAAC;QACxDzE,MAAM;QACNuE;OACA,CAAC;MACFjB,iCAAiC,CAChCrD,UAAU,EACV4B,KAAK,CAAC0B,YAAY,CAClB;MACD,OAAOtD,UAAU;IAClB,CAAC,CAAC,CACF;EACF,CAAC;EAED,MAAMyE,gCAAgC,GACrC7C,KAGE,IAC0B;IAC5B,MAAM;MAAE7B;IAAM,CAAE,GAAG6B,KAAK;IAExB,MAAMgB,aAAa,GAAGS,iCAAiC,CACtD9E,YAAA,CAAAgG,UAAU,CAACG,oBAAoB,CAAC;MAC/B3E,MAAM;MACN4E,gBAAgB,EAAEA,CAAA,KAAMtC,0BAA0B,CAACtC,MAAM;KACzD,CAAC,EACF6B,KAAK,CAAC0B,YAAY,CAClB;IAED,OAAO,IAAAjF,MAAA,CAAAiC,EAAE,EAACsC,aAAa,CAAC;EACzB,CAAC;EAED,MAAMgC,mCAAmC,GACxChD,KAME,IAEF6C,gCAAgC,CAAC;IAChC1E,MAAM,EAAEtB,QAAA,CAAAkF,WAAW,CAAChC,MAAM,CAAC;MAC1BiC,OAAO,EAAEhC,KAAK,CAACiD;KACf,CAAC;IACFvB,YAAY,EAAE1B,KAAK,CAAC0B;GACpB,CAAC;EAEH,MAAMwB,2BAA2B,GAChClD,KAAuB,IACK;;IAC5B,MAAM8B,KAAK,GAAGP,0BAA0B,EAAE;IAC1C,OAAOyB,mCAAmC,CAAC;MAC1CC,YAAY,EAAE;QACbnB,KAAK;QACLG,UAAU,EAAE,CAAA5B,EAAA,GAAAL,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEiC,UAAU,cAAA5B,EAAA,cAAAA,EAAA,GAAI;OACjC;MACDqB,YAAY,EAAE1B,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAE0B;KACrB,CAAC;EACH,CAAC;EAED,MAAMyB,gBAAgB,GAAInD,KAA4B,IAAiB;IACtE,MAAMoD,oBAAoB,GACzB1D,SAAkB,IACkB;MACpC,MAAMC,UAAU,GAAGK,KAA2B;MAC9C,OACCL,UAAU,CAAC0D,YAAY,KAAKnE,SAAS,IACrC,IAAAvC,YAAA,CAAA2G,YAAY,EAAC3D,UAAU,CAAC0D,YAAY,CAAC;IAEvC,CAAC;IAED,IAAIrD,KAAK,KAAK,MAAM,EAAE;MACrB,MAAMuD,SAAS,GAAGlC,sBAAsB,EAAE,GAAG,CAAC;MAC9C,OAAO8B,gBAAgB,CAAC;QAAEvD,OAAO,EAAE2D;MAAS,CAAE,CAAC;KAC/C,MAAM,IAAIvD,KAAK,KAAK,OAAO,EAAE;MAC7B,OAAOmD,gBAAgB,CAAC;QAAEvD,OAAO,EAAE;MAAC,CAAE,CAAC;KACvC,MAAM,IAAIwD,oBAAoB,CAACpD,KAAK,CAAC,EAAE;MACvC,MAAMqD,YAAY,GAAGrD,KAAK,CAACqD,YAAY;MACvCtC,mBAAmB,CAACsC,YAAY,CAAC;MACjCtG,MAAA,CAAAyG,GAAG,CAACC,IAAI,CACP,kCAAkCJ,YAAY,CAAChG,QAAQ,EAAE,EAAE,CAC3D;MACD,OAAOgG,YAAY;KACnB,MAAM,IAAI,IAAAxD,OAAA,CAAAJ,eAAe,EAACO,KAAK,CAAC,EAAE;MAClC,MAAM0D,iBAAiB,GAAG1D,KAAK,CAACJ,OAAO;MACvC,MAAM1C,WAAW,GAAGgE,kBAAkB,CAACI,QAAQ,EAAE;MAEjD,MAAMqC,eAAe,GAAGC,IAAI,CAACC,GAAG,CAC/BH,iBAAiB,EACjBxG,WAAW,CAACQ,IAAI,EAAE,CAClB;MAED,MAAMoG,eAAe,GAAGC,KAAK,CAACC,IAAI,CAAC9G,WAAW,CAACO,GAAG,CAAC,CAACkG,eAAe,CAAC;MACpE,IAAI,CAACG,eAAe,EAAE;QACrB,MAAMG,GAAG,GAAG,iBAAiB;QAC7BlH,MAAA,CAAAyG,GAAG,CAACU,KAAK,CAACD,GAAG,CAAC;QACd,MAAM,IAAI7E,KAAK,CAAC6E,GAAG,CAAC;;MAErB,OAAOd,gBAAgB,CAAC;QAAEE,YAAY,EAAES;MAAe,CAAE,CAAC;KAC1D,MAAM;MACN,MAAMG,GAAG,GAAG,yHAAyH;MACrIlH,MAAA,CAAAyG,GAAG,CAACU,KAAK,CAACD,GAAG,CAAC;MACd,MAAM,IAAI7E,KAAK,CAAC6E,GAAG,CAAC;;EAEtB,CAAC;EAED,IAAI7D,0BAA0B,EAAE;IAC/BH,IAAI,CAAClB,GAAG,CACPmE,2BAA2B,CAAC;MAC3BxB,YAAY,EAAE;KACd,CAAC,CAACyC,SAAS,EAAE,CACd;;EAGF,MAAMC,iBAAiB,GAAGvD,uBAAuB,CAACwD,YAAY,EAAE;EAEhE,MAAMC,YAAY,GAAGpD,kBAAkB,CAACmD,YAAY,EAAE,CAACjC,IAAI,CAAC,IAAAxF,WAAA,CAAA2H,WAAW,GAAE,CAAC;EAE1E,MAAMC,kCAAkC,GACvC1C,KAAa,IACgB;IAC7B,IAAIA,KAAK,GAAG,CAAC,EAAE;MACd,MAAM2C,MAAM,GAAG,kCAAkC;MACjDC,OAAO,CAACR,KAAK,CAACO,MAAM,CAAC;MACrB,OAAO,IAAAhI,MAAA,CAAAkI,UAAU,EAAC,IAAIvF,KAAK,CAACqF,MAAM,CAAC,CAAC;;IAGrC,MAAMG,sBAAsB,GAAGrD,0BAA0B,EAAE;IAC3D,MAAMsD,2BAA2B,GAAG/C,KAAK,GAAG8C,sBAAsB;IAClE,IAAIC,2BAA2B,GAAG,CAAC,EAAE;MACpC,OAAOP,YAAY;;IAGpB,MAAMQ,yBAAyB,GAA8Bf,KAAK,CACjEc,2BAA2B,CAC3B,CACCE,IAAI,CAAC7F,SAAS,CAAC,CACf/B,GAAG,CAAC,CAAC6H,CAAC,EAAElD,KAAK,KACbkB,mCAAmC,CAAC;MACnCC,YAAY,EAAE;QAAEnB,KAAK,EAAE8C,sBAAsB,GAAG9C;MAAK;KACrD,CAAC,CACF;IAEF,OAAO,IAAArF,MAAA,CAAAwI,aAAa,EAACH,yBAAyB,CAAC,CAAC1C,IAAI,CACnD,IAAAxF,WAAA,CAAA0F,QAAQ,EAAC0C,CAAC,IAAIV,YAAY,CAAC,EAC3B,IAAA1H,WAAA,CAAAyF,IAAI,EAAC,CAAC,CAAC,CACP;EACF,CAAC;EAED,MAAM6C,2BAA2B,GAChClF,KAAqC,IACrB;IAChB,MAAM5B,UAAU,GAAGzB,YAAA,CAAAgG,UAAU,CAACwC,cAAc,CAACnF,KAAK,CAAC;IACnDyB,iCAAiC,CAACrD,UAAU,EAAE4B,KAAK,CAAC0B,YAAY,CAAC;IACjE,OAAOtD,UAAU;EAClB,CAAC;EAED,OAAO;IACNgD,cAAc;IACd;IACAgE,qBAAqB,EAAEA,CAAA,KAAmBxE,sBAAsB;IAChEsC,2BAA2B;IAC3BtB,kBAAkB;IAClBuB,gBAAgB;IAChBqB,kCAAkC;IAClCU,2BAA2B;IAC3BG,kBAAkB,EAAEA,CAAA,KAAgCf,YAAY;IAChEgB,uBAAuB,EAAEA,CAAA,KACxBlB,iBAAiB;IAClBmB,IAAI,EAAEA,CACLC,EAA+B,EAC/BC,SAAkB,KAElBrB,iBAAiB,CAAChC,IAAI,CAAC,IAAAxF,WAAA,CAAA0F,QAAQ,EAAClF,CAAC,IAAIA,CAAC,CAACmI,IAAI,CAACC,EAAE,EAAEC,SAAS,CAAC,CAAC,CAAC;IAC7DC,QAAQ,EAAGC,aAAqB,IAC/BvB,iBAAiB,CAAChC,IAAI,CAAC,IAAAxF,WAAA,CAAA0F,QAAQ,EAAClF,CAAC,IAAIA,CAAC,CAACsI,QAAQ,CAACC,aAAa,CAAC,CAAC;GAChE;AACF,CAAC;AAED,MAAMC,8BAA8B,GACnC5F,KAIE,IACuC;EACzC,MAAM6F,YAAY,GAAGA,CAAA,KACpB7I,YAAA,CAAA8I,WAAW,CAACC,WAAW,CAAC/F,KAAK,CAACgG,IAAI,EAAE,EAAGC,CAAU,IAAI;IACpD,MAAMC,eAAe,GAAG,IAAAnJ,MAAA,CAAAoJ,YAAY,EAACF,CAAC,CAAC;IACvC,MAAMxB,MAAM,GAAG,+CAA+CyB,eAAe,GAAG;IAChFnJ,MAAA,CAAAyG,GAAG,CAACU,KAAK,CAACO,MAAM,CAAC;IACjB,OAAO,IAAIrF,KAAK,CAACqF,MAAM,CAAC;EACzB,CAAC,CAAC;EACH,OAAOoB,YAAY,EAAE,CACnB1I,GAAG,CAAEiJ,QAAmB,IAAI;IAC5BrJ,MAAA,CAAAyG,GAAG,CAACC,IAAI,CAAC,+BAA+B,CAAC;IACzC,OAAAlE,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAYQ,KAAK;MAAEoG;IAAQ;EAC5B,CAAC,CAAC,CACDC,OAAO,CAACxG,OAAA,CAAAyG,eAAe,CAACC,YAAY,CAAC;AACxC,CAAC;AAED,MAAMA,YAAY,GACjBvG,KAIE,IAEFnD,QAAA,CAAA2J,QAAQ,CAACC,OAAO,CAACzG,KAAK,CAAC,CACrB7C,GAAG,CAACuJ,OAAO,KAAK;EAAEA;AAAO,CAAE,CAAC,CAAC,CAC7BL,OAAO,CAACxJ,QAAA,CAAA8J,QAAQ,CAACC,WAAW,CAAC,CAC7BzJ,GAAG,CAACgD,QAAQ,KAAK;EACjBA,QAAQ;EACRC,0BAA0B,EAAEJ,KAAK,CAACI;CAClC,CAAC,CAAC,CACFjD,GAAG,CAAC4C,MAAM,CAAC;AAEd,MAAM8G,qCAAqC,GAC1C7G,KAKE,IACuC;EACzC,MAAM;IAAEG,QAAQ;IAAE2G,QAAQ;IAAE1G;EAA0B,CAAE,GAAGJ,KAAK;EAEhE,MAAM+G,IAAI,GAAIC,cAAyB,IACtChK,YAAA,CAAA8I,WAAW,CAACC,WAAW,CAAC/F,KAAK,CAAC+G,IAAI,CAACC,cAAc,CAAC,EAAGf,CAAU,IAAI;IAClE,MAAMC,eAAe,GAAG,IAAAnJ,MAAA,CAAAoJ,YAAY,EAACF,CAAC,CAAC;IACvC,MAAMxB,MAAM,GAAG,+CAA+CyB,eAAe,GAAG;IAChFnJ,MAAA,CAAAyG,GAAG,CAACU,KAAK,CAACO,MAAM,CAAC;IACjB,OAAO,IAAIrF,KAAK,CAACqF,MAAM,CAAC;EACzB,CAAC,CAAC,CAACtH,GAAG,CAAC,MAAK;IACXJ,MAAA,CAAAyG,GAAG,CAACC,IAAI,CAAC,8BAA8B,CAAC;IACxC,OAAOuD,cAAc;EACtB,CAAC,CAAC;EAEH,OAAOnK,QAAA,CAAA2J,QAAQ,CAACS,aAAa,CAAC;IAC7BC,MAAM,EAAE/G,QAAQ,CAACuG,OAAO;IACxBI;GACA,CAAC,CACAT,OAAO,CAACU,IAAI,CAAC,CACb5J,GAAG,CAAEiJ,QAAmB,KAAM;IAC9BA,QAAQ;IACRU,QAAQ;IACR1G;GACA,CAAC,CAAC,CACFiG,OAAO,CAACxG,OAAA,CAAAyG,eAAe,CAACC,YAAY,CAAC;AACxC,CAAC;AAEY1G,OAAA,CAAAyG,eAAe,GAAG;EAC9BvG,MAAM;EACNwG,YAAY;EACZX,8BAA8B;EAC9BiB;CACA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}