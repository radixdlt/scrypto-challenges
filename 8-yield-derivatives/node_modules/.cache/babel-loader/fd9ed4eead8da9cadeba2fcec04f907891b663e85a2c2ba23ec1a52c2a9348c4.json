{"ast":null,"code":"/**\n * Self-balancing binary search tree using the AVL implementation\n */\nvar BinarySearchTree = require('./bst'),\n  customUtils = require('./customUtils'),\n  util = require('util'),\n  _ = require('underscore');\n\n/**\n * Constructor\n * We can't use a direct pointer to the root node (as in the simple binary search tree)\n * as the root will change during tree rotations\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction AVLTree(options) {\n  this.tree = new _AVLTree(options);\n}\n\n/**\n * Constructor of the internal AVLTree\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction _AVLTree(options) {\n  options = options || {};\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) {\n    this.key = options.key;\n  }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n/**\n * Inherit basic functions from the basic binary search tree\n */\nutil.inherits(_AVLTree, BinarySearchTree);\n\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\nAVLTree._AVLTree = _AVLTree;\n\n/**\n * Check the recorded height is correct for every node\n * Throws if one height doesn't match\n */\n_AVLTree.prototype.checkHeightCorrect = function () {\n  var leftH, rightH;\n  if (!this.hasOwnProperty('key')) {\n    return;\n  } // Empty tree\n\n  if (this.left && this.left.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.left.key);\n  }\n  if (this.right && this.right.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.right.key);\n  }\n  if (this.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.key);\n  }\n  leftH = this.left ? this.left.height : 0;\n  rightH = this.right ? this.right.height : 0;\n  if (this.height !== 1 + Math.max(leftH, rightH)) {\n    throw new Error(\"Height constraint failed for node \" + this.key);\n  }\n  if (this.left) {\n    this.left.checkHeightCorrect();\n  }\n  if (this.right) {\n    this.right.checkHeightCorrect();\n  }\n};\n\n/**\n * Return the balance factor\n */\n_AVLTree.prototype.balanceFactor = function () {\n  var leftH = this.left ? this.left.height : 0,\n    rightH = this.right ? this.right.height : 0;\n  return leftH - rightH;\n};\n\n/**\n * Check that the balance factors are all between -1 and 1\n */\n_AVLTree.prototype.checkBalanceFactors = function () {\n  if (Math.abs(this.balanceFactor()) > 1) {\n    throw new Error('Tree is unbalanced at node ' + this.key);\n  }\n  if (this.left) {\n    this.left.checkBalanceFactors();\n  }\n  if (this.right) {\n    this.right.checkBalanceFactors();\n  }\n};\n\n/**\n * When checking if the BST conditions are met, also check that the heights are correct\n * and the tree is balanced\n */\n_AVLTree.prototype.checkIsAVLT = function () {\n  _AVLTree.super_.prototype.checkIsBST.call(this);\n  this.checkHeightCorrect();\n  this.checkBalanceFactors();\n};\nAVLTree.prototype.checkIsAVLT = function () {\n  this.tree.checkIsAVLT();\n};\n\n/**\n * Perform a right rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.rightRotation = function () {\n  var q = this,\n    p = this.left,\n    b,\n    ah,\n    bh,\n    ch;\n  if (!p) {\n    return this;\n  } // No change\n\n  b = p.right;\n\n  // Alter tree structure\n  if (q.parent) {\n    p.parent = q.parent;\n    if (q.parent.left === q) {\n      q.parent.left = p;\n    } else {\n      q.parent.right = p;\n    }\n  } else {\n    p.parent = null;\n  }\n  p.right = q;\n  q.parent = p;\n  q.left = b;\n  if (b) {\n    b.parent = q;\n  }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  q.height = Math.max(bh, ch) + 1;\n  p.height = Math.max(ah, q.height) + 1;\n  return p;\n};\n\n/**\n * Perform a left rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.leftRotation = function () {\n  var p = this,\n    q = this.right,\n    b,\n    ah,\n    bh,\n    ch;\n  if (!q) {\n    return this;\n  } // No change\n\n  b = q.left;\n\n  // Alter tree structure\n  if (p.parent) {\n    q.parent = p.parent;\n    if (p.parent.left === p) {\n      p.parent.left = q;\n    } else {\n      p.parent.right = q;\n    }\n  } else {\n    q.parent = null;\n  }\n  q.left = p;\n  p.parent = q;\n  p.right = b;\n  if (b) {\n    b.parent = p;\n  }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  p.height = Math.max(ah, bh) + 1;\n  q.height = Math.max(ch, p.height) + 1;\n  return q;\n};\n\n/**\n * Modify the tree if its right subtree is too small compared to the left\n * Return the new root if any\n */\n_AVLTree.prototype.rightTooSmall = function () {\n  if (this.balanceFactor() <= 1) {\n    return this;\n  } // Right is not too small, don't change\n\n  if (this.left.balanceFactor() < 0) {\n    this.left.leftRotation();\n  }\n  return this.rightRotation();\n};\n\n/**\n * Modify the tree if its left subtree is too small compared to the right\n * Return the new root if any\n */\n_AVLTree.prototype.leftTooSmall = function () {\n  if (this.balanceFactor() >= -1) {\n    return this;\n  } // Left is not too small, don't change\n\n  if (this.right.balanceFactor() > 0) {\n    this.right.rightRotation();\n  }\n  return this.leftRotation();\n};\n\n/**\n * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n * in the insert and delete functions).\n * Returns the new root of the tree\n * Of course, the first element of the path must be the root of the tree\n */\n_AVLTree.prototype.rebalanceAlongPath = function (path) {\n  var newRoot = this,\n    rotated,\n    i;\n  if (!this.hasOwnProperty('key')) {\n    delete this.height;\n    return this;\n  } // Empty tree\n\n  // Rebalance the tree and update all heights\n  for (i = path.length - 1; i >= 0; i -= 1) {\n    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n    if (path[i].balanceFactor() > 1) {\n      rotated = path[i].rightTooSmall();\n      if (i === 0) {\n        newRoot = rotated;\n      }\n    }\n    if (path[i].balanceFactor() < -1) {\n      rotated = path[i].leftTooSmall();\n      if (i === 0) {\n        newRoot = rotated;\n      }\n    }\n  }\n  return newRoot;\n};\n\n/**\n * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n * Return a pointer to the root node, which may have changed\n */\n_AVLTree.prototype.insert = function (key, value) {\n  var insertPath = [],\n    currentNode = this;\n\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    this.height = 1;\n    return this;\n  }\n\n  // Insert new leaf at the right place\n  while (true) {\n    // Same key: no change in the tree structure\n    if (currentNode.compareKeys(currentNode.key, key) === 0) {\n      if (currentNode.unique) {\n        var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n        err.key = key;\n        err.errorType = 'uniqueViolated';\n        throw err;\n      } else {\n        currentNode.data.push(value);\n      }\n      return this;\n    }\n    insertPath.push(currentNode);\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (!currentNode.left) {\n        insertPath.push(currentNode.createLeftChild({\n          key: key,\n          value: value\n        }));\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        insertPath.push(currentNode.createRightChild({\n          key: key,\n          value: value\n        }));\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n  return this.rebalanceAlongPath(insertPath);\n};\n\n// Insert in the internal tree, update the pointer to the root if needed\nAVLTree.prototype.insert = function (key, value) {\n  var newTree = this.tree.insert(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) {\n    this.tree = newTree;\n  }\n};\n\n/**\n * Delete a key or just a value and return the new root of the tree\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n_AVLTree.prototype.delete = function (key, value) {\n  var newData = [],\n    replaceWith,\n    self = this,\n    currentNode = this,\n    deletePath = [];\n  if (!this.hasOwnProperty('key')) {\n    return this;\n  } // Empty tree\n\n  // Either no match is found and the function will return from within the loop\n  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n  while (true) {\n    if (currentNode.compareKeys(key, currentNode.key) === 0) {\n      break;\n    }\n    deletePath.push(currentNode);\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (currentNode.left) {\n        currentNode = currentNode.left;\n      } else {\n        return this; // Key not found, no modification\n      }\n    } else {\n      // currentNode.compareKeys(key, currentNode.key) is > 0\n      if (currentNode.right) {\n        currentNode = currentNode.right;\n      } else {\n        return this; // Key not found, no modification\n      }\n    }\n  }\n\n  // Delete only a value (no tree modification)\n  if (currentNode.data.length > 1 && value) {\n    currentNode.data.forEach(function (d) {\n      if (!currentNode.checkValueEquality(d, value)) {\n        newData.push(d);\n      }\n    });\n    currentNode.data = newData;\n    return this;\n  }\n\n  // Delete a whole node\n\n  // Leaf\n  if (!currentNode.left && !currentNode.right) {\n    if (currentNode === this) {\n      // This leaf is also the root\n      delete currentNode.key;\n      currentNode.data = [];\n      delete currentNode.height;\n      return this;\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = null;\n      } else {\n        currentNode.parent.right = null;\n      }\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n  // Node with only one child\n  if (!currentNode.left || !currentNode.right) {\n    replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n    if (currentNode === this) {\n      // This node is also the root\n      replaceWith.parent = null;\n      return replaceWith; // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      } else {\n        currentNode.parent.right = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      }\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n  // Node with two children\n  // Use the in-order predecessor (no need to randomize since we actively rebalance)\n  deletePath.push(currentNode);\n  replaceWith = currentNode.left;\n\n  // Special case: the in-order predecessor is right below the node to delete\n  if (!replaceWith.right) {\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    currentNode.left = replaceWith.left;\n    if (replaceWith.left) {\n      replaceWith.left.parent = currentNode;\n    }\n    return this.rebalanceAlongPath(deletePath);\n  }\n\n  // After this loop, replaceWith is the right-most leaf in the left subtree\n  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n  while (true) {\n    if (replaceWith.right) {\n      deletePath.push(replaceWith);\n      replaceWith = replaceWith.right;\n    } else {\n      break;\n    }\n  }\n  currentNode.key = replaceWith.key;\n  currentNode.data = replaceWith.data;\n  replaceWith.parent.right = replaceWith.left;\n  if (replaceWith.left) {\n    replaceWith.left.parent = replaceWith.parent;\n  }\n  return this.rebalanceAlongPath(deletePath);\n};\n\n// Delete a value\nAVLTree.prototype.delete = function (key, value) {\n  var newTree = this.tree.delete(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) {\n    this.tree = newTree;\n  }\n};\n\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n});\n\n// Interface\nmodule.exports = AVLTree;","map":{"version":3,"names":["BinarySearchTree","require","customUtils","util","_","AVLTree","options","tree","_AVLTree","left","right","parent","undefined","hasOwnProperty","key","data","value","unique","compareKeys","defaultCompareKeysFunction","checkValueEquality","defaultCheckValueEquality","inherits","prototype","checkHeightCorrect","leftH","rightH","height","Error","Math","max","balanceFactor","checkBalanceFactors","abs","checkIsAVLT","super_","checkIsBST","call","rightRotation","q","p","b","ah","bh","ch","leftRotation","rightTooSmall","leftTooSmall","rebalanceAlongPath","path","newRoot","rotated","i","length","insert","insertPath","currentNode","push","err","errorType","createLeftChild","createRightChild","newTree","delete","newData","replaceWith","self","deletePath","forEach","d","fn","apply","arguments","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/binary-search-tree/lib/avltree.js"],"sourcesContent":["/**\n * Self-balancing binary search tree using the AVL implementation\n */\nvar BinarySearchTree = require('./bst')\n  , customUtils = require('./customUtils')\n  , util = require('util')\n  , _ = require('underscore')\n  ;\n\n\n/**\n * Constructor\n * We can't use a direct pointer to the root node (as in the simple binary search tree)\n * as the root will change during tree rotations\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction AVLTree (options) {\n  this.tree = new _AVLTree(options);\n}\n\n\n/**\n * Constructor of the internal AVLTree\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction _AVLTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n/**\n * Inherit basic functions from the basic binary search tree\n */\nutil.inherits(_AVLTree, BinarySearchTree);\n\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\nAVLTree._AVLTree = _AVLTree;\n\n\n/**\n * Check the recorded height is correct for every node\n * Throws if one height doesn't match\n */\n_AVLTree.prototype.checkHeightCorrect = function () {\n  var leftH, rightH;\n\n  if (!this.hasOwnProperty('key')) { return; }   // Empty tree\n\n  if (this.left && this.left.height === undefined) { throw new Error(\"Undefined height for node \" + this.left.key); }\n  if (this.right && this.right.height === undefined) { throw new Error(\"Undefined height for node \" + this.right.key); }\n  if (this.height === undefined) { throw new Error(\"Undefined height for node \" + this.key); }\n\n  leftH = this.left ? this.left.height : 0;\n  rightH = this.right ? this.right.height : 0;\n\n  if (this.height !== 1 + Math.max(leftH, rightH)) { throw new Error(\"Height constraint failed for node \" + this.key); }\n  if (this.left) { this.left.checkHeightCorrect(); }\n  if (this.right) { this.right.checkHeightCorrect(); }\n};\n\n\n/**\n * Return the balance factor\n */\n_AVLTree.prototype.balanceFactor = function () {\n  var leftH = this.left ? this.left.height : 0\n    , rightH = this.right ? this.right.height : 0\n    ;\n  return leftH - rightH;\n};\n\n\n/**\n * Check that the balance factors are all between -1 and 1\n */\n_AVLTree.prototype.checkBalanceFactors = function () {\n  if (Math.abs(this.balanceFactor()) > 1) { throw new Error('Tree is unbalanced at node ' + this.key); }\n\n  if (this.left) { this.left.checkBalanceFactors(); }\n  if (this.right) { this.right.checkBalanceFactors(); }\n};\n\n\n/**\n * When checking if the BST conditions are met, also check that the heights are correct\n * and the tree is balanced\n */\n_AVLTree.prototype.checkIsAVLT = function () {\n  _AVLTree.super_.prototype.checkIsBST.call(this);\n  this.checkHeightCorrect();\n  this.checkBalanceFactors();\n};\nAVLTree.prototype.checkIsAVLT = function () { this.tree.checkIsAVLT(); };\n\n\n/**\n * Perform a right rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.rightRotation = function () {\n  var q = this\n    , p = this.left\n    , b\n    , ah, bh, ch;\n\n  if (!p) { return this; }   // No change\n\n  b = p.right;\n\n  // Alter tree structure\n  if (q.parent) {\n    p.parent = q.parent;\n    if (q.parent.left === q) { q.parent.left = p; } else { q.parent.right = p; }\n  } else {\n    p.parent = null;\n  }\n  p.right = q;\n  q.parent = p;\n  q.left = b;\n  if (b) { b.parent = q; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  q.height = Math.max(bh, ch) + 1;\n  p.height = Math.max(ah, q.height) + 1;\n\n  return p;\n};\n\n\n/**\n * Perform a left rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.leftRotation = function () {\n  var p = this\n    , q = this.right\n    , b\n    , ah, bh, ch;\n\n  if (!q) { return this; }   // No change\n\n  b = q.left;\n\n  // Alter tree structure\n  if (p.parent) {\n    q.parent = p.parent;\n    if (p.parent.left === p) { p.parent.left = q; } else { p.parent.right = q; }\n  } else {\n    q.parent = null;\n  }\n  q.left = p;\n  p.parent = q;\n  p.right = b;\n  if (b) { b.parent = p; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  p.height = Math.max(ah, bh) + 1;\n  q.height = Math.max(ch, p.height) + 1;\n\n  return q;\n};\n\n\n/**\n * Modify the tree if its right subtree is too small compared to the left\n * Return the new root if any\n */\n_AVLTree.prototype.rightTooSmall = function () {\n  if (this.balanceFactor() <= 1) { return this; }   // Right is not too small, don't change\n\n  if (this.left.balanceFactor() < 0) {\n    this.left.leftRotation();\n  }\n\n  return this.rightRotation();\n};\n\n\n/**\n * Modify the tree if its left subtree is too small compared to the right\n * Return the new root if any\n */\n_AVLTree.prototype.leftTooSmall = function () {\n  if (this.balanceFactor() >= -1) { return this; }   // Left is not too small, don't change\n\n  if (this.right.balanceFactor() > 0) {\n    this.right.rightRotation();\n  }\n\n  return this.leftRotation();\n};\n\n\n/**\n * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n * in the insert and delete functions).\n * Returns the new root of the tree\n * Of course, the first element of the path must be the root of the tree\n */\n_AVLTree.prototype.rebalanceAlongPath = function (path) {\n  var newRoot = this\n    , rotated\n    , i;\n\n  if (!this.hasOwnProperty('key')) { delete this.height; return this; }   // Empty tree\n\n  // Rebalance the tree and update all heights\n  for (i = path.length - 1; i >= 0; i -= 1) {\n    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n\n    if (path[i].balanceFactor() > 1) {\n      rotated = path[i].rightTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n\n    if (path[i].balanceFactor() < -1) {\n      rotated = path[i].leftTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n  }\n\n  return newRoot;\n};\n\n\n/**\n * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n * Return a pointer to the root node, which may have changed\n */\n_AVLTree.prototype.insert = function (key, value) {\n  var insertPath = []\n    , currentNode = this\n    ;\n\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    this.height = 1;\n    return this;\n  }\n\n  // Insert new leaf at the right place\n  while (true) {\n    // Same key: no change in the tree structure\n    if (currentNode.compareKeys(currentNode.key, key) === 0) {\n      if (currentNode.unique) {\n        var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n        err.key = key;\n        err.errorType = 'uniqueViolated';\n        throw err;\n      } else {\n        currentNode.data.push(value);\n      }\n      return this;\n    }\n\n    insertPath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (!currentNode.left) {\n        insertPath.push(currentNode.createLeftChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        insertPath.push(currentNode.createRightChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n\n  return this.rebalanceAlongPath(insertPath);\n};\n\n// Insert in the internal tree, update the pointer to the root if needed\nAVLTree.prototype.insert = function (key, value) {\n  var newTree = this.tree.insert(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Delete a key or just a value and return the new root of the tree\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n_AVLTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    , currentNode = this\n    , deletePath = []\n    ;\n\n  if (!this.hasOwnProperty('key')) { return this; }   // Empty tree\n\n  // Either no match is found and the function will return from within the loop\n  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n  while (true) {\n    if (currentNode.compareKeys(key, currentNode.key) === 0) { break; }\n\n    deletePath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (currentNode.left) {\n        currentNode = currentNode.left;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    } else {\n      // currentNode.compareKeys(key, currentNode.key) is > 0\n      if (currentNode.right) {\n        currentNode = currentNode.right;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    }\n  }\n\n  // Delete only a value (no tree modification)\n  if (currentNode.data.length > 1 && value) {\n    currentNode.data.forEach(function (d) {\n      if (!currentNode.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    currentNode.data = newData;\n    return this;\n  }\n\n  // Delete a whole node\n\n  // Leaf\n  if (!currentNode.left && !currentNode.right) {\n    if (currentNode === this) {   // This leaf is also the root\n      delete currentNode.key;\n      currentNode.data = [];\n      delete currentNode.height;\n      return this;\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = null;\n      } else {\n        currentNode.parent.right = null;\n      }\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with only one child\n  if (!currentNode.left || !currentNode.right) {\n    replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n\n    if (currentNode === this) {   // This node is also the root\n      replaceWith.parent = null;\n      return replaceWith;   // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      } else {\n        currentNode.parent.right = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with two children\n  // Use the in-order predecessor (no need to randomize since we actively rebalance)\n  deletePath.push(currentNode);\n  replaceWith = currentNode.left;\n\n  // Special case: the in-order predecessor is right below the node to delete\n  if (!replaceWith.right) {\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    currentNode.left = replaceWith.left;\n    if (replaceWith.left) { replaceWith.left.parent = currentNode; }\n    return this.rebalanceAlongPath(deletePath);\n  }\n\n  // After this loop, replaceWith is the right-most leaf in the left subtree\n  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n  while (true) {\n    if (replaceWith.right) {\n      deletePath.push(replaceWith);\n      replaceWith = replaceWith.right;\n    } else {\n      break;\n    }\n  }\n\n  currentNode.key = replaceWith.key;\n  currentNode.data = replaceWith.data;\n\n  replaceWith.parent.right = replaceWith.left;\n  if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n\n  return this.rebalanceAlongPath(deletePath);\n};\n\n// Delete a value\nAVLTree.prototype.delete = function (key, value) {\n  var newTree = this.tree.delete(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n});\n\n\n// Interface\nmodule.exports = AVLTree;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}