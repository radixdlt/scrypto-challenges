{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Provides an error interface for handling when a method is trying to be called but does not exist.\n */\nvar MethodNotFoundError = /** @class */function () {\n  /**\n   * @param methodName The method name that was used.\n   * @param openrpcDocument The OpenRPC document that the method was used against.\n   * @param receievedParams The params, if any, that were used.\n   */\n  function MethodNotFoundError(methodName, openrpcDocument, receievedParams) {\n    if (receievedParams === void 0) {\n      receievedParams = [];\n    }\n    this.methodName = methodName;\n    this.openrpcDocument = openrpcDocument;\n    this.receievedParams = receievedParams;\n    this.name = \"MethodNotFoundError\";\n    var msg = [\"Method Not Found Error for OpenRPC API named \\\"\" + openrpcDocument.info.title + \"\\\"\", \"The requested method: \\\"\" + methodName + \"\\\" not a valid method.\"];\n    if (openrpcDocument.methods.length > 0) {\n      msg.push(\n      // @ts-ignore\n      \"Valid method names are as follows: \" + openrpcDocument.methods.map(function (_a) {\n        var name = _a.name;\n        return name;\n      }).join(\", \"));\n    }\n    var stringedParams;\n    if (receievedParams instanceof Array) {\n      if (receievedParams.length > 0) {\n        stringedParams = receievedParams.map(function (p) {\n          try {\n            return JSON.stringify(p);\n          } catch (e) {\n            return p;\n          }\n        }).join(\"\\n\");\n      }\n    } else {\n      stringedParams = JSON.stringify(receievedParams);\n    }\n    if (stringedParams) {\n      msg.push(\"Params:\");\n      msg.push(stringedParams);\n    }\n    this.message = msg.join(\"\\n\");\n  }\n  return MethodNotFoundError;\n}();\nexports.default = MethodNotFoundError;","map":{"version":3,"names":["Object","defineProperty","exports","value","MethodNotFoundError","methodName","openrpcDocument","receievedParams","name","msg","info","title","methods","length","push","map","_a","join","stringedParams","Array","p","JSON","stringify","e","message","default"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/open-rpc-utils/build/method-call-validator/method-not-found-error.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Provides an error interface for handling when a method is trying to be called but does not exist.\n */\nvar MethodNotFoundError = /** @class */ (function () {\n    /**\n     * @param methodName The method name that was used.\n     * @param openrpcDocument The OpenRPC document that the method was used against.\n     * @param receievedParams The params, if any, that were used.\n     */\n    function MethodNotFoundError(methodName, openrpcDocument, receievedParams) {\n        if (receievedParams === void 0) { receievedParams = []; }\n        this.methodName = methodName;\n        this.openrpcDocument = openrpcDocument;\n        this.receievedParams = receievedParams;\n        this.name = \"MethodNotFoundError\";\n        var msg = [\n            \"Method Not Found Error for OpenRPC API named \\\"\" + openrpcDocument.info.title + \"\\\"\",\n            \"The requested method: \\\"\" + methodName + \"\\\" not a valid method.\",\n        ];\n        if (openrpcDocument.methods.length > 0) {\n            msg.push(\n            // @ts-ignore\n            \"Valid method names are as follows: \" + openrpcDocument.methods.map(function (_a) {\n                var name = _a.name;\n                return name;\n            }).join(\", \"));\n        }\n        var stringedParams;\n        if (receievedParams instanceof Array) {\n            if (receievedParams.length > 0) {\n                stringedParams = receievedParams\n                    .map(function (p) { try {\n                    return JSON.stringify(p);\n                }\n                catch (e) {\n                    return p;\n                } })\n                    .join(\"\\n\");\n            }\n        }\n        else {\n            stringedParams = JSON.stringify(receievedParams);\n        }\n        if (stringedParams) {\n            msg.push(\"Params:\");\n            msg.push(stringedParams);\n        }\n        this.message = msg.join(\"\\n\");\n    }\n    return MethodNotFoundError;\n}());\nexports.default = MethodNotFoundError;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D;AACA;AACA;AACA,IAAIC,mBAAmB,GAAG,aAAe,YAAY;EACjD;AACJ;AACA;AACA;AACA;EACI,SAASA,mBAAmBA,CAACC,UAAU,EAAEC,eAAe,EAAEC,eAAe,EAAE;IACvE,IAAIA,eAAe,KAAK,KAAK,CAAC,EAAE;MAAEA,eAAe,GAAG,EAAE;IAAE;IACxD,IAAI,CAACF,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,IAAI,GAAG,qBAAqB;IACjC,IAAIC,GAAG,GAAG,CACN,iDAAiD,GAAGH,eAAe,CAACI,IAAI,CAACC,KAAK,GAAG,IAAI,EACrF,0BAA0B,GAAGN,UAAU,GAAG,wBAAwB,CACrE;IACD,IAAIC,eAAe,CAACM,OAAO,CAACC,MAAM,GAAG,CAAC,EAAE;MACpCJ,GAAG,CAACK,IAAI;MACR;MACA,qCAAqC,GAAGR,eAAe,CAACM,OAAO,CAACG,GAAG,CAAC,UAAUC,EAAE,EAAE;QAC9E,IAAIR,IAAI,GAAGQ,EAAE,CAACR,IAAI;QAClB,OAAOA,IAAI;MACf,CAAC,CAAC,CAACS,IAAI,CAAC,IAAI,CAAC,CAAC;IAClB;IACA,IAAIC,cAAc;IAClB,IAAIX,eAAe,YAAYY,KAAK,EAAE;MAClC,IAAIZ,eAAe,CAACM,MAAM,GAAG,CAAC,EAAE;QAC5BK,cAAc,GAAGX,eAAe,CAC3BQ,GAAG,CAAC,UAAUK,CAAC,EAAE;UAAE,IAAI;YACxB,OAAOC,IAAI,CAACC,SAAS,CAACF,CAAC,CAAC;UAC5B,CAAC,CACD,OAAOG,CAAC,EAAE;YACN,OAAOH,CAAC;UACZ;QAAE,CAAC,CAAC,CACCH,IAAI,CAAC,IAAI,CAAC;MACnB;IACJ,CAAC,MACI;MACDC,cAAc,GAAGG,IAAI,CAACC,SAAS,CAACf,eAAe,CAAC;IACpD;IACA,IAAIW,cAAc,EAAE;MAChBT,GAAG,CAACK,IAAI,CAAC,SAAS,CAAC;MACnBL,GAAG,CAACK,IAAI,CAACI,cAAc,CAAC;IAC5B;IACA,IAAI,CAACM,OAAO,GAAGf,GAAG,CAACQ,IAAI,CAAC,IAAI,CAAC;EACjC;EACA,OAAOb,mBAAmB;AAC9B,CAAC,CAAC,CAAE;AACJF,OAAO,CAACuB,OAAO,GAAGrB,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}