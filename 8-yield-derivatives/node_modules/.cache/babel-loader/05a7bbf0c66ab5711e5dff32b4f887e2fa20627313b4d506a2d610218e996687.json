{"ast":null,"code":"\"use strict\";\n\n(function (root) {\n  const MAX_VALUE = 0x7fffffff;\n\n  // The SHA256 and PBKDF2 implementation are from scrypt-async-js:\n  // See: https://github.com/dchest/scrypt-async-js\n  function SHA256(m) {\n    const K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);\n    let h0 = 0x6a09e667,\n      h1 = 0xbb67ae85,\n      h2 = 0x3c6ef372,\n      h3 = 0xa54ff53a;\n    let h4 = 0x510e527f,\n      h5 = 0x9b05688c,\n      h6 = 0x1f83d9ab,\n      h7 = 0x5be0cd19;\n    const w = new Uint32Array(64);\n    function blocks(p) {\n      let off = 0,\n        len = p.length;\n      while (len >= 64) {\n        let a = h0,\n          b = h1,\n          c = h2,\n          d = h3,\n          e = h4,\n          f = h5,\n          g = h6,\n          h = h7,\n          u,\n          i,\n          j,\n          t1,\n          t2;\n        for (i = 0; i < 16; i++) {\n          j = off + i * 4;\n          w[i] = (p[j] & 0xff) << 24 | (p[j + 1] & 0xff) << 16 | (p[j + 2] & 0xff) << 8 | p[j + 3] & 0xff;\n        }\n        for (i = 16; i < 64; i++) {\n          u = w[i - 2];\n          t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;\n          u = w[i - 15];\n          t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;\n          w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0) | 0;\n        }\n        for (i = 0; i < 64; i++) {\n          t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;\n          t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;\n          h = g;\n          g = f;\n          f = e;\n          e = d + t1 | 0;\n          d = c;\n          c = b;\n          b = a;\n          a = t1 + t2 | 0;\n        }\n        h0 = h0 + a | 0;\n        h1 = h1 + b | 0;\n        h2 = h2 + c | 0;\n        h3 = h3 + d | 0;\n        h4 = h4 + e | 0;\n        h5 = h5 + f | 0;\n        h6 = h6 + g | 0;\n        h7 = h7 + h | 0;\n        off += 64;\n        len -= 64;\n      }\n    }\n    blocks(m);\n    let i,\n      bytesLeft = m.length % 64,\n      bitLenHi = m.length / 0x20000000 | 0,\n      bitLenLo = m.length << 3,\n      numZeros = bytesLeft < 56 ? 56 : 120,\n      p = m.slice(m.length - bytesLeft, m.length);\n    p.push(0x80);\n    for (i = bytesLeft + 1; i < numZeros; i++) {\n      p.push(0);\n    }\n    p.push(bitLenHi >>> 24 & 0xff);\n    p.push(bitLenHi >>> 16 & 0xff);\n    p.push(bitLenHi >>> 8 & 0xff);\n    p.push(bitLenHi >>> 0 & 0xff);\n    p.push(bitLenLo >>> 24 & 0xff);\n    p.push(bitLenLo >>> 16 & 0xff);\n    p.push(bitLenLo >>> 8 & 0xff);\n    p.push(bitLenLo >>> 0 & 0xff);\n    blocks(p);\n    return [h0 >>> 24 & 0xff, h0 >>> 16 & 0xff, h0 >>> 8 & 0xff, h0 >>> 0 & 0xff, h1 >>> 24 & 0xff, h1 >>> 16 & 0xff, h1 >>> 8 & 0xff, h1 >>> 0 & 0xff, h2 >>> 24 & 0xff, h2 >>> 16 & 0xff, h2 >>> 8 & 0xff, h2 >>> 0 & 0xff, h3 >>> 24 & 0xff, h3 >>> 16 & 0xff, h3 >>> 8 & 0xff, h3 >>> 0 & 0xff, h4 >>> 24 & 0xff, h4 >>> 16 & 0xff, h4 >>> 8 & 0xff, h4 >>> 0 & 0xff, h5 >>> 24 & 0xff, h5 >>> 16 & 0xff, h5 >>> 8 & 0xff, h5 >>> 0 & 0xff, h6 >>> 24 & 0xff, h6 >>> 16 & 0xff, h6 >>> 8 & 0xff, h6 >>> 0 & 0xff, h7 >>> 24 & 0xff, h7 >>> 16 & 0xff, h7 >>> 8 & 0xff, h7 >>> 0 & 0xff];\n  }\n  function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {\n    // compress password if it's longer than hash block length\n    password = password.length <= 64 ? password : SHA256(password);\n    const innerLen = 64 + salt.length + 4;\n    const inner = new Array(innerLen);\n    const outerKey = new Array(64);\n    let i;\n    let dk = [];\n\n    // inner = (password ^ ipad) || salt || counter\n    for (i = 0; i < 64; i++) {\n      inner[i] = 0x36;\n    }\n    for (i = 0; i < password.length; i++) {\n      inner[i] ^= password[i];\n    }\n    for (i = 0; i < salt.length; i++) {\n      inner[64 + i] = salt[i];\n    }\n    for (i = innerLen - 4; i < innerLen; i++) {\n      inner[i] = 0;\n    }\n\n    // outerKey = password ^ opad\n    for (i = 0; i < 64; i++) outerKey[i] = 0x5c;\n    for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];\n\n    // increments counter inside inner\n    function incrementCounter() {\n      for (let i = innerLen - 1; i >= innerLen - 4; i--) {\n        inner[i]++;\n        if (inner[i] <= 0xff) return;\n        inner[i] = 0;\n      }\n    }\n\n    // output blocks = SHA256(outerKey || SHA256(inner)) ...\n    while (dkLen >= 32) {\n      incrementCounter();\n      dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));\n      dkLen -= 32;\n    }\n    if (dkLen > 0) {\n      incrementCounter();\n      dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));\n    }\n    return dk;\n  }\n\n  // The following is an adaptation of scryptsy\n  // See: https://www.npmjs.com/package/scryptsy\n  function blockmix_salsa8(BY, Yi, r, x, _X) {\n    let i;\n    arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);\n    for (i = 0; i < 2 * r; i++) {\n      blockxor(BY, i * 16, _X, 16);\n      salsa20_8(_X, x);\n      arraycopy(_X, 0, BY, Yi + i * 16, 16);\n    }\n    for (i = 0; i < r; i++) {\n      arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);\n    }\n    for (i = 0; i < r; i++) {\n      arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);\n    }\n  }\n  function R(a, b) {\n    return a << b | a >>> 32 - b;\n  }\n  function salsa20_8(B, x) {\n    arraycopy(B, 0, x, 0, 16);\n    for (let i = 8; i > 0; i -= 2) {\n      x[4] ^= R(x[0] + x[12], 7);\n      x[8] ^= R(x[4] + x[0], 9);\n      x[12] ^= R(x[8] + x[4], 13);\n      x[0] ^= R(x[12] + x[8], 18);\n      x[9] ^= R(x[5] + x[1], 7);\n      x[13] ^= R(x[9] + x[5], 9);\n      x[1] ^= R(x[13] + x[9], 13);\n      x[5] ^= R(x[1] + x[13], 18);\n      x[14] ^= R(x[10] + x[6], 7);\n      x[2] ^= R(x[14] + x[10], 9);\n      x[6] ^= R(x[2] + x[14], 13);\n      x[10] ^= R(x[6] + x[2], 18);\n      x[3] ^= R(x[15] + x[11], 7);\n      x[7] ^= R(x[3] + x[15], 9);\n      x[11] ^= R(x[7] + x[3], 13);\n      x[15] ^= R(x[11] + x[7], 18);\n      x[1] ^= R(x[0] + x[3], 7);\n      x[2] ^= R(x[1] + x[0], 9);\n      x[3] ^= R(x[2] + x[1], 13);\n      x[0] ^= R(x[3] + x[2], 18);\n      x[6] ^= R(x[5] + x[4], 7);\n      x[7] ^= R(x[6] + x[5], 9);\n      x[4] ^= R(x[7] + x[6], 13);\n      x[5] ^= R(x[4] + x[7], 18);\n      x[11] ^= R(x[10] + x[9], 7);\n      x[8] ^= R(x[11] + x[10], 9);\n      x[9] ^= R(x[8] + x[11], 13);\n      x[10] ^= R(x[9] + x[8], 18);\n      x[12] ^= R(x[15] + x[14], 7);\n      x[13] ^= R(x[12] + x[15], 9);\n      x[14] ^= R(x[13] + x[12], 13);\n      x[15] ^= R(x[14] + x[13], 18);\n    }\n    for (let i = 0; i < 16; ++i) {\n      B[i] += x[i];\n    }\n  }\n\n  // naive approach... going back to loop unrolling may yield additional performance\n  function blockxor(S, Si, D, len) {\n    for (let i = 0; i < len; i++) {\n      D[i] ^= S[Si + i];\n    }\n  }\n  function arraycopy(src, srcPos, dest, destPos, length) {\n    while (length--) {\n      dest[destPos++] = src[srcPos++];\n    }\n  }\n  function checkBufferish(o) {\n    if (!o || typeof o.length !== 'number') {\n      return false;\n    }\n    for (let i = 0; i < o.length; i++) {\n      const v = o[i];\n      if (typeof v !== 'number' || v % 1 || v < 0 || v >= 256) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function ensureInteger(value, name) {\n    if (typeof value !== \"number\" || value % 1) {\n      throw new Error('invalid ' + name);\n    }\n    return value;\n  }\n\n  // N = Cpu cost, r = Memory cost, p = parallelization cost\n  // callback(error, progress, key)\n  function _scrypt(password, salt, N, r, p, dkLen, callback) {\n    N = ensureInteger(N, 'N');\n    r = ensureInteger(r, 'r');\n    p = ensureInteger(p, 'p');\n    dkLen = ensureInteger(dkLen, 'dkLen');\n    if (N === 0 || (N & N - 1) !== 0) {\n      throw new Error('N must be power of 2');\n    }\n    if (N > MAX_VALUE / 128 / r) {\n      throw new Error('N too large');\n    }\n    if (r > MAX_VALUE / 128 / p) {\n      throw new Error('r too large');\n    }\n    if (!checkBufferish(password)) {\n      throw new Error('password must be an array or buffer');\n    }\n    password = Array.prototype.slice.call(password);\n    if (!checkBufferish(salt)) {\n      throw new Error('salt must be an array or buffer');\n    }\n    salt = Array.prototype.slice.call(salt);\n    let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);\n    const B = new Uint32Array(p * 32 * r);\n    for (let i = 0; i < B.length; i++) {\n      const j = i * 4;\n      B[i] = (b[j + 3] & 0xff) << 24 | (b[j + 2] & 0xff) << 16 | (b[j + 1] & 0xff) << 8 | (b[j + 0] & 0xff) << 0;\n    }\n    const XY = new Uint32Array(64 * r);\n    const V = new Uint32Array(32 * r * N);\n    const Yi = 32 * r;\n\n    // scratch space\n    const x = new Uint32Array(16); // salsa20_8\n    const _X = new Uint32Array(16); // blockmix_salsa8\n\n    const totalOps = p * N * 2;\n    let currentOp = 0;\n    let lastPercent10 = null;\n\n    // Set this to true to abandon the scrypt on the next step\n    let stop = false;\n\n    // State information\n    let state = 0;\n    let i0 = 0,\n      i1;\n    let Bi;\n\n    // How many blockmix_salsa8 can we do per step?\n    const limit = callback ? parseInt(1000 / r) : 0xffffffff;\n\n    // Trick from scrypt-async; if there is a setImmediate shim in place, use it\n    const nextTick = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;\n\n    // This is really all I changed; making scryptsy a state machine so we occasionally\n    // stop and give other evnts on the evnt loop a chance to run. ~RicMoo\n    const incrementalSMix = function () {\n      if (stop) {\n        return callback(new Error('cancelled'), currentOp / totalOps);\n      }\n      let steps;\n      switch (state) {\n        case 0:\n          // for (var i = 0; i < p; i++)...\n          Bi = i0 * 32 * r;\n          arraycopy(B, Bi, XY, 0, Yi); // ROMix - 1\n\n          state = 1; // Move to ROMix 2\n          i1 = 0;\n\n        // Fall through\n\n        case 1:\n          // Run up to 1000 steps of the first inner smix loop\n          steps = N - i1;\n          if (steps > limit) {\n            steps = limit;\n          }\n          for (let i = 0; i < steps; i++) {\n            // ROMix - 2\n            arraycopy(XY, 0, V, (i1 + i) * Yi, Yi); // ROMix - 3\n            blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 4\n          }\n\n          // for (var i = 0; i < N; i++)\n          i1 += steps;\n          currentOp += steps;\n          if (callback) {\n            // Call the callback with the progress (optionally stopping us)\n            const percent10 = parseInt(1000 * currentOp / totalOps);\n            if (percent10 !== lastPercent10) {\n              stop = callback(null, currentOp / totalOps);\n              if (stop) {\n                break;\n              }\n              lastPercent10 = percent10;\n            }\n          }\n          if (i1 < N) {\n            break;\n          }\n          i1 = 0; // Move to ROMix 6\n          state = 2;\n\n        // Fall through\n\n        case 2:\n          // Run up to 1000 steps of the second inner smix loop\n          steps = N - i1;\n          if (steps > limit) {\n            steps = limit;\n          }\n          for (let i = 0; i < steps; i++) {\n            // ROMix - 6\n            const offset = (2 * r - 1) * 16; // ROMix - 7\n            const j = XY[offset] & N - 1;\n            blockxor(V, j * Yi, XY, Yi); // ROMix - 8 (inner)\n            blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 9 (outer)\n          }\n\n          // for (var i = 0; i < N; i++)...\n          i1 += steps;\n          currentOp += steps;\n\n          // Call the callback with the progress (optionally stopping us)\n          if (callback) {\n            const percent10 = parseInt(1000 * currentOp / totalOps);\n            if (percent10 !== lastPercent10) {\n              stop = callback(null, currentOp / totalOps);\n              if (stop) {\n                break;\n              }\n              lastPercent10 = percent10;\n            }\n          }\n          if (i1 < N) {\n            break;\n          }\n          arraycopy(XY, 0, B, Bi, Yi); // ROMix - 10\n\n          // for (var i = 0; i < p; i++)...\n          i0++;\n          if (i0 < p) {\n            state = 0;\n            break;\n          }\n          b = [];\n          for (let i = 0; i < B.length; i++) {\n            b.push(B[i] >> 0 & 0xff);\n            b.push(B[i] >> 8 & 0xff);\n            b.push(B[i] >> 16 & 0xff);\n            b.push(B[i] >> 24 & 0xff);\n          }\n          const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);\n\n          // Send the result to the callback\n          if (callback) {\n            callback(null, 1.0, derivedKey);\n          }\n\n          // Done; don't break (which would reschedule)\n          return derivedKey;\n      }\n\n      // Schedule the next steps\n      if (callback) {\n        nextTick(incrementalSMix);\n      }\n    };\n\n    // Run the smix state machine until completion\n    if (!callback) {\n      while (true) {\n        const derivedKey = incrementalSMix();\n        if (derivedKey != undefined) {\n          return derivedKey;\n        }\n      }\n    }\n\n    // Bootstrap the async incremental smix\n    incrementalSMix();\n  }\n  const lib = {\n    scrypt: function (password, salt, N, r, p, dkLen, progressCallback) {\n      return new Promise(function (resolve, reject) {\n        let lastProgress = 0;\n        if (progressCallback) {\n          progressCallback(0);\n        }\n        _scrypt(password, salt, N, r, p, dkLen, function (error, progress, key) {\n          if (error) {\n            reject(error);\n          } else if (key) {\n            if (progressCallback && lastProgress !== 1) {\n              progressCallback(1);\n            }\n            resolve(new Uint8Array(key));\n          } else if (progressCallback && progress !== lastProgress) {\n            lastProgress = progress;\n            return progressCallback(progress);\n          }\n        });\n      });\n    },\n    syncScrypt: function (password, salt, N, r, p, dkLen) {\n      return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));\n    }\n  };\n\n  // node.js\n  if (typeof exports !== 'undefined') {\n    module.exports = lib;\n\n    // RequireJS/AMD\n    // http://www.requirejs.org/docs/api.html\n    // https://github.com/amdjs/amdjs-api/wiki/AMD\n  } else if (typeof define === 'function' && define.amd) {\n    define(lib);\n\n    // Web Browsers\n  } else if (root) {\n    // If there was an existing library \"scrypt\", make sure it is still available\n    if (root.scrypt) {\n      root._scrypt = root.scrypt;\n    }\n    root.scrypt = lib;\n  }\n})(this);","map":{"version":3,"names":["root","MAX_VALUE","SHA256","m","K","Uint32Array","h0","h1","h2","h3","h4","h5","h6","h7","w","blocks","p","off","len","length","a","b","c","d","e","f","g","h","u","i","j","t1","t2","bytesLeft","bitLenHi","bitLenLo","numZeros","slice","push","PBKDF2_HMAC_SHA256_OneIter","password","salt","dkLen","innerLen","inner","Array","outerKey","dk","incrementCounter","concat","blockmix_salsa8","BY","Yi","r","x","_X","arraycopy","blockxor","salsa20_8","R","B","S","Si","D","src","srcPos","dest","destPos","checkBufferish","o","v","ensureInteger","value","name","Error","_scrypt","N","callback","prototype","call","XY","V","totalOps","currentOp","lastPercent10","stop","state","i0","i1","Bi","limit","parseInt","nextTick","setImmediate","setTimeout","incrementalSMix","steps","percent10","offset","derivedKey","undefined","lib","scrypt","progressCallback","Promise","resolve","reject","lastProgress","error","progress","key","Uint8Array","syncScrypt","exports","module","define","amd"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/scrypt-js/scrypt.js"],"sourcesContent":["\"use strict\";\n\n(function(root) {\n    const MAX_VALUE = 0x7fffffff;\n\n    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:\n    // See: https://github.com/dchest/scrypt-async-js\n    function SHA256(m) {\n        const K = new Uint32Array([\n           0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n           0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n           0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n           0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n           0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n           0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n           0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n           0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n           0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n           0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n           0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n       ]);\n\n        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;\n        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;\n        const w = new Uint32Array(64);\n\n        function blocks(p) {\n            let off = 0, len = p.length;\n            while (len >= 64) {\n                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;\n\n                for (i = 0; i < 16; i++) {\n                    j = off + i*4;\n                    w[i] = ((p[j] & 0xff)<<24) | ((p[j+1] & 0xff)<<16) |\n                    ((p[j+2] & 0xff)<<8) | (p[j+3] & 0xff);\n                }\n\n                for (i = 16; i < 64; i++) {\n                    u = w[i-2];\n                    t1 = ((u>>>17) | (u<<(32-17))) ^ ((u>>>19) | (u<<(32-19))) ^ (u>>>10);\n\n                    u = w[i-15];\n                    t2 = ((u>>>7) | (u<<(32-7))) ^ ((u>>>18) | (u<<(32-18))) ^ (u>>>3);\n\n                    w[i] = (((t1 + w[i-7]) | 0) + ((t2 + w[i-16]) | 0)) | 0;\n                }\n\n                for (i = 0; i < 64; i++) {\n                    t1 = ((((((e>>>6) | (e<<(32-6))) ^ ((e>>>11) | (e<<(32-11))) ^\n                             ((e>>>25) | (e<<(32-25)))) + ((e & f) ^ (~e & g))) | 0) +\n                          ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;\n\n                    t2 = ((((a>>>2) | (a<<(32-2))) ^ ((a>>>13) | (a<<(32-13))) ^\n                           ((a>>>22) | (a<<(32-22)))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;\n\n                    h = g;\n                    g = f;\n                    f = e;\n                    e = (d + t1) | 0;\n                    d = c;\n                    c = b;\n                    b = a;\n                    a = (t1 + t2) | 0;\n                }\n\n                h0 = (h0 + a) | 0;\n                h1 = (h1 + b) | 0;\n                h2 = (h2 + c) | 0;\n                h3 = (h3 + d) | 0;\n                h4 = (h4 + e) | 0;\n                h5 = (h5 + f) | 0;\n                h6 = (h6 + g) | 0;\n                h7 = (h7 + h) | 0;\n\n                off += 64;\n                len -= 64;\n            }\n        }\n\n        blocks(m);\n\n        let i, bytesLeft = m.length % 64,\n        bitLenHi = (m.length / 0x20000000) | 0,\n        bitLenLo = m.length << 3,\n        numZeros = (bytesLeft < 56) ? 56 : 120,\n        p = m.slice(m.length - bytesLeft, m.length);\n\n        p.push(0x80);\n        for (i = bytesLeft + 1; i < numZeros; i++) { p.push(0); }\n        p.push((bitLenHi >>> 24) & 0xff);\n        p.push((bitLenHi >>> 16) & 0xff);\n        p.push((bitLenHi >>> 8)  & 0xff);\n        p.push((bitLenHi >>> 0)  & 0xff);\n        p.push((bitLenLo >>> 24) & 0xff);\n        p.push((bitLenLo >>> 16) & 0xff);\n        p.push((bitLenLo >>> 8)  & 0xff);\n        p.push((bitLenLo >>> 0)  & 0xff);\n\n        blocks(p);\n\n        return [\n            (h0 >>> 24) & 0xff, (h0 >>> 16) & 0xff, (h0 >>> 8) & 0xff, (h0 >>> 0) & 0xff,\n            (h1 >>> 24) & 0xff, (h1 >>> 16) & 0xff, (h1 >>> 8) & 0xff, (h1 >>> 0) & 0xff,\n            (h2 >>> 24) & 0xff, (h2 >>> 16) & 0xff, (h2 >>> 8) & 0xff, (h2 >>> 0) & 0xff,\n            (h3 >>> 24) & 0xff, (h3 >>> 16) & 0xff, (h3 >>> 8) & 0xff, (h3 >>> 0) & 0xff,\n            (h4 >>> 24) & 0xff, (h4 >>> 16) & 0xff, (h4 >>> 8) & 0xff, (h4 >>> 0) & 0xff,\n            (h5 >>> 24) & 0xff, (h5 >>> 16) & 0xff, (h5 >>> 8) & 0xff, (h5 >>> 0) & 0xff,\n            (h6 >>> 24) & 0xff, (h6 >>> 16) & 0xff, (h6 >>> 8) & 0xff, (h6 >>> 0) & 0xff,\n            (h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, (h7 >>> 0) & 0xff\n        ];\n    }\n\n    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {\n        // compress password if it's longer than hash block length\n        password = (password.length <= 64) ? password : SHA256(password);\n\n        const innerLen = 64 + salt.length + 4;\n        const inner = new Array(innerLen);\n        const outerKey = new Array(64);\n\n        let i;\n        let dk = [];\n\n        // inner = (password ^ ipad) || salt || counter\n        for (i = 0; i < 64; i++) { inner[i] = 0x36; }\n        for (i = 0; i < password.length; i++) { inner[i] ^= password[i]; }\n        for (i = 0; i < salt.length; i++) { inner[64 + i] = salt[i]; }\n        for (i = innerLen - 4; i < innerLen; i++) { inner[i] = 0; }\n\n        // outerKey = password ^ opad\n        for (i = 0; i < 64; i++) outerKey[i] = 0x5c;\n        for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];\n\n        // increments counter inside inner\n        function incrementCounter() {\n            for (let i = innerLen - 1; i >= innerLen - 4; i--) {\n                inner[i]++;\n                if (inner[i] <= 0xff) return;\n                inner[i] = 0;\n            }\n        }\n\n        // output blocks = SHA256(outerKey || SHA256(inner)) ...\n        while (dkLen >= 32) {\n            incrementCounter();\n            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));\n            dkLen -= 32;\n        }\n        if (dkLen > 0) {\n            incrementCounter();\n            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));\n        }\n\n        return dk;\n    }\n\n    // The following is an adaptation of scryptsy\n    // See: https://www.npmjs.com/package/scryptsy\n    function blockmix_salsa8(BY, Yi, r, x, _X) {\n        let i;\n\n        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);\n        for (i = 0; i < 2 * r; i++) {\n            blockxor(BY, i * 16, _X, 16);\n            salsa20_8(_X, x);\n            arraycopy(_X, 0, BY, Yi + (i * 16), 16);\n        }\n\n        for (i = 0; i < r; i++) {\n            arraycopy(BY, Yi + (i * 2) * 16, BY, (i * 16), 16);\n        }\n\n        for (i = 0; i < r; i++) {\n            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);\n        }\n    }\n\n    function R(a, b) {\n        return (a << b) | (a >>> (32 - b));\n    }\n\n    function salsa20_8(B, x) {\n        arraycopy(B, 0, x, 0, 16);\n\n        for (let i = 8; i > 0; i -= 2) {\n            x[ 4] ^= R(x[ 0] + x[12], 7);\n            x[ 8] ^= R(x[ 4] + x[ 0], 9);\n            x[12] ^= R(x[ 8] + x[ 4], 13);\n            x[ 0] ^= R(x[12] + x[ 8], 18);\n            x[ 9] ^= R(x[ 5] + x[ 1], 7);\n            x[13] ^= R(x[ 9] + x[ 5], 9);\n            x[ 1] ^= R(x[13] + x[ 9], 13);\n            x[ 5] ^= R(x[ 1] + x[13], 18);\n            x[14] ^= R(x[10] + x[ 6], 7);\n            x[ 2] ^= R(x[14] + x[10], 9);\n            x[ 6] ^= R(x[ 2] + x[14], 13);\n            x[10] ^= R(x[ 6] + x[ 2], 18);\n            x[ 3] ^= R(x[15] + x[11], 7);\n            x[ 7] ^= R(x[ 3] + x[15], 9);\n            x[11] ^= R(x[ 7] + x[ 3], 13);\n            x[15] ^= R(x[11] + x[ 7], 18);\n            x[ 1] ^= R(x[ 0] + x[ 3], 7);\n            x[ 2] ^= R(x[ 1] + x[ 0], 9);\n            x[ 3] ^= R(x[ 2] + x[ 1], 13);\n            x[ 0] ^= R(x[ 3] + x[ 2], 18);\n            x[ 6] ^= R(x[ 5] + x[ 4], 7);\n            x[ 7] ^= R(x[ 6] + x[ 5], 9);\n            x[ 4] ^= R(x[ 7] + x[ 6], 13);\n            x[ 5] ^= R(x[ 4] + x[ 7], 18);\n            x[11] ^= R(x[10] + x[ 9], 7);\n            x[ 8] ^= R(x[11] + x[10], 9);\n            x[ 9] ^= R(x[ 8] + x[11], 13);\n            x[10] ^= R(x[ 9] + x[ 8], 18);\n            x[12] ^= R(x[15] + x[14], 7);\n            x[13] ^= R(x[12] + x[15], 9);\n            x[14] ^= R(x[13] + x[12], 13);\n            x[15] ^= R(x[14] + x[13], 18);\n        }\n\n        for (let i = 0; i < 16; ++i) {\n            B[i] += x[i];\n        }\n    }\n\n    // naive approach... going back to loop unrolling may yield additional performance\n    function blockxor(S, Si, D, len) {\n        for (let i = 0; i < len; i++) {\n            D[i] ^= S[Si + i]\n        }\n    }\n\n    function arraycopy(src, srcPos, dest, destPos, length) {\n        while (length--) {\n            dest[destPos++] = src[srcPos++];\n        }\n    }\n\n    function checkBufferish(o) {\n        if (!o || typeof(o.length) !== 'number') { return false; }\n\n        for (let i = 0; i < o.length; i++) {\n            const v = o[i];\n            if (typeof(v) !== 'number' || v % 1 || v < 0 || v >= 256) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function ensureInteger(value, name) {\n        if (typeof(value) !== \"number\" || (value % 1)) { throw new Error('invalid ' + name); }\n        return value;\n    }\n\n    // N = Cpu cost, r = Memory cost, p = parallelization cost\n    // callback(error, progress, key)\n    function _scrypt(password, salt, N, r, p, dkLen, callback) {\n\n        N = ensureInteger(N, 'N');\n        r = ensureInteger(r, 'r');\n        p = ensureInteger(p, 'p');\n\n        dkLen = ensureInteger(dkLen, 'dkLen');\n\n        if (N === 0 || (N & (N - 1)) !== 0) { throw new Error('N must be power of 2'); }\n\n        if (N > MAX_VALUE / 128 / r) { throw new Error('N too large'); }\n        if (r > MAX_VALUE / 128 / p) { throw new Error('r too large'); }\n\n        if (!checkBufferish(password)) {\n            throw new Error('password must be an array or buffer');\n        }\n        password = Array.prototype.slice.call(password);\n\n        if (!checkBufferish(salt)) {\n            throw new Error('salt must be an array or buffer');\n        }\n        salt = Array.prototype.slice.call(salt);\n\n        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);\n        const B = new Uint32Array(p * 32 * r)\n        for (let i = 0; i < B.length; i++) {\n            const j = i * 4;\n            B[i] = ((b[j + 3] & 0xff) << 24) |\n                   ((b[j + 2] & 0xff) << 16) |\n                   ((b[j + 1] & 0xff) << 8) |\n                   ((b[j + 0] & 0xff) << 0);\n        }\n\n        const XY = new Uint32Array(64 * r);\n        const V = new Uint32Array(32 * r * N);\n\n        const Yi = 32 * r;\n\n        // scratch space\n        const x = new Uint32Array(16);       // salsa20_8\n        const _X = new Uint32Array(16);      // blockmix_salsa8\n\n        const totalOps = p * N * 2;\n        let currentOp = 0;\n        let lastPercent10 = null;\n\n        // Set this to true to abandon the scrypt on the next step\n        let stop = false;\n\n        // State information\n        let state = 0;\n        let i0 = 0, i1;\n        let Bi;\n\n        // How many blockmix_salsa8 can we do per step?\n        const limit = callback ? parseInt(1000 / r): 0xffffffff;\n\n        // Trick from scrypt-async; if there is a setImmediate shim in place, use it\n        const nextTick = (typeof(setImmediate) !== 'undefined') ? setImmediate : setTimeout;\n\n        // This is really all I changed; making scryptsy a state machine so we occasionally\n        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo\n        const incrementalSMix = function() {\n            if (stop) {\n                return callback(new Error('cancelled'), currentOp / totalOps);\n            }\n\n            let steps;\n\n            switch (state) {\n                case 0:\n                    // for (var i = 0; i < p; i++)...\n                    Bi = i0 * 32 * r;\n\n                    arraycopy(B, Bi, XY, 0, Yi);                       // ROMix - 1\n\n                    state = 1;                                         // Move to ROMix 2\n                    i1 = 0;\n\n                    // Fall through\n\n                case 1:\n\n                    // Run up to 1000 steps of the first inner smix loop\n                    steps = N - i1;\n                    if (steps > limit) { steps = limit; }\n                    for (let i = 0; i < steps; i++) {                  // ROMix - 2\n                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi)         // ROMix - 3\n                        blockmix_salsa8(XY, Yi, r, x, _X);             // ROMix - 4\n                    }\n\n                    // for (var i = 0; i < N; i++)\n                    i1 += steps;\n                    currentOp += steps;\n\n                    if (callback) {\n                        // Call the callback with the progress (optionally stopping us)\n                        const percent10 = parseInt(1000 * currentOp / totalOps);\n                        if (percent10 !== lastPercent10) {\n                            stop = callback(null, currentOp / totalOps);\n                            if (stop) { break; }\n                            lastPercent10 = percent10;\n                        }\n                    }\n\n                    if (i1 < N) { break; }\n\n                    i1 = 0;                                          // Move to ROMix 6\n                    state = 2;\n\n                    // Fall through\n\n                case 2:\n\n                    // Run up to 1000 steps of the second inner smix loop\n                    steps = N - i1;\n                    if (steps > limit) { steps = limit; }\n                    for (let i = 0; i < steps; i++) {                // ROMix - 6\n                        const offset = (2 * r - 1) * 16;             // ROMix - 7\n                        const j = XY[offset] & (N - 1);\n                        blockxor(V, j * Yi, XY, Yi);                 // ROMix - 8 (inner)\n                        blockmix_salsa8(XY, Yi, r, x, _X);           // ROMix - 9 (outer)\n                    }\n\n                    // for (var i = 0; i < N; i++)...\n                    i1 += steps;\n                    currentOp += steps;\n\n                    // Call the callback with the progress (optionally stopping us)\n                    if (callback) {\n                        const percent10 = parseInt(1000 * currentOp / totalOps);\n                        if (percent10 !== lastPercent10) {\n                            stop = callback(null, currentOp / totalOps);\n                            if (stop) { break; }\n                            lastPercent10 = percent10;\n                        }\n                    }\n\n                    if (i1 < N) { break; }\n\n                    arraycopy(XY, 0, B, Bi, Yi);                     // ROMix - 10\n\n                    // for (var i = 0; i < p; i++)...\n                    i0++;\n                    if (i0 < p) {\n                        state = 0;\n                        break;\n                    }\n\n                    b = [];\n                    for (let i = 0; i < B.length; i++) {\n                        b.push((B[i] >>  0) & 0xff);\n                        b.push((B[i] >>  8) & 0xff);\n                        b.push((B[i] >> 16) & 0xff);\n                        b.push((B[i] >> 24) & 0xff);\n                    }\n\n                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);\n\n                    // Send the result to the callback\n                    if (callback) { callback(null, 1.0, derivedKey); }\n\n                    // Done; don't break (which would reschedule)\n                    return derivedKey;\n            }\n\n            // Schedule the next steps\n            if (callback) { nextTick(incrementalSMix); }\n        }\n\n        // Run the smix state machine until completion\n        if (!callback) {\n            while (true) {\n                const derivedKey = incrementalSMix();\n                if (derivedKey != undefined) { return derivedKey; }\n            }\n        }\n\n        // Bootstrap the async incremental smix\n        incrementalSMix();\n    }\n\n    const lib = {\n        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {\n            return new Promise(function(resolve, reject) {\n                let lastProgress = 0;\n                if (progressCallback) { progressCallback(0); }\n                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {\n                    if (error) {\n                        reject(error);\n                    } else if (key) {\n                        if (progressCallback && lastProgress !== 1) {\n                            progressCallback(1);\n                        }\n                        resolve(new Uint8Array(key));\n                    } else if (progressCallback && progress !== lastProgress) {\n                        lastProgress = progress;\n                        return progressCallback(progress);\n                    }\n                });\n            });\n        },\n        syncScrypt: function(password, salt, N, r, p, dkLen) {\n            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));\n        }\n    };\n\n    // node.js\n    if (typeof(exports) !== 'undefined') {\n       module.exports = lib;\n\n    // RequireJS/AMD\n    // http://www.requirejs.org/docs/api.html\n    // https://github.com/amdjs/amdjs-api/wiki/AMD\n    } else if (typeof(define) === 'function' && define.amd) {\n        define(lib);\n\n    // Web Browsers\n    } else if (root) {\n\n        // If there was an existing library \"scrypt\", make sure it is still available\n        if (root.scrypt) {\n            root._scrypt = root.scrypt;\n        }\n\n        root.scrypt = lib;\n    }\n\n})(this);\n"],"mappings":"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AC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;MAC7BA,CAAC,CAAC,EAAE,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAC,EAAE,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAC,EAAE,CAAC,GAAGA,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;MAC7BA,CAAC,CAAC,EAAE,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC;MAC7BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAC,EAAE,CAAC,GAAGA,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAC,EAAE,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC;MAC7BA,CAAC,CAAC,EAAE,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAC,EAAE,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC;MAC7BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC;MAC7BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC;MAC7BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC;MAC7BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC;MAC7BA,CAAC,CAAC,EAAE,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAC,EAAE,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAC,EAAE,CAAC,GAAGA,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAE,CAAC,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;MAC7BA,CAAC,CAAC,EAAE,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAE,CAAC,CAAC,GAAGA,CAAC,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC;MAC7BA,CAAC,CAAC,EAAE,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAC,EAAE,CAAC,GAAGA,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAC,EAAE,CAAC,IAAIK,CAAC,CAACL,CAAC,CAAC,EAAE,CAAC,GAAGA,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC5BA,CAAC,CAAC,EAA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}