{"ast":null,"code":"/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { isScheduler } from '../util/isScheduler';\nexport function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n  var resultSelector;\n  var initialState;\n  if (arguments.length == 1) {\n    var options = initialStateOrOptions;\n    initialState = options.initialState;\n    condition = options.condition;\n    iterate = options.iterate;\n    resultSelector = options.resultSelector || identity;\n    scheduler = options.scheduler;\n  } else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n    initialState = initialStateOrOptions;\n    resultSelector = identity;\n    scheduler = resultSelectorOrObservable;\n  } else {\n    initialState = initialStateOrOptions;\n    resultSelector = resultSelectorOrObservable;\n  }\n  return new Observable(function (subscriber) {\n    var state = initialState;\n    if (scheduler) {\n      return scheduler.schedule(dispatch, 0, {\n        subscriber: subscriber,\n        iterate: iterate,\n        condition: condition,\n        resultSelector: resultSelector,\n        state: state\n      });\n    }\n    do {\n      if (condition) {\n        var conditionResult = void 0;\n        try {\n          conditionResult = condition(state);\n        } catch (err) {\n          subscriber.error(err);\n          return undefined;\n        }\n        if (!conditionResult) {\n          subscriber.complete();\n          break;\n        }\n      }\n      var value = void 0;\n      try {\n        value = resultSelector(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n      subscriber.next(value);\n      if (subscriber.closed) {\n        break;\n      }\n      try {\n        state = iterate(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n    } while (true);\n    return undefined;\n  });\n}\nfunction dispatch(state) {\n  var subscriber = state.subscriber,\n    condition = state.condition;\n  if (subscriber.closed) {\n    return undefined;\n  }\n  if (state.needIterate) {\n    try {\n      state.state = state.iterate(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n  } else {\n    state.needIterate = true;\n  }\n  if (condition) {\n    var conditionResult = void 0;\n    try {\n      conditionResult = condition(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n    if (!conditionResult) {\n      subscriber.complete();\n      return undefined;\n    }\n    if (subscriber.closed) {\n      return undefined;\n    }\n  }\n  var value;\n  try {\n    value = state.resultSelector(state.state);\n  } catch (err) {\n    subscriber.error(err);\n    return undefined;\n  }\n  if (subscriber.closed) {\n    return undefined;\n  }\n  subscriber.next(value);\n  if (subscriber.closed) {\n    return undefined;\n  }\n  return this.schedule(state);\n}","map":{"version":3,"names":["Observable","identity","isScheduler","generate","initialStateOrOptions","condition","iterate","resultSelectorOrObservable","scheduler","resultSelector","initialState","arguments","length","options","undefined","subscriber","state","schedule","dispatch","conditionResult","err","error","complete","value","next","closed","needIterate"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/radixdlt/node_modules/rxjs/src/internal/observable/generate.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { identity } from '../util/identity';\nimport { SchedulerAction, SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\n\nexport type ConditionFunc<S> = (state: S) => boolean;\nexport type IterateFunc<S> = (state: S) => S;\nexport type ResultFunc<S, T> = (state: S) => T;\n\ninterface SchedulerState<T, S> {\n  needIterate?: boolean;\n  state: S;\n  subscriber: Subscriber<T>;\n  condition?: ConditionFunc<S>;\n  iterate: IterateFunc<S>;\n  resultSelector: ResultFunc<S, T>;\n}\n\nexport interface GenerateBaseOptions<S> {\n  /**\n   * Initial state.\n   */\n  initialState: S;\n  /**\n   * Condition function that accepts state and returns boolean.\n   * When it returns false, the generator stops.\n   * If not specified, a generator never stops.\n   */\n  condition?: ConditionFunc<S>;\n  /**\n   * Iterate function that accepts state and returns new state.\n   */\n  iterate: IterateFunc<S>;\n  /**\n   * SchedulerLike to use for generation process.\n   * By default, a generator starts immediately.\n   */\n  scheduler?: SchedulerLike;\n}\n\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\n  /**\n   * Result selection function that accepts state and returns a value to emit.\n   */\n  resultSelector: ResultFunc<S, T>;\n}\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate(0, x => x < 10, x => x + 1, x => x);\n *\n * @example <caption>Using asap scheduler, produces sequence of 2, 3, 5, then completes.</caption>\n * const res = generate(1, x => x < 5, x => x * 2, x => x + 1, asap);\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence. (deprecated)\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} on which to run the generator loop. If not provided, defaults to emit immediately.\n * @returns {Observable<T>} The generated sequence.\n */\n  export function generate<T, S>(initialState: S,\n                                 condition: ConditionFunc<S>,\n                                 iterate: IterateFunc<S>,\n                                 resultSelector: ResultFunc<S, T>,\n                                 scheduler?: SchedulerLike): Observable<T>;\n\n/**\n * Generates an Observable by running a state-driven loop\n * that emits an element on each iteration.\n *\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\n *\n * <img src=\"./img/generate.png\" width=\"100%\">\n *\n * `generate` allows you to create stream of values generated with a loop very similar to\n * traditional for loop. First argument of `generate` is a beginning value. Second argument\n * is a function that accepts this value and tests if some condition still holds. If it does,\n * loop continues, if not, it stops. Third value is a function which takes previously defined\n * value and modifies it in some way on each iteration. Note how these three parameters\n * are direct equivalents of three expressions in regular for loop: first expression\n * initializes some state (for example numeric index), second tests if loop can make next\n * iteration (for example if index is lower than 10) and third states how defined value\n * will be modified on every step (index will be incremented by one).\n *\n * Return value of a `generate` operator is an Observable that on each loop iteration\n * emits a value. First, condition function is ran. If it returned true, Observable\n * emits currently stored value (initial value at the first iteration) and then updates\n * that value with iterate function. If at some point condition returned false, Observable\n * completes at that moment.\n *\n * Optionally you can pass fourth parameter to `generate` - a result selector function which allows you\n * to immediately map value that would normally be emitted by an Observable.\n *\n * If you find three anonymous functions in `generate` call hard to read, you can provide\n * single object to the operator instead. That object has properties: `initialState`,\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\n * condition always holds, so output Observable will never complete.\n *\n * Both forms of `generate` can optionally accept a scheduler. In case of multi-parameter call,\n * scheduler simply comes as a last argument (no matter if there is resultSelector\n * function or not). In case of single-parameter call, you can provide it as a\n * `scheduler` property on object passed to the operator. In both cases scheduler decides when\n * next iteration of the loop will happen and therefore when next value will be emitted\n * by the Observable. For example to ensure that each value is pushed to the observer\n * on separate task in event loop, you could use `async` scheduler. Note that\n * by default (when no scheduler is passed) values are simply emitted synchronously.\n *\n *\n * @example <caption>Use with condition and iterate functions.</caption>\n * const generated = generate(0, x => x < 3, x => x + 1);\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // \"Yo!\"\n *\n *\n * @example <caption>Use with condition, iterate and resultSelector functions.</caption>\n * const generated = generate(0, x => x < 3, x => x + 1, x => x * 1000);\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // \"Yo!\"\n *\n *\n * @example <caption>Use with options object.</caption>\n * const generated = generate({\n *   initialState: 0,\n *   condition(value) { return value < 3; },\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // \"Yo!\"\n *\n * @example <caption>Use options object without condition function.</caption>\n * const generated = generate({\n *   initialState: 0,\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!') // This will never run.\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 3000\n * // ...and never stops.\n *\n *\n * @see {@link from}\n * @see {@link index/Observable.create}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence.\n * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emitting immediately.\n * @return {Observable<T>} The generated sequence.\n */\nexport function generate<S>(initialState: S,\n                            condition: ConditionFunc<S>,\n                            iterate: IterateFunc<S>,\n                            scheduler?: SchedulerLike): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition and scheduler.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate({\n *   initialState: 0,\n *   condition: x => x < 10,\n *   iterate: x => x + 1,\n * });\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.\n * @returns {Observable<S>} The generated sequence.\n */\nexport function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition, result selector and scheduler.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate({\n *   initialState: 0,\n *   condition: x => x < 10,\n *   iterate: x => x + 1,\n *   resultSelector: x => x,\n * });\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\n * @returns {Observable<T>} The generated sequence.\n */\nexport function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\n\nexport function generate<T, S>(initialStateOrOptions: S | GenerateOptions<T, S>,\n                               condition?: ConditionFunc<S>,\n                               iterate?: IterateFunc<S>,\n                               resultSelectorOrObservable?: (ResultFunc<S, T>) | SchedulerLike,\n                               scheduler?: SchedulerLike): Observable<T> {\n\n  let resultSelector: ResultFunc<S, T>;\n  let initialState: S;\n\n  if (arguments.length == 1) {\n    const options = initialStateOrOptions as GenerateOptions<T, S>;\n    initialState = options.initialState;\n    condition = options.condition;\n    iterate = options.iterate;\n    resultSelector = options.resultSelector || identity as ResultFunc<S, T>;\n    scheduler = options.scheduler;\n  } else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n    initialState = initialStateOrOptions as S;\n    resultSelector = identity as ResultFunc<S, T>;\n    scheduler = resultSelectorOrObservable as SchedulerLike;\n  } else {\n    initialState = initialStateOrOptions as S;\n    resultSelector = resultSelectorOrObservable as ResultFunc<S, T>;\n  }\n\n  return new Observable<T>(subscriber => {\n    let state = initialState;\n    if (scheduler) {\n      return scheduler.schedule<SchedulerState<T, S>>(dispatch, 0, {\n        subscriber,\n        iterate,\n        condition,\n        resultSelector,\n        state\n      });\n    }\n\n    do {\n      if (condition) {\n        let conditionResult: boolean;\n        try {\n          conditionResult = condition(state);\n        } catch (err) {\n          subscriber.error(err);\n          return undefined;\n        }\n        if (!conditionResult) {\n          subscriber.complete();\n          break;\n        }\n      }\n      let value: T;\n      try {\n        value = resultSelector(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n      subscriber.next(value);\n      if (subscriber.closed) {\n        break;\n      }\n      try {\n        state = iterate(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n    } while (true);\n\n    return undefined;\n  });\n}\n\nfunction dispatch<T, S>(this: SchedulerAction<SchedulerState<T, S>>, state: SchedulerState<T, S>) {\n  const { subscriber, condition } = state;\n  if (subscriber.closed) {\n    return undefined;\n  }\n  if (state.needIterate) {\n    try {\n      state.state = state.iterate(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n  } else {\n    state.needIterate = true;\n  }\n  if (condition) {\n    let conditionResult: boolean;\n    try {\n      conditionResult = condition(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n    if (!conditionResult) {\n      subscriber.complete();\n      return undefined;\n    }\n    if (subscriber.closed) {\n      return undefined;\n    }\n  }\n  let value: T;\n  try {\n    value = state.resultSelector(state.state);\n  } catch (err) {\n    subscriber.error(err);\n    return undefined;\n  }\n  if (subscriber.closed) {\n    return undefined;\n  }\n  subscriber.next(value);\n  if (subscriber.closed) {\n    return undefined;\n  }\n  return this.schedule(state);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}