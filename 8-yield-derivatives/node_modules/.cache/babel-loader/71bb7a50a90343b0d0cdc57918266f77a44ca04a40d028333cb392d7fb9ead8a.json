{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Account = exports.isAccount = void 0;\nconst account_1 = require(\"@radixdlt/account\");\nconst isAccount = something => {\n  const inspection = something;\n  return inspection.signingKey !== undefined && (0, account_1.isSigningKey)(inspection.signingKey) && inspection.address !== undefined && (0, account_1.isAccountAddress)(inspection.address);\n};\nexports.isAccount = isAccount;\nconst create = input => {\n  const {\n    signingKey,\n    address\n  } = input;\n  if (!signingKey.publicKey.equals(address.publicKey)) {\n    const errMsg = \"Incorrect implementation, publicKey of address does not match publicKey of signingKey.\";\n    console.error(errMsg);\n    throw new Error(errMsg);\n  }\n  const network = address.network;\n  const publicKey = signingKey.publicKey;\n  const hdPath = signingKey.hdPath;\n  return Object.assign(Object.assign({}, signingKey), {\n    equals: other => other.publicKey.equals(publicKey),\n    signingKey: signingKey,\n    type: signingKey.type,\n    address,\n    network,\n    publicKey,\n    hdPath\n  });\n};\nexports.Account = {\n  create\n};","map":{"version":3,"names":["account_1","require","isAccount","something","inspection","signingKey","undefined","isSigningKey","address","isAccountAddress","exports","create","input","publicKey","equals","errMsg","console","error","Error","network","hdPath","Object","assign","other","type","Account"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/application/src/account.ts"],"sourcesContent":["import {\n\tSigningKeyT,\n\tAccountAddressT,\n\tisSigningKey,\n\tisAccountAddress,\n} from '@radixdlt/account'\nimport { AccountT } from './_types'\n\nexport const isAccount = (something: unknown): something is AccountT => {\n\tconst inspection = something as AccountT\n\treturn (\n\t\tinspection.signingKey !== undefined &&\n\t\tisSigningKey(inspection.signingKey) &&\n\t\tinspection.address !== undefined &&\n\t\tisAccountAddress(inspection.address)\n\t)\n}\n\nconst create = (\n\tinput: Readonly<{\n\t\taddress: AccountAddressT\n\t\tsigningKey: SigningKeyT\n\t}>,\n): AccountT => {\n\tconst { signingKey, address } = input\n\tif (!signingKey.publicKey.equals(address.publicKey)) {\n\t\tconst errMsg = `Incorrect implementation, publicKey of address does not match publicKey of signingKey.`\n\t\tconsole.error(errMsg)\n\t\tthrow new Error(errMsg)\n\t}\n\tconst network = address.network\n\tconst publicKey = signingKey.publicKey\n\tconst hdPath = signingKey.hdPath\n\treturn {\n\t\t...signingKey, // encrypt, decrypt, sign\n\t\tequals: (other: AccountT): boolean => other.publicKey.equals(publicKey),\n\t\tsigningKey: signingKey,\n\t\ttype: signingKey.type,\n\t\taddress,\n\t\tnetwork,\n\t\tpublicKey,\n\t\thdPath,\n\t}\n}\n\nexport const Account = {\n\tcreate,\n}\n"],"mappings":";;;;;;AAAA,MAAAA,SAAA,GAAAC,OAAA;AAQO,MAAMC,SAAS,GAAIC,SAAkB,IAA2B;EACtE,MAAMC,UAAU,GAAGD,SAAqB;EACxC,OACCC,UAAU,CAACC,UAAU,KAAKC,SAAS,IACnC,IAAAN,SAAA,CAAAO,YAAY,EAACH,UAAU,CAACC,UAAU,CAAC,IACnCD,UAAU,CAACI,OAAO,KAAKF,SAAS,IAChC,IAAAN,SAAA,CAAAS,gBAAgB,EAACL,UAAU,CAACI,OAAO,CAAC;AAEtC,CAAC;AARYE,OAAA,CAAAR,SAAS,GAAAA,SAAA;AAUtB,MAAMS,MAAM,GACXC,KAGE,IACW;EACb,MAAM;IAAEP,UAAU;IAAEG;EAAO,CAAE,GAAGI,KAAK;EACrC,IAAI,CAACP,UAAU,CAACQ,SAAS,CAACC,MAAM,CAACN,OAAO,CAACK,SAAS,CAAC,EAAE;IACpD,MAAME,MAAM,2FAA2F;IACvGC,OAAO,CAACC,KAAK,CAACF,MAAM,CAAC;IACrB,MAAM,IAAIG,KAAK,CAACH,MAAM,CAAC;;EAExB,MAAMI,OAAO,GAAGX,OAAO,CAACW,OAAO;EAC/B,MAAMN,SAAS,GAAGR,UAAU,CAACQ,SAAS;EACtC,MAAMO,MAAM,GAAGf,UAAU,CAACe,MAAM;EAChC,OAAAC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACIjB,UAAU;IACbS,MAAM,EAAGS,KAAe,IAAcA,KAAK,CAACV,SAAS,CAACC,MAAM,CAACD,SAAS,CAAC;IACvER,UAAU,EAAEA,UAAU;IACtBmB,IAAI,EAAEnB,UAAU,CAACmB,IAAI;IACrBhB,OAAO;IACPW,OAAO;IACPN,SAAS;IACTO;EAAM;AAER,CAAC;AAEYV,OAAA,CAAAe,OAAO,GAAG;EACtBd;CACA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}