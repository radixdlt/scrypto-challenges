{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractAssistantStreamRunner_connectedPromise, _AbstractAssistantStreamRunner_resolveConnectedPromise, _AbstractAssistantStreamRunner_rejectConnectedPromise, _AbstractAssistantStreamRunner_endPromise, _AbstractAssistantStreamRunner_resolveEndPromise, _AbstractAssistantStreamRunner_rejectEndPromise, _AbstractAssistantStreamRunner_listeners, _AbstractAssistantStreamRunner_ended, _AbstractAssistantStreamRunner_errored, _AbstractAssistantStreamRunner_aborted, _AbstractAssistantStreamRunner_catchingPromiseCreated, _AbstractAssistantStreamRunner_handleError;\nimport { APIUserAbortError, OpenAIError } from 'openai/error';\nexport class AbstractAssistantStreamRunner {\n  constructor() {\n    this.controller = new AbortController();\n    _AbstractAssistantStreamRunner_connectedPromise.set(this, void 0);\n    _AbstractAssistantStreamRunner_resolveConnectedPromise.set(this, () => {});\n    _AbstractAssistantStreamRunner_rejectConnectedPromise.set(this, () => {});\n    _AbstractAssistantStreamRunner_endPromise.set(this, void 0);\n    _AbstractAssistantStreamRunner_resolveEndPromise.set(this, () => {});\n    _AbstractAssistantStreamRunner_rejectEndPromise.set(this, () => {});\n    _AbstractAssistantStreamRunner_listeners.set(this, {});\n    _AbstractAssistantStreamRunner_ended.set(this, false);\n    _AbstractAssistantStreamRunner_errored.set(this, false);\n    _AbstractAssistantStreamRunner_aborted.set(this, false);\n    _AbstractAssistantStreamRunner_catchingPromiseCreated.set(this, false);\n    _AbstractAssistantStreamRunner_handleError.set(this, error => {\n      __classPrivateFieldSet(this, _AbstractAssistantStreamRunner_errored, true, \"f\");\n      if (error instanceof Error && error.name === 'AbortError') {\n        error = new APIUserAbortError();\n      }\n      if (error instanceof APIUserAbortError) {\n        __classPrivateFieldSet(this, _AbstractAssistantStreamRunner_aborted, true, \"f\");\n        return this._emit('abort', error);\n      }\n      if (error instanceof OpenAIError) {\n        return this._emit('error', error);\n      }\n      if (error instanceof Error) {\n        const openAIError = new OpenAIError(error.message);\n        // @ts-ignore\n        openAIError.cause = error;\n        return this._emit('error', openAIError);\n      }\n      return this._emit('error', new OpenAIError(String(error)));\n    });\n    __classPrivateFieldSet(this, _AbstractAssistantStreamRunner_connectedPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _AbstractAssistantStreamRunner_resolveConnectedPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _AbstractAssistantStreamRunner_rejectConnectedPromise, reject, \"f\");\n    }), \"f\");\n    __classPrivateFieldSet(this, _AbstractAssistantStreamRunner_endPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _AbstractAssistantStreamRunner_resolveEndPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _AbstractAssistantStreamRunner_rejectEndPromise, reject, \"f\");\n    }), \"f\");\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_connectedPromise, \"f\").catch(() => {});\n    __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_endPromise, \"f\").catch(() => {});\n  }\n  _run(executor) {\n    // Unfortunately if we call `executor()` immediately we get runtime errors about\n    // references to `this` before the `super()` constructor call returns.\n    setTimeout(() => {\n      executor().then(() => {\n        // this._emitFinal();\n        this._emit('end');\n      }, __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_handleError, \"f\"));\n    }, 0);\n  }\n  _addRun(run) {\n    return run;\n  }\n  _connected() {\n    if (this.ended) return;\n    __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_resolveConnectedPromise, \"f\").call(this);\n    this._emit('connect');\n  }\n  get ended() {\n    return __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_ended, \"f\");\n  }\n  get errored() {\n    return __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_errored, \"f\");\n  }\n  get aborted() {\n    return __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_aborted, \"f\");\n  }\n  abort() {\n    this.controller.abort();\n  }\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  on(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _AbstractAssistantStreamRunner_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener\n    });\n    return this;\n  }\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  off(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_listeners, \"f\")[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex(l => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  once(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _AbstractAssistantStreamRunner_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener,\n      once: true\n    });\n    return this;\n  }\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted(event) {\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _AbstractAssistantStreamRunner_catchingPromiseCreated, true, \"f\");\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve);\n    });\n  }\n  async done() {\n    __classPrivateFieldSet(this, _AbstractAssistantStreamRunner_catchingPromiseCreated, true, \"f\");\n    await __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_endPromise, \"f\");\n  }\n  _emit(event, ...args) {\n    // make sure we don't emit any events after end\n    if (__classPrivateFieldGet(this, _AbstractAssistantStreamRunner_ended, \"f\")) {\n      return;\n    }\n    if (event === 'end') {\n      __classPrivateFieldSet(this, _AbstractAssistantStreamRunner_ended, true, \"f\");\n      __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_resolveEndPromise, \"f\").call(this);\n    }\n    const listeners = __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_listeners, \"f\")[event];\n    if (listeners) {\n      __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_listeners, \"f\")[event] = listeners.filter(l => !l.once);\n      listeners.forEach(({\n        listener\n      }) => listener(...args));\n    }\n    if (event === 'abort') {\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _AbstractAssistantStreamRunner_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n      return;\n    }\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _AbstractAssistantStreamRunner_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.finalChatCompletion()\n        // - etc.\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _AbstractAssistantStreamRunner_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n    }\n  }\n  async _threadAssistantStream(body, thread, options) {\n    return await this._createThreadAssistantStream(thread, body, options);\n  }\n  async _runAssistantStream(threadId, runs, params, options) {\n    return await this._createAssistantStream(runs, threadId, params, options);\n  }\n  async _runToolAssistantStream(threadId, runId, runs, params, options) {\n    return await this._createToolAssistantStream(runs, threadId, runId, params, options);\n  }\n  async _createThreadAssistantStream(thread, body, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    // this.#validateParams(params);\n    const runResult = await thread.createAndRun({\n      ...body,\n      stream: false\n    }, {\n      ...options,\n      signal: this.controller.signal\n    });\n    this._connected();\n    return this._addRun(runResult);\n  }\n  async _createToolAssistantStream(run, threadId, runId, params, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    const runResult = await run.submitToolOutputs(threadId, runId, {\n      ...params,\n      stream: false\n    }, {\n      ...options,\n      signal: this.controller.signal\n    });\n    this._connected();\n    return this._addRun(runResult);\n  }\n  async _createAssistantStream(run, threadId, params, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    // this.#validateParams(params);\n    const runResult = await run.create(threadId, {\n      ...params,\n      stream: false\n    }, {\n      ...options,\n      signal: this.controller.signal\n    });\n    this._connected();\n    return this._addRun(runResult);\n  }\n}\n_AbstractAssistantStreamRunner_connectedPromise = new WeakMap(), _AbstractAssistantStreamRunner_resolveConnectedPromise = new WeakMap(), _AbstractAssistantStreamRunner_rejectConnectedPromise = new WeakMap(), _AbstractAssistantStreamRunner_endPromise = new WeakMap(), _AbstractAssistantStreamRunner_resolveEndPromise = new WeakMap(), _AbstractAssistantStreamRunner_rejectEndPromise = new WeakMap(), _AbstractAssistantStreamRunner_listeners = new WeakMap(), _AbstractAssistantStreamRunner_ended = new WeakMap(), _AbstractAssistantStreamRunner_errored = new WeakMap(), _AbstractAssistantStreamRunner_aborted = new WeakMap(), _AbstractAssistantStreamRunner_catchingPromiseCreated = new WeakMap(), _AbstractAssistantStreamRunner_handleError = new WeakMap();","map":{"version":3,"names":["APIUserAbortError","OpenAIError","AbstractAssistantStreamRunner","constructor","controller","AbortController","_AbstractAssistantStreamRunner_connectedPromise","set","_AbstractAssistantStreamRunner_resolveConnectedPromise","_AbstractAssistantStreamRunner_rejectConnectedPromise","_AbstractAssistantStreamRunner_endPromise","_AbstractAssistantStreamRunner_resolveEndPromise","_AbstractAssistantStreamRunner_rejectEndPromise","_AbstractAssistantStreamRunner_listeners","_AbstractAssistantStreamRunner_ended","_AbstractAssistantStreamRunner_errored","_AbstractAssistantStreamRunner_aborted","_AbstractAssistantStreamRunner_catchingPromiseCreated","_AbstractAssistantStreamRunner_handleError","error","__classPrivateFieldSet","Error","name","_emit","openAIError","message","cause","String","Promise","resolve","reject","__classPrivateFieldGet","catch","_run","executor","setTimeout","then","_addRun","run","_connected","ended","call","errored","aborted","abort","on","event","listener","listeners","push","off","index","findIndex","l","splice","once","emitted","done","args","filter","forEach","length","_threadAssistantStream","body","thread","options","_createThreadAssistantStream","_runAssistantStream","threadId","runs","params","_createAssistantStream","_runToolAssistantStream","runId","_createToolAssistantStream","signal","addEventListener","runResult","createAndRun","stream","submitToolOutputs","create"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/openai/src/lib/AbstractAssistantStreamRunner.ts"],"sourcesContent":["import * as Core from \"../core\";\nimport { APIUserAbortError, OpenAIError } from \"../error\";\nimport { Run, RunSubmitToolOutputsParamsBase } from \"../resources/beta/threads/runs/runs\";\nimport { RunCreateParamsBase, Runs } from \"../resources/beta/threads/runs/runs\";\nimport { ThreadCreateAndRunParamsBase, Threads } from \"../resources/beta/threads/threads\";\n\nexport abstract class AbstractAssistantStreamRunner<\n  Events extends CustomEvents<any> = AbstractAssistantRunnerEvents,\n> {\n  controller: AbortController = new AbortController();\n\n  #connectedPromise: Promise<void>;\n  #resolveConnectedPromise: () => void = () => {};\n  #rejectConnectedPromise: (error: OpenAIError) => void = () => {};\n\n  #endPromise: Promise<void>;\n  #resolveEndPromise: () => void = () => {};\n  #rejectEndPromise: (error: OpenAIError) => void = () => {};\n\n  #listeners: { [Event in keyof Events]?: ListenersForEvent<Events, Event> } = {};\n\n  #ended = false;\n  #errored = false;\n  #aborted = false;\n  #catchingPromiseCreated = false;\n\n  constructor() {\n    this.#connectedPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveConnectedPromise = resolve;\n      this.#rejectConnectedPromise = reject;\n    });\n\n    this.#endPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveEndPromise = resolve;\n      this.#rejectEndPromise = reject;\n    });\n\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    this.#connectedPromise.catch(() => {});\n    this.#endPromise.catch(() => {});\n  }\n\n  protected _run(executor: () => Promise<any>) {\n    // Unfortunately if we call `executor()` immediately we get runtime errors about\n    // references to `this` before the `super()` constructor call returns.\n    setTimeout(() => {\n      executor().then(() => {\n        // this._emitFinal();\n        this._emit('end');\n      }, this.#handleError);\n    }, 0);\n  }\n\n  protected _addRun(run: Run): Run {\n    return run;\n  }\n\n  protected _connected() {\n    if (this.ended) return;\n    this.#resolveConnectedPromise();\n    this._emit('connect');\n  }\n\n  get ended(): boolean {\n    return this.#ended;\n  }\n\n  get errored(): boolean {\n    return this.#errored;\n  }\n\n  get aborted(): boolean {\n    return this.#aborted;\n  }\n\n  abort() {\n    this.controller.abort();\n  }\n\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  on<Event extends keyof Events>(event: Event, listener: ListenerForEvent<Events, Event>): this {\n    const listeners: ListenersForEvent<Events, Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener });\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  off<Event extends keyof Events>(event: Event, listener: ListenerForEvent<Events, Event>): this {\n    const listeners = this.#listeners[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex((l) => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  once<Event extends keyof Events>(event: Event, listener: ListenerForEvent<Events, Event>): this {\n    const listeners: ListenersForEvent<Events, Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener, once: true });\n    return this;\n  }\n\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted<Event extends keyof Events>(\n    event: Event,\n  ): Promise<\n    EventParameters<Events, Event> extends [infer Param] ? Param\n    : EventParameters<Events, Event> extends [] ? void\n    : EventParameters<Events, Event>\n  > {\n    return new Promise((resolve, reject) => {\n      this.#catchingPromiseCreated = true;\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve as any);\n    });\n  }\n\n  async done(): Promise<void> {\n    this.#catchingPromiseCreated = true;\n    await this.#endPromise;\n  }\n\n  #handleError = (error: unknown) => {\n    this.#errored = true;\n    if (error instanceof Error && error.name === 'AbortError') {\n      error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n      this.#aborted = true;\n      return this._emit('abort', error);\n    }\n    if (error instanceof OpenAIError) {\n      return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n      const openAIError: OpenAIError = new OpenAIError(error.message);\n      // @ts-ignore\n      openAIError.cause = error;\n      return this._emit('error', openAIError);\n    }\n    return this._emit('error', new OpenAIError(String(error)));\n  };\n\n  protected _emit<Event extends keyof Events>(event: Event, ...args: EventParameters<Events, Event>) {\n    // make sure we don't emit any events after end\n    if (this.#ended) {\n      return;\n    }\n\n    if (event === 'end') {\n      this.#ended = true;\n      this.#resolveEndPromise();\n    }\n\n    const listeners: ListenersForEvent<Events, Event> | undefined = this.#listeners[event];\n    if (listeners) {\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\n      listeners.forEach(({ listener }: any) => listener(...args));\n    }\n\n    if (event === 'abort') {\n      const error = args[0] as APIUserAbortError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n      return;\n    }\n\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n\n      const error = args[0] as OpenAIError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.finalChatCompletion()\n        // - etc.\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n    }\n  }\n\n  protected async _threadAssistantStream(\n    body: ThreadCreateAndRunParamsBase,\n    thread: Threads,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    return await this._createThreadAssistantStream(thread, body, options);\n  }\n\n  protected async _runAssistantStream(\n    threadId: string,\n    runs: Runs,\n    params: RunCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    return await this._createAssistantStream(runs, threadId, params, options);\n  }\n\n  protected async _runToolAssistantStream(\n    threadId: string,\n    runId: string,\n    runs: Runs,\n    params: RunSubmitToolOutputsParamsBase,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    return await this._createToolAssistantStream(runs, threadId, runId, params, options);\n  }\n\n  protected async _createThreadAssistantStream(\n    thread: Threads,\n    body: ThreadCreateAndRunParamsBase,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    // this.#validateParams(params);\n\n    const runResult = await thread.createAndRun(\n      { ...body, stream: false },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    return this._addRun(runResult as Run);\n  }\n\n  protected async _createToolAssistantStream(\n    run: Runs,\n    threadId: string,\n    runId: string,\n    params: RunSubmitToolOutputsParamsBase,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n\n    const runResult = await run.submitToolOutputs(\n      threadId,\n      runId,\n      { ...params, stream: false },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    return this._addRun(runResult as Run);\n  }\n\n  protected async _createAssistantStream(\n    run: Runs,\n    threadId: string,\n    params: RunCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    // this.#validateParams(params);\n\n    const runResult = await run.create(\n      threadId,\n      { ...params, stream: false },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    return this._addRun(runResult as Run);\n  }\n}\n\ntype CustomEvents<Event extends string> = {\n  [k in Event]: k extends keyof AbstractAssistantRunnerEvents ? AbstractAssistantRunnerEvents[k]\n  : (...args: any[]) => void;\n};\n\ntype ListenerForEvent<Events extends CustomEvents<any>, Event extends keyof Events> = Event extends (\n  keyof AbstractAssistantRunnerEvents\n) ?\n  AbstractAssistantRunnerEvents[Event]\n: Events[Event];\n\ntype ListenersForEvent<Events extends CustomEvents<any>, Event extends keyof Events> = Array<{\n  listener: ListenerForEvent<Events, Event>;\n  once?: boolean;\n}>;\ntype EventParameters<Events extends CustomEvents<any>, Event extends keyof Events> = Parameters<\n  ListenerForEvent<Events, Event>\n>;\n\nexport interface AbstractAssistantRunnerEvents {\n  connect: () => void;\n  run: (run: Run) => void;\n  error: (error: OpenAIError) => void;\n  abort: (error: APIUserAbortError) => void;\n  end: () => void;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}