{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PrivateKey = exports.fromHex = exports.fromBuffer = void 0;\nconst primitives_1 = require(\"@radixdlt/primitives\");\nconst uint256_1 = require(\"@radixdlt/uint256\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst util_1 = require(\"@radixdlt/util\");\nconst secp256k1_1 = require(\"./secp256k1\");\nconst hash_1 = require(\"../hash\");\nconst elliptic_1 = require(\"elliptic\");\nconst publicKey_1 = require(\"./publicKey\");\nconst signature_1 = require(\"./signature\");\nconst utils_1 = require(\"../utils\");\nconst __signDataWithPrivateKey = input => {\n  // log.info(`Signing ${input.data.toString()} with private key.`)\n  const thirdPartyLibEllipticSecp256k1 = new elliptic_1.ec('secp256k1');\n  const privateKey = thirdPartyLibEllipticSecp256k1.keyFromPrivate(input.privateKey.toString(16));\n  const ellipticSignature = privateKey.sign(input.data, {\n    canonical: true\n  });\n  return signature_1.Signature.fromIndutnyElliptic(ellipticSignature);\n};\nconst __privateKeyFromValidatedScalar = scalar => {\n  const sign = hashedMessage => {\n    if (hashedMessage.length !== 32) {\n      return (0, neverthrow_1.errAsync)(new Error('Incorrect length of message to sign, expected 32 bytes.'));\n    }\n    return (0, primitives_1.resultToAsync)(__signDataWithPrivateKey({\n      privateKey: scalar,\n      data: hashedMessage\n    }));\n  };\n  const diffieHellman = publicKeyOfOtherParty => (0, neverthrow_1.okAsync)(publicKeyOfOtherParty.decodeToPointOnCurve().multiplyWithPrivateKey(privateKey));\n  const privateKey = {\n    sign,\n    diffieHellman: diffieHellman,\n    signUnhashed: input => {\n      var _a;\n      const hasher = (_a = input.hasher) !== null && _a !== void 0 ? _a : hash_1.sha256Twice;\n      const hashedMessage = hasher(input.msgToHash);\n      return sign(hashedMessage);\n    },\n    publicKey: () => {\n      throw new Error('Overridden below.');\n    },\n    toString: () => (0, utils_1.toPrivateKeyHex)(scalar),\n    scalar: scalar\n  };\n  return Object.assign(Object.assign({}, privateKey), {\n    publicKey: () => publicKey_1.PublicKey.fromPrivateKey({\n      privateKey\n    })\n  });\n};\nconst fromBuffer = buffer => (0, exports.fromHex)(buffer.toString('hex'));\nexports.fromBuffer = fromBuffer;\nconst fromHex = privateKeyHexString => fromScalar(new uint256_1.UInt256(privateKeyHexString, 16));\nexports.fromHex = fromHex;\nconst fromScalar = scalar => {\n  if (!validateSecp256k1PrivateKey(scalar)) return (0, neverthrow_1.err)(new Error('Invalid private key scalar.'));\n  return (0, neverthrow_1.ok)(__privateKeyFromValidatedScalar(scalar));\n};\nconst validateSecp256k1PrivateKey = scalar => scalar.gte(uint256_1.UInt256.valueOf(1)) && scalar.lte(secp256k1_1.Secp256k1.order);\nconst generateNew = function () {\n  let secureRandom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : util_1.secureRandomGenerator;\n  // eslint-disable-next-line functional/no-let\n  let scalar = primitives_1.uint256Max;\n  // eslint-disable-next-line functional/no-loop-statement\n  while (!validateSecp256k1PrivateKey(scalar)) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call\n    scalar = (0, primitives_1.secureRandomUInt256)(secureRandom);\n  }\n  return __privateKeyFromValidatedScalar(scalar);\n};\nexports.PrivateKey = {\n  generateNew,\n  fromScalar,\n  fromHex: exports.fromHex,\n  fromBuffer: exports.fromBuffer\n};","map":{"version":3,"names":["primitives_1","require","uint256_1","neverthrow_1","util_1","secp256k1_1","hash_1","elliptic_1","publicKey_1","signature_1","utils_1","__signDataWithPrivateKey","input","thirdPartyLibEllipticSecp256k1","ec","privateKey","keyFromPrivate","toString","ellipticSignature","sign","data","canonical","Signature","fromIndutnyElliptic","__privateKeyFromValidatedScalar","scalar","hashedMessage","length","errAsync","Error","resultToAsync","diffieHellman","publicKeyOfOtherParty","okAsync","decodeToPointOnCurve","multiplyWithPrivateKey","signUnhashed","hasher","_a","sha256Twice","msgToHash","publicKey","toPrivateKeyHex","Object","assign","PublicKey","fromPrivateKey","fromBuffer","buffer","exports","fromHex","privateKeyHexString","fromScalar","UInt256","validateSecp256k1PrivateKey","err","ok","gte","valueOf","lte","Secp256k1","order","generateNew","secureRandom","arguments","undefined","secureRandomGenerator","uint256Max","secureRandomUInt256","PrivateKey"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/src/elliptic-curve/privateKey.ts"],"sourcesContent":["import {\n\tresultToAsync,\n\tsecureRandomUInt256,\n\tuint256Max,\n} from '@radixdlt/primitives'\n\nimport { UInt256 } from '@radixdlt/uint256'\n\nimport { err, errAsync, ok, okAsync, Result, ResultAsync } from 'neverthrow'\n\nimport { SecureRandom, secureRandomGenerator } from '@radixdlt/util'\nimport { Secp256k1 } from './secp256k1'\nimport { sha256Twice } from '../hash'\nimport { ec } from 'elliptic'\nimport { PublicKey } from './publicKey'\nimport {\n\tDiffieHellman,\n\tECPointOnCurveT,\n\tPrivateKeyT,\n\tPublicKeyT,\n\tSignatureT,\n} from './_types'\nimport { Hasher } from '../_types'\nimport { Signature } from './signature'\nimport { toPrivateKeyHex } from '../utils'\n\nconst __signDataWithPrivateKey = (\n\tinput: Readonly<{\n\t\tprivateKey: UInt256\n\t\tdata: Buffer\n\t}>,\n): Result<SignatureT, Error> => {\n\t// log.info(`Signing ${input.data.toString()} with private key.`)\n\tconst thirdPartyLibEllipticSecp256k1 = new ec('secp256k1')\n\n\tconst privateKey = thirdPartyLibEllipticSecp256k1.keyFromPrivate(\n\t\tinput.privateKey.toString(16),\n\t)\n\n\tconst ellipticSignature: ec.Signature = privateKey.sign(input.data, {\n\t\tcanonical: true,\n\t})\n\n\treturn Signature.fromIndutnyElliptic(ellipticSignature)\n}\n\nconst __privateKeyFromValidatedScalar = (scalar: UInt256): PrivateKeyT => {\n\tconst sign = (hashedMessage: Buffer): ResultAsync<SignatureT, Error> => {\n\t\tif (hashedMessage.length !== 32) {\n\t\t\treturn errAsync(\n\t\t\t\tnew Error(\n\t\t\t\t\t'Incorrect length of message to sign, expected 32 bytes.',\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\t\treturn resultToAsync(\n\t\t\t__signDataWithPrivateKey({\n\t\t\t\tprivateKey: scalar,\n\t\t\t\tdata: hashedMessage,\n\t\t\t}),\n\t\t)\n\t}\n\n\tconst diffieHellman: DiffieHellman = (\n\t\tpublicKeyOfOtherParty: PublicKeyT,\n\t): ResultAsync<ECPointOnCurveT, Error> =>\n\t\tokAsync(\n\t\t\tpublicKeyOfOtherParty\n\t\t\t\t.decodeToPointOnCurve()\n\t\t\t\t.multiplyWithPrivateKey(privateKey),\n\t\t)\n\n\tconst privateKey = {\n\t\tsign,\n\t\tdiffieHellman: diffieHellman,\n\t\tsignUnhashed: (\n\t\t\tinput: Readonly<{\n\t\t\t\tmsgToHash: Buffer | string\n\t\t\t\thasher?: Hasher\n\t\t\t}>,\n\t\t): ResultAsync<SignatureT, Error> => {\n\t\t\tconst hasher = input.hasher ?? sha256Twice\n\n\t\t\tconst hashedMessage = hasher(input.msgToHash)\n\n\t\t\treturn sign(hashedMessage)\n\t\t},\n\n\t\tpublicKey: () => {\n\t\t\tthrow new Error('Overridden below.')\n\t\t},\n\n\t\ttoString: () => toPrivateKeyHex(scalar),\n\t\tscalar: scalar,\n\t}\n\n\treturn {\n\t\t...privateKey,\n\t\tpublicKey: (): PublicKeyT => PublicKey.fromPrivateKey({ privateKey }),\n\t}\n}\n\nexport const fromBuffer = (buffer: Buffer): Result<PrivateKeyT, Error> =>\n\tfromHex(buffer.toString('hex'))\n\nexport const fromHex = (\n\tprivateKeyHexString: string,\n): Result<PrivateKeyT, Error> =>\n\tfromScalar(new UInt256(privateKeyHexString, 16))\n\nconst fromScalar = (scalar: UInt256): Result<PrivateKeyT, Error> => {\n\tif (!validateSecp256k1PrivateKey(scalar))\n\t\treturn err(new Error('Invalid private key scalar.'))\n\n\treturn ok(__privateKeyFromValidatedScalar(scalar))\n}\n\nconst validateSecp256k1PrivateKey = (scalar: UInt256): boolean =>\n\tscalar.gte(UInt256.valueOf(1)) && scalar.lte(Secp256k1.order)\n\nconst generateNew = (\n\tsecureRandom: SecureRandom = secureRandomGenerator,\n): PrivateKeyT => {\n\t// eslint-disable-next-line functional/no-let\n\tlet scalar: UInt256 = uint256Max\n\t// eslint-disable-next-line functional/no-loop-statement\n\twhile (!validateSecp256k1PrivateKey(scalar)) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call\n\t\tscalar = secureRandomUInt256(secureRandom)\n\t}\n\treturn __privateKeyFromValidatedScalar(scalar)\n}\n\nexport const PrivateKey = {\n\tgenerateNew,\n\tfromScalar,\n\tfromHex,\n\tfromBuffer,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}