{"ast":null,"code":"'use strict';\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream');\nconst Tagged = require('./tagged');\nconst Simple = require('./simple');\nconst utils = require('./utils');\nconst bignumber = require('bignumber.js').BigNumber;\nconst NoFilter = require('nofilter');\nconst constants = require('./constants');\n// Do not fix this if you want to support node v4\nconst MT = constants.MT;\nconst NUMBYTES = constants.NUMBYTES;\nconst SIMPLE = constants.SIMPLE;\nconst SYMS = constants.SYMS;\nconst NEG_ONE = new bignumber(-1);\nconst NEG_MAX = NEG_ONE.minus(new bignumber(Number.MAX_SAFE_INTEGER.toString(16), 16));\nconst COUNT = Symbol('count');\nconst PENDING_KEY = Symbol('pending_key');\nconst MAJOR = Symbol('major type');\nconst ERROR = Symbol('error');\nconst NOT_FOUND = Symbol('not found');\nfunction parentArray(parent, typ, count) {\n  const a = [];\n  a[COUNT] = count;\n  a[SYMS.PARENT] = parent;\n  a[MAJOR] = typ;\n  return a;\n}\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter();\n  b[COUNT] = -1;\n  b[SYMS.PARENT] = parent;\n  b[MAJOR] = typ;\n  return b;\n}\n\n/**\n * @param {Buffer} v\n * @private\n */\nfunction _tag_2(v) {\n  return utils.bufferToBigInt(v);\n}\n\n/**\n * @param {BigInt} v\n * @private\n */\nfunction _tag_3(v) {\n  // avoid syntax error on old runtimes\n  return BigInt('-1') - utils.bufferToBigInt(v);\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends {BinaryParseStream}\n */\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {object} [options={}]\n   * @param {number} [options.max_depth=-1] - the maximum depth to parse.\n   *   Use -1 for \"until you run out of memory\".  Set this to a finite\n   *   positive number for un-trusted inputs.  Most standard inputs won't nest\n   *   more than 100 or so levels; I've tested into the millions before\n   *   running out of memory.\n   * @param {object} [options.tags] - mapping from tag number to function(v),\n   *   where v is the decoded value that comes after the tag, and where the\n   *   function returns the correctly-created value for that tag.\n   * @param {boolean} [options.bigint=false] generate JavaScript BigInt's\n   *   instead of BigNumbers, when possible.  TODO: when BigInt's are\n   *   more prevalent, change this to default to the value of cbor.hasBigInt.\n   */\n  constructor(options) {\n    options = options || {};\n    const tags = options.tags;\n    delete options.tags;\n    const max_depth = options.max_depth != null ? options.max_depth : -1;\n    delete options.max_depth;\n    const bigI = utils.hasBigInt ? !!options.bigint : false;\n    delete options.bigint;\n    super(options);\n    this.running = true;\n    this.max_depth = max_depth;\n    this.tags = tags;\n    if (bigI) {\n      if (this.tags == null) {\n        this.tags = {};\n      }\n      this.tags[2] = _tag_2;\n      this.tags[3] = _tag_3;\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val - the value to check\n   * @returns {any} the corrected value\n   *\n   * @example\n   * myDecoder.on('data', function(val) {\n   *   val = Decoder.nullcheck(val);\n   *   ...\n   * });\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null;\n      case SYMS.UNDEFINED:\n        return undefined;\n      case NOT_FOUND:\n        throw new Error('Value not found');\n      default:\n        return val;\n    }\n  }\n\n  /**\n   * @typedef DecodeOptions\n   * @property {string} [encoding='hex'] - The encoding of the input.\n   *   Ignored if input is a Buffer.\n   */\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw an\n   * exception if the input is not valid CBOR.\n   *\n   * @static\n   * @param {string|Buffer} input\n   * @param {DecodeOptions|string} [options] Options\n   * @returns {any} - the decoded value\n   */\n  static decodeFirstSync(input, options) {\n    options = options || {\n      encoding: 'hex'\n    };\n    let opts = {};\n    let encod;\n    switch (typeof options) {\n      case 'string':\n        encod = options;\n        break;\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding;\n        delete opts.encoding;\n        break;\n    }\n    const c = new Decoder(opts);\n    const s = new NoFilter(input, encod != null ? encod : utils.guessEncoding(input));\n    const parser = c._parse();\n    let state = parser.next();\n    while (!state.done) {\n      const b = s.read(state.value);\n      if (b == null || b.length !== state.value) {\n        throw new Error('Insufficient data');\n      }\n      state = parser.next(b);\n    }\n    return Decoder.nullcheck(state.value);\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {string|Buffer} input\n   * @param {DecodeOptions|string} [options] Options or encoding string\n   * @returns {Array} - Array of all found items\n   */\n  static decodeAllSync(input, options) {\n    options = options || {\n      encoding: 'hex'\n    };\n    let opts = {};\n    let encod;\n    switch (typeof options) {\n      case 'string':\n        encod = options;\n        break;\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding;\n        delete opts.encoding;\n    }\n    const c = new Decoder(opts);\n    const s = new NoFilter(input, encod != null ? encod : utils.guessEncoding(input));\n    const res = [];\n    while (s.length > 0) {\n      const parser = c._parse();\n      let state = parser.next();\n      while (!state.done) {\n        const b = s.read(state.value);\n        if (b == null || b.length !== state.value) {\n          throw new Error('Insufficient data');\n        }\n        state = parser.next(b);\n      }\n      res.push(Decoder.nullcheck(state.value));\n    }\n    return res;\n  }\n\n  /**\n   * @callback decodeCallback\n   * @param {Error} [error] - if one was generated\n   * @param {any} [value] - the decoded value\n   */\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are more\n   * bytes left over at the end, and optionally if there were no valid CBOR\n   * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback\n   * if no data was found and the `required` option is false.\n   *\n   * @static\n   * @param {string|Buffer} input - the input to parse\n   * @param {DecodeOptions|decodeCallback|string} [options] - options\n   * @param {decodeCallback} [cb]\n   * @returns {Promise} if no cb specified\n   */\n  static decodeFirst(input, options, cb) {\n    let opts = {};\n    let required = false;\n    let encod = 'hex';\n    switch (typeof options) {\n      case 'function':\n        cb = options;\n        encod = utils.guessEncoding(input);\n        break;\n      case 'string':\n        encod = options;\n        break;\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n        required = opts.required != null ? opts.required : false;\n        delete opts.required;\n    }\n    const c = new Decoder(opts);\n    let p;\n    let v = NOT_FOUND;\n    c.on('data', val => {\n      v = Decoder.nullcheck(val);\n      c.close();\n    });\n    if (typeof cb === 'function') {\n      c.once('error', er => {\n        const u = v;\n        v = ERROR;\n        c.close();\n        return cb(er, u);\n      });\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return cb(new Error('No CBOR found'));\n            } else {\n              return cb(null, v);\n            }\n          case ERROR:\n            return void 0;\n          default:\n            return cb(null, v);\n        }\n      });\n    } else {\n      p = new Promise((resolve, reject) => {\n        c.once('error', er => {\n          v = ERROR;\n          c.close();\n          return reject(er);\n        });\n        return c.once('end', () => {\n          switch (v) {\n            case NOT_FOUND:\n              if (required) {\n                return reject(new Error('No CBOR found'));\n              } else {\n                return resolve(v);\n              }\n            case ERROR:\n              return void 0;\n            default:\n              return resolve(v);\n          }\n        });\n      });\n    }\n    c.end(input, encod);\n    return p;\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error - if one was generated\n   * @param {Array} value - all of the decoded values, wrapped in an Array\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {(string|Buffer)} input - the input to parse\n   * @param {(string|Object)} options - Decoding options.\n   *   If string, the input encoding.\n   * @param {decodeAllCallback} cb\n   * @returns {Promise} if no callback\n   */\n  static decodeAll(input, options, cb) {\n    let opts = {};\n    let encod = 'hex';\n    switch (typeof options) {\n      case 'function':\n        cb = options;\n        encod = utils.guessEncoding(input);\n        break;\n      case 'string':\n        encod = options;\n        break;\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n    }\n    const c = new Decoder(opts);\n    let p;\n    const vals = [];\n    c.on('data', val => {\n      return vals.push(Decoder.nullcheck(val));\n    });\n    if (typeof cb === 'function') {\n      c.on('error', cb);\n      c.on('end', () => cb(null, vals));\n    } else {\n      p = new Promise((resolve, reject) => {\n        c.on('error', reject);\n        c.on('end', () => resolve(vals));\n      });\n    }\n    c.end(input, encod);\n    return p;\n  }\n\n  /**\n   * Stop processing\n   */\n  close() {\n    this.running = false;\n    this.__fresh = true;\n  }\n  *_parse() {\n    let parent = null;\n    let depth = 0;\n    let val = null;\n    while (true) {\n      if (this.max_depth >= 0 && depth > this.max_depth) {\n        throw new Error('Maximum depth ' + this.max_depth + ' exceeded');\n      }\n      const octet = (yield 1)[0];\n      if (!this.running) {\n        throw new Error('Unexpected data: 0x' + octet.toString(16));\n      }\n      const mt = octet >> 5;\n      const ai = octet & 0x1f;\n      const parent_major = parent != null ? parent[MAJOR] : undefined;\n      const parent_length = parent != null ? parent.length : undefined;\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length);\n          val = (yield 1)[0];\n          break;\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          const numbytes = 1 << ai - 24;\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length);\n          const buf = yield numbytes;\n          val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);\n          break;\n        case 28:\n        case 29:\n        case 30:\n          this.running = false;\n          throw new Error('Additional info not implemented: ' + ai);\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`);\n          }\n          val = -1;\n          break;\n        default:\n          val = ai;\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // val already decoded\n          break;\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = NEG_MAX;\n          } else if (val instanceof bignumber) {\n            val = NEG_ONE.minus(val);\n          } else {\n            val = -1 - val;\n          }\n          break;\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = mt === MT.BYTE_STRING ? Buffer.allocUnsafe(0) : '';\n              break;\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentBufferStream(parent, mt);\n              depth++;\n              continue;\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = yield val;\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val);\n              }\n          }\n          break;\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = mt === MT.MAP ? {} : [];\n              break;\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentArray(parent, mt, -1);\n              depth++;\n              continue;\n            default:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, val * (mt - 3));\n              depth++;\n              continue;\n          }\n          break;\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length);\n          parent = parentArray(parent, mt, 1);\n          parent.push(val);\n          depth++;\n          continue;\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if (ai === NUMBYTES.ONE && val < 32) {\n              throw new Error(`Invalid two-byte encoding of simple value ${val}`);\n            }\n            const hasParent = parent != null;\n            val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);\n          } else {\n            val = utils.parseCBORfloat(val);\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai);\n      let again = false;\n      while (parent != null) {\n        switch (false) {\n          case val !== SYMS.BREAK:\n            parent[COUNT] = 1;\n            break;\n          case !Array.isArray(parent):\n            parent.push(val);\n            break;\n          case !(parent instanceof NoFilter):\n            const pm = parent[MAJOR];\n            if (pm != null && pm !== mt) {\n              this.running = false;\n              throw new Error('Invalid major type in indefinite encoding');\n            }\n            parent.write(val);\n        }\n        if (--parent[COUNT] !== 0) {\n          again = true;\n          break;\n        }\n        --depth;\n        delete parent[COUNT];\n        this.emit('stop', parent[MAJOR]);\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent;\n              break;\n            case MT.MAP:\n              let allstrings = true;\n              if (parent.length % 2 !== 0) {\n                throw new Error('Invalid map length: ' + parent.length);\n              }\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if (typeof parent[i] !== 'string') {\n                  allstrings = false;\n                  break;\n                }\n              }\n              if (allstrings) {\n                val = {};\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val[parent[i]] = parent[i + 1];\n                }\n              } else {\n                val = new Map();\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val.set(parent[i], parent[i + 1]);\n                }\n              }\n              break;\n            case MT.TAG:\n              const t = new Tagged(parent[0], parent[1]);\n              val = t.convert(this.tags);\n              break;\n          }\n        } else if (parent instanceof NoFilter) {\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice();\n              break;\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8');\n              break;\n          }\n        }\n        const old = parent;\n        parent = parent[SYMS.PARENT];\n        delete old[SYMS.PARENT];\n        delete old[MAJOR];\n      }\n      if (!again) {\n        return val;\n      }\n    }\n  }\n}\nDecoder.NOT_FOUND = NOT_FOUND;\nmodule.exports = Decoder;","map":{"version":3,"names":["BinaryParseStream","require","Tagged","Simple","utils","bignumber","BigNumber","NoFilter","constants","MT","NUMBYTES","SIMPLE","SYMS","NEG_ONE","NEG_MAX","minus","Number","MAX_SAFE_INTEGER","toString","COUNT","Symbol","PENDING_KEY","MAJOR","ERROR","NOT_FOUND","parentArray","parent","typ","count","a","PARENT","parentBufferStream","b","_tag_2","v","bufferToBigInt","_tag_3","BigInt","Decoder","constructor","options","tags","max_depth","bigI","hasBigInt","bigint","running","nullcheck","val","NULL","UNDEFINED","undefined","Error","decodeFirstSync","input","encoding","opts","encod","extend","c","s","guessEncoding","parser","_parse","state","next","done","read","value","length","decodeAllSync","res","push","decodeFirst","cb","required","p","on","close","once","er","u","Promise","resolve","reject","end","decodeAll","vals","__fresh","depth","octet","mt","ai","parent_major","parent_length","ONE","emit","TWO","FOUR","EIGHT","numbytes","buf","SIMPLE_FLOAT","parseCBORint","INDEFINITE","POS_INT","NEG_INT","TAG","BYTE_STRING","UTF8_STRING","Buffer","allocUnsafe","STREAM","utf8","ARRAY","MAP","hasParent","decode","parseCBORfloat","again","BREAK","Array","isArray","pm","write","allstrings","i","len","Map","set","t","convert","slice","old","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/cbor/lib/decoder.js"],"sourcesContent":["'use strict'\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream')\nconst Tagged = require('./tagged')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\nconst constants = require('./constants')\n// Do not fix this if you want to support node v4\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SIMPLE = constants.SIMPLE\nconst SYMS = constants.SYMS\n\nconst NEG_ONE = new bignumber(-1)\nconst NEG_MAX = NEG_ONE.minus(\n  new bignumber(Number.MAX_SAFE_INTEGER.toString(16), 16))\nconst COUNT = Symbol('count')\nconst PENDING_KEY = Symbol('pending_key')\nconst MAJOR = Symbol('major type')\nconst ERROR = Symbol('error')\nconst NOT_FOUND = Symbol('not found')\n\nfunction parentArray(parent, typ, count) {\n  const a = []\n  a[COUNT] = count\n  a[SYMS.PARENT] = parent\n  a[MAJOR] = typ\n  return a\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter()\n  b[COUNT] = -1\n  b[SYMS.PARENT] = parent\n  b[MAJOR] = typ\n  return b\n}\n\n/**\n * @param {Buffer} v\n * @private\n */\nfunction _tag_2(v) {\n  return utils.bufferToBigInt(v)\n}\n\n/**\n * @param {BigInt} v\n * @private\n */\nfunction _tag_3(v) {\n  // avoid syntax error on old runtimes\n  return BigInt('-1') - utils.bufferToBigInt(v)\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends {BinaryParseStream}\n */\nclass Decoder extends BinaryParseStream {\n\n  /**\n   * Create a parsing stream.\n   *\n   * @param {object} [options={}]\n   * @param {number} [options.max_depth=-1] - the maximum depth to parse.\n   *   Use -1 for \"until you run out of memory\".  Set this to a finite\n   *   positive number for un-trusted inputs.  Most standard inputs won't nest\n   *   more than 100 or so levels; I've tested into the millions before\n   *   running out of memory.\n   * @param {object} [options.tags] - mapping from tag number to function(v),\n   *   where v is the decoded value that comes after the tag, and where the\n   *   function returns the correctly-created value for that tag.\n   * @param {boolean} [options.bigint=false] generate JavaScript BigInt's\n   *   instead of BigNumbers, when possible.  TODO: when BigInt's are\n   *   more prevalent, change this to default to the value of cbor.hasBigInt.\n   */\n  constructor(options) {\n    options = options || {}\n    const tags = options.tags\n    delete options.tags\n    const max_depth = (options.max_depth != null) ? options.max_depth : -1\n    delete options.max_depth\n    const bigI = utils.hasBigInt ? (!!options.bigint) : false\n    delete options.bigint\n    super(options)\n\n    this.running = true\n    this.max_depth = max_depth\n    this.tags = tags\n    if (bigI) {\n      if (this.tags == null) {\n        this.tags = {}\n      }\n      this.tags[2] = _tag_2\n      this.tags[3] = _tag_3\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val - the value to check\n   * @returns {any} the corrected value\n   *\n   * @example\n   * myDecoder.on('data', function(val) {\n   *   val = Decoder.nullcheck(val);\n   *   ...\n   * });\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null\n      case SYMS.UNDEFINED:\n        return undefined\n      case NOT_FOUND:\n        throw new Error('Value not found')\n      default:\n        return val\n    }\n  }\n\n  /**\n   * @typedef DecodeOptions\n   * @property {string} [encoding='hex'] - The encoding of the input.\n   *   Ignored if input is a Buffer.\n   */\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw an\n   * exception if the input is not valid CBOR.\n   *\n   * @static\n   * @param {string|Buffer} input\n   * @param {DecodeOptions|string} [options] Options\n   * @returns {any} - the decoded value\n   */\n  static decodeFirstSync(input, options) {\n    options = options || { encoding: 'hex' }\n    let opts = {}\n    let encod\n    switch (typeof options) {\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = opts.encoding\n        delete opts.encoding\n        break\n    }\n    const c = new Decoder(opts)\n    const s = new NoFilter(\n      input,\n      encod != null ? encod : utils.guessEncoding(input))\n    const parser = c._parse()\n    let state = parser.next()\n    while (!state.done) {\n      const b = s.read(state.value)\n      if ((b == null) || (b.length !== state.value)) {\n        throw new Error('Insufficient data')\n      }\n      state = parser.next(b)\n    }\n    return Decoder.nullcheck(state.value)\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {string|Buffer} input\n   * @param {DecodeOptions|string} [options] Options or encoding string\n   * @returns {Array} - Array of all found items\n   */\n  static decodeAllSync(input, options) {\n    options = options || { encoding: 'hex' }\n    let opts = {}\n    let encod\n    switch (typeof options) {\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = opts.encoding\n        delete opts.encoding\n    }\n    const c = new Decoder(opts)\n    const s = new NoFilter(\n      input,\n      encod != null ? encod : utils.guessEncoding(input))\n    const res = []\n    while (s.length > 0) {\n      const parser = c._parse()\n      let state = parser.next()\n      while (!state.done) {\n        const b = s.read(state.value)\n        if ((b == null) || (b.length !== state.value)) {\n          throw new Error('Insufficient data')\n        }\n        state = parser.next(b)\n      }\n      res.push(Decoder.nullcheck(state.value))\n    }\n    return res\n  }\n\n  /**\n   * @callback decodeCallback\n   * @param {Error} [error] - if one was generated\n   * @param {any} [value] - the decoded value\n   */\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are more\n   * bytes left over at the end, and optionally if there were no valid CBOR\n   * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback\n   * if no data was found and the `required` option is false.\n   *\n   * @static\n   * @param {string|Buffer} input - the input to parse\n   * @param {DecodeOptions|decodeCallback|string} [options] - options\n   * @param {decodeCallback} [cb]\n   * @returns {Promise} if no cb specified\n   */\n  static decodeFirst(input, options, cb) {\n    let opts = {}\n    let required = false\n    let encod = 'hex'\n    switch (typeof options) {\n      case 'function':\n        cb = options\n        encod = utils.guessEncoding(input)\n        break\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n        required = (opts.required != null) ? opts.required : false\n        delete opts.required\n    }\n    const c = new Decoder(opts)\n    let p\n    let v = NOT_FOUND\n    c.on('data', (val) => {\n      v = Decoder.nullcheck(val)\n      c.close()\n    })\n    if (typeof cb === 'function') {\n      c.once('error', (er) => {\n        const u = v\n        v = ERROR\n        c.close()\n        return cb(er, u)\n      })\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return cb(new Error('No CBOR found'))\n            } else {\n              return cb(null, v)\n            }\n          case ERROR:\n            return void 0\n          default:\n            return cb(null, v)\n        }\n      })\n    } else {\n      p = new Promise((resolve, reject) => {\n        c.once('error', (er) => {\n          v = ERROR\n          c.close()\n          return reject(er)\n        })\n        return c.once('end', () => {\n          switch (v) {\n            case NOT_FOUND:\n              if (required) {\n                return reject(new Error('No CBOR found'))\n              } else {\n                return resolve(v)\n              }\n            case ERROR:\n              return void 0\n            default:\n              return resolve(v)\n          }\n        })\n      })\n    }\n    c.end(input, encod)\n    return p\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error - if one was generated\n   * @param {Array} value - all of the decoded values, wrapped in an Array\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {(string|Buffer)} input - the input to parse\n   * @param {(string|Object)} options - Decoding options.\n   *   If string, the input encoding.\n   * @param {decodeAllCallback} cb\n   * @returns {Promise} if no callback\n   */\n  static decodeAll(input, options, cb) {\n    let opts = {}\n    let encod = 'hex'\n    switch (typeof options) {\n      case 'function':\n        cb = options\n        encod = utils.guessEncoding(input)\n        break\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n    }\n    const c = new Decoder(opts)\n    let p\n    const vals = []\n    c.on('data', (val) => {\n      return vals.push(Decoder.nullcheck(val))\n    })\n    if (typeof cb === 'function') {\n      c.on('error', cb)\n      c.on('end', () => cb(null, vals))\n    } else {\n      p = new Promise((resolve, reject) => {\n        c.on('error', reject)\n        c.on('end', () => resolve(vals))\n      })\n    }\n    c.end(input, encod)\n    return p\n  }\n\n  /**\n   * Stop processing\n   */\n  close() {\n    this.running = false\n    this.__fresh = true\n  }\n\n  *_parse() {\n    let parent = null\n    let depth = 0\n    let val = null\n    while (true) {\n      if ((this.max_depth >= 0) && (depth > this.max_depth)) {\n        throw new Error('Maximum depth ' + this.max_depth + ' exceeded')\n      }\n      const octet = (yield 1)[0]\n      if (!this.running) {\n        throw new Error('Unexpected data: 0x' + (octet.toString(16)))\n      }\n      const mt = octet >> 5\n      const ai = octet & 0x1f\n      const parent_major = (parent != null) ? parent[MAJOR] : undefined\n      const parent_length = (parent != null) ? parent.length : undefined\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length)\n          val = (yield 1)[0]\n          break\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          const numbytes = 1 << (ai - 24)\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length)\n          const buf = yield numbytes\n          val = (mt === MT.SIMPLE_FLOAT) ? buf : utils.parseCBORint(ai, buf)\n          break\n        case 28:\n        case 29:\n        case 30:\n          this.running = false\n          throw new Error('Additional info not implemented: ' + ai)\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`)\n          }\n          val = -1\n          break\n        default:\n          val = ai\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // val already decoded\n          break\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = NEG_MAX\n          } else if (val instanceof bignumber) {\n            val = NEG_ONE.minus(val)\n          } else {\n            val = -1 - val\n          }\n          break\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = (mt === MT.BYTE_STRING) ? Buffer.allocUnsafe(0) : ''\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentBufferStream(parent, mt)\n              depth++\n              continue\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = yield val\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val)\n              }\n          }\n          break\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = (mt === MT.MAP) ? {} : []\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentArray(parent, mt, -1)\n              depth++\n              continue\n            default:\n              this.emit('start', mt, val, parent_major, parent_length)\n              parent = parentArray(parent, mt, val * (mt - 3))\n              depth++\n              continue\n          }\n          break\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length)\n          parent = parentArray(parent, mt, 1)\n          parent.push(val)\n          depth++\n          continue\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if ((ai === NUMBYTES.ONE) && (val < 32)) {\n              throw new Error(\n                `Invalid two-byte encoding of simple value ${val}`\n              )\n            }\n            const hasParent = (parent != null)\n            val = Simple.decode(val, hasParent, hasParent && (parent[COUNT] < 0))\n          } else {\n            val = utils.parseCBORfloat(val)\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai)\n      let again = false\n      while (parent != null) {\n        switch (false) {\n          case val !== SYMS.BREAK:\n            parent[COUNT] = 1\n            break\n          case !Array.isArray(parent):\n            parent.push(val)\n            break\n          case !(parent instanceof NoFilter):\n            const pm = parent[MAJOR]\n            if ((pm != null) && (pm !== mt)) {\n              this.running = false\n              throw new Error('Invalid major type in indefinite encoding')\n            }\n            parent.write(val)\n        }\n        if ((--parent[COUNT]) !== 0) {\n          again = true\n          break\n        }\n        --depth\n        delete parent[COUNT]\n        this.emit('stop', parent[MAJOR])\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent\n              break\n            case MT.MAP:\n              let allstrings = true\n              if ((parent.length % 2) !== 0) {\n                throw new Error('Invalid map length: ' + parent.length)\n              }\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if (typeof parent[i] !== 'string') {\n                  allstrings = false\n                  break\n                }\n              }\n              if (allstrings) {\n                val = {}\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val[parent[i]] = parent[i + 1]\n                }\n              } else {\n                val = new Map\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val.set(parent[i], parent[i + 1])\n                }\n              }\n              break\n            case MT.TAG:\n              const t = new Tagged(parent[0], parent[1])\n              val = t.convert(this.tags)\n              break\n          }\n        } else if (parent instanceof NoFilter) {\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice()\n              break\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8')\n              break\n          }\n        }\n\n        const old = parent\n        parent = parent[SYMS.PARENT]\n        delete old[SYMS.PARENT]\n        delete old[MAJOR]\n      }\n      if (!again) {\n        return val\n      }\n    }\n  }\n}\n\nDecoder.NOT_FOUND = NOT_FOUND\nmodule.exports = Decoder\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}