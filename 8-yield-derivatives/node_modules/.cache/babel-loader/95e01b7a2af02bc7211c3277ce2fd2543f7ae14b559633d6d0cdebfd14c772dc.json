{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Message = exports.__validateEncryptedMessageLength = void 0;\nconst _types_1 = require(\"./_types\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst util_1 = require(\"@radixdlt/util\");\nconst sealedMessage_1 = require(\"./sealedMessage\");\nconst utils_1 = require(\"../utils\");\nconst elliptic_curve_1 = require(\"../elliptic-curve\");\nconst messageEncryption_1 = require(\"./messageEncryption\");\nconst maxLengthEncryptedMessage = 255;\nconst minLengthEncryptedMessage = sealedMessage_1.SealedMessage.authTagByteCount + sealedMessage_1.SealedMessage.nonceByteCount + elliptic_curve_1.PublicKey.compressedByteCount + _types_1.ENCRYPTION_SCHEME_BYTES + _types_1.MESSAGE_TYPE_BYTES;\nconst maxLengthOfCipherTextOfSealedMsg = maxLengthEncryptedMessage - minLengthEncryptedMessage;\nconst isPlaintext = rawHex => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.PLAINTEXT;\nconst isEncrypted = rawHex => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.ENCRYPTED;\nconst isHexEncoded = rawHex => parseInt(rawHex.slice(0, 2)) === _types_1.MessageType.HEX;\nconst __validateEncryptedMessageMaxLength = utils_1.validateMaxLength.bind(null, maxLengthEncryptedMessage, 'encryptedMessage');\nconst __validateEncryptedMessageMinLength = utils_1.validateMinLength.bind(null, minLengthEncryptedMessage, 'encryptedMessage');\nconst __validateEncryptedMessageLength = buffer => (0, neverthrow_1.combine)([__validateEncryptedMessageMaxLength(buffer), __validateEncryptedMessageMinLength(buffer)]).map(_ => buffer);\nexports.__validateEncryptedMessageLength = __validateEncryptedMessageLength;\nconst createEncrypted = (encryptionScheme, sealedMessage) => (0, exports.__validateEncryptedMessageLength)(Buffer.concat([Buffer.from([_types_1.MessageType.ENCRYPTED]), Buffer.from([encryptionScheme]), sealedMessage.combined()])).map(combinedBuffer => ({\n  kind: 'ENCRYPTED',\n  messageType: _types_1.MessageType.ENCRYPTED,\n  encryptionScheme,\n  sealedMessage,\n  combined: () => combinedBuffer\n}));\nconst createPlaintext = message => ({\n  kind: 'PLAINTEXT',\n  plaintext: (0, util_1.isString)(message) ? message : message.toString('utf8'),\n  bytes: Buffer.concat([Buffer.from([_types_1.MessageType.PLAINTEXT]), Buffer.from([_types_1.EncryptionScheme.NONE]), messageEncryption_1.MessageEncryption.encodePlaintext(message)])\n});\nconst plaintextToString = (plaintext, startAt = 2) => Buffer.from(plaintext.slice(startAt).toString('hex'), 'hex').toString('utf-8');\nconst fromBuffer = buf => (0, exports.__validateEncryptedMessageLength)(buf).andThen(buffer => {\n  const readNextBuffer = (0, util_1.readBuffer)(buf);\n  const messageTypeResult = readNextBuffer(_types_1.MESSAGE_TYPE_BYTES);\n  if (messageTypeResult.isErr()) return (0, neverthrow_1.err)(messageTypeResult.error);\n  const messageType = messageTypeResult.value.readUIntBE(0, 1);\n  if (!(messageType in _types_1.MessageType)) return (0, neverthrow_1.err)(Error(`Unknown message type: ${messageType}`));\n  const schemeResult = readNextBuffer(_types_1.ENCRYPTION_SCHEME_BYTES);\n  if (schemeResult.isErr()) return (0, neverthrow_1.err)(schemeResult.error);\n  const scheme = schemeResult.value.readUIntBE(0, 1);\n  if (!(scheme in _types_1.EncryptionScheme)) return (0, neverthrow_1.err)(Error(`Unknown encryption scheme: ${scheme}`));\n  const payloadResult = readNextBuffer(buffer.length - _types_1.ENCRYPTION_SCHEME_BYTES - _types_1.MESSAGE_TYPE_BYTES);\n  if (payloadResult.isErr()) return (0, neverthrow_1.err)(payloadResult.error);\n  const payload = payloadResult.value;\n  if (messageType === _types_1.MessageType.ENCRYPTED && scheme !== _types_1.EncryptionScheme.NONE) {\n    const sealedMessageResult = sealedMessage_1.SealedMessage.fromBuffer(payload);\n    if (sealedMessageResult.isErr()) return (0, neverthrow_1.err)(sealedMessageResult.error);\n    return createEncrypted(scheme, sealedMessageResult.value);\n  }\n  if (messageType === _types_1.MessageType.PLAINTEXT && scheme === _types_1.EncryptionScheme.NONE) {\n    return (0, neverthrow_1.ok)(createPlaintext(payload));\n  }\n  return (0, neverthrow_1.err)(Error(`Invalid combination of message type ${messageType} and encryption scheme ${scheme}.`));\n});\nexports.Message = {\n  maxLength: maxLengthEncryptedMessage,\n  maxLengthOfCipherTextOfSealedMsg,\n  minLengthEncryptedMessage,\n  createEncrypted,\n  createPlaintext,\n  fromBuffer,\n  plaintextToString,\n  isPlaintext,\n  isEncrypted,\n  isHexEncoded\n};","map":{"version":3,"names":["_types_1","require","neverthrow_1","util_1","sealedMessage_1","utils_1","elliptic_curve_1","messageEncryption_1","maxLengthEncryptedMessage","minLengthEncryptedMessage","SealedMessage","authTagByteCount","nonceByteCount","PublicKey","compressedByteCount","ENCRYPTION_SCHEME_BYTES","MESSAGE_TYPE_BYTES","maxLengthOfCipherTextOfSealedMsg","isPlaintext","rawHex","parseInt","slice","MessageType","PLAINTEXT","isEncrypted","ENCRYPTED","isHexEncoded","HEX","__validateEncryptedMessageMaxLength","validateMaxLength","bind","__validateEncryptedMessageMinLength","validateMinLength","__validateEncryptedMessageLength","buffer","combine","map","_","exports","createEncrypted","encryptionScheme","sealedMessage","Buffer","concat","from","combined","combinedBuffer","kind","messageType","createPlaintext","message","plaintext","isString","toString","bytes","EncryptionScheme","NONE","MessageEncryption","encodePlaintext","plaintextToString","startAt","fromBuffer","buf","andThen","readNextBuffer","readBuffer","messageTypeResult","isErr","err","error","value","readUIntBE","Error","schemeResult","scheme","payloadResult","length","payload","sealedMessageResult","ok","Message","maxLength"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/src/encryption/message.ts"],"sourcesContent":["import {\n\tEncryptedMessageT,\n\tEncryptionScheme,\n\tENCRYPTION_SCHEME_BYTES,\n\tMessageType,\n\tMESSAGE_TYPE_BYTES,\n\tPlaintextMessageT,\n\tSealedMessageT,\n} from './_types'\nimport { combine, err, ok, Result } from 'neverthrow'\nimport { isString, readBuffer } from '@radixdlt/util'\nimport { SealedMessage } from './sealedMessage'\nimport { validateMaxLength, validateMinLength } from '../utils'\nimport { PublicKey } from '../elliptic-curve'\nimport { MessageEncryption } from './messageEncryption'\n\nconst maxLengthEncryptedMessage = 255\n\nconst minLengthEncryptedMessage =\n\tSealedMessage.authTagByteCount +\n\tSealedMessage.nonceByteCount +\n\tPublicKey.compressedByteCount +\n\tENCRYPTION_SCHEME_BYTES +\n\tMESSAGE_TYPE_BYTES\n\nconst maxLengthOfCipherTextOfSealedMsg =\n\tmaxLengthEncryptedMessage - minLengthEncryptedMessage\n\nconst isPlaintext = (rawHex: string) =>\n\tparseInt(rawHex.slice(0, 2)) === MessageType.PLAINTEXT\n\nconst isEncrypted = (rawHex: string) =>\n\tparseInt(rawHex.slice(0, 2)) === MessageType.ENCRYPTED\n\nconst isHexEncoded = (rawHex: string) =>\n\tparseInt(rawHex.slice(0, 2)) === MessageType.HEX\n\nconst __validateEncryptedMessageMaxLength: (\n\tbuffer: Buffer,\n) => Result<Buffer, Error> = validateMaxLength.bind(\n\tnull,\n\tmaxLengthEncryptedMessage,\n\t'encryptedMessage',\n)\n\nconst __validateEncryptedMessageMinLength: (\n\tbuffer: Buffer,\n) => Result<Buffer, Error> = validateMinLength.bind(\n\tnull,\n\tminLengthEncryptedMessage,\n\t'encryptedMessage',\n)\n\nexport const __validateEncryptedMessageLength = (\n\tbuffer: Buffer,\n): Result<Buffer, Error> =>\n\tcombine([\n\t\t__validateEncryptedMessageMaxLength(buffer),\n\t\t__validateEncryptedMessageMinLength(buffer),\n\t]).map(_ => buffer)\n\nconst createEncrypted = (\n\tencryptionScheme: EncryptionScheme,\n\tsealedMessage: SealedMessageT,\n): Result<EncryptedMessageT, Error> =>\n\t__validateEncryptedMessageLength(\n\t\tBuffer.concat([\n\t\t\tBuffer.from([MessageType.ENCRYPTED]),\n\t\t\tBuffer.from([encryptionScheme]),\n\t\t\tsealedMessage.combined(),\n\t\t]),\n\t).map(combinedBuffer => ({\n\t\tkind: 'ENCRYPTED',\n\t\tmessageType: MessageType.ENCRYPTED,\n\t\tencryptionScheme,\n\t\tsealedMessage,\n\t\tcombined: (): Buffer => combinedBuffer,\n\t}))\n\nconst createPlaintext = (message: string | Buffer): PlaintextMessageT => ({\n\tkind: 'PLAINTEXT',\n\tplaintext: isString(message) ? message : message.toString('utf8'),\n\tbytes: Buffer.concat([\n\t\tBuffer.from([MessageType.PLAINTEXT]),\n\t\tBuffer.from([EncryptionScheme.NONE]),\n\t\tMessageEncryption.encodePlaintext(message),\n\t]),\n})\n\nconst plaintextToString = (plaintext: Buffer, startAt = 2) =>\n\tBuffer.from(plaintext.slice(startAt).toString('hex'), 'hex').toString(\n\t\t'utf-8',\n\t)\n\nconst fromBuffer = (\n\tbuf: Buffer,\n): Result<EncryptedMessageT | PlaintextMessageT, Error> =>\n\t__validateEncryptedMessageLength(buf).andThen(\n\t\t(buffer): Result<EncryptedMessageT | PlaintextMessageT, Error> => {\n\t\t\tconst readNextBuffer = readBuffer(buf)\n\n\t\t\tconst messageTypeResult = readNextBuffer(MESSAGE_TYPE_BYTES)\n\t\t\tif (messageTypeResult.isErr()) return err(messageTypeResult.error)\n\n\t\t\tconst messageType = messageTypeResult.value.readUIntBE(0, 1)\n\t\t\tif (!(messageType in MessageType))\n\t\t\t\treturn err(Error(`Unknown message type: ${messageType}`))\n\n\t\t\tconst schemeResult = readNextBuffer(ENCRYPTION_SCHEME_BYTES)\n\t\t\tif (schemeResult.isErr()) return err(schemeResult.error)\n\n\t\t\tconst scheme = schemeResult.value.readUIntBE(0, 1)\n\t\t\tif (!(scheme in EncryptionScheme))\n\t\t\t\treturn err(Error(`Unknown encryption scheme: ${scheme}`))\n\n\t\t\tconst payloadResult = readNextBuffer(\n\t\t\t\tbuffer.length - ENCRYPTION_SCHEME_BYTES - MESSAGE_TYPE_BYTES,\n\t\t\t)\n\t\t\tif (payloadResult.isErr()) return err(payloadResult.error)\n\n\t\t\tconst payload = payloadResult.value\n\n\t\t\tif (\n\t\t\t\tmessageType === MessageType.ENCRYPTED &&\n\t\t\t\tscheme !== EncryptionScheme.NONE\n\t\t\t) {\n\t\t\t\tconst sealedMessageResult = SealedMessage.fromBuffer(payload)\n\t\t\t\tif (sealedMessageResult.isErr())\n\t\t\t\t\treturn err(sealedMessageResult.error)\n\n\t\t\t\treturn createEncrypted(scheme, sealedMessageResult.value)\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tmessageType === MessageType.PLAINTEXT &&\n\t\t\t\tscheme === EncryptionScheme.NONE\n\t\t\t) {\n\t\t\t\treturn ok(createPlaintext(payload))\n\t\t\t}\n\n\t\t\treturn err(\n\t\t\t\tError(\n\t\t\t\t\t`Invalid combination of message type ${messageType} and encryption scheme ${scheme}.`,\n\t\t\t\t),\n\t\t\t)\n\t\t},\n\t)\n\nexport const Message = {\n\tmaxLength: maxLengthEncryptedMessage,\n\tmaxLengthOfCipherTextOfSealedMsg,\n\tminLengthEncryptedMessage,\n\tcreateEncrypted,\n\tcreatePlaintext,\n\tfromBuffer,\n\tplaintextToString,\n\tisPlaintext,\n\tisEncrypted,\n\tisHexEncoded,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}