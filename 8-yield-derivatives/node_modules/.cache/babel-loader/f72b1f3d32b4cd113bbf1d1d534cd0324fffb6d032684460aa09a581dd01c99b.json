{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n/**\n * A sequence of values, organized in-memory as a strict linked list.\n * Each element has an head (value) and a tail (the rest of the list).\n *\n * The code is organized through the class [[EmptyLinkedList]] (empty list\n * or tail), the class [[ConsLinkedList]] (list value and pointer to next),\n * and the type alias [[LinkedList]] (empty or cons).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[LinkedListStatic]] and are accessed through the global constant LinkedList.\n *\n * Random access is expensive, appending is expensive, prepend or getting\n * the tail of the list is very cheap.\n * If you often need random access you should rather use [[Vector]].\n * Avoid appending at the end of the list in a loop, prefer prepending and\n * then reversing the list.\n *\n * Examples:\n *\n *     LinkedList.of(1,2,3);\n *     LinkedList.of(1,2,3).map(x => x*2).last();\n */\nvar Option_1 = require(\"./Option\");\nvar Vector_1 = require(\"./Vector\");\nvar Comparison_1 = require(\"./Comparison\");\nvar Contract_1 = require(\"./Contract\");\nvar Value_1 = require(\"./Value\");\nvar HashMap_1 = require(\"./HashMap\");\nvar HashSet_1 = require(\"./HashSet\");\nvar SeqHelpers = require(\"./SeqHelpers\");\n/**\n * Holds the \"static methods\" for [[LinkedList]]\n */\nvar LinkedListStatic = /** @class */function () {\n  function LinkedListStatic() {}\n  /**\n   * The empty stream\n   */\n  LinkedListStatic.prototype.empty = function () {\n    return emptyLinkedList;\n  };\n  LinkedListStatic.prototype.of = function () {\n    var elts = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      elts[_i] = arguments[_i];\n    }\n    return exports.LinkedList.ofIterable(elts);\n  };\n  /**\n   * Build a stream from any iterable, which means also\n   * an array for instance.\n   * @param T the item type\n   */\n  LinkedListStatic.prototype.ofIterable = function (elts) {\n    var iterator = elts[Symbol.iterator]();\n    var curItem = iterator.next();\n    var result = emptyLinkedList;\n    while (!curItem.done) {\n      result = new ConsLinkedList(curItem.value, result);\n      curItem = iterator.next();\n    }\n    return result.reverse();\n  };\n  /**\n   * Curried type guard for LinkedList.\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(LinkedList.of(1), LinkedList.empty<number>())\n   *         .filter(LinkedList.isEmpty)\n   *     => Vector.of(LinkedList.empty<number>())\n   */\n  LinkedListStatic.prototype.isEmpty = function (l) {\n    return l.isEmpty();\n  };\n  /**\n   * Curried type guard for LinkedList.\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Stream.of(1), Stream.empty<number>())\n   *         .filter(Stream.isNotEmpty)\n   *         .map(s => s.head().get()+1)\n   *     => Vector.of(2)\n   */\n  LinkedListStatic.prototype.isNotEmpty = function (l) {\n    return !l.isEmpty();\n  };\n  /**\n   * Dual to the foldRight function. Build a collection from a seed.\n   * Takes a starting element and a function.\n   * It applies the function on the starting element; if the\n   * function returns None, it stops building the list, if it\n   * returns Some of a pair, it adds the first element to the result\n   * and takes the second element as a seed to keep going.\n   *\n   *     LinkedList.unfoldRight(\n   *          10, x=>Option.of(x)\n   *              .filter(x => x!==0)\n   *              .map<[number,number]>(x => [x,x-1]))\n   *     => LinkedList.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n   */\n  LinkedListStatic.prototype.unfoldRight = function (seed, fn) {\n    var nextVal = fn(seed);\n    var result = emptyLinkedList;\n    while (!nextVal.isNone()) {\n      result = new ConsLinkedList(nextVal.get()[0], result);\n      nextVal = fn(nextVal.get()[1]);\n    }\n    return result.reverse();\n  };\n  /**\n   * Combine any number of iterables you give in as\n   * parameters to produce a new collection which combines all,\n   * in tuples. For instance:\n   *\n   *     LinkedList.zip(LinkedList.of(1,2,3), [\"a\",\"b\",\"c\"], Vector.of(8,9,10))\n   *     => LinkedList.of([1,\"a\",8], [2,\"b\",9], [3,\"c\",10])\n   *\n   * The result collection will have the length of the shorter\n   * of the input iterables. Extra elements will be discarded.\n   *\n   * Also see the non-static version [[ConsLinkedList.zip]], which only combines two\n   * collections.\n   * @param A A is the type of the tuple that'll be generated\n   *          (`[number,string,number]` for the code sample)\n   */\n  LinkedListStatic.prototype.zip = function () {\n    var iterables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      iterables[_i] = arguments[_i];\n    }\n    var r = exports.LinkedList.empty();\n    var iterators = iterables.map(function (i) {\n      return i[Symbol.iterator]();\n    });\n    var items = iterators.map(function (i) {\n      return i.next();\n    });\n    while (!items.some(function (item) {\n      return item.done;\n    })) {\n      r = r.prepend(items.map(function (item) {\n        return item.value;\n      }));\n      items = iterators.map(function (i) {\n        return i.next();\n      });\n    }\n    return r.reverse();\n  };\n  return LinkedListStatic;\n}();\nexports.LinkedListStatic = LinkedListStatic;\n/**\n * The LinkedList constant allows to call the LinkedList \"static\" methods\n */\nexports.LinkedList = new LinkedListStatic();\n/**\n * EmptyLinkedList is the empty linked list; every non-empty\n * linked list also has a pointer to an empty linked list\n * after its last element.\n * \"static methods\" available through [[LinkedListStatic]]\n * @param T the item type\n */\nvar EmptyLinkedList = /** @class */function () {\n  function EmptyLinkedList() {\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * @hidden\n   */\n  EmptyLinkedList.prototype.hasTrueEquality = function () {\n    return SeqHelpers.seqHasTrueEquality(this);\n  };\n  /**\n   * Implementation of the Iterator interface.\n   */\n  EmptyLinkedList.prototype[Symbol.iterator] = function () {\n    return {\n      next: function () {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  };\n  /**\n   * View this Some a as LinkedList. Useful to help typescript type\n   * inference sometimes.\n   */\n  EmptyLinkedList.prototype.asLinkedList = function () {\n    return this;\n  };\n  /**\n   * Get the length of the collection.\n   */\n  EmptyLinkedList.prototype.length = function () {\n    return 0;\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  EmptyLinkedList.prototype.single = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * true if the collection is empty, false otherwise.\n   */\n  EmptyLinkedList.prototype.isEmpty = function () {\n    return true;\n  };\n  /**\n   * Get the first value of the collection, if any.\n   * In this case the list is empty, so returns Option.none\n   */\n  EmptyLinkedList.prototype.head = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * Get all the elements in the collection but the first one.\n   * If the collection is empty, return None.\n   */\n  EmptyLinkedList.prototype.tail = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * Get the last value of the collection, if any.\n   * returns Option.Some if the collection is not empty,\n   * Option.None if it's empty.\n   */\n  EmptyLinkedList.prototype.last = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * Retrieve the element at index idx.\n   * Returns an option because the collection may\n   * contain less elements than the index.\n   *\n   * Careful this is going to have poor performance\n   * on LinkedList, which is not a good data structure\n   * for random access!\n   */\n  EmptyLinkedList.prototype.get = function (idx) {\n    return Option_1.Option.none();\n  };\n  /**\n   * Search for an item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   */\n  EmptyLinkedList.prototype.find = function (predicate) {\n    return Option_1.Option.none();\n  };\n  /**\n   * Returns true if the item is in the collection,\n   * false otherwise.\n   */\n  EmptyLinkedList.prototype.contains = function (v) {\n    return false;\n  };\n  /**\n   * Return a new stream keeping only the first n elements\n   * from this stream.\n   */\n  EmptyLinkedList.prototype.take = function (n) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate.\n   */\n  EmptyLinkedList.prototype.takeWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate,\n   * but starting from the end of the collection.\n   *\n   *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)\n   *     => LinkedList.of(3,4)\n   */\n  EmptyLinkedList.prototype.takeRightWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection with the first\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  EmptyLinkedList.prototype.drop = function (n) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the first elements\n   * until one element fails the predicate. All elements\n   * after that point are retained.\n   */\n  EmptyLinkedList.prototype.dropWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection with the last\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  EmptyLinkedList.prototype.dropRight = function (n) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the last elements\n   * until one element fails the predicate. All elements\n   * before that point are retained.\n   */\n  EmptyLinkedList.prototype.dropRightWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Reduces the collection to a single value using the\n   * associative binary function you give. Since the function\n   * is associative, order of application doesn't matter.\n   *\n   * Example:\n   *\n   *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);\n   *     => 6\n   */\n  EmptyLinkedList.prototype.fold = function (zero, fn) {\n    return zero;\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Left-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n   *     => \"cba!\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the previous value and\n   *           the current collection item, and returning\n   *           an updated value.\n   */\n  EmptyLinkedList.prototype.foldLeft = function (zero, fn) {\n    return zero;\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Right-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n   *     => \"!cba\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the current collection item and\n   *           the previous value , and returning\n   *           an updated value.\n   */\n  EmptyLinkedList.prototype.foldRight = function (zero, fn) {\n    return zero;\n  };\n  /**\n   * Combine this collection with the collection you give in\n   * parameter to produce a new collection which combines both,\n   * in pairs. For instance:\n   *\n   *     Vector.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n   *     => Vector.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n   *\n   * The result collection will have the length of the shorter\n   * of both collections. Extra elements will be discarded.\n   *\n   * Also see [[LinkedListStatic.zip]] (static version which can more than two\n   * iterables)\n   */\n  EmptyLinkedList.prototype.zip = function (other) {\n    return emptyLinkedList;\n  };\n  /**\n   * Combine this collection with the index of the elements\n   * in it. Handy if you need the index when you map on\n   * the collection for instance:\n   *\n   *     LinkedList.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n   *     => LinkedList.of(\"a0\", \"b1\")\n   */\n  EmptyLinkedList.prototype.zipWithIndex = function () {\n    return this;\n  };\n  /**\n   * Reverse the collection. For instance:\n   *\n   *     LinkedList.of(1,2,3).reverse();\n   *     => LinkedList.of(3,2,1)\n   */\n  EmptyLinkedList.prototype.reverse = function () {\n    return this;\n  };\n  /**\n   * Takes a predicate; returns a pair of collections.\n   * The first one is the longest prefix of this collection\n   * which satisfies the predicate, and the second collection\n   * is the remainder of the collection.\n   *\n   *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)\n   *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]\n   */\n  EmptyLinkedList.prototype.span = function (predicate) {\n    return [this, this];\n  };\n  /**\n   * Split the collection at a specific index.\n   *\n   *     LinkedList.of(1,2,3,4,5).splitAt(3)\n   *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]\n   */\n  EmptyLinkedList.prototype.splitAt = function (index) {\n    return [this, this];\n  };\n  EmptyLinkedList.prototype.partition = function (predicate) {\n    return [exports.LinkedList.empty(), exports.LinkedList.empty()];\n  };\n  /**\n   * Group elements in the collection using a classifier function.\n   * Elements are then organized in a map. The key is the value of\n   * the classifier, and in value we get the list of elements\n   * matching that value.\n   *\n   * also see [[ConsLinkedList.arrangeBy]]\n   */\n  EmptyLinkedList.prototype.groupBy = function (classifier) {\n    return HashMap_1.HashMap.empty();\n  };\n  /**\n   * Matches each element with a unique key that you extract from it.\n   * If the same key is present twice, the function will return None.\n   *\n   * also see [[ConsLinkedList.groupBy]]\n   */\n  EmptyLinkedList.prototype.arrangeBy = function (getKey) {\n    return SeqHelpers.arrangeBy(this, getKey);\n  };\n  /**\n   * Randomly reorder the elements of the collection.\n   */\n  EmptyLinkedList.prototype.shuffle = function () {\n    return this;\n  };\n  /**\n   * Append an element at the end of this LinkedList.\n   * Warning: appending in a loop on a linked list is going\n   * to be very slow!\n   */\n  EmptyLinkedList.prototype.append = function (v) {\n    return exports.LinkedList.of(v);\n  };\n  /*\n   * Append multiple elements at the end of this LinkedList.\n   */\n  EmptyLinkedList.prototype.appendAll = function (elts) {\n    return exports.LinkedList.ofIterable(elts);\n  };\n  /**\n   * Remove multiple elements from a LinkedList\n   *\n   *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])\n   *     => LinkedList.of(1,3,3,1)\n   */\n  EmptyLinkedList.prototype.removeAll = function (elts) {\n    return this;\n  };\n  /**\n   * Removes the first element matching the predicate\n   * (use [[Seq.filter]] to remove all elements matching a predicate)\n   */\n  EmptyLinkedList.prototype.removeFirst = function (predicate) {\n    return this;\n  };\n  /**\n   * Prepend an element at the beginning of the collection.\n   */\n  EmptyLinkedList.prototype.prepend = function (elt) {\n    return new ConsLinkedList(elt, this);\n  };\n  /**\n   * Prepend multiple elements at the beginning of the collection.\n   */\n  EmptyLinkedList.prototype.prependAll = function (elt) {\n    return exports.LinkedList.ofIterable(elt);\n  };\n  /**\n   * Return a new collection where each element was transformed\n   * by the mapper function you give.\n   */\n  EmptyLinkedList.prototype.map = function (mapper) {\n    return emptyLinkedList;\n  };\n  /**\n   * Apply the mapper function on every element of this collection.\n   * The mapper function returns an Option; if the Option is a Some,\n   * the value it contains is added to the result Collection, if it's\n   * a None, the value is discarded.\n   *\n   *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?\n   *         Option.of(x+1) : Option.none<number>())\n   *     => LinkedList.of(3, 7)\n   */\n  EmptyLinkedList.prototype.mapOption = function (mapper) {\n    return emptyLinkedList;\n  };\n  /**\n   * Calls the function you give for each item in the collection,\n   * your function returns a collection, all the collections are\n   * concatenated.\n   * This is the monadic bind.\n   */\n  EmptyLinkedList.prototype.flatMap = function (mapper) {\n    return emptyLinkedList;\n  };\n  EmptyLinkedList.prototype.allMatch = function (predicate) {\n    return true;\n  };\n  /**\n   * Returns true if there the predicate returns true for any\n   * element in the collection.\n   */\n  EmptyLinkedList.prototype.anyMatch = function (predicate) {\n    return false;\n  };\n  EmptyLinkedList.prototype.filter = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection with elements\n   * sorted according to the comparator you give.\n   *\n   *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n   *     LinkedList.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n   *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n   *     => LinkedList.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n   *\n   * also see [[ConsLinkedList.sortOn]]\n   */\n  EmptyLinkedList.prototype.sortBy = function (compare) {\n    return this;\n  };\n  /**\n   * Give a function associating a number or a string with\n   * elements from the collection, and the elements\n   * are sorted according to that value.\n   *\n   *     LinkedList.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n   *     => LinkedList.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n   *\n   * You can also sort by multiple criteria, and request 'descending'\n   * sorting:\n   *\n   *     LinkedList.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n   *     => LinkedList.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n   *\n   * also see [[ConsLinkedList.sortBy]]\n   */\n  EmptyLinkedList.prototype.sortOn = function () {\n    var getKeys = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      getKeys[_i] = arguments[_i];\n    }\n    return this;\n  };\n  /**\n   * Remove duplicate items; elements are mapped to keys, those\n   * get compared.\n   *\n   *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)\n   *     => LinkedList.of(1,2,3)\n   */\n  EmptyLinkedList.prototype.distinctBy = function (keyExtractor) {\n    return this;\n  };\n  /**\n   * Call a function for element in the collection.\n   */\n  EmptyLinkedList.prototype.forEach = function (fn) {\n    return this;\n  };\n  /**\n   * Reduces the collection to a single value by repeatedly\n   * calling the combine function.\n   * No starting value. The order in which the elements are\n   * passed to the combining function is undetermined.\n   */\n  EmptyLinkedList.prototype.reduce = function (combine) {\n    return SeqHelpers.reduce(this, combine);\n  };\n  /**\n   * Compare values in the collection and return the smallest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsLinkedList.minOn]]\n   */\n  EmptyLinkedList.prototype.minBy = function (compare) {\n    return SeqHelpers.minBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the smallest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n   *     => Option.of({name:\"Paula\", age:6})\n   *\n   * also see [[ConsLinkedList.minBy]]\n   */\n  EmptyLinkedList.prototype.minOn = function (getOrderable) {\n    return SeqHelpers.minOn(this, getOrderable);\n  };\n  /**\n   * Compare values in the collection and return the largest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsLinkedList.maxOn]]\n   */\n  EmptyLinkedList.prototype.maxBy = function (compare) {\n    return SeqHelpers.maxBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the largest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n   *     => Option.of({name:\"Joe\", age:12})\n   *\n   * also see [[ConsLinkedList.maxBy]]\n   */\n  EmptyLinkedList.prototype.maxOn = function (getOrderable) {\n    return SeqHelpers.maxOn(this, getOrderable);\n  };\n  /**\n   * Call the function you give for each element in the collection\n   * and sum all the numbers, return that sum.\n   * Will return 0 if the collection is empty.\n   *\n   *     LinkedList.of(1,2,3).sumOn(x=>x)\n   *     => 6\n   */\n  EmptyLinkedList.prototype.sumOn = function (getNumber) {\n    return SeqHelpers.sumOn(this, getNumber);\n  };\n  /**\n   * Slides a window of a specific size over the sequence.\n   * Returns a lazy stream so memory use is not prohibitive.\n   *\n   *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)\n   *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))\n   */\n  EmptyLinkedList.prototype.sliding = function (count) {\n    return SeqHelpers.sliding(this, count);\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   * The last element of the result is the final cumulative result.\n   *\n   *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n   *     => LinkedList.of(0,1,3,6)\n   */\n  EmptyLinkedList.prototype.scanLeft = function (init, fn) {\n    return exports.LinkedList.of(init);\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   * The first element of the result is the final cumulative result.\n   *\n   *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n   *     => LinkedList.of(6,5,3,0)\n   */\n  EmptyLinkedList.prototype.scanRight = function (init, fn) {\n    return exports.LinkedList.of(init);\n  };\n  /**\n   * Joins elements of the collection by a separator.\n   * Example:\n   *\n   *     LinkedList.of(1,2,3).mkString(\", \")\n   *     => \"1, 2, 3\"\n   */\n  EmptyLinkedList.prototype.mkString = function (separator) {\n    return \"\";\n  };\n  /**\n   * Convert to array.\n   * Don't do it on an infinite stream!\n   */\n  EmptyLinkedList.prototype.toArray = function () {\n    return [];\n  };\n  /**\n   * Convert to vector.\n   * Don't do it on an infinite stream!\n   */\n  EmptyLinkedList.prototype.toVector = function () {\n    return Vector_1.Vector.empty();\n  };\n  /**\n   * Convert this collection to a map. You give a function which\n   * for each element in the collection returns a pair. The\n   * key of the pair will be used as a key in the map, the value,\n   * as a value in the map. If several values get the same key,\n   * entries will be lost.\n   *\n   *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])\n   *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n   */\n  EmptyLinkedList.prototype.toMap = function (converter) {\n    return HashMap_1.HashMap.empty();\n  };\n  /**\n   * Convert this collection to a set. Since the elements of the\n   * Seq may not support equality, you must pass a function returning\n   * a value supporting equality.\n   *\n   *     LinkedList.of(1,2,3,3,4).toSet(x=>x)\n   *     => HashSet.of(1,2,3,4)\n   */\n  EmptyLinkedList.prototype.toSet = function (converter) {\n    return HashSet_1.HashSet.empty();\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  EmptyLinkedList.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  EmptyLinkedList.prototype.equals = function (other) {\n    if (!other) {\n      return false;\n    }\n    return other.isEmpty();\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  EmptyLinkedList.prototype.hashCode = function () {\n    return 1;\n  };\n  EmptyLinkedList.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   *\n   * Also see [[ConsLinkedList.mkString]]\n   */\n  EmptyLinkedList.prototype.toString = function () {\n    return \"LinkedList()\";\n  };\n  return EmptyLinkedList;\n}();\nexports.EmptyLinkedList = EmptyLinkedList;\n/**\n * ConsLinkedList holds a value and a pointer to a next element,\n * which could be [[ConsLinkedList]] or [[EmptyLinkedList]].\n * A ConsLinkedList is basically a non-empty linked list. It will\n * contain at least one element.\n * \"static methods\" available through [[LinkedListStatic]]\n * @param T the item type\n */\nvar ConsLinkedList = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function ConsLinkedList(value, _tail) {\n    this.value = value;\n    this._tail = _tail;\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * @hidden\n   */\n  ConsLinkedList.prototype.hasTrueEquality = function () {\n    return SeqHelpers.seqHasTrueEquality(this);\n  };\n  /**\n   * View this Some a as LinkedList. Useful to help typescript type\n   * inference sometimes.\n   */\n  ConsLinkedList.prototype.asLinkedList = function () {\n    return this;\n  };\n  /**\n   * Implementation of the Iterator interface.\n   */\n  ConsLinkedList.prototype[Symbol.iterator] = function () {\n    var item = this;\n    return {\n      next: function () {\n        if (item.isEmpty()) {\n          return {\n            done: true,\n            value: undefined\n          };\n        }\n        var value = item.head().get();\n        item = item.tail().get();\n        return {\n          done: false,\n          value: value\n        };\n      }\n    };\n  };\n  /**\n   * Get the length of the collection.\n   */\n  ConsLinkedList.prototype.length = function () {\n    return this.foldLeft(0, function (n, ignored) {\n      return n + 1;\n    });\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  ConsLinkedList.prototype.single = function () {\n    return this._tail.isEmpty() ? Option_1.Option.of(this.value) : Option_1.Option.none();\n  };\n  /**\n   * true if the collection is empty, false otherwise.\n   */\n  ConsLinkedList.prototype.isEmpty = function () {\n    return false;\n  };\n  /**\n   * Get the first value of the collection, if any.\n   * In this case the list is not empty, so returns Option.some\n   */\n  ConsLinkedList.prototype.head = function () {\n    return Option_1.Option.some(this.value);\n  };\n  /**\n   * Get all the elements in the collection but the first one.\n   * If the collection is empty, return None.\n   */\n  ConsLinkedList.prototype.tail = function () {\n    return Option_1.Option.some(this._tail);\n  };\n  /**\n   * Get the last value of the collection, if any.\n   * returns Option.Some if the collection is not empty,\n   * Option.None if it's empty.\n   */\n  ConsLinkedList.prototype.last = function () {\n    var curItem = this;\n    while (true) {\n      var item = curItem.value;\n      curItem = curItem._tail;\n      if (curItem.isEmpty()) {\n        return Option_1.Option.some(item);\n      }\n    }\n  };\n  /**\n   * Retrieve the element at index idx.\n   * Returns an option because the collection may\n   * contain less elements than the index.\n   *\n   * Careful this is going to have poor performance\n   * on LinkedList, which is not a good data structure\n   * for random access!\n   */\n  ConsLinkedList.prototype.get = function (idx) {\n    var curItem = this;\n    var i = 0;\n    while (!curItem.isEmpty()) {\n      if (i === idx) {\n        var item = curItem.value;\n        return Option_1.Option.of(item);\n      }\n      curItem = curItem._tail;\n      ++i;\n    }\n    return Option_1.Option.none();\n  };\n  /**\n   * Search for an item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   */\n  ConsLinkedList.prototype.find = function (predicate) {\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      var item = curItem.value;\n      if (predicate(item)) {\n        return Option_1.Option.of(item);\n      }\n      curItem = curItem._tail;\n    }\n    return Option_1.Option.none();\n  };\n  /**\n   * Returns true if the item is in the collection,\n   * false otherwise.\n   */\n  ConsLinkedList.prototype.contains = function (v) {\n    return this.find(function (x) {\n      return Comparison_1.areEqual(x, v);\n    }).isSome();\n  };\n  /**\n   * Return a new stream keeping only the first n elements\n   * from this stream.\n   */\n  ConsLinkedList.prototype.take = function (n) {\n    var result = emptyLinkedList;\n    var curItem = this;\n    var i = 0;\n    while (i++ < n && !curItem.isEmpty()) {\n      result = new ConsLinkedList(curItem.value, result);\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate.\n   */\n  ConsLinkedList.prototype.takeWhile = function (predicate) {\n    var result = emptyLinkedList;\n    var curItem = this;\n    while (!curItem.isEmpty() && predicate(curItem.value)) {\n      result = new ConsLinkedList(curItem.value, result);\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate,\n   * but starting from the end of the collection.\n   *\n   *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)\n   *     => LinkedList.of(3,4)\n   */\n  ConsLinkedList.prototype.takeRightWhile = function (predicate) {\n    return this.reverse().takeWhile(predicate).reverse();\n  };\n  /**\n   * Returns a new collection with the first\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  ConsLinkedList.prototype.drop = function (n) {\n    var i = n;\n    var curItem = this;\n    while (i-- > 0 && !curItem.isEmpty()) {\n      curItem = curItem._tail;\n    }\n    return curItem;\n  };\n  /**\n   * Returns a new collection, discarding the first elements\n   * until one element fails the predicate. All elements\n   * after that point are retained.\n   */\n  ConsLinkedList.prototype.dropWhile = function (predicate) {\n    var curItem = this;\n    while (!curItem.isEmpty() && predicate(curItem.value)) {\n      curItem = curItem._tail;\n    }\n    return curItem;\n  };\n  /**\n   * Returns a new collection with the last\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  ConsLinkedList.prototype.dropRight = function (n) {\n    // going twice through the list...\n    var length = this.length();\n    return this.take(length - n);\n  };\n  /**\n   * Returns a new collection, discarding the last elements\n   * until one element fails the predicate. All elements\n   * before that point are retained.\n   */\n  ConsLinkedList.prototype.dropRightWhile = function (predicate) {\n    return this.reverse().dropWhile(predicate).reverse();\n  };\n  /**\n   * Reduces the collection to a single value using the\n   * associative binary function you give. Since the function\n   * is associative, order of application doesn't matter.\n   *\n   * Example:\n   *\n   *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);\n   *     => 6\n   */\n  ConsLinkedList.prototype.fold = function (zero, fn) {\n    return this.foldLeft(zero, fn);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Left-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n   *     => \"cba!\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the previous value and\n   *           the current collection item, and returning\n   *           an updated value.\n   */\n  ConsLinkedList.prototype.foldLeft = function (zero, fn) {\n    var r = zero;\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      r = fn(r, curItem.value);\n      curItem = curItem._tail;\n    }\n    return r;\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Right-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n   *     => \"!cba\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the current collection item and\n   *           the previous value , and returning\n   *           an updated value.\n   */\n  ConsLinkedList.prototype.foldRight = function (zero, fn) {\n    return this.reverse().foldLeft(zero, function (xs, x) {\n      return fn(x, xs);\n    });\n  };\n  /**\n   * Combine this collection with the collection you give in\n   * parameter to produce a new collection which combines both,\n   * in pairs. For instance:\n   *\n   *     Vector.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n   *     => Vector.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n   *\n   * The result collection will have the length of the shorter\n   * of both collections. Extra elements will be discarded.\n   *\n   * Also see [[LinkedListStatic.zip]] (static version which can more than two\n   * iterables)\n   */\n  ConsLinkedList.prototype.zip = function (other) {\n    var otherIterator = other[Symbol.iterator]();\n    var otherCurItem = otherIterator.next();\n    var curItem = this;\n    var result = emptyLinkedList;\n    while (!curItem.isEmpty() && !otherCurItem.done) {\n      result = new ConsLinkedList([curItem.value, otherCurItem.value], result);\n      curItem = curItem._tail;\n      otherCurItem = otherIterator.next();\n    }\n    return result.reverse();\n  };\n  /**\n   * Combine this collection with the index of the elements\n   * in it. Handy if you need the index when you map on\n   * the collection for instance:\n   *\n   *     LinkedList.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n   *     => LinkedList.of(\"a0\", \"b1\")\n   */\n  ConsLinkedList.prototype.zipWithIndex = function () {\n    return SeqHelpers.zipWithIndex(this);\n  };\n  /**\n   * Reverse the collection. For instance:\n   *\n   *     LinkedList.of(1,2,3).reverse();\n   *     => LinkedList.of(3,2,1)\n   */\n  ConsLinkedList.prototype.reverse = function () {\n    return this.foldLeft(emptyLinkedList, function (xs, x) {\n      return xs.prepend(x);\n    });\n  };\n  /**\n   * Takes a predicate; returns a pair of collections.\n   * The first one is the longest prefix of this collection\n   * which satisfies the predicate, and the second collection\n   * is the remainder of the collection.\n   *\n   *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)\n   *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]\n   */\n  ConsLinkedList.prototype.span = function (predicate) {\n    var first = emptyLinkedList;\n    var curItem = this;\n    while (!curItem.isEmpty() && predicate(curItem.value)) {\n      first = new ConsLinkedList(curItem.value, first);\n      curItem = curItem._tail;\n    }\n    return [first.reverse(), curItem];\n  };\n  /**\n   * Split the collection at a specific index.\n   *\n   *     LinkedList.of(1,2,3,4,5).splitAt(3)\n   *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]\n   */\n  ConsLinkedList.prototype.splitAt = function (index) {\n    var first = emptyLinkedList;\n    var curItem = this;\n    var i = 0;\n    while (i++ < index && !curItem.isEmpty()) {\n      first = new ConsLinkedList(curItem.value, first);\n      curItem = curItem._tail;\n    }\n    return [first.reverse(), curItem];\n  };\n  ConsLinkedList.prototype.partition = function (predicate) {\n    var fst = exports.LinkedList.empty();\n    var snd = exports.LinkedList.empty();\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      if (predicate(curItem.value)) {\n        fst = new ConsLinkedList(curItem.value, fst);\n      } else {\n        snd = new ConsLinkedList(curItem.value, snd);\n      }\n      curItem = curItem._tail;\n    }\n    return [fst.reverse(), snd.reverse()];\n  };\n  /**\n   * Group elements in the collection using a classifier function.\n   * Elements are then organized in a map. The key is the value of\n   * the classifier, and in value we get the list of elements\n   * matching that value.\n   *\n   * also see [[ConsLinkedList.arrangeBy]]\n   */\n  ConsLinkedList.prototype.groupBy = function (classifier) {\n    return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, v) {\n      return acc.putWithMerge(classifier(v), exports.LinkedList.of(v), function (v1, v2) {\n        return v1.prepend(v2.single().getOrThrow());\n      });\n    }).mapValues(function (l) {\n      return l.reverse();\n    });\n  };\n  /**\n   * Matches each element with a unique key that you extract from it.\n   * If the same key is present twice, the function will return None.\n   *\n   * also see [[ConsLinkedList.groupBy]]\n   */\n  ConsLinkedList.prototype.arrangeBy = function (getKey) {\n    return SeqHelpers.arrangeBy(this, getKey);\n  };\n  /**\n   * Randomly reorder the elements of the collection.\n   */\n  ConsLinkedList.prototype.shuffle = function () {\n    return exports.LinkedList.ofIterable(SeqHelpers.shuffle(this.toArray()));\n  };\n  /**\n   * Append an element at the end of this LinkedList.\n   * Warning: appending in a loop on a linked list is going\n   * to be very slow!\n   */\n  ConsLinkedList.prototype.append = function (v) {\n    return new ConsLinkedList(this.value, this._tail.append(v));\n  };\n  /*\n   * Append multiple elements at the end of this LinkedList.\n   */\n  ConsLinkedList.prototype.appendAll = function (elts) {\n    return exports.LinkedList.ofIterable(elts).prependAll(this);\n  };\n  /**\n   * Remove multiple elements from a LinkedList\n   *\n   *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])\n   *     => LinkedList.of(1,3,3,1)\n   */\n  ConsLinkedList.prototype.removeAll = function (elts) {\n    return SeqHelpers.removeAll(this, elts);\n  };\n  /**\n   * Removes the first element matching the predicate\n   * (use [[Seq.filter]] to remove all elements matching a predicate)\n   */\n  ConsLinkedList.prototype.removeFirst = function (predicate) {\n    var curItem = this;\n    var result = emptyLinkedList;\n    var removed = false;\n    while (!curItem.isEmpty()) {\n      if (predicate(curItem.value) && !removed) {\n        removed = true;\n      } else {\n        result = new ConsLinkedList(curItem.value, result);\n      }\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Prepend an element at the beginning of the collection.\n   */\n  ConsLinkedList.prototype.prepend = function (elt) {\n    return new ConsLinkedList(elt, this);\n  };\n  /**\n   * Prepend multiple elements at the beginning of the collection.\n   */\n  ConsLinkedList.prototype.prependAll = function (elts) {\n    var leftToAdd = exports.LinkedList.ofIterable(elts).reverse();\n    var result = this;\n    while (!leftToAdd.isEmpty()) {\n      result = new ConsLinkedList(leftToAdd.value, result);\n      leftToAdd = leftToAdd._tail;\n    }\n    return result;\n  };\n  /**\n   * Return a new collection where each element was transformed\n   * by the mapper function you give.\n   */\n  ConsLinkedList.prototype.map = function (mapper) {\n    var curItem = this;\n    var result = emptyLinkedList;\n    while (!curItem.isEmpty()) {\n      result = new ConsLinkedList(mapper(curItem.value), result);\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Apply the mapper function on every element of this collection.\n   * The mapper function returns an Option; if the Option is a Some,\n   * the value it contains is added to the result Collection, if it's\n   * a None, the value is discarded.\n   *\n   *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?\n   *         Option.of(x+1) : Option.none<number>())\n   *     => LinkedList.of(3, 7)\n   */\n  ConsLinkedList.prototype.mapOption = function (mapper) {\n    var curItem = this;\n    var result = emptyLinkedList;\n    while (!curItem.isEmpty()) {\n      var mapped = mapper(curItem.value);\n      if (mapped.isSome()) {\n        result = new ConsLinkedList(mapped.get(), result);\n      }\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Calls the function you give for each item in the collection,\n   * your function returns a collection, all the collections are\n   * concatenated.\n   * This is the monadic bind.\n   */\n  ConsLinkedList.prototype.flatMap = function (mapper) {\n    var curItem = this;\n    var result = emptyLinkedList;\n    while (!curItem.isEmpty()) {\n      result = result.prependAll(mapper(curItem.value).reverse());\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  ConsLinkedList.prototype.allMatch = function (predicate) {\n    return this.find(function (x) {\n      return !predicate(x);\n    }).isNone();\n  };\n  /**\n   * Returns true if there the predicate returns true for any\n   * element in the collection.\n   */\n  ConsLinkedList.prototype.anyMatch = function (predicate) {\n    return this.find(predicate).isSome();\n  };\n  ConsLinkedList.prototype.filter = function (predicate) {\n    var curItem = this;\n    var result = emptyLinkedList;\n    while (!curItem.isEmpty()) {\n      if (predicate(curItem.value)) {\n        result = new ConsLinkedList(curItem.value, result);\n      }\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Returns a new collection with elements\n   * sorted according to the comparator you give.\n   *\n   *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n   *     LinkedList.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n   *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n   *     => LinkedList.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n   *\n   * also see [[ConsLinkedList.sortOn]]\n   */\n  ConsLinkedList.prototype.sortBy = function (compare) {\n    return exports.LinkedList.ofIterable(this.toArray().sort(compare));\n  };\n  /**\n   * Give a function associating a number or a string with\n   * elements from the collection, and the elements\n   * are sorted according to that value.\n   *\n   *     LinkedList.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n   *     => LinkedList.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n   *\n   * You can also sort by multiple criteria, and request 'descending'\n   * sorting:\n   *\n   *     LinkedList.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n   *     => LinkedList.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n   *\n   * also see [[ConsLinkedList.sortBy]]\n   */\n  ConsLinkedList.prototype.sortOn = function () {\n    var getKeys = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      getKeys[_i] = arguments[_i];\n    }\n    return SeqHelpers.sortOn(this, getKeys);\n  };\n  /**\n   * Remove duplicate items; elements are mapped to keys, those\n   * get compared.\n   *\n   *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)\n   *     => LinkedList.of(1,2,3)\n   */\n  ConsLinkedList.prototype.distinctBy = function (keyExtractor) {\n    return SeqHelpers.distinctBy(this, keyExtractor);\n  };\n  /**\n   * Call a function for element in the collection.\n   */\n  ConsLinkedList.prototype.forEach = function (fn) {\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      fn(curItem.value);\n      curItem = curItem._tail;\n    }\n    return this;\n  };\n  /**\n   * Reduces the collection to a single value by repeatedly\n   * calling the combine function.\n   * No starting value. The order in which the elements are\n   * passed to the combining function is undetermined.\n   */\n  ConsLinkedList.prototype.reduce = function (combine) {\n    return SeqHelpers.reduce(this, combine);\n  };\n  /**\n   * Compare values in the collection and return the smallest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsLinkedList.minOn]]\n   */\n  ConsLinkedList.prototype.minBy = function (compare) {\n    return SeqHelpers.minBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the smallest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n   *     => Option.of({name:\"Paula\", age:6})\n   *\n   * also see [[ConsLinkedList.minBy]]\n   */\n  ConsLinkedList.prototype.minOn = function (getOrderable) {\n    return SeqHelpers.minOn(this, getOrderable);\n  };\n  /**\n   * Compare values in the collection and return the largest element.\n   * Returns Option.none if the collection is empty.\n   *\n   *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n   *     => Option.of({name:\"Joe\", age:12})\n   *\n   * also see [[ConsLinkedList.maxOn]]\n   */\n  ConsLinkedList.prototype.maxBy = function (compare) {\n    return SeqHelpers.maxBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the largest.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsLinkedList.maxBy]]\n   */\n  ConsLinkedList.prototype.maxOn = function (getOrderable) {\n    return SeqHelpers.maxOn(this, getOrderable);\n  };\n  /**\n   * Call the function you give for each element in the collection\n   * and sum all the numbers, return that sum.\n   * Will return 0 if the collection is empty.\n   *\n   *     LinkedList.of(1,2,3).sumOn(x=>x)\n   *     => 6\n   */\n  ConsLinkedList.prototype.sumOn = function (getNumber) {\n    return SeqHelpers.sumOn(this, getNumber);\n  };\n  /**\n   * Slides a window of a specific size over the sequence.\n   * Returns a lazy stream so memory use is not prohibitive.\n   *\n   *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)\n   *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))\n   */\n  ConsLinkedList.prototype.sliding = function (count) {\n    return SeqHelpers.sliding(this, count);\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   *\n   *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n   *     => LinkedList.of(0,1,3,6)\n   */\n  ConsLinkedList.prototype.scanLeft = function (init, fn) {\n    var result = exports.LinkedList.of(init);\n    var curItem = this;\n    var soFar = init;\n    while (!curItem.isEmpty()) {\n      soFar = fn(soFar, curItem.value);\n      result = new ConsLinkedList(soFar, result);\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   * The first element of the result is the final cumulative result.\n   *\n   *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n   *     => LinkedList.of(6,5,3,0)\n   */\n  ConsLinkedList.prototype.scanRight = function (init, fn) {\n    var result = exports.LinkedList.of(init);\n    var curItem = this.reverse();\n    var soFar = init;\n    while (!curItem.isEmpty()) {\n      soFar = fn(curItem.value, soFar);\n      result = new ConsLinkedList(soFar, result);\n      curItem = curItem._tail;\n    }\n    return result;\n  };\n  /**\n   * Joins elements of the collection by a separator.\n   * Example:\n   *\n   *     LinkedList.of(1,2,3).mkString(\", \")\n   *     => \"1, 2, 3\"\n   */\n  ConsLinkedList.prototype.mkString = function (separator) {\n    var r = \"\";\n    var curItem = this;\n    var isNotFirst = false;\n    while (!curItem.isEmpty()) {\n      if (isNotFirst) {\n        r += separator;\n      }\n      r += SeqHelpers.toStringHelper(curItem.value, {\n        quoteStrings: false\n      });\n      curItem = curItem._tail;\n      isNotFirst = true;\n    }\n    return r;\n  };\n  /**\n   * Convert to array.\n   * Don't do it on an infinite stream!\n   */\n  ConsLinkedList.prototype.toArray = function () {\n    var r = [];\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      r.push(curItem.value);\n      curItem = curItem._tail;\n    }\n    return r;\n  };\n  /**\n   * Convert to vector.\n   * Don't do it on an infinite stream!\n   */\n  ConsLinkedList.prototype.toVector = function () {\n    return Vector_1.Vector.ofIterable(this.toArray());\n  };\n  /**\n   * Convert this collection to a map. You give a function which\n   * for each element in the collection returns a pair. The\n   * key of the pair will be used as a key in the map, the value,\n   * as a value in the map. If several values get the same key,\n   * entries will be lost.\n   *\n   *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])\n   *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n   */\n  ConsLinkedList.prototype.toMap = function (converter) {\n    return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, cur) {\n      var converted = converter(cur);\n      return acc.put(converted[0], converted[1]);\n    });\n  };\n  /**\n   * Convert this collection to a set. Since the elements of the\n   * Seq may not support equality, you must pass a function returning\n   * a value supporting equality.\n   *\n   *     LinkedList.of(1,2,3,3,4).toSet(x=>x)\n   *     => HashSet.of(1,2,3,4)\n   */\n  ConsLinkedList.prototype.toSet = function (converter) {\n    return this.foldLeft(HashSet_1.HashSet.empty(), function (acc, cur) {\n      return acc.add(converter(cur));\n    });\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  ConsLinkedList.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  ConsLinkedList.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || !other.tail) {\n      return false;\n    }\n    Contract_1.contractTrueEquality(\"LinkedList.equals\", this, other);\n    var myVal = this;\n    var hisVal = other;\n    while (true) {\n      if (myVal.isEmpty() !== hisVal.isEmpty()) {\n        return false;\n      }\n      if (myVal.isEmpty()) {\n        // they are both empty, end of the stream\n        return true;\n      }\n      var myHead = myVal.value;\n      var hisHead = hisVal.value;\n      if (myHead === undefined !== (hisHead === undefined)) {\n        return false;\n      }\n      if (myHead === undefined || hisHead === undefined) {\n        // they are both undefined, the || is for TS's flow analysis\n        // so he realizes none of them is undefined after this.\n        continue;\n      }\n      if (!Comparison_1.areEqual(myHead, hisHead)) {\n        return false;\n      }\n      myVal = myVal._tail;\n      hisVal = hisVal._tail;\n    }\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  ConsLinkedList.prototype.hashCode = function () {\n    var hash = 1;\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      hash = 31 * hash + Comparison_1.getHashCode(curItem.value);\n      curItem = curItem._tail;\n    }\n    return hash;\n  };\n  ConsLinkedList.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   *\n   * Also see [[ConsLinkedList.mkString]]\n   */\n  ConsLinkedList.prototype.toString = function () {\n    var curItem = this;\n    var result = \"LinkedList(\";\n    while (!curItem.isEmpty()) {\n      result += SeqHelpers.toStringHelper(curItem.value);\n      var tail = curItem._tail;\n      curItem = tail;\n      if (!curItem.isEmpty()) {\n        result += \", \";\n      }\n    }\n    return result + \")\";\n  };\n  return ConsLinkedList;\n}();\nexports.ConsLinkedList = ConsLinkedList;\nvar emptyLinkedList = new EmptyLinkedList();","map":{"version":3,"names":["Option_1","require","Vector_1","Comparison_1","Contract_1","Value_1","HashMap_1","HashSet_1","SeqHelpers","LinkedListStatic","prototype","empty","emptyLinkedList","of","elts","_i","arguments","length","exports","LinkedList","ofIterable","iterator","Symbol","curItem","next","result","done","ConsLinkedList","value","reverse","isEmpty","l","isNotEmpty","unfoldRight","seed","fn","nextVal","isNone","get","zip","iterables","r","iterators","map","i","items","some","item","prepend","EmptyLinkedList","className","undefined","hasTrueEquality","seqHasTrueEquality","asLinkedList","single","Option","none","head","tail","last","idx","find","predicate","contains","v","take","n","takeWhile","takeRightWhile","drop","dropWhile","dropRight","dropRightWhile","fold","zero","foldLeft","foldRight","other","zipWithIndex","span","splitAt","index","partition","groupBy","classifier","HashMap","arrangeBy","getKey","shuffle","append","appendAll","removeAll","removeFirst","elt","prependAll","mapper","mapOption","flatMap","allMatch","anyMatch","filter","sortBy","compare","sortOn","getKeys","distinctBy","keyExtractor","forEach","reduce","combine","minBy","minOn","getOrderable","maxBy","maxOn","sumOn","getNumber","sliding","count","scanLeft","init","scanRight","mkString","separator","toArray","toVector","Vector","toMap","converter","toSet","HashSet","transform","equals","hashCode","inspect","toString","_tail","ignored","x","areEqual","isSome","xs","otherIterator","otherCurItem","first","fst","snd","acc","putWithMerge","v1","v2","getOrThrow","mapValues","removed","leftToAdd","mapped","sort","soFar","isNotFirst","toStringHelper","quoteStrings","push","cur","converted","put","add","contractTrueEquality","myVal","hisVal","myHead","hisHead","hash","getHashCode"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/LinkedList.ts"],"sourcesContent":["/**\n * A sequence of values, organized in-memory as a strict linked list.\n * Each element has an head (value) and a tail (the rest of the list).\n *\n * The code is organized through the class [[EmptyLinkedList]] (empty list\n * or tail), the class [[ConsLinkedList]] (list value and pointer to next),\n * and the type alias [[LinkedList]] (empty or cons).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[LinkedListStatic]] and are accessed through the global constant LinkedList.\n *\n * Random access is expensive, appending is expensive, prepend or getting\n * the tail of the list is very cheap.\n * If you often need random access you should rather use [[Vector]].\n * Avoid appending at the end of the list in a loop, prefer prepending and\n * then reversing the list.\n *\n * Examples:\n *\n *     LinkedList.of(1,2,3);\n *     LinkedList.of(1,2,3).map(x => x*2).last();\n */\nimport { Option, Some, None } from \"./Option\";\nimport { Vector } from \"./Vector\";\nimport { WithEquality, getHashCode,\n         areEqual, Ordering, ToOrderable } from \"./Comparison\";\nimport { contractTrueEquality } from \"./Contract\";\nimport { inspect } from \"./Value\";\nimport { HashMap } from \"./HashMap\";\nimport { HashSet } from \"./HashSet\";\nimport { Seq, IterableArray } from \"./Seq\";\nimport { Stream } from \"./Stream\";\nimport * as SeqHelpers from \"./SeqHelpers\";\n\n/**\n * Holds the \"static methods\" for [[LinkedList]]\n */\nexport class LinkedListStatic {\n    /**\n     * The empty stream\n     */\n    empty<T>(): LinkedList<T> {\n        return <EmptyLinkedList<T>>emptyLinkedList;\n    }\n\n    /**\n     * Create a LinkedList with the elements you give.\n     */\n    of<T>(elt: T, ...elts:T[]): ConsLinkedList<T>;\n    of<T>(...elts:T[]): LinkedList<T>;\n    of<T>(...elts:T[]): LinkedList<T> {\n        return LinkedList.ofIterable(elts);\n    }\n\n    /**\n     * Build a stream from any iterable, which means also\n     * an array for instance.\n     * @param T the item type\n     */\n    ofIterable<T>(elts: Iterable<T>): LinkedList<T> {\n        const iterator = elts[Symbol.iterator]();\n        let curItem = iterator.next();\n        let result: LinkedList<T> = <EmptyLinkedList<T>>emptyLinkedList;\n        while (!curItem.done) {\n            result = new ConsLinkedList(curItem.value, result);\n            curItem = iterator.next();\n        }\n        return result.reverse();\n    }\n\n    /**\n     * Curried type guard for LinkedList.\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(LinkedList.of(1), LinkedList.empty<number>())\n     *         .filter(LinkedList.isEmpty)\n     *     => Vector.of(LinkedList.empty<number>())\n     */\n    isEmpty<T>(l: LinkedList<T>): l is EmptyLinkedList<T> {\n        return l.isEmpty();\n    }\n\n    /**\n     * Curried type guard for LinkedList.\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Stream.of(1), Stream.empty<number>())\n     *         .filter(Stream.isNotEmpty)\n     *         .map(s => s.head().get()+1)\n     *     => Vector.of(2)\n     */\n    isNotEmpty<T>(l: LinkedList<T>): l is ConsLinkedList<T> {\n        return !l.isEmpty();\n    }\n\n    /**\n     * Dual to the foldRight function. Build a collection from a seed.\n     * Takes a starting element and a function.\n     * It applies the function on the starting element; if the\n     * function returns None, it stops building the list, if it\n     * returns Some of a pair, it adds the first element to the result\n     * and takes the second element as a seed to keep going.\n     *\n     *     LinkedList.unfoldRight(\n     *          10, x=>Option.of(x)\n     *              .filter(x => x!==0)\n     *              .map<[number,number]>(x => [x,x-1]))\n     *     => LinkedList.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n     */\n    unfoldRight<T,U>(seed: T, fn: (x:T)=>Option<[U,T]>): LinkedList<U> {\n        let nextVal = fn(seed);\n        let result = <LinkedList<U>><EmptyLinkedList<U>>emptyLinkedList;\n        while (!nextVal.isNone()) {\n            result = new ConsLinkedList(\n                nextVal.get()[0],\n                result);\n            nextVal = fn(nextVal.get()[1]);\n        }\n        return result.reverse();\n    }\n\n    /**\n     * Combine any number of iterables you give in as\n     * parameters to produce a new collection which combines all,\n     * in tuples. For instance:\n     *\n     *     LinkedList.zip(LinkedList.of(1,2,3), [\"a\",\"b\",\"c\"], Vector.of(8,9,10))\n     *     => LinkedList.of([1,\"a\",8], [2,\"b\",9], [3,\"c\",10])\n     *\n     * The result collection will have the length of the shorter\n     * of the input iterables. Extra elements will be discarded.\n     *\n     * Also see the non-static version [[ConsLinkedList.zip]], which only combines two\n     * collections.\n     * @param A A is the type of the tuple that'll be generated\n     *          (`[number,string,number]` for the code sample)\n     */\n    zip<A extends any[]>(...iterables: IterableArray<A>): LinkedList<A> {\n        let r = LinkedList.empty<A>();\n        const iterators = iterables.map(i => i[Symbol.iterator]());\n        let items = iterators.map(i => i.next());\n\n        while (!items.some(item => item.done)) {\n            r = r.prepend(<any>items.map(item => item.value));\n            items = iterators.map(i => i.next());\n        }\n        return r.reverse();\n    }\n}\n\n/**\n * The LinkedList constant allows to call the LinkedList \"static\" methods\n */\nexport const LinkedList = new LinkedListStatic();\n\n/**\n * A LinkedList is either [[EmptyLinkedList]] or [[ConsLinkedList]]\n * \"static methods\" available through [[LinkedListStatic]]\n * @param T the item type\n */\nexport type LinkedList<T> = EmptyLinkedList<T> | ConsLinkedList<T>;\n\n/**\n * EmptyLinkedList is the empty linked list; every non-empty\n * linked list also has a pointer to an empty linked list\n * after its last element.\n * \"static methods\" available through [[LinkedListStatic]]\n * @param T the item type\n */\nexport class EmptyLinkedList<T> implements Seq<T> {\n\n    /**\n     * @hidden\n     */\n    hasTrueEquality(): boolean {\n        return SeqHelpers.seqHasTrueEquality<T>(this);\n    }\n\n    /**\n     * Implementation of the Iterator interface.\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return {\n            next(): IteratorResult<T> {\n                return {\n                    done: true,\n                    value: <any>undefined\n                };\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    readonly className: \"EmptyLinkedList\" = <any>undefined;  // https://stackoverflow.com/a/47841595/516188\n\n    /**\n     * View this Some a as LinkedList. Useful to help typescript type\n     * inference sometimes.\n     */\n    asLinkedList(): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Get the length of the collection.\n     */\n    length(): number {\n        return 0;\n    }\n\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    single(): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * true if the collection is empty, false otherwise.\n     */\n    isEmpty(): this is EmptyLinkedList<T> {\n        return true;\n    }\n\n    /**\n     * Get the first value of the collection, if any.\n     * In this case the list is empty, so returns Option.none\n     */\n    head(): None<T> {\n        return <None<T>>Option.none<T>();\n    }\n\n    /**\n     * Get all the elements in the collection but the first one.\n     * If the collection is empty, return None.\n     */\n    tail(): Option<LinkedList<T>> {\n        return Option.none<LinkedList<T>>();\n    }\n\n    /**\n     * Get the last value of the collection, if any.\n     * returns Option.Some if the collection is not empty,\n     * Option.None if it's empty.\n     */\n    last(): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * Retrieve the element at index idx.\n     * Returns an option because the collection may\n     * contain less elements than the index.\n     *\n     * Careful this is going to have poor performance\n     * on LinkedList, which is not a good data structure\n     * for random access!\n     */\n    get(idx: number): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * Search for an item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     */\n    find(predicate:(v:T)=>boolean): Option<T> {\n        return Option.none<T>();\n    }\n\n    /**\n     * Returns true if the item is in the collection,\n     * false otherwise.\n     */\n    contains(v:T&WithEquality): boolean {\n        return false;\n    }\n\n    /**\n     * Return a new stream keeping only the first n elements\n     * from this stream.\n     */\n    take(n: number): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate.\n     */\n    takeWhile(predicate: (x:T)=>boolean): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate,\n     * but starting from the end of the collection.\n     *\n     *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)\n     *     => LinkedList.of(3,4)\n     */\n    takeRightWhile(predicate:(x:T)=>boolean): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection with the first\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    drop(n:number): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection, discarding the first elements\n     * until one element fails the predicate. All elements\n     * after that point are retained.\n     */\n    dropWhile(predicate:(x:T)=>boolean): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection with the last\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    dropRight(n:number): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection, discarding the last elements\n     * until one element fails the predicate. All elements\n     * before that point are retained.\n     */\n    dropRightWhile(predicate:(x:T)=>boolean): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Reduces the collection to a single value using the\n     * associative binary function you give. Since the function\n     * is associative, order of application doesn't matter.\n     *\n     * Example:\n     *\n     *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);\n     *     => 6\n     */\n    fold(zero:T, fn:(v1:T,v2:T)=>T): T {\n        return zero;\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Left-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n     *     => \"cba!\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the previous value and\n     *           the current collection item, and returning\n     *           an updated value.\n     */\n    foldLeft<U>(zero: U, fn:(soFar:U,cur:T)=>U): U {\n        return zero;\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Right-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n     *     => \"!cba\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the current collection item and\n     *           the previous value , and returning\n     *           an updated value.\n     */\n    foldRight<U>(zero: U, fn:(cur:T, soFar:U)=>U): U {\n        return zero;\n    }\n\n    /**\n     * Combine this collection with the collection you give in\n     * parameter to produce a new collection which combines both,\n     * in pairs. For instance:\n     *\n     *     Vector.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n     *     => Vector.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n     *\n     * The result collection will have the length of the shorter\n     * of both collections. Extra elements will be discarded.\n     *\n     * Also see [[LinkedListStatic.zip]] (static version which can more than two\n     * iterables)\n     */\n    zip<U>(other: Iterable<U>): LinkedList<[T,U]> {\n        return <EmptyLinkedList<[T,U]>>emptyLinkedList;\n    }\n\n    /**\n     * Combine this collection with the index of the elements\n     * in it. Handy if you need the index when you map on\n     * the collection for instance:\n     *\n     *     LinkedList.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n     *     => LinkedList.of(\"a0\", \"b1\")\n     */\n    zipWithIndex(): LinkedList<[T,number]> {\n        return <EmptyLinkedList<[T,number]>><any>this;\n    }\n\n    /**\n     * Reverse the collection. For instance:\n     *\n     *     LinkedList.of(1,2,3).reverse();\n     *     => LinkedList.of(3,2,1)\n     */\n    reverse(): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Takes a predicate; returns a pair of collections.\n     * The first one is the longest prefix of this collection\n     * which satisfies the predicate, and the second collection\n     * is the remainder of the collection.\n     *\n     *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)\n     *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]\n     */\n    span(predicate:(x:T)=>boolean): [LinkedList<T>,LinkedList<T>] {\n        return [this, this];\n    }\n\n    /**\n     * Split the collection at a specific index.\n     *\n     *     LinkedList.of(1,2,3,4,5).splitAt(3)\n     *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]\n     */\n    splitAt(index:number): [LinkedList<T>,LinkedList<T>] {\n        return [this, this];\n    }\n\n    /**\n     * Returns a pair of two collections; the first one\n     * will only contain the items from this collection for\n     * which the predicate you give returns true, the second\n     * will only contain the items from this collection where\n     * the predicate returns false.\n     *\n     *     LinkedList.of(1,2,3,4).partition(x => x%2===0)\n     *     => [LinkedList.of(2,4),LinkedList.of(1,3)]\n     */\n    partition<U extends T>(predicate:(v:T)=>v is U): [LinkedList<U>,LinkedList<Exclude<T,U>>];\n    partition(predicate:(x:T)=>boolean): [LinkedList<T>,LinkedList<T>];\n    partition<U extends T>(predicate:(v:T)=>boolean): [LinkedList<U>,LinkedList<any>] {\n        return [LinkedList.empty<U>(), LinkedList.empty<T>()];\n    }\n\n    /**\n     * Group elements in the collection using a classifier function.\n     * Elements are then organized in a map. The key is the value of\n     * the classifier, and in value we get the list of elements\n     * matching that value.\n     *\n     * also see [[ConsLinkedList.arrangeBy]]\n     */\n    groupBy<C>(classifier: (v:T)=>C & WithEquality): HashMap<C,LinkedList<T>> {\n        return HashMap.empty<C,LinkedList<T>>();\n    }\n\n    /**\n     * Matches each element with a unique key that you extract from it.\n     * If the same key is present twice, the function will return None.\n     *\n     * also see [[ConsLinkedList.groupBy]]\n     */\n    arrangeBy<K>(getKey: (v:T)=>K&WithEquality): Option<HashMap<K,T>> {\n        return SeqHelpers.arrangeBy<T,K>(this, getKey);\n    }\n\n    /**\n     * Randomly reorder the elements of the collection.\n     */\n    shuffle(): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Append an element at the end of this LinkedList.\n     * Warning: appending in a loop on a linked list is going\n     * to be very slow!\n     */\n    append(v:T): LinkedList<T> {\n        return LinkedList.of(v);\n    }\n\n    /*\n     * Append multiple elements at the end of this LinkedList.\n     */\n    appendAll(elts:Iterable<T>): LinkedList<T> {\n        return LinkedList.ofIterable(elts);\n    }\n\n    /**\n     * Remove multiple elements from a LinkedList\n     *\n     *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])\n     *     => LinkedList.of(1,3,3,1)\n     */\n    removeAll(elts:Iterable<T&WithEquality>): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Removes the first element matching the predicate\n     * (use [[Seq.filter]] to remove all elements matching a predicate)\n     */\n    removeFirst(predicate: (x:T)=>boolean): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Prepend an element at the beginning of the collection.\n     */\n    prepend(elt: T): LinkedList<T> {\n        return new ConsLinkedList(elt, this);\n    }\n\n    /**\n     * Prepend multiple elements at the beginning of the collection.\n     */\n    prependAll(elt: Iterable<T>): LinkedList<T> {\n        return LinkedList.ofIterable(elt);\n    }\n\n    /**\n     * Return a new collection where each element was transformed\n     * by the mapper function you give.\n     */\n    map<U>(mapper:(v:T)=>U): LinkedList<U> {\n        return <EmptyLinkedList<U>>emptyLinkedList;\n    }\n\n    /**\n     * Apply the mapper function on every element of this collection.\n     * The mapper function returns an Option; if the Option is a Some,\n     * the value it contains is added to the result Collection, if it's\n     * a None, the value is discarded.\n     *\n     *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?\n     *         Option.of(x+1) : Option.none<number>())\n     *     => LinkedList.of(3, 7)\n     */\n    mapOption<U>(mapper:(v:T)=>Option<U>): LinkedList<U> {\n        return <EmptyLinkedList<U>>emptyLinkedList;\n    }\n\n    /**\n     * Calls the function you give for each item in the collection,\n     * your function returns a collection, all the collections are\n     * concatenated.\n     * This is the monadic bind.\n     */\n    flatMap<U>(mapper:(v:T)=>LinkedList<U>): LinkedList<U> {\n        return <EmptyLinkedList<U>>emptyLinkedList;\n    }\n\n    /**\n     * Returns true if the predicate returns true for all the\n     * elements in the collection.\n     */\n    allMatch<U extends T>(predicate:(v:T)=>v is U): this is LinkedList<U>;\n    allMatch(predicate:(v:T)=>boolean): boolean;\n    allMatch(predicate:(v:T)=>boolean): boolean {\n        return true;\n    }\n\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    anyMatch(predicate:(v:T)=>boolean): boolean {\n        return false;\n    }\n\n    /**\n     * Call a predicate for each element in the collection,\n     * build a new collection holding only the elements\n     * for which the predicate returned true.\n     */\n    filter<U extends T>(predicate:(v:T)=>v is U): LinkedList<U>;\n    filter(predicate:(v:T)=>boolean): LinkedList<T>;\n    filter(predicate:(v:T)=>boolean): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Returns a new collection with elements\n     * sorted according to the comparator you give.\n     *\n     *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n     *     LinkedList.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n     *     => LinkedList.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n     *\n     * also see [[ConsLinkedList.sortOn]]\n     */\n    sortBy(compare: (v1:T,v2:T)=>Ordering): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Give a function associating a number or a string with\n     * elements from the collection, and the elements\n     * are sorted according to that value.\n     *\n     *     LinkedList.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n     *     => LinkedList.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n     *\n     * You can also sort by multiple criteria, and request 'descending'\n     * sorting:\n     *\n     *     LinkedList.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n     *     => LinkedList.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n     *\n     * also see [[ConsLinkedList.sortBy]]\n     */\n    sortOn(...getKeys: Array<ToOrderable<T>|{desc:ToOrderable<T>}>): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Remove duplicate items; elements are mapped to keys, those\n     * get compared.\n     *\n     *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)\n     *     => LinkedList.of(1,2,3)\n     */\n    distinctBy<U>(keyExtractor: (x:T)=>U&WithEquality): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Call a function for element in the collection.\n     */\n    forEach(fn: (v:T)=>void): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Reduces the collection to a single value by repeatedly\n     * calling the combine function.\n     * No starting value. The order in which the elements are\n     * passed to the combining function is undetermined.\n     */\n    reduce(combine: (v1:T,v2:T)=>T): Option<T> {\n        return SeqHelpers.reduce(this, combine);\n    }\n\n    /**\n     * Compare values in the collection and return the smallest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsLinkedList.minOn]]\n     */\n    minBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return SeqHelpers.minBy(this, compare);\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the smallest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n     *     => Option.of({name:\"Paula\", age:6})\n     *\n     * also see [[ConsLinkedList.minBy]]\n     */\n    minOn(getOrderable: ToOrderable<T>): Option<T> {\n        return SeqHelpers.minOn(this, getOrderable);\n    }\n\n    /**\n     * Compare values in the collection and return the largest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsLinkedList.maxOn]]\n     */\n    maxBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return SeqHelpers.maxBy(this, compare);\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the largest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n     *     => Option.of({name:\"Joe\", age:12})\n     *\n     * also see [[ConsLinkedList.maxBy]]\n     */\n    maxOn(getOrderable: ToOrderable<T>): Option<T> {\n        return SeqHelpers.maxOn(this, getOrderable);\n    }\n\n    /**\n     * Call the function you give for each element in the collection\n     * and sum all the numbers, return that sum.\n     * Will return 0 if the collection is empty.\n     *\n     *     LinkedList.of(1,2,3).sumOn(x=>x)\n     *     => 6\n     */\n    sumOn(getNumber: (v:T)=>number): number {\n        return SeqHelpers.sumOn(this, getNumber);\n    }\n\n    /**\n     * Slides a window of a specific size over the sequence.\n     * Returns a lazy stream so memory use is not prohibitive.\n     *\n     *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)\n     *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))\n     */\n    sliding(count:number): Stream<ConsLinkedList<T>> {\n        return <Stream<ConsLinkedList<T>>>SeqHelpers.sliding(this, count);\n    }\n\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     * The last element of the result is the final cumulative result.\n     *\n     *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n     *     => LinkedList.of(0,1,3,6)\n     */\n    scanLeft<U>(init:U, fn:(soFar:U,cur:T)=>U): LinkedList<U> {\n        return LinkedList.of<U>(init);\n    }\n\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     * The first element of the result is the final cumulative result.\n     *\n     *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n     *     => LinkedList.of(6,5,3,0)\n     */\n    scanRight<U>(init:U, fn:(cur:T,soFar:U)=>U): LinkedList<U> {\n        return LinkedList.of<U>(init);\n    }\n\n    /**\n     * Joins elements of the collection by a separator.\n     * Example:\n     *\n     *     LinkedList.of(1,2,3).mkString(\", \")\n     *     => \"1, 2, 3\"\n     */\n    mkString(separator: string): string {\n        return \"\";\n    }\n\n    /**\n     * Convert to array.\n     * Don't do it on an infinite stream!\n     */\n    toArray(): T[] {\n        return [];\n    }\n\n    /**\n     * Convert to vector.\n     * Don't do it on an infinite stream!\n     */\n    toVector(): Vector<T> {\n        return Vector.empty<T>();\n    }\n\n    /**\n     * Convert this collection to a map. You give a function which\n     * for each element in the collection returns a pair. The\n     * key of the pair will be used as a key in the map, the value,\n     * as a value in the map. If several values get the same key,\n     * entries will be lost.\n     *\n     *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])\n     *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n     */\n    toMap<K,V>(converter:(x:T)=>[K & WithEquality,V]): HashMap<K,V> {\n        return HashMap.empty<K,V>();\n    }\n\n    /**\n     * Convert this collection to a set. Since the elements of the\n     * Seq may not support equality, you must pass a function returning\n     * a value supporting equality.\n     *\n     *     LinkedList.of(1,2,3,3,4).toSet(x=>x)\n     *     => HashSet.of(1,2,3,4)\n     */\n    toSet<K>(converter:(x:T)=>K&WithEquality): HashSet<K> {\n        return HashSet.empty<K>();\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:LinkedList<T>)=>U): U {\n        return converter(this);\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other: LinkedList<T&WithEquality>): boolean {\n        if (!other) {\n            return false;\n        }\n        return other.isEmpty();\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        return 1;\n    }\n\n    [inspect](): string {\n        return this.toString();\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     *\n     * Also see [[ConsLinkedList.mkString]]\n     */\n    toString(): string {\n        return \"LinkedList()\";\n    }\n}\n\n/**\n * ConsLinkedList holds a value and a pointer to a next element,\n * which could be [[ConsLinkedList]] or [[EmptyLinkedList]].\n * A ConsLinkedList is basically a non-empty linked list. It will\n * contain at least one element.\n * \"static methods\" available through [[LinkedListStatic]]\n * @param T the item type\n */\nexport class ConsLinkedList<T> implements Seq<T> {\n\n    /**\n     * @hidden\n     */\n    readonly className: \"ConsLinkedList\" = <any>undefined;  // https://stackoverflow.com/a/47841595/516188\n\n    /**\n     * @hidden\n     */\n    public constructor(protected value: T, protected _tail: LinkedList<T>) {}\n\n    /**\n     * @hidden\n     */\n    hasTrueEquality(): boolean {\n        return SeqHelpers.seqHasTrueEquality<T>(this);\n    }\n\n    /**\n     * View this Some a as LinkedList. Useful to help typescript type\n     * inference sometimes.\n     */\n    asLinkedList(): LinkedList<T> {\n        return this;\n    }\n\n    /**\n     * Implementation of the Iterator interface.\n     */\n    [Symbol.iterator](): Iterator<T> {\n        let item: LinkedList<T> = this;\n        return {\n            next(): IteratorResult<T> {\n                if (item.isEmpty()) {\n                    return { done: true, value: <any>undefined };\n                }\n                const value = item.head().get();\n                item = item.tail().get();\n                return {done: false, value};\n            }\n        };\n    }\n\n    /**\n     * Get the length of the collection.\n     */\n    length(): number {\n        return this.foldLeft(0, (n, ignored) => n + 1);\n    }\n\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    single(): Option<T> {\n        return this._tail.isEmpty() ?\n            Option.of(this.value) :\n            Option.none<T>();\n    }\n\n    /**\n     * true if the collection is empty, false otherwise.\n     */\n    isEmpty(): this is EmptyLinkedList<T> {\n        return false;\n    }\n\n    /**\n     * Get the first value of the collection, if any.\n     * In this case the list is not empty, so returns Option.some\n     */\n    head(): Some<T> {\n        return Option.some(this.value);\n    }\n\n    /**\n     * Get all the elements in the collection but the first one.\n     * If the collection is empty, return None.\n     */\n    tail(): Some<LinkedList<T>> {\n        return Option.some(this._tail);\n    }\n\n    /**\n     * Get the last value of the collection, if any.\n     * returns Option.Some if the collection is not empty,\n     * Option.None if it's empty.\n     */\n    last(): Some<T> {\n        let curItem: LinkedList<T> = this;\n        while (true) {\n            const item = (<ConsLinkedList<T>>curItem).value;\n            curItem = (<ConsLinkedList<T>>curItem)._tail;\n            if (curItem.isEmpty()) {\n                return Option.some(item);\n            }\n        }\n    }\n\n    /**\n     * Retrieve the element at index idx.\n     * Returns an option because the collection may\n     * contain less elements than the index.\n     *\n     * Careful this is going to have poor performance\n     * on LinkedList, which is not a good data structure\n     * for random access!\n     */\n    get(idx: number): Option<T> {\n        let curItem: LinkedList<T> = this;\n        let i=0;\n        while (!curItem.isEmpty()) {\n            if (i === idx) {\n                const item = curItem.value;\n                return Option.of(item);\n            }\n            curItem = curItem._tail;\n            ++i;\n        }\n        return Option.none<T>();\n    }\n\n    /**\n     * Search for an item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     */\n    find(predicate:(v:T)=>boolean): Option<T> {\n        let curItem: LinkedList<T> = this;\n        while (!curItem.isEmpty()) {\n            const item = curItem.value;\n            if (predicate(item)) {\n                return Option.of(item);\n            }\n            curItem = curItem._tail;\n        }\n        return Option.none<T>();\n    }\n\n    /**\n     * Returns true if the item is in the collection,\n     * false otherwise.\n     */\n    contains(v:T&WithEquality): boolean {\n        return this.find(x => areEqual(x,v)).isSome();\n    }\n\n    /**\n     * Return a new stream keeping only the first n elements\n     * from this stream.\n     */\n    take(n: number): LinkedList<T> {\n        let result = <LinkedList<T>><EmptyLinkedList<T>>emptyLinkedList;\n        let curItem: LinkedList<T> = this;\n        let i = 0;\n        while (i++ < n && (!curItem.isEmpty())) {\n            result = new ConsLinkedList(curItem.value, result);\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    }\n\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate.\n     */\n    takeWhile(predicate: (x:T)=>boolean): LinkedList<T> {\n        let result = <LinkedList<T>><EmptyLinkedList<T>>emptyLinkedList;\n        let curItem: LinkedList<T> = this;\n        while ((!curItem.isEmpty()) && predicate(curItem.value)) {\n            result = new ConsLinkedList(curItem.value, result);\n            curItem =curItem._tail;\n        }\n        return result.reverse();\n    }\n\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate,\n     * but starting from the end of the collection.\n     *\n     *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)\n     *     => LinkedList.of(3,4)\n     */\n    takeRightWhile(predicate:(x:T)=>boolean): LinkedList<T> {\n        return this.reverse().takeWhile(predicate).reverse();\n    }\n\n    /**\n     * Returns a new collection with the first\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    drop(n:number): LinkedList<T> {\n        let i = n;\n        let curItem: LinkedList<T> = this;\n        while (i-- > 0 && !curItem.isEmpty()) {\n            curItem = curItem._tail;\n        }\n        return curItem;\n    }\n\n    /**\n     * Returns a new collection, discarding the first elements\n     * until one element fails the predicate. All elements\n     * after that point are retained.\n     */\n    dropWhile(predicate:(x:T)=>boolean): LinkedList<T> {\n        let curItem: LinkedList<T> = this;\n        while (!curItem.isEmpty() && predicate(curItem.value)) {\n            curItem = curItem._tail;\n        }\n        return curItem;\n    }\n\n    /**\n     * Returns a new collection with the last\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    dropRight(n:number): LinkedList<T> {\n        // going twice through the list...\n        const length = this.length();\n        return this.take(length-n);\n    }\n\n    /**\n     * Returns a new collection, discarding the last elements\n     * until one element fails the predicate. All elements\n     * before that point are retained.\n     */\n    dropRightWhile(predicate:(x:T)=>boolean): LinkedList<T> {\n        return this.reverse().dropWhile(predicate).reverse();\n    }\n\n    /**\n     * Reduces the collection to a single value using the\n     * associative binary function you give. Since the function\n     * is associative, order of application doesn't matter.\n     *\n     * Example:\n     *\n     *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);\n     *     => 6\n     */\n    fold(zero:T, fn:(v1:T,v2:T)=>T): T {\n        return this.foldLeft(zero, fn);\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Left-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n     *     => \"cba!\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the previous value and\n     *           the current collection item, and returning\n     *           an updated value.\n     */\n    foldLeft<U>(zero: U, fn:(soFar:U,cur:T)=>U): U {\n        let r = zero;\n        let curItem: LinkedList<T> = this;\n        while (!curItem.isEmpty()) {\n            r = fn(r, curItem.value);\n            curItem = curItem._tail;\n        }\n        return r;\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Right-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n     *     => \"!cba\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the current collection item and\n     *           the previous value , and returning\n     *           an updated value.\n     */\n    foldRight<U>(zero: U, fn:(cur:T, soFar:U)=>U): U {\n        return this.reverse().foldLeft(zero, (xs,x)=>fn(x,xs));\n    }\n\n    /**\n     * Combine this collection with the collection you give in\n     * parameter to produce a new collection which combines both,\n     * in pairs. For instance:\n     *\n     *     Vector.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n     *     => Vector.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n     *\n     * The result collection will have the length of the shorter\n     * of both collections. Extra elements will be discarded.\n     *\n     * Also see [[LinkedListStatic.zip]] (static version which can more than two\n     * iterables)\n     */\n    zip<U>(other: Iterable<U>): LinkedList<[T,U]> {\n        const otherIterator = other[Symbol.iterator]();\n        let otherCurItem = otherIterator.next();\n\n        let curItem: LinkedList<T> = this;\n        let result: LinkedList<[T,U]> = <EmptyLinkedList<[T,U]>>emptyLinkedList;\n\n        while ((!curItem.isEmpty()) && (!otherCurItem.done)) {\n            result = new ConsLinkedList(\n                [curItem.value, otherCurItem.value] as [T,U], result);\n            curItem = curItem._tail;\n            otherCurItem = otherIterator.next();\n        }\n        return result.reverse();\n    }\n\n    /**\n     * Combine this collection with the index of the elements\n     * in it. Handy if you need the index when you map on\n     * the collection for instance:\n     *\n     *     LinkedList.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n     *     => LinkedList.of(\"a0\", \"b1\")\n     */\n    zipWithIndex(): LinkedList<[T,number]> {\n        return <LinkedList<[T,number]>>SeqHelpers.zipWithIndex<T>(this);\n    }\n\n    /**\n     * Reverse the collection. For instance:\n     *\n     *     LinkedList.of(1,2,3).reverse();\n     *     => LinkedList.of(3,2,1)\n     */\n    reverse(): LinkedList<T> {\n        return this.foldLeft(<LinkedList<T>><EmptyLinkedList<T>>emptyLinkedList, (xs,x) => xs.prepend(x));\n    }\n\n    /**\n     * Takes a predicate; returns a pair of collections.\n     * The first one is the longest prefix of this collection\n     * which satisfies the predicate, and the second collection\n     * is the remainder of the collection.\n     *\n     *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)\n     *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]\n     */\n    span(predicate:(x:T)=>boolean): [LinkedList<T>,LinkedList<T>] {\n        let first: LinkedList<T> = <EmptyLinkedList<T>>emptyLinkedList;\n        let curItem: LinkedList<T> = this;\n        while ((!curItem.isEmpty()) && predicate(curItem.value)) {\n            first = new ConsLinkedList(curItem.value, first);\n            curItem = curItem._tail;\n        }\n        return [first.reverse(), curItem];\n    }\n\n    /**\n     * Split the collection at a specific index.\n     *\n     *     LinkedList.of(1,2,3,4,5).splitAt(3)\n     *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]\n     */\n    splitAt(index:number): [LinkedList<T>,LinkedList<T>] {\n        let first: LinkedList<T> = <EmptyLinkedList<T>>emptyLinkedList;\n        let curItem: LinkedList<T> = this;\n        let i = 0;\n        while (i++ < index && (!curItem.isEmpty())) {\n            first = new ConsLinkedList(curItem.value, first);\n            curItem = curItem._tail;\n        }\n        return [first.reverse(), curItem];\n    }\n\n    /**\n     * Returns a pair of two collections; the first one\n     * will only contain the items from this collection for\n     * which the predicate you give returns true, the second\n     * will only contain the items from this collection where\n     * the predicate returns false.\n     *\n     *     LinkedList.of(1,2,3,4).partition(x => x%2===0)\n     *     => [LinkedList.of(2,4),LinkedList.of(1,3)]\n     */\n    partition<U extends T>(predicate:(v:T)=>v is U): [LinkedList<U>,LinkedList<Exclude<T,U>>];\n    partition(predicate:(x:T)=>boolean): [LinkedList<T>,LinkedList<T>];\n    partition(predicate:(v:T)=>boolean): [LinkedList<T>,LinkedList<T>] {\n        let fst = LinkedList.empty<T>();\n        let snd = LinkedList.empty<T>();\n        let curItem: LinkedList<T> = this;\n        while (!curItem.isEmpty()) {\n            if (predicate(curItem.value)) {\n                fst = new ConsLinkedList(curItem.value, fst);\n            } else {\n                snd = new ConsLinkedList(curItem.value, snd);\n            }\n            curItem = curItem._tail;\n        }\n        return [fst.reverse(), snd.reverse()];\n    }\n\n    /**\n     * Group elements in the collection using a classifier function.\n     * Elements are then organized in a map. The key is the value of\n     * the classifier, and in value we get the list of elements\n     * matching that value.\n     *\n     * also see [[ConsLinkedList.arrangeBy]]\n     */\n    groupBy<C>(classifier: (v:T)=>C & WithEquality): HashMap<C,LinkedList<T>> {\n        return this.foldLeft(\n            HashMap.empty<C,LinkedList<T>>(),\n            (acc: HashMap<C,LinkedList<T>>, v:T) =>\n                acc.putWithMerge(\n                    classifier(v), LinkedList.of(v),\n                    (v1:LinkedList<T>,v2:LinkedList<T>)=>\n                        v1.prepend(v2.single().getOrThrow())))\n            .mapValues(l => l.reverse());\n    }\n\n    /**\n     * Matches each element with a unique key that you extract from it.\n     * If the same key is present twice, the function will return None.\n     *\n     * also see [[ConsLinkedList.groupBy]]\n     */\n    arrangeBy<K>(getKey: (v:T)=>K&WithEquality): Option<HashMap<K,T>> {\n        return SeqHelpers.arrangeBy<T,K>(this, getKey);\n    }\n\n    /**\n     * Randomly reorder the elements of the collection.\n     */\n    shuffle(): LinkedList<T> {\n        return LinkedList.ofIterable<T>(SeqHelpers.shuffle(this.toArray()));\n    }\n\n    /**\n     * Append an element at the end of this LinkedList.\n     * Warning: appending in a loop on a linked list is going\n     * to be very slow!\n     */\n    append(v:T): LinkedList<T> {\n        return new ConsLinkedList(\n            this.value,\n            this._tail.append(v));\n    }\n\n    /*\n     * Append multiple elements at the end of this LinkedList.\n     */\n    appendAll(elts:Iterable<T>): LinkedList<T> {\n        return LinkedList.ofIterable(elts).prependAll(<LinkedList<T>>this);\n    }\n\n    /**\n     * Remove multiple elements from a LinkedList\n     *\n     *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])\n     *     => LinkedList.of(1,3,3,1)\n     */\n    removeAll(elts:Iterable<T&WithEquality>): LinkedList<T> {\n        return <LinkedList<T>><any>SeqHelpers.removeAll(this, elts);\n    }\n\n    /**\n     * Removes the first element matching the predicate\n     * (use [[Seq.filter]] to remove all elements matching a predicate)\n     */\n    removeFirst(predicate: (x:T)=>boolean): LinkedList<T> {\n        let curItem: LinkedList<T> = this;\n        let result: LinkedList<T> = <EmptyLinkedList<T>>emptyLinkedList;\n        let removed = false;\n        while (!curItem.isEmpty()) {\n            if (predicate(curItem.value) && !removed) {\n                removed = true;\n            } else {\n                result = new ConsLinkedList(curItem.value, result);\n            }\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    }\n\n    /**\n     * Prepend an element at the beginning of the collection.\n     */\n    prepend(elt: T): LinkedList<T> {\n        return new ConsLinkedList(elt, this);\n    }\n\n    /**\n     * Prepend multiple elements at the beginning of the collection.\n     */\n    prependAll(elts: Iterable<T>): LinkedList<T> {\n        let leftToAdd = LinkedList.ofIterable(elts).reverse();\n        let result: LinkedList<T> = this;\n        while (!leftToAdd.isEmpty()) {\n            result = new ConsLinkedList(leftToAdd.value, result);\n            leftToAdd = leftToAdd._tail;\n        }\n        return result;\n    }\n\n    /**\n     * Return a new collection where each element was transformed\n     * by the mapper function you give.\n     */\n    map<U>(mapper:(v:T)=>U): LinkedList<U> {\n        let curItem: LinkedList<T> = this;\n        let result: LinkedList<U> = <EmptyLinkedList<U>>emptyLinkedList;\n        while (!curItem.isEmpty()) {\n            result = new ConsLinkedList(mapper(curItem.value), result);\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    }\n\n    /**\n     * Apply the mapper function on every element of this collection.\n     * The mapper function returns an Option; if the Option is a Some,\n     * the value it contains is added to the result Collection, if it's\n     * a None, the value is discarded.\n     *\n     *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?\n     *         Option.of(x+1) : Option.none<number>())\n     *     => LinkedList.of(3, 7)\n     */\n    mapOption<U>(mapper:(v:T)=>Option<U>): LinkedList<U> {\n        let curItem: LinkedList<T> = this;\n        let result: LinkedList<U> = <EmptyLinkedList<U>>emptyLinkedList;\n        while (!curItem.isEmpty()) {\n            const mapped = mapper(curItem.value);\n            if (mapped.isSome()) {\n                result = new ConsLinkedList(mapped.get(), result);\n            }\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    }\n\n    /**\n     * Calls the function you give for each item in the collection,\n     * your function returns a collection, all the collections are\n     * concatenated.\n     * This is the monadic bind.\n     */\n    flatMap<U>(mapper:(v:T)=>LinkedList<U>): LinkedList<U> {\n        let curItem: LinkedList<T> = this;\n        let result: LinkedList<U> = <EmptyLinkedList<U>>emptyLinkedList;\n        while (!curItem.isEmpty()) {\n            result = result.prependAll(mapper(curItem.value).reverse());\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    }\n\n    /**\n     * Returns true if the predicate returns true for all the\n     * elements in the collection.\n     */\n    allMatch<U extends T>(predicate:(v:T)=>v is U): this is LinkedList<U>;\n    allMatch(predicate:(v:T)=>boolean): boolean;\n    allMatch(predicate:(v:T)=>boolean): boolean {\n        return this.find(x => !predicate(x)).isNone();\n    }\n\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    anyMatch(predicate:(v:T)=>boolean): boolean {\n        return this.find(predicate).isSome();\n    }\n\n    /**\n     * Call a predicate for each element in the collection,\n     * build a new collection holding only the elements\n     * for which the predicate returned true.\n     */\n    filter<U extends T>(predicate:(v:T)=>v is U): LinkedList<U>;\n    filter(predicate:(v:T)=>boolean): LinkedList<T>;\n    filter(predicate:(v:T)=>boolean): LinkedList<T> {\n        let curItem: LinkedList<T> = this;\n        let result: LinkedList<T> = <EmptyLinkedList<T>>emptyLinkedList;\n        while (!curItem.isEmpty()) {\n            if (predicate(curItem.value)) {\n                result = new ConsLinkedList(curItem.value, result);\n            }\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    }\n\n    /**\n     * Returns a new collection with elements\n     * sorted according to the comparator you give.\n     *\n     *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n     *     LinkedList.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n     *     => LinkedList.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n     *\n     * also see [[ConsLinkedList.sortOn]]\n     */\n    sortBy(compare: (v1:T,v2:T)=>Ordering): LinkedList<T> {\n        return LinkedList.ofIterable<T>(this.toArray().sort(compare));\n    }\n\n    /**\n     * Give a function associating a number or a string with\n     * elements from the collection, and the elements\n     * are sorted according to that value.\n     *\n     *     LinkedList.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n     *     => LinkedList.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n     *\n     * You can also sort by multiple criteria, and request 'descending'\n     * sorting:\n     *\n     *     LinkedList.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n     *     => LinkedList.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n     *\n     * also see [[ConsLinkedList.sortBy]]\n     */\n    sortOn(...getKeys: Array<ToOrderable<T>|{desc:ToOrderable<T>}>): LinkedList<T> {\n        return <LinkedList<T>>SeqHelpers.sortOn<T>(this, getKeys);\n    }\n\n    /**\n     * Remove duplicate items; elements are mapped to keys, those\n     * get compared.\n     *\n     *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)\n     *     => LinkedList.of(1,2,3)\n     */\n    distinctBy<U>(keyExtractor: (x:T)=>U&WithEquality): LinkedList<T> {\n        return <LinkedList<T>>SeqHelpers.distinctBy(this, keyExtractor);\n    }\n\n    /**\n     * Call a function for element in the collection.\n     */\n    forEach(fn: (v:T)=>void): LinkedList<T> {\n        let curItem: LinkedList<T> = this;\n        while (!curItem.isEmpty()) {\n            fn(curItem.value);\n            curItem = curItem._tail;\n        }\n        return this;\n    }\n\n    /**\n     * Reduces the collection to a single value by repeatedly\n     * calling the combine function.\n     * No starting value. The order in which the elements are\n     * passed to the combining function is undetermined.\n     */\n    reduce(combine: (v1:T,v2:T)=>T): Option<T> {\n        return SeqHelpers.reduce(this, combine);\n    }\n\n    /**\n     * Compare values in the collection and return the smallest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsLinkedList.minOn]]\n     */\n    minBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return SeqHelpers.minBy(this, compare);\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the smallest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n     *     => Option.of({name:\"Paula\", age:6})\n     *\n     * also see [[ConsLinkedList.minBy]]\n     */\n    minOn(getOrderable: ToOrderable<T>): Option<T> {\n        return SeqHelpers.minOn(this, getOrderable);\n    }\n\n    /**\n     * Compare values in the collection and return the largest element.\n     * Returns Option.none if the collection is empty.\n     *\n     *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n     *     => Option.of({name:\"Joe\", age:12})\n     *\n     * also see [[ConsLinkedList.maxOn]]\n     */\n    maxBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return SeqHelpers.maxBy(this, compare);\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the largest.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsLinkedList.maxBy]]\n     */\n    maxOn(getOrderable: ToOrderable<T>): Option<T> {\n        return SeqHelpers.maxOn(this, getOrderable);\n    }\n\n    /**\n     * Call the function you give for each element in the collection\n     * and sum all the numbers, return that sum.\n     * Will return 0 if the collection is empty.\n     *\n     *     LinkedList.of(1,2,3).sumOn(x=>x)\n     *     => 6\n     */\n    sumOn(getNumber: (v:T)=>number): number {\n        return SeqHelpers.sumOn(this, getNumber);\n    }\n\n    /**\n     * Slides a window of a specific size over the sequence.\n     * Returns a lazy stream so memory use is not prohibitive.\n     *\n     *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)\n     *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))\n     */\n    sliding(count:number): Stream<ConsLinkedList<T>> {\n        return <Stream<ConsLinkedList<T>>>SeqHelpers.sliding(this, count);\n    }\n\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     *\n     *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n     *     => LinkedList.of(0,1,3,6)\n     */\n    scanLeft<U>(init:U, fn:(soFar:U,cur:T)=>U): LinkedList<U> {\n        let result = LinkedList.of(init);\n        let curItem: LinkedList<T> = this;\n        let soFar = init;\n        while (!curItem.isEmpty()) {\n            soFar = fn(soFar, curItem.value);\n            result = new ConsLinkedList(soFar, result);\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    }\n\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     * The first element of the result is the final cumulative result.\n     *\n     *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n     *     => LinkedList.of(6,5,3,0)\n     */\n    scanRight<U>(init:U, fn:(cur:T,soFar:U)=>U): LinkedList<U> {\n        let result = LinkedList.of(init);\n        let curItem: LinkedList<T> = this.reverse();\n        let soFar = init;\n        while (!curItem.isEmpty()) {\n            soFar = fn(curItem.value, soFar);\n            result = new ConsLinkedList(soFar, result);\n            curItem = curItem._tail;\n        }\n        return result;\n    }\n\n    /**\n     * Joins elements of the collection by a separator.\n     * Example:\n     *\n     *     LinkedList.of(1,2,3).mkString(\", \")\n     *     => \"1, 2, 3\"\n     */\n    mkString(separator: string): string {\n        let r = \"\";\n        let curItem: LinkedList<T> = this;\n        let isNotFirst = false;\n        while (!curItem.isEmpty()) {\n            if (isNotFirst) {\n                r += separator;\n            }\n            r += SeqHelpers.toStringHelper(curItem.value, {quoteStrings:false});\n            curItem = curItem._tail;\n            isNotFirst = true;\n        }\n        return r;\n    }\n\n    /**\n     * Convert to array.\n     * Don't do it on an infinite stream!\n     */\n    toArray(): T[] {\n        let r:T[] = [];\n        let curItem: LinkedList<T> = this;\n        while (!curItem.isEmpty()) {\n            r.push(curItem.value);\n            curItem = curItem._tail;\n        }\n        return r;\n    }\n\n    /**\n     * Convert to vector.\n     * Don't do it on an infinite stream!\n     */\n    toVector(): Vector<T> {\n        return Vector.ofIterable<T>(this.toArray());\n    }\n\n    /**\n     * Convert this collection to a map. You give a function which\n     * for each element in the collection returns a pair. The\n     * key of the pair will be used as a key in the map, the value,\n     * as a value in the map. If several values get the same key,\n     * entries will be lost.\n     *\n     *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])\n     *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n     */\n    toMap<K,V>(converter:(x:T)=>[K & WithEquality,V]): HashMap<K,V> {\n        return this.foldLeft(HashMap.empty<K,V>(), (acc,cur) => {\n            const converted = converter(cur);\n            return acc.put(converted[0], converted[1]);\n        });\n    }\n\n    /**\n     * Convert this collection to a set. Since the elements of the\n     * Seq may not support equality, you must pass a function returning\n     * a value supporting equality.\n     *\n     *     LinkedList.of(1,2,3,3,4).toSet(x=>x)\n     *     => HashSet.of(1,2,3,4)\n     */\n    toSet<K>(converter:(x:T)=>K&WithEquality): HashSet<K> {\n        return this.foldLeft(HashSet.empty<K>(), (acc,cur) => {\n            return acc.add(converter(cur));\n        });\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:LinkedList<T>)=>U): U {\n        return converter(this);\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other: LinkedList<T&WithEquality>): boolean {\n        if (<any>other === this) {\n            return true;\n        }\n        if (!other || !other.tail) {\n            return false;\n        }\n        contractTrueEquality(\"LinkedList.equals\", this, other);\n        let myVal: LinkedList<T> = this;\n        let hisVal = other;\n        while (true) {\n            if (myVal.isEmpty() !== hisVal.isEmpty()) {\n                return false;\n            }\n            if (myVal.isEmpty()) {\n                // they are both empty, end of the stream\n                return true;\n            }\n            const myHead = myVal.value;\n            const hisHead = (<ConsLinkedList<T>>hisVal).value;\n\n            if ((myHead === undefined) !== (hisHead === undefined)) {\n                return false;\n            }\n            if (myHead === undefined || hisHead === undefined) {\n                // they are both undefined, the || is for TS's flow analysis\n                // so he realizes none of them is undefined after this.\n                continue;\n            }\n            if (!areEqual(myHead, hisHead)) {\n                return false;\n            }\n            myVal = myVal._tail;\n            hisVal = (<ConsLinkedList<T&WithEquality>>hisVal)._tail;\n        }\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        let hash = 1;\n        let curItem: LinkedList<T> = this;\n        while (!curItem.isEmpty()) {\n            hash = 31 * hash + getHashCode(curItem.value);\n            curItem = curItem._tail;\n        }\n        return hash;\n    }\n\n    [inspect](): string {\n        return this.toString();\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     *\n     * Also see [[ConsLinkedList.mkString]]\n     */\n    toString(): string {\n        let curItem: LinkedList<T> = this;\n        let result = \"LinkedList(\";\n\n        while (!curItem.isEmpty()) {\n            result += SeqHelpers.toStringHelper(curItem.value);\n            const tail: LinkedList<T> = curItem._tail;\n            curItem = tail;\n            if (!curItem.isEmpty()) {\n                result += \", \";\n            }\n        }\n\n        return result + \")\";\n    }\n}\n\nconst emptyLinkedList = new EmptyLinkedList<any>();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}