{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { SubjectSubscriber } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nvar ConnectableObservable = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ConnectableObservable, _super);\n  function ConnectableObservable(source, subjectFactory) {\n    var _this = _super.call(this) || this;\n    _this.source = source;\n    _this.subjectFactory = subjectFactory;\n    _this._refCount = 0;\n    _this._isComplete = false;\n    return _this;\n  }\n  ConnectableObservable.prototype._subscribe = function (subscriber) {\n    return this.getSubject().subscribe(subscriber);\n  };\n  ConnectableObservable.prototype.getSubject = function () {\n    var subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  };\n  ConnectableObservable.prototype.connect = function () {\n    var connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  };\n  ConnectableObservable.prototype.refCount = function () {\n    return higherOrderRefCount()(this);\n  };\n  return ConnectableObservable;\n}(Observable);\nexport { ConnectableObservable };\nexport var connectableObservableDescriptor = /*@__PURE__*/function () {\n  var connectableProto = ConnectableObservable.prototype;\n  return {\n    operator: {\n      value: null\n    },\n    _refCount: {\n      value: 0,\n      writable: true\n    },\n    _subject: {\n      value: null,\n      writable: true\n    },\n    _connection: {\n      value: null,\n      writable: true\n    },\n    _subscribe: {\n      value: connectableProto._subscribe\n    },\n    _isComplete: {\n      value: connectableProto._isComplete,\n      writable: true\n    },\n    getSubject: {\n      value: connectableProto.getSubject\n    },\n    connect: {\n      value: connectableProto.connect\n    },\n    refCount: {\n      value: connectableProto.refCount\n    }\n  };\n}();\nvar ConnectableSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ConnectableSubscriber, _super);\n  function ConnectableSubscriber(destination, connectable) {\n    var _this = _super.call(this, destination) || this;\n    _this.connectable = connectable;\n    return _this;\n  }\n  ConnectableSubscriber.prototype._error = function (err) {\n    this._unsubscribe();\n    _super.prototype._error.call(this, err);\n  };\n  ConnectableSubscriber.prototype._complete = function () {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    _super.prototype._complete.call(this);\n  };\n  ConnectableSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      var connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  };\n  return ConnectableSubscriber;\n}(SubjectSubscriber);\nvar RefCountOperator = /*@__PURE__*/function () {\n  function RefCountOperator(connectable) {\n    this.connectable = connectable;\n  }\n  RefCountOperator.prototype.call = function (subscriber, source) {\n    var connectable = this.connectable;\n    connectable._refCount++;\n    var refCounter = new RefCountSubscriber(subscriber, connectable);\n    var subscription = source.subscribe(refCounter);\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n    return subscription;\n  };\n  return RefCountOperator;\n}();\nvar RefCountSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(RefCountSubscriber, _super);\n  function RefCountSubscriber(destination, connectable) {\n    var _this = _super.call(this, destination) || this;\n    _this.connectable = connectable;\n    return _this;\n  }\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n    this.connectable = null;\n    var refCount = connectable._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n    connectable._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n  return RefCountSubscriber;\n}(Subscriber);","map":{"version":3,"names":["tslib_1","SubjectSubscriber","Observable","Subscriber","Subscription","refCount","higherOrderRefCount","ConnectableObservable","_super","__extends","source","subjectFactory","_this","call","_refCount","prototype","_subscribe","subscriber","getSubject","subscribe","subject","_subject","isStopped","connect","connection","_connection","_isComplete","add","ConnectableSubscriber","closed","EMPTY","connectableObservableDescriptor","connectableProto","operator","value","writable","destination","connectable","_error","err","_unsubscribe","_complete","unsubscribe","RefCountOperator","refCounter","RefCountSubscriber","subscription","sharedConnection"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/radixdlt/node_modules/rxjs/src/internal/observable/ConnectableObservable.ts"],"sourcesContent":["import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic } from '../types';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  protected _subject: Subject<T>;\n  protected _refCount: number = 0;\n  protected _connection: Subscription;\n  /** @internal */\n  _isComplete = false;\n\n  constructor(public source: Observable<T>,\n              protected subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = (() => {\n  const connectableProto = <any>ConnectableObservable.prototype;\n  return {\n    operator: { value: null as null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null as null, writable: true },\n    _connection: { value: null as null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n  };\n})();\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  protected _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // ).subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}