{"ast":null,"code":"import { __extends, __read, __spreadArray, __values } from \"tslib\";\nimport { Observable } from '../Observable';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { COMPLETE_NOTIFICATION, errorNotification, nextNotification } from '../NotificationFactories';\nimport { dateTimestampProvider } from '../scheduler/dateTimestampProvider';\nimport { performanceTimestampProvider } from '../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../scheduler/animationFrameProvider';\nimport { immediateProvider } from '../scheduler/immediateProvider';\nimport { intervalProvider } from '../scheduler/intervalProvider';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\nvar defaultMaxFrame = 750;\nvar TestScheduler = function (_super) {\n  __extends(TestScheduler, _super);\n  function TestScheduler(assertDeepEqual) {\n    var _this = _super.call(this, VirtualAction, defaultMaxFrame) || this;\n    _this.assertDeepEqual = assertDeepEqual;\n    _this.hotObservables = [];\n    _this.coldObservables = [];\n    _this.flushTests = [];\n    _this.runMode = false;\n    return _this;\n  }\n  TestScheduler.prototype.createTime = function (marbles) {\n    var indexOf = this.runMode ? marbles.trim().indexOf('|') : marbles.indexOf('|');\n    if (indexOf === -1) {\n      throw new Error('marble diagram for time should have a completion marker \"|\"');\n    }\n    return indexOf * TestScheduler.frameTimeFactor;\n  };\n  TestScheduler.prototype.createColdObservable = function (marbles, values, error) {\n    if (marbles.indexOf('^') !== -1) {\n      throw new Error('cold observable cannot have subscription offset \"^\"');\n    }\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('cold observable cannot have unsubscription marker \"!\"');\n    }\n    var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    var cold = new ColdObservable(messages, this);\n    this.coldObservables.push(cold);\n    return cold;\n  };\n  TestScheduler.prototype.createHotObservable = function (marbles, values, error) {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('hot observable cannot have unsubscription marker \"!\"');\n    }\n    var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    var subject = new HotObservable(messages, this);\n    this.hotObservables.push(subject);\n    return subject;\n  };\n  TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {\n    var _this = this;\n    var messages = [];\n    observable.subscribe(function (value) {\n      messages.push({\n        frame: _this.frame - outerFrame,\n        notification: nextNotification(value)\n      });\n    }, function (error) {\n      messages.push({\n        frame: _this.frame - outerFrame,\n        notification: errorNotification(error)\n      });\n    }, function () {\n      messages.push({\n        frame: _this.frame - outerFrame,\n        notification: COMPLETE_NOTIFICATION\n      });\n    });\n    return messages;\n  };\n  TestScheduler.prototype.expectObservable = function (observable, subscriptionMarbles) {\n    var _this = this;\n    if (subscriptionMarbles === void 0) {\n      subscriptionMarbles = null;\n    }\n    var actual = [];\n    var flushTest = {\n      actual: actual,\n      ready: false\n    };\n    var subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n    var subscriptionFrame = subscriptionParsed.subscribedFrame === Infinity ? 0 : subscriptionParsed.subscribedFrame;\n    var unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n    var subscription;\n    this.schedule(function () {\n      subscription = observable.subscribe(function (x) {\n        var value = x instanceof Observable ? _this.materializeInnerObservable(x, _this.frame) : x;\n        actual.push({\n          frame: _this.frame,\n          notification: nextNotification(value)\n        });\n      }, function (error) {\n        actual.push({\n          frame: _this.frame,\n          notification: errorNotification(error)\n        });\n      }, function () {\n        actual.push({\n          frame: _this.frame,\n          notification: COMPLETE_NOTIFICATION\n        });\n      });\n    }, subscriptionFrame);\n    if (unsubscriptionFrame !== Infinity) {\n      this.schedule(function () {\n        return subscription.unsubscribe();\n      }, unsubscriptionFrame);\n    }\n    this.flushTests.push(flushTest);\n    var runMode = this.runMode;\n    return {\n      toBe: function (marbles, values, errorValue) {\n        flushTest.ready = true;\n        flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n      },\n      toEqual: function (other) {\n        flushTest.ready = true;\n        flushTest.expected = [];\n        _this.schedule(function () {\n          subscription = other.subscribe(function (x) {\n            var value = x instanceof Observable ? _this.materializeInnerObservable(x, _this.frame) : x;\n            flushTest.expected.push({\n              frame: _this.frame,\n              notification: nextNotification(value)\n            });\n          }, function (error) {\n            flushTest.expected.push({\n              frame: _this.frame,\n              notification: errorNotification(error)\n            });\n          }, function () {\n            flushTest.expected.push({\n              frame: _this.frame,\n              notification: COMPLETE_NOTIFICATION\n            });\n          });\n        }, subscriptionFrame);\n      }\n    };\n  };\n  TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {\n    var flushTest = {\n      actual: actualSubscriptionLogs,\n      ready: false\n    };\n    this.flushTests.push(flushTest);\n    var runMode = this.runMode;\n    return {\n      toBe: function (marblesOrMarblesArray) {\n        var marblesArray = typeof marblesOrMarblesArray === 'string' ? [marblesOrMarblesArray] : marblesOrMarblesArray;\n        flushTest.ready = true;\n        flushTest.expected = marblesArray.map(function (marbles) {\n          return TestScheduler.parseMarblesAsSubscriptions(marbles, runMode);\n        }).filter(function (marbles) {\n          return marbles.subscribedFrame !== Infinity;\n        });\n      }\n    };\n  };\n  TestScheduler.prototype.flush = function () {\n    var _this = this;\n    var hotObservables = this.hotObservables;\n    while (hotObservables.length > 0) {\n      hotObservables.shift().setup();\n    }\n    _super.prototype.flush.call(this);\n    this.flushTests = this.flushTests.filter(function (test) {\n      if (test.ready) {\n        _this.assertDeepEqual(test.actual, test.expected);\n        return false;\n      }\n      return true;\n    });\n  };\n  TestScheduler.parseMarblesAsSubscriptions = function (marbles, runMode) {\n    var _this = this;\n    if (runMode === void 0) {\n      runMode = false;\n    }\n    if (typeof marbles !== 'string') {\n      return new SubscriptionLog(Infinity);\n    }\n    var characters = __spreadArray([], __read(marbles));\n    var len = characters.length;\n    var groupStart = -1;\n    var subscriptionFrame = Infinity;\n    var unsubscriptionFrame = Infinity;\n    var frame = 0;\n    var _loop_1 = function (i) {\n      var nextFrame = frame;\n      var advanceFrameBy = function (count) {\n        nextFrame += count * _this.frameTimeFactor;\n      };\n      var c = characters[i];\n      switch (c) {\n        case ' ':\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n          break;\n        case '-':\n          advanceFrameBy(1);\n          break;\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n        case '^':\n          if (subscriptionFrame !== Infinity) {\n            throw new Error(\"found a second subscription point '^' in a \" + 'subscription marble diagram. There can only be one.');\n          }\n          subscriptionFrame = groupStart > -1 ? groupStart : frame;\n          advanceFrameBy(1);\n          break;\n        case '!':\n          if (unsubscriptionFrame !== Infinity) {\n            throw new Error(\"found a second unsubscription point '!' in a \" + 'subscription marble diagram. There can only be one.');\n          }\n          unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n        default:\n          if (runMode && c.match(/^[0-9]$/)) {\n            if (i === 0 || characters[i - 1] === ' ') {\n              var buffer = characters.slice(i).join('');\n              var match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n              if (match) {\n                i += match[0].length - 1;\n                var duration = parseFloat(match[1]);\n                var unit = match[2];\n                var durationInMs = void 0;\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n                  default:\n                    break;\n                }\n                advanceFrameBy(durationInMs / this_1.frameTimeFactor);\n                break;\n              }\n            }\n          }\n          throw new Error(\"there can only be '^' and '!' markers in a \" + \"subscription marble diagram. Found instead '\" + c + \"'.\");\n      }\n      frame = nextFrame;\n      out_i_1 = i;\n    };\n    var this_1 = this,\n      out_i_1;\n    for (var i = 0; i < len; i++) {\n      _loop_1(i);\n      i = out_i_1;\n    }\n    if (unsubscriptionFrame < 0) {\n      return new SubscriptionLog(subscriptionFrame);\n    } else {\n      return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n    }\n  };\n  TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables, runMode) {\n    var _this = this;\n    if (materializeInnerObservables === void 0) {\n      materializeInnerObservables = false;\n    }\n    if (runMode === void 0) {\n      runMode = false;\n    }\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker \"!\"');\n    }\n    var characters = __spreadArray([], __read(marbles));\n    var len = characters.length;\n    var testMessages = [];\n    var subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n    var frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;\n    var getValue = typeof values !== 'object' ? function (x) {\n      return x;\n    } : function (x) {\n      if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n        return values[x].messages;\n      }\n      return values[x];\n    };\n    var groupStart = -1;\n    var _loop_2 = function (i) {\n      var nextFrame = frame;\n      var advanceFrameBy = function (count) {\n        nextFrame += count * _this.frameTimeFactor;\n      };\n      var notification = void 0;\n      var c = characters[i];\n      switch (c) {\n        case ' ':\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n          break;\n        case '-':\n          advanceFrameBy(1);\n          break;\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n        case '|':\n          notification = COMPLETE_NOTIFICATION;\n          advanceFrameBy(1);\n          break;\n        case '^':\n          advanceFrameBy(1);\n          break;\n        case '#':\n          notification = errorNotification(errorValue || 'error');\n          advanceFrameBy(1);\n          break;\n        default:\n          if (runMode && c.match(/^[0-9]$/)) {\n            if (i === 0 || characters[i - 1] === ' ') {\n              var buffer = characters.slice(i).join('');\n              var match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n              if (match) {\n                i += match[0].length - 1;\n                var duration = parseFloat(match[1]);\n                var unit = match[2];\n                var durationInMs = void 0;\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n                  default:\n                    break;\n                }\n                advanceFrameBy(durationInMs / this_2.frameTimeFactor);\n                break;\n              }\n            }\n          }\n          notification = nextNotification(getValue(c));\n          advanceFrameBy(1);\n          break;\n      }\n      if (notification) {\n        testMessages.push({\n          frame: groupStart > -1 ? groupStart : frame,\n          notification: notification\n        });\n      }\n      frame = nextFrame;\n      out_i_2 = i;\n    };\n    var this_2 = this,\n      out_i_2;\n    for (var i = 0; i < len; i++) {\n      _loop_2(i);\n      i = out_i_2;\n    }\n    return testMessages;\n  };\n  TestScheduler.prototype.createAnimator = function () {\n    var _this = this;\n    if (!this.runMode) {\n      throw new Error('animate() must only be used in run mode');\n    }\n    var lastHandle = 0;\n    var map;\n    var delegate = {\n      requestAnimationFrame: function (callback) {\n        if (!map) {\n          throw new Error('animate() was not called within run()');\n        }\n        var handle = ++lastHandle;\n        map.set(handle, callback);\n        return handle;\n      },\n      cancelAnimationFrame: function (handle) {\n        if (!map) {\n          throw new Error('animate() was not called within run()');\n        }\n        map.delete(handle);\n      }\n    };\n    var animate = function (marbles) {\n      var e_1, _a;\n      if (map) {\n        throw new Error('animate() must not be called more than once within run()');\n      }\n      if (/[|#]/.test(marbles)) {\n        throw new Error('animate() must not complete or error');\n      }\n      map = new Map();\n      var messages = TestScheduler.parseMarbles(marbles, undefined, undefined, undefined, true);\n      try {\n        for (var messages_1 = __values(messages), messages_1_1 = messages_1.next(); !messages_1_1.done; messages_1_1 = messages_1.next()) {\n          var message = messages_1_1.value;\n          _this.schedule(function () {\n            var e_2, _a;\n            var now = _this.now();\n            var callbacks = Array.from(map.values());\n            map.clear();\n            try {\n              for (var callbacks_1 = (e_2 = void 0, __values(callbacks)), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\n                var callback = callbacks_1_1.value;\n                callback(now);\n              }\n            } catch (e_2_1) {\n              e_2 = {\n                error: e_2_1\n              };\n            } finally {\n              try {\n                if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\n              } finally {\n                if (e_2) throw e_2.error;\n              }\n            }\n          }, message.frame);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (messages_1_1 && !messages_1_1.done && (_a = messages_1.return)) _a.call(messages_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n    return {\n      animate: animate,\n      delegate: delegate\n    };\n  };\n  TestScheduler.prototype.createDelegates = function () {\n    var _this = this;\n    var lastHandle = 0;\n    var scheduleLookup = new Map();\n    var run = function () {\n      var now = _this.now();\n      var scheduledRecords = Array.from(scheduleLookup.values());\n      var scheduledRecordsDue = scheduledRecords.filter(function (_a) {\n        var due = _a.due;\n        return due <= now;\n      });\n      var dueImmediates = scheduledRecordsDue.filter(function (_a) {\n        var type = _a.type;\n        return type === 'immediate';\n      });\n      if (dueImmediates.length > 0) {\n        var _a = dueImmediates[0],\n          handle = _a.handle,\n          handler = _a.handler;\n        scheduleLookup.delete(handle);\n        handler();\n        return;\n      }\n      var dueIntervals = scheduledRecordsDue.filter(function (_a) {\n        var type = _a.type;\n        return type === 'interval';\n      });\n      if (dueIntervals.length > 0) {\n        var firstDueInterval = dueIntervals[0];\n        var duration = firstDueInterval.duration,\n          handler = firstDueInterval.handler;\n        firstDueInterval.due = now + duration;\n        firstDueInterval.subscription = _this.schedule(run, duration);\n        handler();\n        return;\n      }\n      var dueTimeouts = scheduledRecordsDue.filter(function (_a) {\n        var type = _a.type;\n        return type === 'timeout';\n      });\n      if (dueTimeouts.length > 0) {\n        var _b = dueTimeouts[0],\n          handle = _b.handle,\n          handler = _b.handler;\n        scheduleLookup.delete(handle);\n        handler();\n        return;\n      }\n      throw new Error('Expected a due immediate or interval');\n    };\n    var immediate = {\n      setImmediate: function (handler) {\n        var handle = ++lastHandle;\n        scheduleLookup.set(handle, {\n          due: _this.now(),\n          duration: 0,\n          handle: handle,\n          handler: handler,\n          subscription: _this.schedule(run, 0),\n          type: 'immediate'\n        });\n        return handle;\n      },\n      clearImmediate: function (handle) {\n        var value = scheduleLookup.get(handle);\n        if (value) {\n          value.subscription.unsubscribe();\n          scheduleLookup.delete(handle);\n        }\n      }\n    };\n    var interval = {\n      setInterval: function (handler, duration) {\n        if (duration === void 0) {\n          duration = 0;\n        }\n        var handle = ++lastHandle;\n        scheduleLookup.set(handle, {\n          due: _this.now() + duration,\n          duration: duration,\n          handle: handle,\n          handler: handler,\n          subscription: _this.schedule(run, duration),\n          type: 'interval'\n        });\n        return handle;\n      },\n      clearInterval: function (handle) {\n        var value = scheduleLookup.get(handle);\n        if (value) {\n          value.subscription.unsubscribe();\n          scheduleLookup.delete(handle);\n        }\n      }\n    };\n    var timeout = {\n      setTimeout: function (handler, duration) {\n        if (duration === void 0) {\n          duration = 0;\n        }\n        var handle = ++lastHandle;\n        scheduleLookup.set(handle, {\n          due: _this.now() + duration,\n          duration: duration,\n          handle: handle,\n          handler: handler,\n          subscription: _this.schedule(run, duration),\n          type: 'timeout'\n        });\n        return handle;\n      },\n      clearTimeout: function (handle) {\n        var value = scheduleLookup.get(handle);\n        if (value) {\n          value.subscription.unsubscribe();\n          scheduleLookup.delete(handle);\n        }\n      }\n    };\n    return {\n      immediate: immediate,\n      interval: interval,\n      timeout: timeout\n    };\n  };\n  TestScheduler.prototype.run = function (callback) {\n    var prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n    var prevMaxFrames = this.maxFrames;\n    TestScheduler.frameTimeFactor = 1;\n    this.maxFrames = Infinity;\n    this.runMode = true;\n    var animator = this.createAnimator();\n    var delegates = this.createDelegates();\n    animationFrameProvider.delegate = animator.delegate;\n    dateTimestampProvider.delegate = this;\n    immediateProvider.delegate = delegates.immediate;\n    intervalProvider.delegate = delegates.interval;\n    timeoutProvider.delegate = delegates.timeout;\n    performanceTimestampProvider.delegate = this;\n    var helpers = {\n      cold: this.createColdObservable.bind(this),\n      hot: this.createHotObservable.bind(this),\n      flush: this.flush.bind(this),\n      time: this.createTime.bind(this),\n      expectObservable: this.expectObservable.bind(this),\n      expectSubscriptions: this.expectSubscriptions.bind(this),\n      animate: animator.animate\n    };\n    try {\n      var ret = callback(helpers);\n      this.flush();\n      return ret;\n    } finally {\n      TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n      this.maxFrames = prevMaxFrames;\n      this.runMode = false;\n      animationFrameProvider.delegate = undefined;\n      dateTimestampProvider.delegate = undefined;\n      immediateProvider.delegate = undefined;\n      intervalProvider.delegate = undefined;\n      timeoutProvider.delegate = undefined;\n      performanceTimestampProvider.delegate = undefined;\n    }\n  };\n  TestScheduler.frameTimeFactor = 10;\n  return TestScheduler;\n}(VirtualTimeScheduler);\nexport { TestScheduler };","map":{"version":3,"names":["Observable","ColdObservable","HotObservable","SubscriptionLog","VirtualTimeScheduler","VirtualAction","COMPLETE_NOTIFICATION","errorNotification","nextNotification","dateTimestampProvider","performanceTimestampProvider","animationFrameProvider","immediateProvider","intervalProvider","timeoutProvider","defaultMaxFrame","TestScheduler","_super","__extends","assertDeepEqual","_this","call","hotObservables","coldObservables","flushTests","runMode","prototype","createTime","marbles","indexOf","trim","Error","frameTimeFactor","createColdObservable","values","error","messages","parseMarbles","undefined","cold","push","createHotObservable","subject","materializeInnerObservable","observable","outerFrame","subscribe","value","frame","notification","expectObservable","subscriptionMarbles","actual","flushTest","ready","subscriptionParsed","parseMarblesAsSubscriptions","subscriptionFrame","subscribedFrame","Infinity","unsubscriptionFrame","unsubscribedFrame","subscription","schedule","x","unsubscribe","toBe","errorValue","expected","toEqual","other","expectSubscriptions","actualSubscriptionLogs","marblesOrMarblesArray","marblesArray","map","filter","flush","length","shift","setup","test","characters","__spreadArray","__read","len","groupStart","i","nextFrame","advanceFrameBy","count","c","match","buffer","slice","join","duration","parseFloat","unit","durationInMs","this_1","out_i_1","materializeInnerObservables","testMessages","subIndex","replace","getValue","this_2","out_i_2","createAnimator","lastHandle","delegate","requestAnimationFrame","callback","handle","set","cancelAnimationFrame","delete","animate","Map","messages_1","__values","messages_1_1","next","done","message","now","callbacks","Array","from","clear","callbacks_1","e_2","callbacks_1_1","createDelegates","scheduleLookup","run","scheduledRecords","scheduledRecordsDue","_a","due","dueImmediates","type","handler","dueIntervals","firstDueInterval","dueTimeouts","_b","immediate","setImmediate","clearImmediate","get","interval","setInterval","clearInterval","timeout","setTimeout","clearTimeout","prevFrameTimeFactor","prevMaxFrames","maxFrames","animator","delegates","helpers","bind","hot","time","ret"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/rxjs/src/internal/testing/TestScheduler.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { TestMessage } from './TestMessage';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { Subscription } from '../Subscription';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { ObservableNotification } from '../types';\nimport { COMPLETE_NOTIFICATION, errorNotification, nextNotification } from '../NotificationFactories';\nimport { dateTimestampProvider } from '../scheduler/dateTimestampProvider';\nimport { performanceTimestampProvider } from '../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../scheduler/animationFrameProvider';\nimport { immediateProvider } from '../scheduler/immediateProvider';\nimport { intervalProvider } from '../scheduler/intervalProvider';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\nconst defaultMaxFrame: number = 750;\n\nexport interface RunHelpers {\n  cold: typeof TestScheduler.prototype.createColdObservable;\n  hot: typeof TestScheduler.prototype.createHotObservable;\n  flush: typeof TestScheduler.prototype.flush;\n  time: typeof TestScheduler.prototype.createTime;\n  expectObservable: typeof TestScheduler.prototype.expectObservable;\n  expectSubscriptions: typeof TestScheduler.prototype.expectSubscriptions;\n  animate: (marbles: string) => void;\n}\n\ninterface FlushableTest {\n  ready: boolean;\n  actual?: any[];\n  expected?: any[];\n}\n\nexport type observableToBeFn = (marbles: string, values?: any, errorValue?: any) => void;\nexport type subscriptionLogsToBeFn = (marbles: string | string[]) => void;\n\nexport class TestScheduler extends VirtualTimeScheduler {\n  /**\n   * The number of virtual time units each character in a marble diagram represents. If\n   * the test scheduler is being used in \"run mode\", via the `run` method, this is temporarly\n   * set to `1` for the duration of the `run` block, then set back to whatever value it was.\n   * @nocollapse\n   */\n  static frameTimeFactor = 10;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public readonly hotObservables: HotObservable<any>[] = [];\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public readonly coldObservables: ColdObservable<any>[] = [];\n\n  /**\n   * Test meta data to be processed during `flush()`\n   */\n  private flushTests: FlushableTest[] = [];\n\n  /**\n   * Indicates whether the TestScheduler instance is operating in \"run mode\",\n   * meaning it's processing a call to `run()`\n   */\n  private runMode = false;\n\n  /**\n   *\n   * @param assertDeepEqual A function to set up your assertion for your test harness\n   */\n  constructor(public assertDeepEqual: (actual: any, expected: any) => boolean | void) {\n    super(VirtualAction, defaultMaxFrame);\n  }\n\n  createTime(marbles: string): number {\n    const indexOf = this.runMode ? marbles.trim().indexOf('|') : marbles.indexOf('|');\n    if (indexOf === -1) {\n      throw new Error('marble diagram for time should have a completion marker \"|\"');\n    }\n    return indexOf * TestScheduler.frameTimeFactor;\n  }\n\n  /**\n   * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.\n   * @param values Values to use for the letters in `marbles`. If ommitted, the letters themselves are used.\n   * @param error The error to use for the `#` marble (if present).\n   */\n  createColdObservable<T = string>(marbles: string, values?: { [marble: string]: T }, error?: any): ColdObservable<T> {\n    if (marbles.indexOf('^') !== -1) {\n      throw new Error('cold observable cannot have subscription offset \"^\"');\n    }\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('cold observable cannot have unsubscription marker \"!\"');\n    }\n    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    const cold = new ColdObservable<T>(messages, this);\n    this.coldObservables.push(cold);\n    return cold;\n  }\n\n  /**\n   * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.\n   * @param values Values to use for the letters in `marbles`. If ommitted, the letters themselves are used.\n   * @param error The error to use for the `#` marble (if present).\n   */\n  createHotObservable<T = string>(marbles: string, values?: { [marble: string]: T }, error?: any): HotObservable<T> {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('hot observable cannot have unsubscription marker \"!\"');\n    }\n    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    const subject = new HotObservable<T>(messages, this);\n    this.hotObservables.push(subject);\n    return subject;\n  }\n\n  private materializeInnerObservable(observable: Observable<any>, outerFrame: number): TestMessage[] {\n    const messages: TestMessage[] = [];\n    observable.subscribe(\n      (value) => {\n        messages.push({ frame: this.frame - outerFrame, notification: nextNotification(value) });\n      },\n      (error) => {\n        messages.push({ frame: this.frame - outerFrame, notification: errorNotification(error) });\n      },\n      () => {\n        messages.push({ frame: this.frame - outerFrame, notification: COMPLETE_NOTIFICATION });\n      }\n    );\n    return messages;\n  }\n\n  expectObservable<T>(observable: Observable<T>, subscriptionMarbles: string | null = null) {\n    const actual: TestMessage[] = [];\n    const flushTest: FlushableTest = { actual, ready: false };\n    const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n    const subscriptionFrame = subscriptionParsed.subscribedFrame === Infinity ? 0 : subscriptionParsed.subscribedFrame;\n    const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n    let subscription: Subscription;\n\n    this.schedule(() => {\n      subscription = observable.subscribe(\n        (x) => {\n          // Support Observable-of-Observables\n          const value = x instanceof Observable ? this.materializeInnerObservable(x, this.frame) : x;\n          actual.push({ frame: this.frame, notification: nextNotification(value) });\n        },\n        (error) => {\n          actual.push({ frame: this.frame, notification: errorNotification(error) });\n        },\n        () => {\n          actual.push({ frame: this.frame, notification: COMPLETE_NOTIFICATION });\n        }\n      );\n    }, subscriptionFrame);\n\n    if (unsubscriptionFrame !== Infinity) {\n      this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);\n    }\n\n    this.flushTests.push(flushTest);\n    const { runMode } = this;\n\n    return {\n      toBe(marbles: string, values?: any, errorValue?: any) {\n        flushTest.ready = true;\n        flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n      },\n      toEqual: (other: Observable<T>) => {\n        flushTest.ready = true;\n        flushTest.expected = [];\n        this.schedule(() => {\n          subscription = other.subscribe(\n            (x) => {\n              // Support Observable-of-Observables\n              const value = x instanceof Observable ? this.materializeInnerObservable(x, this.frame) : x;\n              flushTest.expected!.push({ frame: this.frame, notification: nextNotification(value) });\n            },\n            (error) => {\n              flushTest.expected!.push({ frame: this.frame, notification: errorNotification(error) });\n            },\n            () => {\n              flushTest.expected!.push({ frame: this.frame, notification: COMPLETE_NOTIFICATION });\n            }\n          );\n        }, subscriptionFrame);\n      },\n    };\n  }\n\n  expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]): { toBe: subscriptionLogsToBeFn } {\n    const flushTest: FlushableTest = { actual: actualSubscriptionLogs, ready: false };\n    this.flushTests.push(flushTest);\n    const { runMode } = this;\n    return {\n      toBe(marblesOrMarblesArray: string | string[]) {\n        const marblesArray: string[] = typeof marblesOrMarblesArray === 'string' ? [marblesOrMarblesArray] : marblesOrMarblesArray;\n        flushTest.ready = true;\n        flushTest.expected = marblesArray\n          .map((marbles) => TestScheduler.parseMarblesAsSubscriptions(marbles, runMode))\n          .filter((marbles) => marbles.subscribedFrame !== Infinity);\n      },\n    };\n  }\n\n  flush() {\n    const hotObservables = this.hotObservables;\n    while (hotObservables.length > 0) {\n      hotObservables.shift()!.setup();\n    }\n\n    super.flush();\n\n    this.flushTests = this.flushTests.filter((test) => {\n      if (test.ready) {\n        this.assertDeepEqual(test.actual, test.expected);\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /** @nocollapse */\n  static parseMarblesAsSubscriptions(marbles: string | null, runMode = false): SubscriptionLog {\n    if (typeof marbles !== 'string') {\n      return new SubscriptionLog(Infinity);\n    }\n    // Spreading the marbles into an array leverages ES2015's support for emoji\n    // characters when iterating strings.\n    const characters = [...marbles];\n    const len = characters.length;\n    let groupStart = -1;\n    let subscriptionFrame = Infinity;\n    let unsubscriptionFrame = Infinity;\n    let frame = 0;\n\n    for (let i = 0; i < len; i++) {\n      let nextFrame = frame;\n      const advanceFrameBy = (count: number) => {\n        nextFrame += count * this.frameTimeFactor;\n      };\n      const c = characters[i];\n      switch (c) {\n        case ' ':\n          // Whitespace no longer advances time\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n          break;\n        case '-':\n          advanceFrameBy(1);\n          break;\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n        case '^':\n          if (subscriptionFrame !== Infinity) {\n            throw new Error(\"found a second subscription point '^' in a \" + 'subscription marble diagram. There can only be one.');\n          }\n          subscriptionFrame = groupStart > -1 ? groupStart : frame;\n          advanceFrameBy(1);\n          break;\n        case '!':\n          if (unsubscriptionFrame !== Infinity) {\n            throw new Error(\"found a second unsubscription point '!' in a \" + 'subscription marble diagram. There can only be one.');\n          }\n          unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n        default:\n          // time progression syntax\n          if (runMode && c.match(/^[0-9]$/)) {\n            // Time progression must be preceded by at least one space\n            // if it's not at the beginning of the diagram\n            if (i === 0 || characters[i - 1] === ' ') {\n              const buffer = characters.slice(i).join('');\n              const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n              if (match) {\n                i += match[0].length - 1;\n                const duration = parseFloat(match[1]);\n                const unit = match[2];\n                let durationInMs: number;\n\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n                  default:\n                    break;\n                }\n\n                advanceFrameBy(durationInMs! / this.frameTimeFactor);\n                break;\n              }\n            }\n          }\n\n          throw new Error(\"there can only be '^' and '!' markers in a \" + \"subscription marble diagram. Found instead '\" + c + \"'.\");\n      }\n\n      frame = nextFrame;\n    }\n\n    if (unsubscriptionFrame < 0) {\n      return new SubscriptionLog(subscriptionFrame);\n    } else {\n      return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n    }\n  }\n\n  /** @nocollapse */\n  static parseMarbles(\n    marbles: string,\n    values?: any,\n    errorValue?: any,\n    materializeInnerObservables: boolean = false,\n    runMode = false\n  ): TestMessage[] {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker \"!\"');\n    }\n    // Spreading the marbles into an array leverages ES2015's support for emoji\n    // characters when iterating strings.\n    const characters = [...marbles];\n    const len = characters.length;\n    const testMessages: TestMessage[] = [];\n    const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n    let frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;\n    const getValue =\n      typeof values !== 'object'\n        ? (x: any) => x\n        : (x: any) => {\n            // Support Observable-of-Observables\n            if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n              return values[x].messages;\n            }\n            return values[x];\n          };\n    let groupStart = -1;\n\n    for (let i = 0; i < len; i++) {\n      let nextFrame = frame;\n      const advanceFrameBy = (count: number) => {\n        nextFrame += count * this.frameTimeFactor;\n      };\n\n      let notification: ObservableNotification<any> | undefined;\n      const c = characters[i];\n      switch (c) {\n        case ' ':\n          // Whitespace no longer advances time\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n          break;\n        case '-':\n          advanceFrameBy(1);\n          break;\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n        case '|':\n          notification = COMPLETE_NOTIFICATION;\n          advanceFrameBy(1);\n          break;\n        case '^':\n          advanceFrameBy(1);\n          break;\n        case '#':\n          notification = errorNotification(errorValue || 'error');\n          advanceFrameBy(1);\n          break;\n        default:\n          // Might be time progression syntax, or a value literal\n          if (runMode && c.match(/^[0-9]$/)) {\n            // Time progression must be preceded by at least one space\n            // if it's not at the beginning of the diagram\n            if (i === 0 || characters[i - 1] === ' ') {\n              const buffer = characters.slice(i).join('');\n              const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n              if (match) {\n                i += match[0].length - 1;\n                const duration = parseFloat(match[1]);\n                const unit = match[2];\n                let durationInMs: number;\n\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n                  default:\n                    break;\n                }\n\n                advanceFrameBy(durationInMs! / this.frameTimeFactor);\n                break;\n              }\n            }\n          }\n\n          notification = nextNotification(getValue(c));\n          advanceFrameBy(1);\n          break;\n      }\n\n      if (notification) {\n        testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification });\n      }\n\n      frame = nextFrame;\n    }\n    return testMessages;\n  }\n\n  private createAnimator() {\n    if (!this.runMode) {\n      throw new Error('animate() must only be used in run mode');\n    }\n\n    // The TestScheduler assigns a delegate to the provider that's used for\n    // requestAnimationFrame (rAF). The delegate works in conjunction with the\n    // animate run helper to coordinate the invocation of any rAF callbacks,\n    // that are effected within tests, with the animation frames specified by\n    // the test's author - in the marbles that are passed to the animate run\n    // helper. This allows the test's author to write deterministic tests and\n    // gives the author full control over when - or if - animation frames are\n    // 'painted'.\n\n    let lastHandle = 0;\n    let map: Map<number, FrameRequestCallback> | undefined;\n\n    const delegate = {\n      requestAnimationFrame(callback: FrameRequestCallback) {\n        if (!map) {\n          throw new Error('animate() was not called within run()');\n        }\n        const handle = ++lastHandle;\n        map.set(handle, callback);\n        return handle;\n      },\n      cancelAnimationFrame(handle: number) {\n        if (!map) {\n          throw new Error('animate() was not called within run()');\n        }\n        map.delete(handle);\n      },\n    };\n\n    const animate = (marbles: string) => {\n      if (map) {\n        throw new Error('animate() must not be called more than once within run()');\n      }\n      if (/[|#]/.test(marbles)) {\n        throw new Error('animate() must not complete or error');\n      }\n      map = new Map<number, FrameRequestCallback>();\n      const messages = TestScheduler.parseMarbles(marbles, undefined, undefined, undefined, true);\n      for (const message of messages) {\n        this.schedule(() => {\n          const now = this.now();\n          // Capture the callbacks within the queue and clear the queue\n          // before enumerating the callbacks, as callbacks might\n          // reschedule themselves. (And, yeah, we're using a Map to represent\n          // the queue, but the values are guaranteed to be returned in\n          // insertion order, so it's all good. Trust me, I've read the docs.)\n          const callbacks = Array.from(map!.values());\n          map!.clear();\n          for (const callback of callbacks) {\n            callback(now);\n          }\n        }, message.frame);\n      }\n    };\n\n    return { animate, delegate };\n  }\n\n  private createDelegates() {\n    // When in run mode, the TestScheduler provides alternate implementations\n    // of set/clearImmediate and set/clearInterval. These implementations are\n    // consumed by the scheduler implementations via the providers. This is\n    // done to effect deterministic asap and async scheduler behavior so that\n    // all of the schedulers are testable in 'run mode'. Prior to v7,\n    // delegation occurred at the scheduler level. That is, the asap and\n    // animation frame schedulers were identical in behavior to the async\n    // scheduler. Now, when in run mode, asap actions are prioritized over\n    // async actions and animation frame actions are coordinated using the\n    // animate run helper.\n\n    let lastHandle = 0;\n    const scheduleLookup = new Map<\n      number,\n      {\n        due: number;\n        duration: number;\n        handle: number;\n        handler: () => void;\n        subscription: Subscription;\n        type: 'immediate' | 'interval' | 'timeout';\n      }\n    >();\n\n    const run = () => {\n      // Whenever a scheduled run is executed, it must run a single immediate\n      // or interval action - with immediate actions being prioritized over\n      // interval and timeout actions.\n      const now = this.now();\n      const scheduledRecords = Array.from(scheduleLookup.values());\n      const scheduledRecordsDue = scheduledRecords.filter(({ due }) => due <= now);\n      const dueImmediates = scheduledRecordsDue.filter(({ type }) => type === 'immediate');\n      if (dueImmediates.length > 0) {\n        const { handle, handler } = dueImmediates[0];\n        scheduleLookup.delete(handle);\n        handler();\n        return;\n      }\n      const dueIntervals = scheduledRecordsDue.filter(({ type }) => type === 'interval');\n      if (dueIntervals.length > 0) {\n        const firstDueInterval = dueIntervals[0];\n        const { duration, handler } = firstDueInterval;\n        firstDueInterval.due = now + duration;\n        // The interval delegate must behave like setInterval, so run needs to\n        // be rescheduled. This will continue until the clearInterval delegate\n        // unsubscribes and deletes the handle from the map.\n        firstDueInterval.subscription = this.schedule(run, duration);\n        handler();\n        return;\n      }\n      const dueTimeouts = scheduledRecordsDue.filter(({ type }) => type === 'timeout');\n      if (dueTimeouts.length > 0) {\n        const { handle, handler } = dueTimeouts[0];\n        scheduleLookup.delete(handle);\n        handler();\n        return;\n      }\n      throw new Error('Expected a due immediate or interval');\n    };\n\n    // The following objects are the delegates that replace conventional\n    // runtime implementations with TestScheduler implementations.\n    //\n    // The immediate delegate is depended upon by the asapScheduler.\n    //\n    // The interval delegate is depended upon by the asyncScheduler.\n    //\n    // The timeout delegate is not depended upon by any scheduler, but it's\n    // included here because the onUnhandledError and onStoppedNotification\n    // configuration points use setTimeout to avoid producer interference. It's\n    // inclusion allows for the testing of these configuration points.\n\n    const immediate = {\n      setImmediate: (handler: () => void) => {\n        const handle = ++lastHandle;\n        scheduleLookup.set(handle, {\n          due: this.now(),\n          duration: 0,\n          handle,\n          handler,\n          subscription: this.schedule(run, 0),\n          type: 'immediate',\n        });\n        return handle;\n      },\n      clearImmediate: (handle: number) => {\n        const value = scheduleLookup.get(handle);\n        if (value) {\n          value.subscription.unsubscribe();\n          scheduleLookup.delete(handle);\n        }\n      },\n    };\n\n    const interval = {\n      setInterval: (handler: () => void, duration = 0) => {\n        const handle = ++lastHandle;\n        scheduleLookup.set(handle, {\n          due: this.now() + duration,\n          duration,\n          handle,\n          handler,\n          subscription: this.schedule(run, duration),\n          type: 'interval',\n        });\n        return handle;\n      },\n      clearInterval: (handle: number) => {\n        const value = scheduleLookup.get(handle);\n        if (value) {\n          value.subscription.unsubscribe();\n          scheduleLookup.delete(handle);\n        }\n      },\n    };\n\n    const timeout = {\n      setTimeout: (handler: () => void, duration = 0) => {\n        const handle = ++lastHandle;\n        scheduleLookup.set(handle, {\n          due: this.now() + duration,\n          duration,\n          handle,\n          handler,\n          subscription: this.schedule(run, duration),\n          type: 'timeout',\n        });\n        return handle;\n      },\n      clearTimeout: (handle: number) => {\n        const value = scheduleLookup.get(handle);\n        if (value) {\n          value.subscription.unsubscribe();\n          scheduleLookup.delete(handle);\n        }\n      },\n    };\n\n    return { immediate, interval, timeout };\n  }\n\n  /**\n   * The `run` method performs the test in 'run mode' - in which schedulers\n   * used within the test automatically delegate to the `TestScheduler`. That\n   * is, in 'run mode' there is no need to explicitly pass a `TestScheduler`\n   * instance to observable creators or operators.\n   *\n   * @see {@link /guide/testing/marble-testing}\n   */\n  run<T>(callback: (helpers: RunHelpers) => T): T {\n    const prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n    const prevMaxFrames = this.maxFrames;\n\n    TestScheduler.frameTimeFactor = 1;\n    this.maxFrames = Infinity;\n    this.runMode = true;\n\n    const animator = this.createAnimator();\n    const delegates = this.createDelegates();\n\n    animationFrameProvider.delegate = animator.delegate;\n    dateTimestampProvider.delegate = this;\n    immediateProvider.delegate = delegates.immediate;\n    intervalProvider.delegate = delegates.interval;\n    timeoutProvider.delegate = delegates.timeout;\n    performanceTimestampProvider.delegate = this;\n\n    const helpers: RunHelpers = {\n      cold: this.createColdObservable.bind(this),\n      hot: this.createHotObservable.bind(this),\n      flush: this.flush.bind(this),\n      time: this.createTime.bind(this),\n      expectObservable: this.expectObservable.bind(this),\n      expectSubscriptions: this.expectSubscriptions.bind(this),\n      animate: animator.animate,\n    };\n    try {\n      const ret = callback(helpers);\n      this.flush();\n      return ret;\n    } finally {\n      TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n      this.maxFrames = prevMaxFrames;\n      this.runMode = false;\n      animationFrameProvider.delegate = undefined;\n      dateTimestampProvider.delegate = undefined;\n      immediateProvider.delegate = undefined;\n      intervalProvider.delegate = undefined;\n      timeoutProvider.delegate = undefined;\n      performanceTimestampProvider.delegate = undefined;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}