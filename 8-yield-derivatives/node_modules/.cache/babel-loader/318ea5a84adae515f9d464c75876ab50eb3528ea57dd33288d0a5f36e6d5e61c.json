{"ast":null,"code":"import { __extends, __read, __spreadArray } from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nvar Subscriber = function (_super) {\n  __extends(Subscriber, _super);\n  function Subscriber(destination) {\n    var _this = _super.call(this) || this;\n    _this.isStopped = false;\n    if (destination) {\n      _this.destination = destination;\n      if (isSubscription(destination)) {\n        destination.add(_this);\n      }\n    } else {\n      _this.destination = EMPTY_OBSERVER;\n    }\n    return _this;\n  }\n  Subscriber.create = function (next, error, complete) {\n    return new SafeSubscriber(next, error, complete);\n  };\n  Subscriber.prototype.next = function (value) {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value);\n    }\n  };\n  Subscriber.prototype.error = function (err) {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  };\n  Subscriber.prototype.complete = function () {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  };\n  Subscriber.prototype.unsubscribe = function () {\n    if (!this.closed) {\n      this.isStopped = true;\n      _super.prototype.unsubscribe.call(this);\n      this.destination = null;\n    }\n  };\n  Subscriber.prototype._next = function (value) {\n    this.destination.next(value);\n  };\n  Subscriber.prototype._error = function (err) {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  };\n  Subscriber.prototype._complete = function () {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  };\n  return Subscriber;\n}(Subscription);\nexport { Subscriber };\nvar SafeSubscriber = function (_super) {\n  __extends(SafeSubscriber, _super);\n  function SafeSubscriber(observerOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n    var next;\n    if (isFunction(observerOrNext)) {\n      next = observerOrNext;\n    } else if (observerOrNext) {\n      next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete;\n      var context_1;\n      if (_this && config.useDeprecatedNextContext) {\n        context_1 = Object.create(observerOrNext);\n        context_1.unsubscribe = function () {\n          return _this.unsubscribe();\n        };\n      } else {\n        context_1 = observerOrNext;\n      }\n      next = next === null || next === void 0 ? void 0 : next.bind(context_1);\n      error = error === null || error === void 0 ? void 0 : error.bind(context_1);\n      complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);\n    }\n    _this.destination = {\n      next: next ? wrapForErrorHandling(next, _this) : noop,\n      error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler, _this),\n      complete: complete ? wrapForErrorHandling(complete, _this) : noop\n    };\n    return _this;\n  }\n  return SafeSubscriber;\n}(Subscriber);\nexport { SafeSubscriber };\nfunction wrapForErrorHandling(handler, instance) {\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    try {\n      handler.apply(void 0, __spreadArray([], __read(args)));\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        if (instance._syncErrorHack_isSubscribing) {\n          instance.__syncError = err;\n        } else {\n          throw err;\n        }\n      } else {\n        reportUnhandledError(err);\n      }\n    }\n  };\n}\nfunction defaultErrorHandler(err) {\n  throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n  var onStoppedNotification = config.onStoppedNotification;\n  onStoppedNotification && timeoutProvider.setTimeout(function () {\n    return onStoppedNotification(notification, subscriber);\n  });\n}\nexport var EMPTY_OBSERVER = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop\n};","map":{"version":3,"names":["isFunction","isSubscription","Subscription","config","reportUnhandledError","noop","nextNotification","errorNotification","COMPLETE_NOTIFICATION","timeoutProvider","Subscriber","_super","__extends","destination","_this","call","isStopped","add","EMPTY_OBSERVER","create","next","error","complete","SafeSubscriber","prototype","value","handleStoppedNotification","_next","err","_error","_complete","unsubscribe","closed","observerOrNext","context_1","useDeprecatedNextContext","Object","bind","wrapForErrorHandling","defaultErrorHandler","handler","instance","args","_i","arguments","length","apply","__spreadArray","__read","useDeprecatedSynchronousErrorHandling","_syncErrorHack_isSubscribing","__syncError","notification","subscriber","onStoppedNotification","setTimeout"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/rxjs/src/internal/Subscriber.ts"],"sourcesContent":["import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let next: ((value: T) => void) | undefined;\n    if (isFunction(observerOrNext)) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      next = observerOrNext;\n    } else if (observerOrNext) {\n      // The first argument is an observer object, we have to pull the handlers\n      // off and capture the owner object as the context. That is because we're\n      // going to put them all in a new destination with ensured methods\n      // for `next`, `error`, and `complete`. That's part of what makes this\n      // the \"Safe\" Subscriber.\n      ({ next, error, complete } = observerOrNext);\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n      } else {\n        context = observerOrNext;\n      }\n      next = next?.bind(context);\n      error = error?.bind(context);\n      complete = complete?.bind(context);\n    }\n\n    // Once we set the destination, the superclass `Subscriber` will\n    // do it's magic in the `_next`, `_error`, and `_complete` methods.\n    this.destination = {\n      next: next ? wrapForErrorHandling(next, this) : noop,\n      error: wrapForErrorHandling(error ?? defaultErrorHandler, this),\n      complete: complete ? wrapForErrorHandling(complete, this) : noop,\n    };\n  }\n}\n\n/**\n * Wraps a user-provided handler (or our {@link defaultErrorHandler} in one case) to\n * ensure that any thrown errors are caught and handled appropriately.\n *\n * @param handler The handler to wrap\n * @param instance The SafeSubscriber instance we're going to mark if there's an error.\n */\nfunction wrapForErrorHandling(handler: (arg?: any) => void, instance: SafeSubscriber<any>) {\n  return (...args: any[]) => {\n    try {\n      handler(...args);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        // If the user has opted for \"super-gross\" mode, we need to check to see\n        // if we're currently subscribing. If we are, we need to mark the _syncError\n        // So that it can be rethrown in the `subscribe` call on `Observable`.\n        if ((instance as any)._syncErrorHack_isSubscribing) {\n          (instance as any).__syncError = err;\n        } else {\n          // We're not currently subscribing, but we're in super-gross mode,\n          // so throw it immediately.\n          throw err;\n        }\n      } else {\n        // Ideal path, we report this as an unhandled error,\n        // which is thrown on a new call stack.\n        reportUnhandledError(err);\n      }\n    }\n  };\n}\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}