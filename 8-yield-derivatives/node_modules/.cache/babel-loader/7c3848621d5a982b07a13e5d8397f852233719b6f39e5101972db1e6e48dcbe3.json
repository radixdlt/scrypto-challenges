{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nexports.__esModule = true;\nvar ISet_1 = require(\"./ISet\");\nvar Vector_1 = require(\"./Vector\");\nvar HashMap_1 = require(\"./HashMap\");\nvar LinkedList_1 = require(\"./LinkedList\");\nvar Option_1 = require(\"./Option\");\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers = require(\"./SeqHelpers\");\nvar Contract_1 = require(\"./Contract\");\nvar Value_1 = require(\"./Value\");\nvar hamt = require(\"hamt_plus\");\n/**\n * An unordered collection of values, where no two values\n * may be equal. A value can only be present once.\n * @param T the item type\n */\nvar HashSet = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function HashSet(hamt) {\n    this.hamt = hamt;\n  }\n  /**\n   * The empty hashset.\n   * @param T the item type\n   */\n  HashSet.empty = function () {\n    return emptyHashSet;\n  };\n  /**\n   * Build a hashset from any iterable, which means also\n   * an array for instance.\n   * @param T the item type\n   */\n  HashSet.ofIterable = function (elts) {\n    return new EmptyHashSet().addAll(elts);\n  };\n  /**\n   * Build a hashset from a series of items (any number, as parameters)\n   * @param T the item type\n   */\n  HashSet.of = function () {\n    var arr = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      arr[_i] = arguments[_i];\n    }\n    return HashSet.ofIterable(arr);\n  };\n  /**\n   * Curried predicate to find out whether the HashSet is empty.\n   *\n   *     Vector.of(HashSet.of(1), HashSet.empty<number>())\n   *         .filter(HashSet.isEmpty)\n   *     => Vector.of(HashSet.empty<number>())\n   */\n  HashSet.isEmpty = function (v) {\n    return v.isEmpty();\n  };\n  /**\n   * Curried predicate to find out whether the HashSet is empty.\n   *\n   *     Vector.of(HashSet.of(1), HashSet.empty<number>())\n   *         .filter(HashSet.isNotEmpty)\n   *     => Vector.of(HashSet.of(1))\n   */\n  HashSet.isNotEmpty = function (v) {\n    return !v.isEmpty();\n  };\n  /**\n   * Implementation of the Iterator interface.\n   */\n  HashSet.prototype[Symbol.iterator] = function () {\n    return this.hamt.keys();\n  };\n  /**\n   * Add an element to this set.\n   */\n  HashSet.prototype.add = function (elt) {\n    return new HashSet(this.hamt.set(elt, elt));\n  };\n  HashSet.prototype.addAllArray = function (elts) {\n    return new HashSet(this.hamt.mutate(function (h) {\n      if (elts.length > 0) {\n        Contract_1.contractTrueEquality(\"Error building a HashSet\", elts[0]);\n      }\n      for (var _i = 0, elts_1 = elts; _i < elts_1.length; _i++) {\n        var val = elts_1[_i];\n        h.set(val, val);\n      }\n    }));\n  };\n  /**\n   * Add multiple elements to this set.\n   */\n  HashSet.prototype.addAll = function (elts) {\n    if (Array.isArray(elts)) {\n      return this.addAllArray(elts);\n    }\n    return new HashSet(this.hamt.mutate(function (h) {\n      var checkedEq = false;\n      var iterator = elts[Symbol.iterator]();\n      var curItem = iterator.next();\n      if (!curItem.done && curItem.value && !checkedEq) {\n        Contract_1.contractTrueEquality(\"Error building a HashSet\", curItem.value);\n        checkedEq = true;\n      }\n      while (!curItem.done) {\n        h.set(curItem.value, curItem.value);\n        curItem = iterator.next();\n      }\n    }));\n  };\n  /**\n   * Returns true if the element you give is present in\n   * the set, false otherwise.\n   */\n  HashSet.prototype.contains = function (elt) {\n    return this.hamt.has(elt);\n  };\n  /**\n   * Return a new collection where each element was transformed\n   * by the mapper function you give.\n   * The resulting set may be smaller than the source.\n   */\n  HashSet.prototype.map = function (mapper) {\n    return this.hamt.fold(function (acc, value, key) {\n      return acc.add(mapper(value));\n    }, HashSet.empty());\n  };\n  /**\n   * Apply the mapper function on every element of this collection.\n   * The mapper function returns an Option; if the Option is a Some,\n   * the value it contains is added to the result Collection, if it's\n   * a None, the value is discarded.\n   *\n   *     HashSet.of(1,2,6).mapOption(x => x%2===0 ?\n   *         Option.of(x+1) : Option.none<number>())\n   *     => HashSet.of(3, 7)\n   */\n  HashSet.prototype.mapOption = function (mapper) {\n    return this.hamt.fold(function (acc, value, key) {\n      var val = mapper(value);\n      return val.isSome() ? acc.add(val.get()) : acc;\n    }, HashSet.empty());\n  };\n  /**\n   * Call a function for element in the collection.\n   */\n  HashSet.prototype.forEach = function (fun) {\n    var iterator = this.hamt.values();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      fun(curItem.value);\n      curItem = iterator.next();\n    }\n    return this;\n  };\n  /**\n   * Calls the function you give for each item in the set,\n   * your function returns a set, all the sets are\n   * merged.\n   */\n  HashSet.prototype.flatMap = function (mapper) {\n    return this.foldLeft(HashSet.empty(), function (soFar, cur) {\n      return soFar.addAll(mapper(cur));\n    });\n  };\n  HashSet.prototype.filter = function (predicate) {\n    var _this = this;\n    return new HashSet(hamt.make({\n      hash: this.hamt._config.hash,\n      keyEq: this.hamt._config.keyEq\n    }).mutate(function (h) {\n      var iterator = _this.hamt.values();\n      var curItem = iterator.next();\n      while (!curItem.done) {\n        if (predicate(curItem.value)) {\n          h.set(curItem.value, curItem.value);\n        }\n        curItem = iterator.next();\n      }\n    }));\n  };\n  /**\n   * Search for an item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   * We name the method findAny instead of find to emphasize\n   * that there is not ordering in a hashset.\n   *\n   *     HashSet.of(1,2,3).findAny(x => x>=3)\n   *     => Option.of(3)\n   *\n   *     HashSet.of(1,2,3).findAny(x => x>=4)\n   *     => Option.none<number>()\n   */\n  HashSet.prototype.findAny = function (predicate) {\n    var iterator = this.hamt.values();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (predicate(curItem.value)) {\n        return Option_1.Option.of(curItem.value);\n      }\n      curItem = iterator.next();\n    }\n    return Option_1.Option.none();\n  };\n  /**\n   * Reduces the collection to a single value using the\n   * associative binary function you give. Since the function\n   * is associative, order of application doesn't matter.\n   *\n   * Example:\n   *\n   *     HashSet.of(1,2,3).fold(0, (a,b) => a + b);\n   *     => 6\n   */\n  HashSet.prototype.fold = function (zero, fn) {\n    return this.foldLeft(zero, fn);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Left-associative.\n   * No guarantees for the order of items in a hashset!\n   *\n   * Example:\n   *\n   *     HashSet.of(\"a\", \"bb\", \"ccc\").foldLeft(0, (soFar,item) => soFar+item.length);\n   *     => 6\n   *\n   * @param zero The initial value\n   * @param fn A function taking the previous value and\n   *           the current collection item, and returning\n   *           an updated value.\n   */\n  HashSet.prototype.foldLeft = function (zero, fn) {\n    return this.hamt.fold(function (acc, v, k) {\n      return fn(acc, v);\n    }, zero);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Right-associative.\n   * No guarantees for the order of items in a hashset!\n   *\n   * Example:\n   *\n   *     HashSet.of(\"a\", \"bb\", \"ccc\").foldRight(0, (item,soFar) => soFar+item.length);\n   *     => 6\n   *\n   * @param zero The initial value\n   * @param fn A function taking the current collection item and\n   *           the previous value , and returning\n   *           an updated value.\n   */\n  HashSet.prototype.foldRight = function (zero, fn) {\n    return this.foldLeft(zero, function (cur, soFar) {\n      return fn(soFar, cur);\n    });\n  };\n  /**\n   * Converts this set to an array. Since a Set is not ordered\n   * and since this method returns a JS array, it can be awkward\n   * to get an array sorted in the way you'd like. So you can pass\n   * an optional sorting function too.\n   *\n   *     HashSet.of(1,2,3).toArray().sort()\n   *     => [1,2,3]\n   *\n   *     HashSet.of(1,2,3).toArray({sortOn:x=>x})\n   *     => [1,2,3]\n   *\n   *     HashSet.of(1,2,3).toArray({sortBy:(x,y)=>x-y})\n   *     => [1,2,3]\n   *\n   * You can also pass an array in sortOn, listing lambdas to\n   * several fields to sort by those fields, and also {desc:lambda}\n   * to sort by some fields descending.\n   */\n  HashSet.prototype.toArray = function (sort) {\n    var _a;\n    if (!sort) {\n      return Array.from(this.hamt.keys());\n    }\n    if (ISet_1.isSortOnSpec(sort)) {\n      var sortOn = sort.sortOn instanceof Array ? sort.sortOn : [sort.sortOn];\n      return (_a = Vector_1.Vector.ofIterable(this.hamt.keys())).sortOn.apply(_a, sortOn).toArray();\n    }\n    return Array.from(this.hamt.keys()).sort(sort.sortBy);\n  };\n  /**\n   * Converts this set to an vector\n   */\n  HashSet.prototype.toVector = function () {\n    return Vector_1.Vector.ofIterable(this.hamt.keys());\n  };\n  /**\n   * Converts this set to an list\n   */\n  HashSet.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.ofIterable(this.hamt.keys());\n  };\n  /**\n   * Returns the number of elements in the set.\n   */\n  HashSet.prototype.length = function () {\n    return this.hamt.size;\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  HashSet.prototype.single = function () {\n    return this.hamt.size === 1 ? Option_1.Option.of(this.hamt.keys().next().value) : Option_1.Option.none();\n  };\n  /**\n   * true if the set is empty, false otherwise.\n   */\n  HashSet.prototype.isEmpty = function () {\n    return this.hamt.size === 0;\n  };\n  /**\n   * Returns a new Set containing the difference\n   * between this set and the other Set passed as parameter.\n   * also see [[HashSet.intersect]]\n   */\n  HashSet.prototype.diff = function (elts) {\n    return new HashSet(this.hamt.fold(function (acc, v, k) {\n      return elts.contains(k) ? acc : acc.set(k, k);\n    }, hamt.empty));\n  };\n  /**\n   * Returns a new Set containing the intersection\n   * of this set and the other Set passed as parameter\n   * (the elements which are common to both sets)\n   * also see [[HashSet.diff]]\n   */\n  HashSet.prototype.intersect = function (other) {\n    return new HashSet(this.hamt.fold(function (acc, v, k) {\n      return other.contains(k) ? acc.set(k, k) : acc;\n    }, hamt.empty));\n  };\n  HashSet.prototype.isSubsetOf = function (other) {\n    return this.allMatch(function (x) {\n      return other.contains(x);\n    });\n  };\n  /**\n   * Returns a new set with the element you give removed\n   * if it was present in the set.\n   */\n  HashSet.prototype.remove = function (elt) {\n    return new HashSet(this.hamt.remove(elt));\n  };\n  /**\n   * Returns a new set with all the elements of the current\n   * Set, minus the elements of the iterable you give as a parameter.\n   * If you call this function with a HashSet as parameter,\n   * rather call 'diff', as it'll be faster.\n   */\n  HashSet.prototype.removeAll = function (elts) {\n    return this.diff(HashSet.ofIterable(elts));\n  };\n  HashSet.prototype.allMatch = function (predicate) {\n    var iterator = this.hamt.values();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (!predicate(curItem.value)) {\n        return false;\n      }\n      curItem = iterator.next();\n    }\n    return true;\n  };\n  /**\n   * Returns true if there the predicate returns true for any\n   * element in the collection.\n   */\n  HashSet.prototype.anyMatch = function (predicate) {\n    var iterator = this.hamt.values();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (predicate(curItem.value)) {\n        return true;\n      }\n      curItem = iterator.next();\n    }\n    return false;\n  };\n  /**\n   * Group elements in the collection using a classifier function.\n   * Elements are then organized in a map. The key is the value of\n   * the classifier, and in value we get the list of elements\n   * matching that value.\n   *\n   * also see [[HashSet.arrangeBy]]\n   */\n  HashSet.prototype.groupBy = function (classifier) {\n    var _this = this;\n    // make a singleton set with the same equality as this\n    var singletonHamtSet = function (v) {\n      return hamt.make({\n        hash: _this.hamt._config.hash,\n        keyEq: _this.hamt._config.keyEq\n      }).set(v, v);\n    };\n    // merge two mutable hamt sets, but I know the second has only 1 elt\n    var mergeSets = function (v1, v2) {\n      var k = v2.keys().next().value;\n      v1.set(k, k);\n      return v1;\n    };\n    return this.hamt.fold(\n    // fold operation: combine a new value from the set with the accumulator\n    function (acc, v, k) {\n      return acc.putWithMerge(classifier(v), singletonHamtSet(v).beginMutation(), mergeSets);\n    },\n    // fold accumulator: the empty hashmap\n    HashMap_1.HashMap.empty()).mapValues(function (h) {\n      return new HashSet(h.endMutation());\n    });\n  };\n  /**\n   * Matches each element with a unique key that you extract from it.\n   * If the same key is present twice, the function will return None.\n   *\n   * also see [[HashSet.groupBy]]\n   */\n  HashSet.prototype.arrangeBy = function (getKey) {\n    return SeqHelpers.arrangeBy(this, getKey);\n  };\n  HashSet.prototype.partition = function (predicate) {\n    var r1 = hamt.make({\n      hash: this.hamt._config.hash,\n      keyEq: this.hamt._config.keyEq\n    }).beginMutation();\n    var r2 = hamt.make({\n      hash: this.hamt._config.hash,\n      keyEq: this.hamt._config.keyEq\n    }).beginMutation();\n    var iterator = this.hamt.values();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (predicate(curItem.value)) {\n        r1.set(curItem.value, curItem.value);\n      } else {\n        r2.set(curItem.value, curItem.value);\n      }\n      curItem = iterator.next();\n    }\n    return [new HashSet(r1), new HashSet(r2)];\n  };\n  /**\n   * Reduces the collection to a single value by repeatedly\n   * calling the combine function.\n   * No starting value. The order in which the elements are\n   * passed to the combining function is undetermined.\n   */\n  HashSet.prototype.reduce = function (combine) {\n    return SeqHelpers.reduce(this, combine);\n  };\n  /**\n   * Compare values in the collection and return the smallest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[HashSet.minOn]]\n   */\n  HashSet.prototype.minBy = function (compare) {\n    return SeqHelpers.minBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the smallest.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[HashSet.minBy]]\n   */\n  HashSet.prototype.minOn = function (getOrderable) {\n    return SeqHelpers.minOn(this, getOrderable);\n  };\n  /**\n   * Compare values in the collection and return the largest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[HashSet.maxOn]]\n   */\n  HashSet.prototype.maxBy = function (compare) {\n    return SeqHelpers.maxBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the largest.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[HashSet.maxBy]]\n   */\n  HashSet.prototype.maxOn = function (getOrderable) {\n    return SeqHelpers.maxOn(this, getOrderable);\n  };\n  /**\n   * Call the function you give for each element in the collection\n   * and sum all the numbers, return that sum.\n   * Will return 0 if the collection is empty.\n   *\n   *     HashSet.of(1,2,3).sumOn(x=>x)\n   *     => 6\n   */\n  HashSet.prototype.sumOn = function (getNumber) {\n    return SeqHelpers.sumOn(this, getNumber);\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  HashSet.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  HashSet.prototype.toJsSet = function (keyConvert) {\n    return this.foldLeft(new Set(), function (sofar, cur) {\n      return sofar.add(keyConvert(cur));\n    });\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  HashSet.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    var sz = this.hamt.size;\n    if (other === emptyHashSet && sz === 0) {\n      // we could get that i'm not the empty map\n      // but my size is zero, after some filtering and such.\n      return true;\n    }\n    if (!other || !other.hamt) {\n      return false;\n    }\n    if (sz !== other.hamt.size) {\n      return false;\n    }\n    Contract_1.contractTrueEquality(\"HashSet.equals\", this, other);\n    var keys = Array.from(this.hamt.keys());\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var k = keys_1[_i];\n      var hisVal = other.hamt.get(k);\n      if (hisVal === undefined) {\n        return false;\n      }\n      if (!Comparison_1.areEqual(k, hisVal)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  HashSet.prototype.hashCode = function () {\n    return this.hamt.fold(function (acc, value, key) {\n      return acc + Comparison_1.getHashCode(key);\n    }, 0);\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   *\n   * Also see [[HashSet.mkString]]\n   */\n  HashSet.prototype.toString = function () {\n    return \"HashSet(\" + this.hamt.fold(function (acc, value, key) {\n      acc.push(SeqHelpers.toStringHelper(key));\n      return acc;\n    }, []).join(\", \") + \")\";\n  };\n  HashSet.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  /**\n   * Joins elements of the collection by a separator.\n   * Example:\n   *\n   *     HashSet.of(1,2,3).mkString(\", \")\n   *     => \"1, 2, 3\"\n   *\n   * (of course, order is not guaranteed)\n   */\n  HashSet.prototype.mkString = function (separator) {\n    return this.hamt.fold(function (acc, value, key) {\n      acc.push(SeqHelpers.toStringHelper(key, {\n        quoteStrings: false\n      }));\n      return acc;\n    }, []).join(separator);\n  };\n  return HashSet;\n}();\nexports.HashSet = HashSet;\n// we need to override the empty hashmap\n// because i don't know how to get the hash & keyset\n// functions for the keys without a key value to get\n// the functions from\nvar EmptyHashSet = /** @class */function (_super) {\n  __extends(EmptyHashSet, _super);\n  function EmptyHashSet() {\n    return _super.call(this, {}) || this;\n  }\n  EmptyHashSet.prototype.add = function (elt) {\n    Contract_1.contractTrueEquality(\"Error building a HashSet\", elt);\n    if (!elt) {\n      // special case if we get null for the first element...\n      // less optimized variant because we don't know\n      // if we should use '===' or 'equals'\n      return new HashSet(hamt.make({\n        hash: function (v) {\n          return Comparison_1.getHashCode(v);\n        },\n        keyEq: function (a, b) {\n          return Comparison_1.areEqual(a, b);\n        }\n      }).set(elt, elt));\n    }\n    // if the element is not null, save a if later by finding\n    // out right now whether we should call equals or ===\n    if (Comparison_1.hasEquals(elt)) {\n      return new HashSet(hamt.make({\n        hash: function (v) {\n          return v.hashCode();\n        },\n        keyEq: function (a, b) {\n          return a.equals(b);\n        }\n      }).set(elt, elt));\n    }\n    return new HashSet(hamt.make().set(elt, elt));\n  };\n  EmptyHashSet.prototype.addAll = function (elts) {\n    var _a;\n    var it = elts[Symbol.iterator]();\n    var curItem = it.next();\n    if (curItem.done) {\n      return emptyHashSet;\n    }\n    return this.add(curItem.value).addAll((_a = {}, _a[Symbol.iterator] = function () {\n      return it;\n    }, _a));\n  };\n  EmptyHashSet.prototype.contains = function (elt) {\n    return false;\n  };\n  EmptyHashSet.prototype.map = function (mapper) {\n    return emptyHashSet;\n  };\n  EmptyHashSet.prototype.mapOption = function (mapper) {\n    return emptyHashSet;\n  };\n  EmptyHashSet.prototype.forEach = function (fun) {\n    return this;\n  };\n  EmptyHashSet.prototype.filter = function (predicate) {\n    return this;\n  };\n  EmptyHashSet.prototype.findAny = function (predicate) {\n    return Option_1.Option.none();\n  };\n  EmptyHashSet.prototype.foldLeft = function (zero, fn) {\n    return zero;\n  };\n  EmptyHashSet.prototype.toArray = function (sort) {\n    return [];\n  };\n  EmptyHashSet.prototype.toVector = function () {\n    return Vector_1.Vector.empty();\n  };\n  EmptyHashSet.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.empty();\n  };\n  EmptyHashSet.prototype[Symbol.iterator] = function () {\n    return {\n      next: function () {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  };\n  EmptyHashSet.prototype.length = function () {\n    return 0;\n  };\n  EmptyHashSet.prototype.isEmpty = function () {\n    return true;\n  };\n  EmptyHashSet.prototype.diff = function (elts) {\n    return this;\n  };\n  EmptyHashSet.prototype.intersect = function (other) {\n    return this;\n  };\n  EmptyHashSet.prototype.anyMatch = function (predicate) {\n    return false;\n  };\n  EmptyHashSet.prototype.groupBy = function (classifier) {\n    return HashMap_1.HashMap.empty();\n  };\n  EmptyHashSet.prototype.allMatch = function (predicate) {\n    return true;\n  };\n  EmptyHashSet.prototype.partition = function (predicate) {\n    return [this, this];\n  };\n  EmptyHashSet.prototype.remove = function (elt) {\n    return this;\n  };\n  EmptyHashSet.prototype.equals = function (other) {\n    if (!other || !other.length) {\n      return false;\n    }\n    return other === emptyHashSet || other.length() === 0;\n  };\n  EmptyHashSet.prototype.hashCode = function () {\n    return 0;\n  };\n  EmptyHashSet.prototype.toString = function () {\n    return \"HashSet()\";\n  };\n  EmptyHashSet.prototype.mkString = function (separator) {\n    return \"\";\n  };\n  return EmptyHashSet;\n}(HashSet);\nvar emptyHashSet = new EmptyHashSet();","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","exports","__esModule","ISet_1","require","Vector_1","HashMap_1","LinkedList_1","Option_1","Comparison_1","SeqHelpers","Contract_1","Value_1","hamt","HashSet","empty","emptyHashSet","ofIterable","elts","EmptyHashSet","addAll","of","arr","_i","arguments","length","isEmpty","v","isNotEmpty","Symbol","iterator","keys","add","elt","set","addAllArray","mutate","h","contractTrueEquality","elts_1","val","isArray","checkedEq","curItem","next","done","value","contains","has","map","mapper","fold","acc","key","mapOption","isSome","get","forEach","fun","values","flatMap","foldLeft","soFar","cur","filter","predicate","_this","make","hash","_config","keyEq","findAny","Option","none","zero","fn","k","foldRight","toArray","sort","_a","from","isSortOnSpec","sortOn","Vector","apply","sortBy","toVector","toLinkedList","LinkedList","size","single","diff","intersect","other","isSubsetOf","allMatch","x","remove","removeAll","anyMatch","groupBy","classifier","singletonHamtSet","mergeSets","v1","v2","putWithMerge","beginMutation","HashMap","mapValues","endMutation","arrangeBy","getKey","partition","r1","r2","reduce","combine","minBy","compare","minOn","getOrderable","maxBy","maxOn","sumOn","getNumber","transform","converter","toJsSet","keyConvert","Set","sofar","equals","sz","keys_1","hisVal","undefined","areEqual","hashCode","getHashCode","toString","push","toStringHelper","join","inspect","mkString","separator","quoteStrings","_super","call","a","hasEquals","it"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/dist/src/HashSet.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nexports.__esModule = true;\nvar ISet_1 = require(\"./ISet\");\nvar Vector_1 = require(\"./Vector\");\nvar HashMap_1 = require(\"./HashMap\");\nvar LinkedList_1 = require(\"./LinkedList\");\nvar Option_1 = require(\"./Option\");\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers = require(\"./SeqHelpers\");\nvar Contract_1 = require(\"./Contract\");\nvar Value_1 = require(\"./Value\");\nvar hamt = require(\"hamt_plus\");\n/**\n * An unordered collection of values, where no two values\n * may be equal. A value can only be present once.\n * @param T the item type\n */\nvar HashSet = /** @class */ (function () {\n    /**\n     * @hidden\n     */\n    function HashSet(hamt) {\n        this.hamt = hamt;\n    }\n    /**\n     * The empty hashset.\n     * @param T the item type\n     */\n    HashSet.empty = function () {\n        return emptyHashSet;\n    };\n    /**\n     * Build a hashset from any iterable, which means also\n     * an array for instance.\n     * @param T the item type\n     */\n    HashSet.ofIterable = function (elts) {\n        return new EmptyHashSet().addAll(elts);\n    };\n    /**\n     * Build a hashset from a series of items (any number, as parameters)\n     * @param T the item type\n     */\n    HashSet.of = function () {\n        var arr = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arr[_i] = arguments[_i];\n        }\n        return HashSet.ofIterable(arr);\n    };\n    /**\n     * Curried predicate to find out whether the HashSet is empty.\n     *\n     *     Vector.of(HashSet.of(1), HashSet.empty<number>())\n     *         .filter(HashSet.isEmpty)\n     *     => Vector.of(HashSet.empty<number>())\n     */\n    HashSet.isEmpty = function (v) {\n        return v.isEmpty();\n    };\n    /**\n     * Curried predicate to find out whether the HashSet is empty.\n     *\n     *     Vector.of(HashSet.of(1), HashSet.empty<number>())\n     *         .filter(HashSet.isNotEmpty)\n     *     => Vector.of(HashSet.of(1))\n     */\n    HashSet.isNotEmpty = function (v) {\n        return !v.isEmpty();\n    };\n    /**\n     * Implementation of the Iterator interface.\n     */\n    HashSet.prototype[Symbol.iterator] = function () {\n        return this.hamt.keys();\n    };\n    /**\n     * Add an element to this set.\n     */\n    HashSet.prototype.add = function (elt) {\n        return new HashSet(this.hamt.set(elt, elt));\n    };\n    HashSet.prototype.addAllArray = function (elts) {\n        return new HashSet(this.hamt.mutate(function (h) {\n            if (elts.length > 0) {\n                Contract_1.contractTrueEquality(\"Error building a HashSet\", elts[0]);\n            }\n            for (var _i = 0, elts_1 = elts; _i < elts_1.length; _i++) {\n                var val = elts_1[_i];\n                h.set(val, val);\n            }\n        }));\n    };\n    /**\n     * Add multiple elements to this set.\n     */\n    HashSet.prototype.addAll = function (elts) {\n        if (Array.isArray(elts)) {\n            return this.addAllArray(elts);\n        }\n        return new HashSet(this.hamt.mutate(function (h) {\n            var checkedEq = false;\n            var iterator = elts[Symbol.iterator]();\n            var curItem = iterator.next();\n            if (!curItem.done && curItem.value && !checkedEq) {\n                Contract_1.contractTrueEquality(\"Error building a HashSet\", curItem.value);\n                checkedEq = true;\n            }\n            while (!curItem.done) {\n                h.set(curItem.value, curItem.value);\n                curItem = iterator.next();\n            }\n        }));\n    };\n    /**\n     * Returns true if the element you give is present in\n     * the set, false otherwise.\n     */\n    HashSet.prototype.contains = function (elt) {\n        return this.hamt.has(elt);\n    };\n    /**\n     * Return a new collection where each element was transformed\n     * by the mapper function you give.\n     * The resulting set may be smaller than the source.\n     */\n    HashSet.prototype.map = function (mapper) {\n        return this.hamt.fold(function (acc, value, key) {\n            return acc.add(mapper(value));\n        }, HashSet.empty());\n    };\n    /**\n     * Apply the mapper function on every element of this collection.\n     * The mapper function returns an Option; if the Option is a Some,\n     * the value it contains is added to the result Collection, if it's\n     * a None, the value is discarded.\n     *\n     *     HashSet.of(1,2,6).mapOption(x => x%2===0 ?\n     *         Option.of(x+1) : Option.none<number>())\n     *     => HashSet.of(3, 7)\n     */\n    HashSet.prototype.mapOption = function (mapper) {\n        return this.hamt.fold(function (acc, value, key) {\n            var val = mapper(value);\n            return val.isSome() ? acc.add(val.get()) : acc;\n        }, HashSet.empty());\n    };\n    /**\n     * Call a function for element in the collection.\n     */\n    HashSet.prototype.forEach = function (fun) {\n        var iterator = this.hamt.values();\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            fun(curItem.value);\n            curItem = iterator.next();\n        }\n        return this;\n    };\n    /**\n     * Calls the function you give for each item in the set,\n     * your function returns a set, all the sets are\n     * merged.\n     */\n    HashSet.prototype.flatMap = function (mapper) {\n        return this.foldLeft(HashSet.empty(), function (soFar, cur) { return soFar.addAll(mapper(cur)); });\n    };\n    HashSet.prototype.filter = function (predicate) {\n        var _this = this;\n        return new HashSet(hamt.make({ hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq }).mutate(function (h) {\n            var iterator = _this.hamt.values();\n            var curItem = iterator.next();\n            while (!curItem.done) {\n                if (predicate(curItem.value)) {\n                    h.set(curItem.value, curItem.value);\n                }\n                curItem = iterator.next();\n            }\n        }));\n    };\n    /**\n     * Search for an item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     * We name the method findAny instead of find to emphasize\n     * that there is not ordering in a hashset.\n     *\n     *     HashSet.of(1,2,3).findAny(x => x>=3)\n     *     => Option.of(3)\n     *\n     *     HashSet.of(1,2,3).findAny(x => x>=4)\n     *     => Option.none<number>()\n     */\n    HashSet.prototype.findAny = function (predicate) {\n        var iterator = this.hamt.values();\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            if (predicate(curItem.value)) {\n                return Option_1.Option.of(curItem.value);\n            }\n            curItem = iterator.next();\n        }\n        return Option_1.Option.none();\n    };\n    /**\n     * Reduces the collection to a single value using the\n     * associative binary function you give. Since the function\n     * is associative, order of application doesn't matter.\n     *\n     * Example:\n     *\n     *     HashSet.of(1,2,3).fold(0, (a,b) => a + b);\n     *     => 6\n     */\n    HashSet.prototype.fold = function (zero, fn) {\n        return this.foldLeft(zero, fn);\n    };\n    /**\n     * Reduces the collection to a single value.\n     * Left-associative.\n     * No guarantees for the order of items in a hashset!\n     *\n     * Example:\n     *\n     *     HashSet.of(\"a\", \"bb\", \"ccc\").foldLeft(0, (soFar,item) => soFar+item.length);\n     *     => 6\n     *\n     * @param zero The initial value\n     * @param fn A function taking the previous value and\n     *           the current collection item, and returning\n     *           an updated value.\n     */\n    HashSet.prototype.foldLeft = function (zero, fn) {\n        return this.hamt.fold(function (acc, v, k) {\n            return fn(acc, v);\n        }, zero);\n    };\n    /**\n     * Reduces the collection to a single value.\n     * Right-associative.\n     * No guarantees for the order of items in a hashset!\n     *\n     * Example:\n     *\n     *     HashSet.of(\"a\", \"bb\", \"ccc\").foldRight(0, (item,soFar) => soFar+item.length);\n     *     => 6\n     *\n     * @param zero The initial value\n     * @param fn A function taking the current collection item and\n     *           the previous value , and returning\n     *           an updated value.\n     */\n    HashSet.prototype.foldRight = function (zero, fn) {\n        return this.foldLeft(zero, function (cur, soFar) { return fn(soFar, cur); });\n    };\n    /**\n     * Converts this set to an array. Since a Set is not ordered\n     * and since this method returns a JS array, it can be awkward\n     * to get an array sorted in the way you'd like. So you can pass\n     * an optional sorting function too.\n     *\n     *     HashSet.of(1,2,3).toArray().sort()\n     *     => [1,2,3]\n     *\n     *     HashSet.of(1,2,3).toArray({sortOn:x=>x})\n     *     => [1,2,3]\n     *\n     *     HashSet.of(1,2,3).toArray({sortBy:(x,y)=>x-y})\n     *     => [1,2,3]\n     *\n     * You can also pass an array in sortOn, listing lambdas to\n     * several fields to sort by those fields, and also {desc:lambda}\n     * to sort by some fields descending.\n     */\n    HashSet.prototype.toArray = function (sort) {\n        var _a;\n        if (!sort) {\n            return Array.from(this.hamt.keys());\n        }\n        if (ISet_1.isSortOnSpec(sort)) {\n            var sortOn = sort.sortOn instanceof Array ? sort.sortOn : [sort.sortOn];\n            return (_a = Vector_1.Vector.ofIterable(this.hamt.keys())).sortOn.apply(_a, sortOn).toArray();\n        }\n        return Array.from(this.hamt.keys()).sort(sort.sortBy);\n    };\n    /**\n     * Converts this set to an vector\n     */\n    HashSet.prototype.toVector = function () {\n        return Vector_1.Vector.ofIterable(this.hamt.keys());\n    };\n    /**\n     * Converts this set to an list\n     */\n    HashSet.prototype.toLinkedList = function () {\n        return LinkedList_1.LinkedList.ofIterable(this.hamt.keys());\n    };\n    /**\n     * Returns the number of elements in the set.\n     */\n    HashSet.prototype.length = function () {\n        return this.hamt.size;\n    };\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    HashSet.prototype.single = function () {\n        return this.hamt.size === 1\n            ? Option_1.Option.of(this.hamt.keys().next().value)\n            : Option_1.Option.none();\n    };\n    /**\n     * true if the set is empty, false otherwise.\n     */\n    HashSet.prototype.isEmpty = function () {\n        return this.hamt.size === 0;\n    };\n    /**\n     * Returns a new Set containing the difference\n     * between this set and the other Set passed as parameter.\n     * also see [[HashSet.intersect]]\n     */\n    HashSet.prototype.diff = function (elts) {\n        return new HashSet(this.hamt.fold(function (acc, v, k) {\n            return elts.contains(k) ? acc : acc.set(k, k);\n        }, hamt.empty));\n    };\n    /**\n     * Returns a new Set containing the intersection\n     * of this set and the other Set passed as parameter\n     * (the elements which are common to both sets)\n     * also see [[HashSet.diff]]\n     */\n    HashSet.prototype.intersect = function (other) {\n        return new HashSet(this.hamt.fold(function (acc, v, k) {\n            return other.contains(k) ? acc.set(k, k) : acc;\n        }, hamt.empty));\n    };\n    HashSet.prototype.isSubsetOf = function (other) {\n        return this.allMatch(function (x) { return other.contains(x); });\n    };\n    /**\n     * Returns a new set with the element you give removed\n     * if it was present in the set.\n     */\n    HashSet.prototype.remove = function (elt) {\n        return new HashSet(this.hamt.remove(elt));\n    };\n    /**\n     * Returns a new set with all the elements of the current\n     * Set, minus the elements of the iterable you give as a parameter.\n     * If you call this function with a HashSet as parameter,\n     * rather call 'diff', as it'll be faster.\n     */\n    HashSet.prototype.removeAll = function (elts) {\n        return this.diff(HashSet.ofIterable(elts));\n    };\n    HashSet.prototype.allMatch = function (predicate) {\n        var iterator = this.hamt.values();\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            if (!predicate(curItem.value)) {\n                return false;\n            }\n            curItem = iterator.next();\n        }\n        return true;\n    };\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    HashSet.prototype.anyMatch = function (predicate) {\n        var iterator = this.hamt.values();\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            if (predicate(curItem.value)) {\n                return true;\n            }\n            curItem = iterator.next();\n        }\n        return false;\n    };\n    /**\n     * Group elements in the collection using a classifier function.\n     * Elements are then organized in a map. The key is the value of\n     * the classifier, and in value we get the list of elements\n     * matching that value.\n     *\n     * also see [[HashSet.arrangeBy]]\n     */\n    HashSet.prototype.groupBy = function (classifier) {\n        var _this = this;\n        // make a singleton set with the same equality as this\n        var singletonHamtSet = function (v) { return hamt.make({\n            hash: _this.hamt._config.hash, keyEq: _this.hamt._config.keyEq\n        }).set(v, v); };\n        // merge two mutable hamt sets, but I know the second has only 1 elt\n        var mergeSets = function (v1, v2) {\n            var k = v2.keys().next().value;\n            v1.set(k, k);\n            return v1;\n        };\n        return this.hamt.fold(\n        // fold operation: combine a new value from the set with the accumulator\n        function (acc, v, k) {\n            return acc.putWithMerge(classifier(v), singletonHamtSet(v).beginMutation(), mergeSets);\n        }, \n        // fold accumulator: the empty hashmap\n        HashMap_1.HashMap.empty())\n            .mapValues(function (h) { return new HashSet(h.endMutation()); });\n    };\n    /**\n     * Matches each element with a unique key that you extract from it.\n     * If the same key is present twice, the function will return None.\n     *\n     * also see [[HashSet.groupBy]]\n     */\n    HashSet.prototype.arrangeBy = function (getKey) {\n        return SeqHelpers.arrangeBy(this, getKey);\n    };\n    HashSet.prototype.partition = function (predicate) {\n        var r1 = hamt.make({\n            hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq\n        }).beginMutation();\n        var r2 = hamt.make({\n            hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq\n        }).beginMutation();\n        var iterator = this.hamt.values();\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            if (predicate(curItem.value)) {\n                r1.set(curItem.value, curItem.value);\n            }\n            else {\n                r2.set(curItem.value, curItem.value);\n            }\n            curItem = iterator.next();\n        }\n        return [new HashSet(r1), new HashSet(r2)];\n    };\n    /**\n     * Reduces the collection to a single value by repeatedly\n     * calling the combine function.\n     * No starting value. The order in which the elements are\n     * passed to the combining function is undetermined.\n     */\n    HashSet.prototype.reduce = function (combine) {\n        return SeqHelpers.reduce(this, combine);\n    };\n    /**\n     * Compare values in the collection and return the smallest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[HashSet.minOn]]\n     */\n    HashSet.prototype.minBy = function (compare) {\n        return SeqHelpers.minBy(this, compare);\n    };\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the smallest.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[HashSet.minBy]]\n     */\n    HashSet.prototype.minOn = function (getOrderable) {\n        return SeqHelpers.minOn(this, getOrderable);\n    };\n    /**\n     * Compare values in the collection and return the largest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[HashSet.maxOn]]\n     */\n    HashSet.prototype.maxBy = function (compare) {\n        return SeqHelpers.maxBy(this, compare);\n    };\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the largest.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[HashSet.maxBy]]\n     */\n    HashSet.prototype.maxOn = function (getOrderable) {\n        return SeqHelpers.maxOn(this, getOrderable);\n    };\n    /**\n     * Call the function you give for each element in the collection\n     * and sum all the numbers, return that sum.\n     * Will return 0 if the collection is empty.\n     *\n     *     HashSet.of(1,2,3).sumOn(x=>x)\n     *     => 6\n     */\n    HashSet.prototype.sumOn = function (getNumber) {\n        return SeqHelpers.sumOn(this, getNumber);\n    };\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    HashSet.prototype.transform = function (converter) {\n        return converter(this);\n    };\n    HashSet.prototype.toJsSet = function (keyConvert) {\n        return this.foldLeft(new Set(), function (sofar, cur) { return sofar.add(keyConvert(cur)); });\n    };\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    HashSet.prototype.equals = function (other) {\n        if (other === this) {\n            return true;\n        }\n        var sz = this.hamt.size;\n        if (other === emptyHashSet && sz === 0) {\n            // we could get that i'm not the empty map\n            // but my size is zero, after some filtering and such.\n            return true;\n        }\n        if (!other || !other.hamt) {\n            return false;\n        }\n        if (sz !== other.hamt.size) {\n            return false;\n        }\n        Contract_1.contractTrueEquality(\"HashSet.equals\", this, other);\n        var keys = Array.from(this.hamt.keys());\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var k = keys_1[_i];\n            var hisVal = other.hamt.get(k);\n            if (hisVal === undefined) {\n                return false;\n            }\n            if (!Comparison_1.areEqual(k, hisVal)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    HashSet.prototype.hashCode = function () {\n        return this.hamt.fold(function (acc, value, key) {\n            return acc + Comparison_1.getHashCode(key);\n        }, 0);\n    };\n    /**\n     * Get a human-friendly string representation of that value.\n     *\n     * Also see [[HashSet.mkString]]\n     */\n    HashSet.prototype.toString = function () {\n        return \"HashSet(\" +\n            this.hamt.fold(function (acc, value, key) { acc.push(SeqHelpers.toStringHelper(key)); return acc; }, []).join(\", \")\n            + \")\";\n    };\n    HashSet.prototype[Value_1.inspect] = function () {\n        return this.toString();\n    };\n    /**\n     * Joins elements of the collection by a separator.\n     * Example:\n     *\n     *     HashSet.of(1,2,3).mkString(\", \")\n     *     => \"1, 2, 3\"\n     *\n     * (of course, order is not guaranteed)\n     */\n    HashSet.prototype.mkString = function (separator) {\n        return this.hamt.fold(function (acc, value, key) { acc.push(SeqHelpers.toStringHelper(key, { quoteStrings: false })); return acc; }, []).join(separator);\n    };\n    return HashSet;\n}());\nexports.HashSet = HashSet;\n// we need to override the empty hashmap\n// because i don't know how to get the hash & keyset\n// functions for the keys without a key value to get\n// the functions from\nvar EmptyHashSet = /** @class */ (function (_super) {\n    __extends(EmptyHashSet, _super);\n    function EmptyHashSet() {\n        return _super.call(this, {}) || this;\n    }\n    EmptyHashSet.prototype.add = function (elt) {\n        Contract_1.contractTrueEquality(\"Error building a HashSet\", elt);\n        if (!elt) {\n            // special case if we get null for the first element...\n            // less optimized variant because we don't know\n            // if we should use '===' or 'equals'\n            return new HashSet(hamt.make({\n                hash: function (v) { return Comparison_1.getHashCode(v); },\n                keyEq: function (a, b) { return Comparison_1.areEqual(a, b); }\n            }).set(elt, elt));\n        }\n        // if the element is not null, save a if later by finding\n        // out right now whether we should call equals or ===\n        if (Comparison_1.hasEquals(elt)) {\n            return new HashSet(hamt.make({\n                hash: function (v) { return v.hashCode(); },\n                keyEq: function (a, b) { return a.equals(b); }\n            }).set(elt, elt));\n        }\n        return new HashSet(hamt.make().set(elt, elt));\n    };\n    EmptyHashSet.prototype.addAll = function (elts) {\n        var _a;\n        var it = elts[Symbol.iterator]();\n        var curItem = it.next();\n        if (curItem.done) {\n            return emptyHashSet;\n        }\n        return this.add(curItem.value).addAll((_a = {}, _a[Symbol.iterator] = function () { return it; }, _a));\n    };\n    EmptyHashSet.prototype.contains = function (elt) {\n        return false;\n    };\n    EmptyHashSet.prototype.map = function (mapper) {\n        return emptyHashSet;\n    };\n    EmptyHashSet.prototype.mapOption = function (mapper) {\n        return emptyHashSet;\n    };\n    EmptyHashSet.prototype.forEach = function (fun) {\n        return this;\n    };\n    EmptyHashSet.prototype.filter = function (predicate) {\n        return this;\n    };\n    EmptyHashSet.prototype.findAny = function (predicate) {\n        return Option_1.Option.none();\n    };\n    EmptyHashSet.prototype.foldLeft = function (zero, fn) {\n        return zero;\n    };\n    EmptyHashSet.prototype.toArray = function (sort) {\n        return [];\n    };\n    EmptyHashSet.prototype.toVector = function () {\n        return Vector_1.Vector.empty();\n    };\n    EmptyHashSet.prototype.toLinkedList = function () {\n        return LinkedList_1.LinkedList.empty();\n    };\n    EmptyHashSet.prototype[Symbol.iterator] = function () {\n        return { next: function () { return ({ done: true, value: undefined }); } };\n    };\n    EmptyHashSet.prototype.length = function () {\n        return 0;\n    };\n    EmptyHashSet.prototype.isEmpty = function () {\n        return true;\n    };\n    EmptyHashSet.prototype.diff = function (elts) {\n        return this;\n    };\n    EmptyHashSet.prototype.intersect = function (other) {\n        return this;\n    };\n    EmptyHashSet.prototype.anyMatch = function (predicate) {\n        return false;\n    };\n    EmptyHashSet.prototype.groupBy = function (classifier) {\n        return HashMap_1.HashMap.empty();\n    };\n    EmptyHashSet.prototype.allMatch = function (predicate) {\n        return true;\n    };\n    EmptyHashSet.prototype.partition = function (predicate) {\n        return [this, this];\n    };\n    EmptyHashSet.prototype.remove = function (elt) {\n        return this;\n    };\n    EmptyHashSet.prototype.equals = function (other) {\n        if (!other || !other.length) {\n            return false;\n        }\n        return other === emptyHashSet || other.length() === 0;\n    };\n    EmptyHashSet.prototype.hashCode = function () {\n        return 0;\n    };\n    EmptyHashSet.prototype.toString = function () {\n        return \"HashSet()\";\n    };\n    EmptyHashSet.prototype.mkString = function (separator) {\n        return \"\";\n    };\n    return EmptyHashSet;\n}(HashSet));\nvar emptyHashSet = new EmptyHashSet();\n//# sourceMappingURL=HashSet.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}