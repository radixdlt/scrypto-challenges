{"ast":null,"code":"var assert = require('assert');\nvar Buffer = require('safe-buffer').Buffer;\nvar crypto = require('crypto');\nvar bs58check = require('bs58check');\nvar RIPEMD160 = require('ripemd160');\nvar secp256k1 = require('secp256k1');\nvar MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');\nvar HARDENED_OFFSET = 0x80000000;\nvar LEN = 78;\n\n// Bitcoin hardcoded by default, can use package `coininfo` for others\nvar BITCOIN_VERSIONS = {\n  private: 0x0488ADE4,\n  public: 0x0488B21E\n};\nfunction HDKey(versions) {\n  this.versions = versions || BITCOIN_VERSIONS;\n  this.depth = 0;\n  this.index = 0;\n  this._privateKey = null;\n  this._publicKey = null;\n  this.chainCode = null;\n  this._fingerprint = 0;\n  this.parentFingerprint = 0;\n}\nObject.defineProperty(HDKey.prototype, 'fingerprint', {\n  get: function () {\n    return this._fingerprint;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'identifier', {\n  get: function () {\n    return this._identifier;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'pubKeyHash', {\n  get: function () {\n    return this.identifier;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'privateKey', {\n  get: function () {\n    return this._privateKey;\n  },\n  set: function (value) {\n    assert.equal(value.length, 32, 'Private key must be 32 bytes.');\n    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key');\n    this._privateKey = value;\n    this._publicKey = Buffer.from(secp256k1.publicKeyCreate(value, true));\n    this._identifier = hash160(this.publicKey);\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0);\n  }\n});\nfunction setPublicKey(hdkey, publicKey) {\n  hdkey._publicKey = Buffer.from(publicKey);\n  hdkey._identifier = hash160(publicKey);\n  hdkey._fingerprint = hdkey._identifier.slice(0, 4).readUInt32BE(0);\n  hdkey._privateKey = null;\n}\nObject.defineProperty(HDKey.prototype, 'publicKey', {\n  get: function () {\n    return this._publicKey;\n  },\n  set: function (value) {\n    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.');\n    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key');\n    // force compressed point (performs public key verification)\n    const publicKey = value.length === 65 ? secp256k1.publicKeyConvert(value, true) : value;\n    setPublicKey(this, publicKey);\n  }\n});\nObject.defineProperty(HDKey.prototype, 'privateExtendedKey', {\n  get: function () {\n    if (this._privateKey) return bs58check.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])));else return null;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'publicExtendedKey', {\n  get: function () {\n    return bs58check.encode(serialize(this, this.versions.public, this.publicKey));\n  }\n});\nHDKey.prototype.derive = function (path) {\n  if (path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return this;\n  }\n  var entries = path.split('/');\n  var hdkey = this;\n  entries.forEach(function (c, i) {\n    if (i === 0) {\n      assert(/^[mM]{1}/.test(c), 'Path must start with \"m\" or \"M\"');\n      return;\n    }\n    var hardened = c.length > 1 && c[c.length - 1] === \"'\";\n    var childIndex = parseInt(c, 10); // & (HARDENED_OFFSET - 1)\n    assert(childIndex < HARDENED_OFFSET, 'Invalid index');\n    if (hardened) childIndex += HARDENED_OFFSET;\n    hdkey = hdkey.deriveChild(childIndex);\n  });\n  return hdkey;\n};\nHDKey.prototype.deriveChild = function (index) {\n  var isHardened = index >= HARDENED_OFFSET;\n  var indexBuffer = Buffer.allocUnsafe(4);\n  indexBuffer.writeUInt32BE(index, 0);\n  var data;\n  if (isHardened) {\n    // Hardened child\n    assert(this.privateKey, 'Could not derive hardened child key');\n    var pk = this.privateKey;\n    var zb = Buffer.alloc(1, 0);\n    pk = Buffer.concat([zb, pk]);\n\n    // data = 0x00 || ser256(kpar) || ser32(index)\n    data = Buffer.concat([pk, indexBuffer]);\n  } else {\n    // Normal child\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    data = Buffer.concat([this.publicKey, indexBuffer]);\n  }\n  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var hd = new HDKey(this.versions);\n\n  // Private parent key -> private child key\n  if (this.privateKey) {\n    // ki = parse256(IL) + kpar (mod n)\n    try {\n      hd.privateKey = Buffer.from(secp256k1.privateKeyTweakAdd(Buffer.from(this.privateKey), IL));\n      // throw if IL >= n || (privateKey + IL) === 0\n    } catch (err) {\n      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i\n      return this.deriveChild(index + 1);\n    }\n    // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    try {\n      hd.publicKey = Buffer.from(secp256k1.publicKeyTweakAdd(Buffer.from(this.publicKey), IL, true));\n      // throw if IL >= n || (g**IL + publicKey) is infinity\n    } catch (err) {\n      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i\n      return this.deriveChild(index + 1);\n    }\n  }\n  hd.chainCode = IR;\n  hd.depth = this.depth + 1;\n  hd.parentFingerprint = this.fingerprint; // .readUInt32BE(0)\n  hd.index = index;\n  return hd;\n};\nHDKey.prototype.sign = function (hash) {\n  return Buffer.from(secp256k1.ecdsaSign(Uint8Array.from(hash), Uint8Array.from(this.privateKey)).signature);\n};\nHDKey.prototype.verify = function (hash, signature) {\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(hash), Uint8Array.from(this.publicKey));\n};\nHDKey.prototype.wipePrivateData = function () {\n  if (this._privateKey) crypto.randomBytes(this._privateKey.length).copy(this._privateKey);\n  this._privateKey = null;\n  return this;\n};\nHDKey.prototype.toJSON = function () {\n  return {\n    xpriv: this.privateExtendedKey,\n    xpub: this.publicExtendedKey\n  };\n};\nHDKey.fromMasterSeed = function (seedBuffer, versions) {\n  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var hdkey = new HDKey(versions);\n  hdkey.chainCode = IR;\n  hdkey.privateKey = IL;\n  return hdkey;\n};\nHDKey.fromExtendedKey = function (base58key, versions, skipVerification) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  versions = versions || BITCOIN_VERSIONS;\n  skipVerification = skipVerification || false;\n  var hdkey = new HDKey(versions);\n  var keyBuffer = bs58check.decode(base58key);\n  var version = keyBuffer.readUInt32BE(0);\n  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public');\n  hdkey.depth = keyBuffer.readUInt8(4);\n  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5);\n  hdkey.index = keyBuffer.readUInt32BE(9);\n  hdkey.chainCode = keyBuffer.slice(13, 45);\n  var key = keyBuffer.slice(45);\n  if (key.readUInt8(0) === 0) {\n    // private\n    assert(version === versions.private, 'Version mismatch: version does not match private');\n    hdkey.privateKey = key.slice(1); // cut off first 0x0 byte\n  } else {\n    assert(version === versions.public, 'Version mismatch: version does not match public');\n    if (skipVerification) {\n      setPublicKey(hdkey, key);\n    } else {\n      hdkey.publicKey = key;\n    }\n  }\n  return hdkey;\n};\nHDKey.fromJSON = function (obj) {\n  return HDKey.fromExtendedKey(obj.xpriv);\n};\nfunction serialize(hdkey, version, key) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  var buffer = Buffer.allocUnsafe(LEN);\n  buffer.writeUInt32BE(version, 0);\n  buffer.writeUInt8(hdkey.depth, 4);\n  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000;\n  buffer.writeUInt32BE(fingerprint, 5);\n  buffer.writeUInt32BE(hdkey.index, 9);\n  hdkey.chainCode.copy(buffer, 13);\n  key.copy(buffer, 45);\n  return buffer;\n}\nfunction hash160(buf) {\n  var sha = crypto.createHash('sha256').update(buf).digest();\n  return new RIPEMD160().update(sha).digest();\n}\nHDKey.HARDENED_OFFSET = HARDENED_OFFSET;\nmodule.exports = HDKey;","map":{"version":3,"names":["assert","require","Buffer","crypto","bs58check","RIPEMD160","secp256k1","MASTER_SECRET","from","HARDENED_OFFSET","LEN","BITCOIN_VERSIONS","private","public","HDKey","versions","depth","index","_privateKey","_publicKey","chainCode","_fingerprint","parentFingerprint","Object","defineProperty","prototype","get","_identifier","identifier","set","value","equal","length","privateKeyVerify","publicKeyCreate","hash160","publicKey","slice","readUInt32BE","setPublicKey","hdkey","publicKeyVerify","publicKeyConvert","encode","serialize","concat","alloc","privateKey","derive","path","entries","split","forEach","c","i","test","hardened","childIndex","parseInt","deriveChild","isHardened","indexBuffer","allocUnsafe","writeUInt32BE","data","pk","zb","I","createHmac","update","digest","IL","IR","hd","privateKeyTweakAdd","err","publicKeyTweakAdd","fingerprint","sign","hash","ecdsaSign","Uint8Array","signature","verify","ecdsaVerify","wipePrivateData","randomBytes","copy","toJSON","xpriv","privateExtendedKey","xpub","publicExtendedKey","fromMasterSeed","seedBuffer","fromExtendedKey","base58key","skipVerification","keyBuffer","decode","version","readUInt8","key","fromJSON","obj","buffer","writeUInt8","buf","sha","createHash","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/hdkey/lib/hdkey.js"],"sourcesContent":["var assert = require('assert')\nvar Buffer = require('safe-buffer').Buffer\nvar crypto = require('crypto')\nvar bs58check = require('bs58check')\nvar RIPEMD160 = require('ripemd160')\nvar secp256k1 = require('secp256k1')\n\nvar MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')\nvar HARDENED_OFFSET = 0x80000000\nvar LEN = 78\n\n// Bitcoin hardcoded by default, can use package `coininfo` for others\nvar BITCOIN_VERSIONS = {private: 0x0488ADE4, public: 0x0488B21E}\n\nfunction HDKey (versions) {\n  this.versions = versions || BITCOIN_VERSIONS\n  this.depth = 0\n  this.index = 0\n  this._privateKey = null\n  this._publicKey = null\n  this.chainCode = null\n  this._fingerprint = 0\n  this.parentFingerprint = 0\n}\n\nObject.defineProperty(HDKey.prototype, 'fingerprint', { get: function () { return this._fingerprint } })\nObject.defineProperty(HDKey.prototype, 'identifier', { get: function () { return this._identifier } })\nObject.defineProperty(HDKey.prototype, 'pubKeyHash', { get: function () { return this.identifier } })\n\nObject.defineProperty(HDKey.prototype, 'privateKey', {\n  get: function () {\n    return this._privateKey\n  },\n  set: function (value) {\n    assert.equal(value.length, 32, 'Private key must be 32 bytes.')\n    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key')\n\n    this._privateKey = value\n    this._publicKey = Buffer.from(secp256k1.publicKeyCreate(value, true))\n    this._identifier = hash160(this.publicKey)\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)\n  }\n})\n\nfunction setPublicKey (hdkey, publicKey) {\n  hdkey._publicKey = Buffer.from(publicKey)\n  hdkey._identifier = hash160(publicKey)\n  hdkey._fingerprint = hdkey._identifier.slice(0, 4).readUInt32BE(0)\n  hdkey._privateKey = null\n}\n\nObject.defineProperty(HDKey.prototype, 'publicKey', {\n  get: function () {\n    return this._publicKey\n  },\n  set: function (value) {\n    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.')\n    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key')\n    // force compressed point (performs public key verification)\n    const publicKey = (value.length === 65) ? secp256k1.publicKeyConvert(value, true) : value\n    setPublicKey(this, publicKey)\n  }\n})\n\nObject.defineProperty(HDKey.prototype, 'privateExtendedKey', {\n  get: function () {\n    if (this._privateKey) return bs58check.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])))\n    else return null\n  }\n})\n\nObject.defineProperty(HDKey.prototype, 'publicExtendedKey', {\n  get: function () {\n    return bs58check.encode(serialize(this, this.versions.public, this.publicKey))\n  }\n})\n\nHDKey.prototype.derive = function (path) {\n  if (path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return this\n  }\n\n  var entries = path.split('/')\n  var hdkey = this\n  entries.forEach(function (c, i) {\n    if (i === 0) {\n      assert(/^[mM]{1}/.test(c), 'Path must start with \"m\" or \"M\"')\n      return\n    }\n\n    var hardened = (c.length > 1) && (c[c.length - 1] === \"'\")\n    var childIndex = parseInt(c, 10) // & (HARDENED_OFFSET - 1)\n    assert(childIndex < HARDENED_OFFSET, 'Invalid index')\n    if (hardened) childIndex += HARDENED_OFFSET\n\n    hdkey = hdkey.deriveChild(childIndex)\n  })\n\n  return hdkey\n}\n\nHDKey.prototype.deriveChild = function (index) {\n  var isHardened = index >= HARDENED_OFFSET\n  var indexBuffer = Buffer.allocUnsafe(4)\n  indexBuffer.writeUInt32BE(index, 0)\n\n  var data\n\n  if (isHardened) { // Hardened child\n    assert(this.privateKey, 'Could not derive hardened child key')\n\n    var pk = this.privateKey\n    var zb = Buffer.alloc(1, 0)\n    pk = Buffer.concat([zb, pk])\n\n    // data = 0x00 || ser256(kpar) || ser32(index)\n    data = Buffer.concat([pk, indexBuffer])\n  } else { // Normal child\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    data = Buffer.concat([this.publicKey, indexBuffer])\n  }\n\n  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  var hd = new HDKey(this.versions)\n\n  // Private parent key -> private child key\n  if (this.privateKey) {\n    // ki = parse256(IL) + kpar (mod n)\n    try {\n      hd.privateKey = Buffer.from(secp256k1.privateKeyTweakAdd(Buffer.from(this.privateKey), IL))\n      // throw if IL >= n || (privateKey + IL) === 0\n    } catch (err) {\n      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i\n      return this.deriveChild(index + 1)\n    }\n  // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    try {\n      hd.publicKey = Buffer.from(secp256k1.publicKeyTweakAdd(Buffer.from(this.publicKey), IL, true))\n      // throw if IL >= n || (g**IL + publicKey) is infinity\n    } catch (err) {\n      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i\n      return this.deriveChild(index + 1)\n    }\n  }\n\n  hd.chainCode = IR\n  hd.depth = this.depth + 1\n  hd.parentFingerprint = this.fingerprint// .readUInt32BE(0)\n  hd.index = index\n\n  return hd\n}\n\nHDKey.prototype.sign = function (hash) {\n  return Buffer.from(secp256k1.ecdsaSign(Uint8Array.from(hash), Uint8Array.from(this.privateKey)).signature)\n}\n\nHDKey.prototype.verify = function (hash, signature) {\n  return secp256k1.ecdsaVerify(\n    Uint8Array.from(signature),\n    Uint8Array.from(hash),\n    Uint8Array.from(this.publicKey)\n  )\n}\n\nHDKey.prototype.wipePrivateData = function () {\n  if (this._privateKey) crypto.randomBytes(this._privateKey.length).copy(this._privateKey)\n  this._privateKey = null\n  return this\n}\n\nHDKey.prototype.toJSON = function () {\n  return {\n    xpriv: this.privateExtendedKey,\n    xpub: this.publicExtendedKey\n  }\n}\n\nHDKey.fromMasterSeed = function (seedBuffer, versions) {\n  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  var hdkey = new HDKey(versions)\n  hdkey.chainCode = IR\n  hdkey.privateKey = IL\n\n  return hdkey\n}\n\nHDKey.fromExtendedKey = function (base58key, versions, skipVerification) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  versions = versions || BITCOIN_VERSIONS\n  skipVerification = skipVerification || false\n  var hdkey = new HDKey(versions)\n\n  var keyBuffer = bs58check.decode(base58key)\n\n  var version = keyBuffer.readUInt32BE(0)\n  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public')\n\n  hdkey.depth = keyBuffer.readUInt8(4)\n  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5)\n  hdkey.index = keyBuffer.readUInt32BE(9)\n  hdkey.chainCode = keyBuffer.slice(13, 45)\n\n  var key = keyBuffer.slice(45)\n  if (key.readUInt8(0) === 0) { // private\n    assert(version === versions.private, 'Version mismatch: version does not match private')\n    hdkey.privateKey = key.slice(1) // cut off first 0x0 byte\n  } else {\n    assert(version === versions.public, 'Version mismatch: version does not match public')\n    if (skipVerification) {\n      setPublicKey(hdkey, key)\n    } else {\n      hdkey.publicKey = key\n    }\n  }\n\n  return hdkey\n}\n\nHDKey.fromJSON = function (obj) {\n  return HDKey.fromExtendedKey(obj.xpriv)\n}\n\nfunction serialize (hdkey, version, key) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  var buffer = Buffer.allocUnsafe(LEN)\n\n  buffer.writeUInt32BE(version, 0)\n  buffer.writeUInt8(hdkey.depth, 4)\n\n  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000\n  buffer.writeUInt32BE(fingerprint, 5)\n  buffer.writeUInt32BE(hdkey.index, 9)\n\n  hdkey.chainCode.copy(buffer, 13)\n  key.copy(buffer, 45)\n\n  return buffer\n}\n\nfunction hash160 (buf) {\n  var sha = crypto.createHash('sha256').update(buf).digest()\n  return new RIPEMD160().update(sha).digest()\n}\n\nHDKey.HARDENED_OFFSET = HARDENED_OFFSET\nmodule.exports = HDKey\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}