{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionIntentBuilder = exports.flatMapAddressesOf = exports.getUniqueAddresses = exports.isUnstakeTokensAction = exports.isStakeTokensAction = exports.isTransferTokensAction = exports.singleRecipientFromActions = void 0;\nconst actions_1 = require(\"../actions\");\nconst account_1 = require(\"../../../account\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst actions_2 = require(\"../actions\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst crypto_1 = require(\"../../../crypto\");\nconst prelude_ts_1 = require(\"prelude-ts\");\nconst primitives_1 = require(\"../../../primitives\");\nconst util_1 = require(\"../../../util\");\nconst singleRecipientFromActions = (mine, actions) => {\n  const others = (0, exports.flatMapAddressesOf)({\n    actions\n  }).map(a => a.publicKey).filter(a => !a.equals(mine));\n  if (others.length > 1) {\n    const errMsg = `Cannot encrypt/decrypt message for a transaction containing more than one recipient addresses.`;\n    util_1.log.error(errMsg);\n    throw new Error(errMsg);\n  }\n  const toSelf = others.length === 0;\n  if (toSelf) {\n    util_1.log.debug(`Encrypted message is to oneself.`);\n  }\n  return (0, neverthrow_1.ok)(toSelf ? mine : others[0]);\n};\nexports.singleRecipientFromActions = singleRecipientFromActions;\nconst ensureSingleRecipient = input => (0, util_1.toObservableFromResult)((0, exports.singleRecipientFromActions)(input.encryptingAccount.publicKey, input.intendedActionsFrom.intendedActions)).pipe((0, operators_1.map)(singleRecipientPublicKey => ({\n  encryptingAccount: input.encryptingAccount,\n  singleRecipientPublicKey: singleRecipientPublicKey\n})));\nconst mustHaveAtLeastOneAction = new Error('A transaction intent must contain at least one of the following actions: TransferToken, StakeTokens or UnstakeTokens');\nconst isTransferTokensAction = something => {\n  const inspection = something;\n  return inspection.type === actions_1.ActionType.TOKEN_TRANSFER && !!inspection.to_account && !!inspection.from_account && (0, primitives_1.isAmount)(inspection.amount) && (0, account_1.isResourceIdentifier)(inspection.rri);\n};\nexports.isTransferTokensAction = isTransferTokensAction;\nconst isStakeTokensAction = something => {\n  const inspection = something;\n  return inspection.type === actions_1.ActionType.STAKE_TOKENS && !!inspection.from_account && !!inspection.to_validator && (0, primitives_1.isAmount)(inspection.amount);\n};\nexports.isStakeTokensAction = isStakeTokensAction;\nconst isUnstakeTokensAction = something => {\n  const inspection = something;\n  return inspection.type === actions_1.ActionType.UNSTAKE_TOKENS && !!inspection.from_validator && !!inspection.to_account && (0, primitives_1.isAmount)(inspection.amount);\n};\nexports.isUnstakeTokensAction = isUnstakeTokensAction;\nconst decodeApiAddress = address => {\n  const result = account_1.AccountAddress.fromUnsafe(address);\n  return result._unsafeUnwrap();\n};\nconst getUniqueAddresses = input => {\n  var _a, _b;\n  const action = input.action;\n  const includeFrom = (_a = input.includeFrom) !== null && _a !== void 0 ? _a : true;\n  const includeTo = (_b = input.includeTo) !== null && _b !== void 0 ? _b : true;\n  if ((0, exports.isTransferTokensAction)(action)) {\n    const addresses = [];\n    if (includeTo) {\n      addresses.push(decodeApiAddress(action.to_account));\n    }\n    if (includeFrom) {\n      addresses.push(decodeApiAddress(action.from_account));\n    }\n    return addresses;\n  } else if ((0, exports.isStakeTokensAction)(action)) {\n    const addresses = [];\n    if (includeFrom) {\n      addresses.push(decodeApiAddress(action.from_account));\n    }\n    return addresses;\n  } else if ((0, exports.isUnstakeTokensAction)(action)) {\n    const addresses = [];\n    if (includeFrom) {\n      addresses.push(decodeApiAddress(action.to_account));\n    }\n    return addresses;\n  } else {\n    return [];\n  }\n};\nexports.getUniqueAddresses = getUniqueAddresses;\nconst flatMapAddressesOf = input => {\n  const {\n    actions,\n    includeFrom,\n    includeTo\n  } = input;\n  const flatMapped = actions.reduce((acc, action) => {\n    const uniqueAddressOfAction = (0, exports.getUniqueAddresses)({\n      action,\n      includeFrom,\n      includeTo\n    });\n    return acc.concat(...uniqueAddressOfAction);\n  }, []);\n  const set = new Set();\n  return flatMapped.filter(a => {\n    const str = a.toString();\n    const hasNt = !set.has(str);\n    set.add(str);\n    return hasNt;\n  });\n};\nexports.flatMapAddressesOf = flatMapAddressesOf;\nconst isTransactionIntentBuilderEncryptInput = something => {\n  const inspection = something;\n  return inspection.encryptMessageIfAnyWithAccount !== undefined && (0, rxjs_1.isObservable)(inspection.encryptMessageIfAnyWithAccount) && (inspection.spendingSender !== undefined ? (0, rxjs_1.isObservable)(inspection.spendingSender) : true);\n};\nconst isTransactionIntentBuilderDoNotEncryptInput = something => {\n  if (isTransactionIntentBuilderEncryptInput(something)) {\n    return false;\n  }\n  const inspection = something;\n  return inspection.spendingSender !== undefined && (0, rxjs_1.isObservable)(inspection.spendingSender);\n};\nconst isTransactionIntentBuilderDoNotEncryptOption = something => {\n  const inspection = something;\n  return inspection.skipEncryptionOfMessageIfAny !== undefined && isTransactionIntentBuilderDoNotEncryptInput(inspection.skipEncryptionOfMessageIfAny);\n};\nconst create = () => {\n  const intermediateActions = [];\n  let maybePlaintextMsgToEncrypt = prelude_ts_1.Option.none();\n  const snapshotState = () => ({\n    actionInputs: intermediateActions,\n    message: maybePlaintextMsgToEncrypt.getOrUndefined()\n  });\n  const snapshotBuilderState = () => ({\n    __state: snapshotState()\n  });\n  const addAction = (input, type) => {\n    intermediateActions.push(Object.assign({\n      type\n    }, input));\n    return Object.assign(Object.assign({}, methods), snapshotBuilderState());\n  };\n  const transferTokens = input => addAction(input, 'transfer');\n  const stakeTokens = input => addAction(input, 'stake');\n  const unstakeTokens = input => addAction(input, 'unstake');\n  const replaceAnyPreviousMessageWithNew = newMessage => {\n    maybePlaintextMsgToEncrypt = prelude_ts_1.Option.some(newMessage);\n    return Object.assign(Object.assign({}, methods), snapshotBuilderState());\n  };\n  const intendedActionsFromIntermediateActions = from => {\n    if (intermediateActions.length === 0) return (0, neverthrow_1.err)(mustHaveAtLeastOneAction);\n    return (0, neverthrow_1.combine)(intermediateActions.map(i => {\n      const intermediateActionType = i.type;\n      if (intermediateActionType === 'transfer') {\n        if ((0, actions_2.isTransferTokensInput)(i)) {\n          return actions_2.IntendedTransferTokens.create(i, from);\n        } else {\n          throw new Error('Not transfer tokens input');\n        }\n      } else if (intermediateActionType === 'stake') {\n        if ((0, actions_2.isStakeTokensInput)(i)) {\n          return actions_2.IntendedStakeTokens.create(i, from);\n        } else {\n          throw new Error('Not stake tokens input');\n        }\n      } else if (intermediateActionType === 'unstake') {\n        return actions_2.IntendedUnstakeTokens.create(i, from);\n      } else {\n        return (0, neverthrow_1.err)(new Error('Incorrect implementation, forgot something...'));\n      }\n    })).map(intendedActions => ({\n      intendedActions,\n      from\n    }));\n  };\n  const syncBuildDoNotEncryptMessageIfAny = from => intendedActionsFromIntermediateActions(from).map(({\n    intendedActions\n  }) => ({\n    actions: intendedActions,\n    message: maybePlaintextMsgToEncrypt.map(msg => msg.plaintext ? crypto_1.Message.createPlaintext(msg.plaintext).bytes : undefined).getOrUndefined()\n  }));\n  const build = options => {\n    var _a;\n    if (isTransactionIntentBuilderDoNotEncryptOption(options)) {\n      if (maybePlaintextMsgToEncrypt.map(m => m.encrypt).getOrElse(false)) {\n        const errMsg = `Message in transaction specifies it should be encrypted, but input to TransactionIntentBuilder build method specifies that it (the builder) should not encrypt the message, and does not provide any account with which we can perform encryption.`;\n        console.error(errMsg);\n        util_1.log.error(errMsg);\n        return (0, rxjs_1.throwError)(new Error(errMsg));\n      }\n      return options.skipEncryptionOfMessageIfAny.spendingSender.pipe((0, operators_1.mergeMap)(from => (0, util_1.toObservableFromResult)(syncBuildDoNotEncryptMessageIfAny(from))));\n    }\n    if (!isTransactionIntentBuilderEncryptInput(options)) {\n      throw new Error('Incorrect implementation');\n    }\n    const encryptingAccount$ = options.encryptMessageIfAnyWithAccount;\n    const spendingSender = (_a = options.spendingSender) !== null && _a !== void 0 ? _a : options.encryptMessageIfAnyWithAccount.pipe((0, operators_1.map)(account => account.address));\n    return spendingSender.pipe((0, operators_1.mergeMap)(from => (0, util_1.toObservableFromResult)(intendedActionsFromIntermediateActions(from))), (0, operators_1.mergeMap)(intendedActionsFrom => {\n      const transactionIntentWithoutEncryption = plaintextMessage => {\n        util_1.log.info(`Successfully built transaction. Actions: ${intendedActionsFrom.intendedActions.map(action => action.type).toString()}`);\n        return (0, rxjs_1.of)({\n          actions: intendedActionsFrom.intendedActions,\n          message: plaintextMessage !== undefined ? crypto_1.MessageEncryption.encodePlaintext(plaintextMessage) : undefined\n        });\n      };\n      return maybePlaintextMsgToEncrypt.match({\n        Some: msgInTx => {\n          if (!msgInTx.encrypt) {\n            const errMsg = 'You are trying to encrypt a message which was specified not to be encrypted.';\n            console.error(errMsg);\n            util_1.log.error(errMsg);\n            return (0, rxjs_1.throwError)(new Error(errMsg));\n          }\n          return encryptingAccount$.pipe((0, operators_1.mergeMap)(encryptingAccount => ensureSingleRecipient({\n            intendedActionsFrom,\n            encryptingAccount\n          })), (0, operators_1.mergeMap)(actors => actors.encryptingAccount.encrypt({\n            plaintext: msgInTx.plaintext,\n            publicKeyOfOtherParty: actors.singleRecipientPublicKey\n          })), (0, operators_1.map)(encryptedMessage => {\n            util_1.log.info(`Successfully built transaction with encrypted message. Actions: ${intendedActionsFrom.intendedActions.map(action => action.type).toString()}`);\n            return {\n              actions: intendedActionsFrom.intendedActions,\n              message: encryptedMessage.combined()\n            };\n          }));\n        },\n        None: () => transactionIntentWithoutEncryption(undefined)\n      });\n    }));\n  };\n  const methods = {\n    transferTokens,\n    stakeTokens,\n    unstakeTokens,\n    build,\n    message: replaceAnyPreviousMessageWithNew,\n    __syncBuildDoNotEncryptMessageIfAny: syncBuildDoNotEncryptMessageIfAny\n  };\n  return Object.assign(Object.assign({}, snapshotBuilderState()), methods);\n};\nexports.TransactionIntentBuilder = {\n  create\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","TransactionIntentBuilder","flatMapAddressesOf","getUniqueAddresses","isUnstakeTokensAction","isStakeTokensAction","isTransferTokensAction","singleRecipientFromActions","actions_1","require","account_1","rxjs_1","operators_1","actions_2","neverthrow_1","crypto_1","prelude_ts_1","primitives_1","util_1","mine","actions","others","map","a","publicKey","filter","equals","length","errMsg","log","error","Error","toSelf","debug","ok","ensureSingleRecipient","input","toObservableFromResult","encryptingAccount","intendedActionsFrom","intendedActions","pipe","singleRecipientPublicKey","mustHaveAtLeastOneAction","something","inspection","type","ActionType","TOKEN_TRANSFER","to_account","from_account","isAmount","amount","isResourceIdentifier","rri","STAKE_TOKENS","to_validator","UNSTAKE_TOKENS","from_validator","decodeApiAddress","address","result","AccountAddress","fromUnsafe","_unsafeUnwrap","_a","_b","action","includeFrom","includeTo","addresses","push","flatMapped","reduce","acc","uniqueAddressOfAction","concat","set","Set","str","toString","hasNt","has","add","isTransactionIntentBuilderEncryptInput","encryptMessageIfAnyWithAccount","undefined","isObservable","spendingSender","isTransactionIntentBuilderDoNotEncryptInput","isTransactionIntentBuilderDoNotEncryptOption","skipEncryptionOfMessageIfAny","create","intermediateActions","maybePlaintextMsgToEncrypt","Option","none","snapshotState","actionInputs","message","getOrUndefined","snapshotBuilderState","__state","addAction","assign","methods","transferTokens","stakeTokens","unstakeTokens","replaceAnyPreviousMessageWithNew","newMessage","some","intendedActionsFromIntermediateActions","from","err","combine","i","intermediateActionType","isTransferTokensInput","IntendedTransferTokens","isStakeTokensInput","IntendedStakeTokens","IntendedUnstakeTokens","syncBuildDoNotEncryptMessageIfAny","msg","plaintext","Message","createPlaintext","bytes","build","options","m","encrypt","getOrElse","console","throwError","mergeMap","encryptingAccount$","account","transactionIntentWithoutEncryption","plaintextMessage","info","of","MessageEncryption","encodePlaintext","match","Some","msgInTx","actors","publicKeyOfOtherParty","encryptedMessage","combined","None","__syncBuildDoNotEncryptMessageIfAny"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/application/dist/dto/transactionIntentBuilder.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionIntentBuilder = exports.flatMapAddressesOf = exports.getUniqueAddresses = exports.isUnstakeTokensAction = exports.isStakeTokensAction = exports.isTransferTokensAction = exports.singleRecipientFromActions = void 0;\nconst actions_1 = require(\"../actions\");\nconst account_1 = require(\"../../../account\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst actions_2 = require(\"../actions\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst crypto_1 = require(\"../../../crypto\");\nconst prelude_ts_1 = require(\"prelude-ts\");\nconst primitives_1 = require(\"../../../primitives\");\nconst util_1 = require(\"../../../util\");\nconst singleRecipientFromActions = (mine, actions) => {\n    const others = (0, exports.flatMapAddressesOf)({ actions })\n        .map(a => a.publicKey)\n        .filter(a => !a.equals(mine));\n    if (others.length > 1) {\n        const errMsg = `Cannot encrypt/decrypt message for a transaction containing more than one recipient addresses.`;\n        util_1.log.error(errMsg);\n        throw new Error(errMsg);\n    }\n    const toSelf = others.length === 0;\n    if (toSelf) {\n        util_1.log.debug(`Encrypted message is to oneself.`);\n    }\n    return (0, neverthrow_1.ok)(toSelf ? mine : others[0]);\n};\nexports.singleRecipientFromActions = singleRecipientFromActions;\nconst ensureSingleRecipient = (input) => (0, util_1.toObservableFromResult)((0, exports.singleRecipientFromActions)(input.encryptingAccount.publicKey, input.intendedActionsFrom.intendedActions)).pipe((0, operators_1.map)(singleRecipientPublicKey => ({\n    encryptingAccount: input.encryptingAccount,\n    singleRecipientPublicKey: singleRecipientPublicKey,\n})));\nconst mustHaveAtLeastOneAction = new Error('A transaction intent must contain at least one of the following actions: TransferToken, StakeTokens or UnstakeTokens');\nconst isTransferTokensAction = (something) => {\n    const inspection = something;\n    return (inspection.type === actions_1.ActionType.TOKEN_TRANSFER &&\n        !!inspection.to_account &&\n        !!inspection.from_account &&\n        (0, primitives_1.isAmount)(inspection.amount) &&\n        (0, account_1.isResourceIdentifier)(inspection.rri));\n};\nexports.isTransferTokensAction = isTransferTokensAction;\nconst isStakeTokensAction = (something) => {\n    const inspection = something;\n    return (inspection.type === actions_1.ActionType.STAKE_TOKENS &&\n        !!inspection.from_account &&\n        !!inspection.to_validator &&\n        (0, primitives_1.isAmount)(inspection.amount));\n};\nexports.isStakeTokensAction = isStakeTokensAction;\nconst isUnstakeTokensAction = (something) => {\n    const inspection = something;\n    return (inspection.type === actions_1.ActionType.UNSTAKE_TOKENS &&\n        !!inspection.from_validator &&\n        !!inspection.to_account &&\n        (0, primitives_1.isAmount)(inspection.amount));\n};\nexports.isUnstakeTokensAction = isUnstakeTokensAction;\nconst decodeApiAddress = (address) => {\n    const result = account_1.AccountAddress.fromUnsafe(address);\n    return result._unsafeUnwrap();\n};\nconst getUniqueAddresses = (input) => {\n    var _a, _b;\n    const action = input.action;\n    const includeFrom = (_a = input.includeFrom) !== null && _a !== void 0 ? _a : true;\n    const includeTo = (_b = input.includeTo) !== null && _b !== void 0 ? _b : true;\n    if ((0, exports.isTransferTokensAction)(action)) {\n        const addresses = [];\n        if (includeTo) {\n            addresses.push(decodeApiAddress(action.to_account));\n        }\n        if (includeFrom) {\n            addresses.push(decodeApiAddress(action.from_account));\n        }\n        return addresses;\n    }\n    else if ((0, exports.isStakeTokensAction)(action)) {\n        const addresses = [];\n        if (includeFrom) {\n            addresses.push(decodeApiAddress(action.from_account));\n        }\n        return addresses;\n    }\n    else if ((0, exports.isUnstakeTokensAction)(action)) {\n        const addresses = [];\n        if (includeFrom) {\n            addresses.push(decodeApiAddress(action.to_account));\n        }\n        return addresses;\n    }\n    else {\n        return [];\n    }\n};\nexports.getUniqueAddresses = getUniqueAddresses;\nconst flatMapAddressesOf = (input) => {\n    const { actions, includeFrom, includeTo } = input;\n    const flatMapped = actions.reduce((acc, action) => {\n        const uniqueAddressOfAction = (0, exports.getUniqueAddresses)({\n            action,\n            includeFrom,\n            includeTo,\n        });\n        return acc.concat(...uniqueAddressOfAction);\n    }, []);\n    const set = new Set();\n    return flatMapped.filter(a => {\n        const str = a.toString();\n        const hasNt = !set.has(str);\n        set.add(str);\n        return hasNt;\n    });\n};\nexports.flatMapAddressesOf = flatMapAddressesOf;\nconst isTransactionIntentBuilderEncryptInput = (something) => {\n    const inspection = something;\n    return (inspection.encryptMessageIfAnyWithAccount !== undefined &&\n        (0, rxjs_1.isObservable)(inspection.encryptMessageIfAnyWithAccount) &&\n        (inspection.spendingSender !== undefined\n            ? (0, rxjs_1.isObservable)(inspection.spendingSender)\n            : true));\n};\nconst isTransactionIntentBuilderDoNotEncryptInput = (something) => {\n    if (isTransactionIntentBuilderEncryptInput(something)) {\n        return false;\n    }\n    const inspection = something;\n    return (inspection.spendingSender !== undefined &&\n        (0, rxjs_1.isObservable)(inspection.spendingSender));\n};\nconst isTransactionIntentBuilderDoNotEncryptOption = (something) => {\n    const inspection = something;\n    return (inspection.skipEncryptionOfMessageIfAny !== undefined &&\n        isTransactionIntentBuilderDoNotEncryptInput(inspection.skipEncryptionOfMessageIfAny));\n};\nconst create = () => {\n    const intermediateActions = [];\n    let maybePlaintextMsgToEncrypt = prelude_ts_1.Option.none();\n    const snapshotState = () => ({\n        actionInputs: intermediateActions,\n        message: maybePlaintextMsgToEncrypt.getOrUndefined(),\n    });\n    const snapshotBuilderState = () => ({\n        __state: snapshotState(),\n    });\n    const addAction = (input, type) => {\n        intermediateActions.push(Object.assign({ type }, input));\n        return Object.assign(Object.assign({}, methods), snapshotBuilderState());\n    };\n    const transferTokens = (input) => addAction(input, 'transfer');\n    const stakeTokens = (input) => addAction(input, 'stake');\n    const unstakeTokens = (input) => addAction(input, 'unstake');\n    const replaceAnyPreviousMessageWithNew = (newMessage) => {\n        maybePlaintextMsgToEncrypt = prelude_ts_1.Option.some(newMessage);\n        return Object.assign(Object.assign({}, methods), snapshotBuilderState());\n    };\n    const intendedActionsFromIntermediateActions = (from) => {\n        if (intermediateActions.length === 0)\n            return (0, neverthrow_1.err)(mustHaveAtLeastOneAction);\n        return (0, neverthrow_1.combine)(intermediateActions.map((i) => {\n            const intermediateActionType = i.type;\n            if (intermediateActionType === 'transfer') {\n                if ((0, actions_2.isTransferTokensInput)(i)) {\n                    return actions_2.IntendedTransferTokens.create(i, from);\n                }\n                else {\n                    throw new Error('Not transfer tokens input');\n                }\n            }\n            else if (intermediateActionType === 'stake') {\n                if ((0, actions_2.isStakeTokensInput)(i)) {\n                    return actions_2.IntendedStakeTokens.create(i, from);\n                }\n                else {\n                    throw new Error('Not stake tokens input');\n                }\n            }\n            else if (intermediateActionType === 'unstake') {\n                return actions_2.IntendedUnstakeTokens.create(i, from);\n            }\n            else {\n                return (0, neverthrow_1.err)(new Error('Incorrect implementation, forgot something...'));\n            }\n        })).map(intendedActions => ({ intendedActions, from }));\n    };\n    const syncBuildDoNotEncryptMessageIfAny = (from) => intendedActionsFromIntermediateActions(from).map(({ intendedActions }) => ({\n        actions: intendedActions,\n        message: maybePlaintextMsgToEncrypt\n            .map(msg => msg.plaintext\n            ? crypto_1.Message.createPlaintext(msg.plaintext).bytes\n            : undefined)\n            .getOrUndefined(),\n    }));\n    const build = (options) => {\n        var _a;\n        if (isTransactionIntentBuilderDoNotEncryptOption(options)) {\n            if (maybePlaintextMsgToEncrypt.map(m => m.encrypt).getOrElse(false)) {\n                const errMsg = `Message in transaction specifies it should be encrypted, but input to TransactionIntentBuilder build method specifies that it (the builder) should not encrypt the message, and does not provide any account with which we can perform encryption.`;\n                console.error(errMsg);\n                util_1.log.error(errMsg);\n                return (0, rxjs_1.throwError)(new Error(errMsg));\n            }\n            return options.skipEncryptionOfMessageIfAny.spendingSender.pipe((0, operators_1.mergeMap)((from) => (0, util_1.toObservableFromResult)(syncBuildDoNotEncryptMessageIfAny(from))));\n        }\n        if (!isTransactionIntentBuilderEncryptInput(options)) {\n            throw new Error('Incorrect implementation');\n        }\n        const encryptingAccount$ = options.encryptMessageIfAnyWithAccount;\n        const spendingSender = (_a = options.spendingSender) !== null && _a !== void 0 ? _a : options.encryptMessageIfAnyWithAccount.pipe((0, operators_1.map)(account => account.address));\n        return spendingSender.pipe((0, operators_1.mergeMap)((from) => (0, util_1.toObservableFromResult)(intendedActionsFromIntermediateActions(from))), (0, operators_1.mergeMap)((intendedActionsFrom) => {\n            const transactionIntentWithoutEncryption = (plaintextMessage) => {\n                util_1.log.info(`Successfully built transaction. Actions: ${intendedActionsFrom.intendedActions\n                    .map(action => action.type)\n                    .toString()}`);\n                return (0, rxjs_1.of)({\n                    actions: intendedActionsFrom.intendedActions,\n                    message: plaintextMessage !== undefined\n                        ? crypto_1.MessageEncryption.encodePlaintext(plaintextMessage)\n                        : undefined,\n                });\n            };\n            return maybePlaintextMsgToEncrypt.match({\n                Some: msgInTx => {\n                    if (!msgInTx.encrypt) {\n                        const errMsg = 'You are trying to encrypt a message which was specified not to be encrypted.';\n                        console.error(errMsg);\n                        util_1.log.error(errMsg);\n                        return (0, rxjs_1.throwError)(new Error(errMsg));\n                    }\n                    return encryptingAccount$.pipe((0, operators_1.mergeMap)((encryptingAccount) => ensureSingleRecipient({\n                        intendedActionsFrom,\n                        encryptingAccount,\n                    })), (0, operators_1.mergeMap)((actors) => actors.encryptingAccount.encrypt({\n                        plaintext: msgInTx.plaintext,\n                        publicKeyOfOtherParty: actors.singleRecipientPublicKey,\n                    })), (0, operators_1.map)((encryptedMessage) => {\n                        util_1.log.info(`Successfully built transaction with encrypted message. Actions: ${intendedActionsFrom.intendedActions\n                            .map(action => action.type)\n                            .toString()}`);\n                        return {\n                            actions: intendedActionsFrom.intendedActions,\n                            message: encryptedMessage.combined(),\n                        };\n                    }));\n                },\n                None: () => transactionIntentWithoutEncryption(undefined),\n            });\n        }));\n    };\n    const methods = {\n        transferTokens,\n        stakeTokens,\n        unstakeTokens,\n        build,\n        message: replaceAnyPreviousMessageWithNew,\n        __syncBuildDoNotEncryptMessageIfAny: syncBuildDoNotEncryptMessageIfAny,\n    };\n    return Object.assign(Object.assign({}, snapshotBuilderState()), methods);\n};\nexports.TransactionIntentBuilder = {\n    create,\n};\n//# sourceMappingURL=transactionIntentBuilder.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}