{"ast":null,"code":"/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.URI = global.URI || {});\n})(this, function (exports) {\n  'use strict';\n\n  function merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n      sets[_key] = arguments[_key];\n    }\n    if (sets.length > 1) {\n      sets[0] = sets[0].slice(0, -1);\n      var xl = sets.length - 1;\n      for (var x = 1; x < xl; ++x) {\n        sets[x] = sets[x].slice(1, -1);\n      }\n      sets[xl] = sets[xl].slice(1);\n      return sets.join('');\n    } else {\n      return sets[0];\n    }\n  }\n  function subexp(str) {\n    return \"(?:\" + str + \")\";\n  }\n  function typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n  }\n  function toUpperCase(str) {\n    return str.toUpperCase();\n  }\n  function toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n  }\n  function assign(target, source) {\n    var obj = target;\n    if (source) {\n      for (var key in source) {\n        obj[key] = source[key];\n      }\n    }\n    return obj;\n  }\n  function buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n      CR$ = \"[\\\\x0D]\",\n      DIGIT$$ = \"[0-9]\",\n      DQUOTE$$ = \"[\\\\x22]\",\n      HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n      //case-insensitive\n      LF$$ = \"[\\\\x0A]\",\n      SP$$ = \"[\\\\x20]\",\n      PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n      //expanded\n      GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n      SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n      RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n      UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n      //subset, excludes bidi control characters\n      IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n      //subset\n      UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n      SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n      USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n      DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n      DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n      //relaxed parsing rules\n      IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n      H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n      LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n      IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n      //                           6( h16 \":\" ) ls32\n      IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n      //                      \"::\" 5( h16 \":\" ) ls32\n      IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n      //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n      IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n      //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n      IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n      //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n      IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n      //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n      IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n      //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n      IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n      //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n      IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n      //[ *6( h16 \":\" ) h16 ] \"::\"\n      IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n      ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n      //RFC 6874\n      IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n      //RFC 6874\n      IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n      //RFC 6874, with relaxed parsing rules\n      IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n      IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n      //RFC 6874\n      REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n      HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n      PORT$ = subexp(DIGIT$$ + \"*\"),\n      AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n      PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n      SEGMENT$ = subexp(PCHAR$ + \"*\"),\n      SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n      SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n      PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n      PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n      //simplified\n      PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n      //simplified\n      PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n      //simplified\n      PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n      PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n      QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n      FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n      HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n      URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n      RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n      RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n      URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n      ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n      GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n      RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n      ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n      SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n      AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n      NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n      NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n      NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n      ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n      OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n      PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n      IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n      IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n  }\n  var URI_PROTOCOL = buildExps(false);\n  var IRI_PROTOCOL = buildExps(true);\n  var slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n      return _arr;\n    }\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  }();\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  /** Highest positive signed 32-bit float value */\n\n  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n  /** Bootstring parameters */\n  var base = 36;\n  var tMin = 1;\n  var tMax = 26;\n  var skew = 38;\n  var damp = 700;\n  var initialBias = 72;\n  var initialN = 128; // 0x80\n  var delimiter = '-'; // '\\x2D'\n\n  /** Regular expressions */\n  var regexPunycode = /^xn--/;\n  var regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\n  var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n  /** Error messages */\n  var errors = {\n    'overflow': 'Overflow: input needs wider integers to process',\n    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n    'invalid-input': 'Invalid input'\n  };\n\n  /** Convenience shortcuts */\n  var baseMinusTMin = base - tMin;\n  var floor = Math.floor;\n  var stringFromCharCode = String.fromCharCode;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A generic error utility function.\n   * @private\n   * @param {String} type The error type.\n   * @returns {Error} Throws a `RangeError` with the applicable error message.\n   */\n  function error$1(type) {\n    throw new RangeError(errors[type]);\n  }\n\n  /**\n   * A generic `Array#map` utility function.\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} callback The function that gets called for every array\n   * item.\n   * @returns {Array} A new array of values returned by the callback function.\n   */\n  function map(array, fn) {\n    var result = [];\n    var length = array.length;\n    while (length--) {\n      result[length] = fn(array[length]);\n    }\n    return result;\n  }\n\n  /**\n   * A simple `Array#map`-like wrapper to work with domain name strings or email\n   * addresses.\n   * @private\n   * @param {String} domain The domain name or email address.\n   * @param {Function} callback The function that gets called for every\n   * character.\n   * @returns {Array} A new string of characters returned by the callback\n   * function.\n   */\n  function mapDomain(string, fn) {\n    var parts = string.split('@');\n    var result = '';\n    if (parts.length > 1) {\n      // In email addresses, only the domain name should be punycoded. Leave\n      // the local part (i.e. everything up to `@`) intact.\n      result = parts[0] + '@';\n      string = parts[1];\n    }\n    // Avoid `split(regex)` for IE8 compatibility. See #17.\n    string = string.replace(regexSeparators, '\\x2E');\n    var labels = string.split('.');\n    var encoded = map(labels, fn).join('.');\n    return result + encoded;\n  }\n\n  /**\n   * Creates an array containing the numeric code points of each Unicode\n   * character in the string. While JavaScript uses UCS-2 internally,\n   * this function will convert a pair of surrogate halves (each of which\n   * UCS-2 exposes as separate characters) into a single code point,\n   * matching UTF-16.\n   * @see `punycode.ucs2.encode`\n   * @see <https://mathiasbynens.be/notes/javascript-encoding>\n   * @memberOf punycode.ucs2\n   * @name decode\n   * @param {String} string The Unicode input string (UCS-2).\n   * @returns {Array} The new array of code points.\n   */\n  function ucs2decode(string) {\n    var output = [];\n    var counter = 0;\n    var length = string.length;\n    while (counter < length) {\n      var value = string.charCodeAt(counter++);\n      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n        // It's a high surrogate, and there is a next character.\n        var extra = string.charCodeAt(counter++);\n        if ((extra & 0xFC00) == 0xDC00) {\n          // Low surrogate.\n          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n        } else {\n          // It's an unmatched surrogate; only append this code unit, in case the\n          // next code unit is the high surrogate of a surrogate pair.\n          output.push(value);\n          counter--;\n        }\n      } else {\n        output.push(value);\n      }\n    }\n    return output;\n  }\n\n  /**\n   * Creates a string based on an array of numeric code points.\n   * @see `punycode.ucs2.decode`\n   * @memberOf punycode.ucs2\n   * @name encode\n   * @param {Array} codePoints The array of numeric code points.\n   * @returns {String} The new Unicode string (UCS-2).\n   */\n  var ucs2encode = function ucs2encode(array) {\n    return String.fromCodePoint.apply(String, toConsumableArray(array));\n  };\n\n  /**\n   * Converts a basic code point into a digit/integer.\n   * @see `digitToBasic()`\n   * @private\n   * @param {Number} codePoint The basic numeric code point value.\n   * @returns {Number} The numeric value of a basic code point (for use in\n   * representing integers) in the range `0` to `base - 1`, or `base` if\n   * the code point does not represent a value.\n   */\n  var basicToDigit = function basicToDigit(codePoint) {\n    if (codePoint - 0x30 < 0x0A) {\n      return codePoint - 0x16;\n    }\n    if (codePoint - 0x41 < 0x1A) {\n      return codePoint - 0x41;\n    }\n    if (codePoint - 0x61 < 0x1A) {\n      return codePoint - 0x61;\n    }\n    return base;\n  };\n\n  /**\n   * Converts a digit/integer into a basic code point.\n   * @see `basicToDigit()`\n   * @private\n   * @param {Number} digit The numeric value of a basic code point.\n   * @returns {Number} The basic code point whose value (when used for\n   * representing integers) is `digit`, which needs to be in the range\n   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n   * used; else, the lowercase form is used. The behavior is undefined\n   * if `flag` is non-zero and `digit` has no uppercase form.\n   */\n  var digitToBasic = function digitToBasic(digit, flag) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n  };\n\n  /**\n   * Bias adaptation function as per section 3.4 of RFC 3492.\n   * https://tools.ietf.org/html/rfc3492#section-3.4\n   * @private\n   */\n  var adapt = function adapt(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n    for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n      delta = floor(delta / baseMinusTMin);\n    }\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n  };\n\n  /**\n   * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n   * symbols.\n   * @memberOf punycode\n   * @param {String} input The Punycode string of ASCII-only symbols.\n   * @returns {String} The resulting string of Unicode symbols.\n   */\n  var decode = function decode(input) {\n    // Don't use UCS-2.\n    var output = [];\n    var inputLength = input.length;\n    var i = 0;\n    var n = initialN;\n    var bias = initialBias;\n\n    // Handle the basic code points: let `basic` be the number of input code\n    // points before the last delimiter, or `0` if there is none, then copy\n    // the first basic code points to the output.\n\n    var basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n      basic = 0;\n    }\n    for (var j = 0; j < basic; ++j) {\n      // if it's not a basic code point\n      if (input.charCodeAt(j) >= 0x80) {\n        error$1('not-basic');\n      }\n      output.push(input.charCodeAt(j));\n    }\n\n    // Main decoding loop: start just after the last delimiter if any basic code\n    // points were copied; start at the beginning otherwise.\n\n    for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n      // `index` is the index of the next character to be consumed.\n      // Decode a generalized variable-length integer into `delta`,\n      // which gets added to `i`. The overflow checking is easier\n      // if we increase `i` as we go, then subtract off its starting\n      // value at the end to obtain `delta`.\n      var oldi = i;\n      for (var w = 1, k = base;; /* no condition */k += base) {\n        if (index >= inputLength) {\n          error$1('invalid-input');\n        }\n        var digit = basicToDigit(input.charCodeAt(index++));\n        if (digit >= base || digit > floor((maxInt - i) / w)) {\n          error$1('overflow');\n        }\n        i += digit * w;\n        var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n        if (digit < t) {\n          break;\n        }\n        var baseMinusT = base - t;\n        if (w > floor(maxInt / baseMinusT)) {\n          error$1('overflow');\n        }\n        w *= baseMinusT;\n      }\n      var out = output.length + 1;\n      bias = adapt(i - oldi, out, oldi == 0);\n\n      // `i` was supposed to wrap around from `out` to `0`,\n      // incrementing `n` each time, so we'll fix that now:\n      if (floor(i / out) > maxInt - n) {\n        error$1('overflow');\n      }\n      n += floor(i / out);\n      i %= out;\n\n      // Insert `n` at position `i` of the output.\n      output.splice(i++, 0, n);\n    }\n    return String.fromCodePoint.apply(String, output);\n  };\n\n  /**\n   * Converts a string of Unicode symbols (e.g. a domain name label) to a\n   * Punycode string of ASCII-only symbols.\n   * @memberOf punycode\n   * @param {String} input The string of Unicode symbols.\n   * @returns {String} The resulting Punycode string of ASCII-only symbols.\n   */\n  var encode = function encode(input) {\n    var output = [];\n\n    // Convert the input in UCS-2 to an array of Unicode code points.\n    input = ucs2decode(input);\n\n    // Cache the length.\n    var inputLength = input.length;\n\n    // Initialize the state.\n    var n = initialN;\n    var delta = 0;\n    var bias = initialBias;\n\n    // Handle the basic code points.\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n      for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _currentValue2 = _step.value;\n        if (_currentValue2 < 0x80) {\n          output.push(stringFromCharCode(_currentValue2));\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    var basicLength = output.length;\n    var handledCPCount = basicLength;\n\n    // `handledCPCount` is the number of code points that have been handled;\n    // `basicLength` is the number of basic code points.\n\n    // Finish the basic string with a delimiter unless it's empty.\n    if (basicLength) {\n      output.push(delimiter);\n    }\n\n    // Main encoding loop:\n    while (handledCPCount < inputLength) {\n      // All non-basic code points < n have been handled already. Find the next\n      // larger one:\n      var m = maxInt;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var currentValue = _step2.value;\n          if (currentValue >= n && currentValue < m) {\n            m = currentValue;\n          }\n        }\n\n        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n        // but guard against overflow.\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n      var handledCPCountPlusOne = handledCPCount + 1;\n      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n        error$1('overflow');\n      }\n      delta += (m - n) * handledCPCountPlusOne;\n      n = m;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n      try {\n        for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _currentValue = _step3.value;\n          if (_currentValue < n && ++delta > maxInt) {\n            error$1('overflow');\n          }\n          if (_currentValue == n) {\n            // Represent delta as a generalized variable-length integer.\n            var q = delta;\n            for (var k = base;; /* no condition */k += base) {\n              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n              if (q < t) {\n                break;\n              }\n              var qMinusT = q - t;\n              var baseMinusT = base - t;\n              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n              q = floor(qMinusT / baseMinusT);\n            }\n            output.push(stringFromCharCode(digitToBasic(q, 0)));\n            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n            delta = 0;\n            ++handledCPCount;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n      ++delta;\n      ++n;\n    }\n    return output.join('');\n  };\n\n  /**\n   * Converts a Punycode string representing a domain name or an email address\n   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n   * it doesn't matter if you call it on a string that has already been\n   * converted to Unicode.\n   * @memberOf punycode\n   * @param {String} input The Punycoded domain name or email address to\n   * convert to Unicode.\n   * @returns {String} The Unicode representation of the given Punycode\n   * string.\n   */\n  var toUnicode = function toUnicode(input) {\n    return mapDomain(input, function (string) {\n      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n    });\n  };\n\n  /**\n   * Converts a Unicode string representing a domain name or an email address to\n   * Punycode. Only the non-ASCII parts of the domain name will be converted,\n   * i.e. it doesn't matter if you call it with a domain that's already in\n   * ASCII.\n   * @memberOf punycode\n   * @param {String} input The domain name or email address to convert, as a\n   * Unicode string.\n   * @returns {String} The Punycode representation of the given domain name or\n   * email address.\n   */\n  var toASCII = function toASCII(input) {\n    return mapDomain(input, function (string) {\n      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n    });\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  /** Define the public API */\n  var punycode = {\n    /**\n     * A string representing the current Punycode.js version number.\n     * @memberOf punycode\n     * @type String\n     */\n    'version': '2.1.0',\n    /**\n     * An object of methods to convert from JavaScript's internal character\n     * representation (UCS-2) to Unicode code points, and back.\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n     * @memberOf punycode\n     * @type Object\n     */\n    'ucs2': {\n      'decode': ucs2decode,\n      'encode': ucs2encode\n    },\n    'decode': decode,\n    'encode': encode,\n    'toASCII': toASCII,\n    'toUnicode': toUnicode\n  };\n\n  /**\n   * URI.js\n   *\n   * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n   * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n   * @see http://github.com/garycourt/uri-js\n   */\n  /**\n   * Copyright 2011 Gary Court. All rights reserved.\n   *\n   * Redistribution and use in source and binary forms, with or without modification, are\n   * permitted provided that the following conditions are met:\n   *\n   *    1. Redistributions of source code must retain the above copyright notice, this list of\n   *       conditions and the following disclaimer.\n   *\n   *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n   *       of conditions and the following disclaimer in the documentation and/or other materials\n   *       provided with the distribution.\n   *\n   * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n   * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n   * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   *\n   * The views and conclusions contained in the software and documentation are those of the\n   * authors and should not be interpreted as representing official policies, either expressed\n   * or implied, of Gary Court.\n   */\n  var SCHEMES = {};\n  function pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n  }\n  function pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n      var c = parseInt(str.substr(i + 1, 2), 16);\n      if (c < 128) {\n        newStr += String.fromCharCode(c);\n        i += 3;\n      } else if (c >= 194 && c < 224) {\n        if (il - i >= 6) {\n          var c2 = parseInt(str.substr(i + 4, 2), 16);\n          newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n        } else {\n          newStr += str.substr(i, 6);\n        }\n        i += 6;\n      } else if (c >= 224) {\n        if (il - i >= 9) {\n          var _c = parseInt(str.substr(i + 4, 2), 16);\n          var c3 = parseInt(str.substr(i + 7, 2), 16);\n          newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n        } else {\n          newStr += str.substr(i, 9);\n        }\n        i += 9;\n      } else {\n        newStr += str.substr(i, 3);\n        i += 3;\n      }\n    }\n    return newStr;\n  }\n  function _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n      var decStr = pctDecChars(str);\n      return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n  }\n  function _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n  }\n  function _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n    var _matches = slicedToArray(matches, 2),\n      address = _matches[1];\n    if (address) {\n      return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n      return host;\n    }\n  }\n  function _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n    var _matches2 = slicedToArray(matches, 3),\n      address = _matches2[1],\n      zone = _matches2[2];\n    if (address) {\n      var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n        _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n        last = _address$toLowerCase$2[0],\n        first = _address$toLowerCase$2[1];\n      var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n      var lastFields = last.split(\":\").map(_stripLeadingZeros);\n      var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n      var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n      var lastFieldsStart = lastFields.length - fieldCount;\n      var fields = Array(fieldCount);\n      for (var x = 0; x < fieldCount; ++x) {\n        fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n      }\n      if (isLastFieldIPv4Address) {\n        fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n      }\n      var allZeroFields = fields.reduce(function (acc, field, index) {\n        if (!field || field === \"0\") {\n          var lastLongest = acc[acc.length - 1];\n          if (lastLongest && lastLongest.index + lastLongest.length === index) {\n            lastLongest.length++;\n          } else {\n            acc.push({\n              index: index,\n              length: 1\n            });\n          }\n        }\n        return acc;\n      }, []);\n      var longestZeroFields = allZeroFields.sort(function (a, b) {\n        return b.length - a.length;\n      })[0];\n      var newHost = void 0;\n      if (longestZeroFields && longestZeroFields.length > 1) {\n        var newFirst = fields.slice(0, longestZeroFields.index);\n        var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n        newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n      } else {\n        newHost = fields.join(\":\");\n      }\n      if (zone) {\n        newHost += \"%\" + zone;\n      }\n      return newHost;\n    } else {\n      return host;\n    }\n  }\n  var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\n  var NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\n  function parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n      if (NO_MATCH_IS_UNDEFINED) {\n        //store each component\n        components.scheme = matches[1];\n        components.userinfo = matches[3];\n        components.host = matches[4];\n        components.port = parseInt(matches[5], 10);\n        components.path = matches[6] || \"\";\n        components.query = matches[7];\n        components.fragment = matches[8];\n        //fix port number\n        if (isNaN(components.port)) {\n          components.port = matches[5];\n        }\n      } else {\n        //IE FIX for improper RegExp matching\n        //store each component\n        components.scheme = matches[1] || undefined;\n        components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n        components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n        components.port = parseInt(matches[5], 10);\n        components.path = matches[6] || \"\";\n        components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n        components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n        //fix port number\n        if (isNaN(components.port)) {\n          components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n        }\n      }\n      if (components.host) {\n        //normalize IP hosts\n        components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n      }\n      //determine reference type\n      if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n        components.reference = \"same-document\";\n      } else if (components.scheme === undefined) {\n        components.reference = \"relative\";\n      } else if (components.fragment === undefined) {\n        components.reference = \"absolute\";\n      } else {\n        components.reference = \"uri\";\n      }\n      //check for reference errors\n      if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n        components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n      }\n      //find scheme handler\n      var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n      //check if scheme can't handle IRIs\n      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n        //if host component is a domain name\n        if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n          //convert Unicode IDN -> ASCII IDN\n          try {\n            components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n          } catch (e) {\n            components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n          }\n        }\n        //convert IRI -> URI\n        _normalizeComponentEncoding(components, URI_PROTOCOL);\n      } else {\n        //normalize encodings\n        _normalizeComponentEncoding(components, protocol);\n      }\n      //perform scheme specific parsing\n      if (schemeHandler && schemeHandler.parse) {\n        schemeHandler.parse(components, options);\n      }\n    } else {\n      components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n  }\n  function _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n      uriTokens.push(components.userinfo);\n      uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n      //normalize IP hosts, add brackets and escape zone separator for IPv6\n      uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n        return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n      }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n      uriTokens.push(\":\");\n      uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n  }\n  var RDS1 = /^\\.\\.?\\//;\n  var RDS2 = /^\\/\\.(\\/|$)/;\n  var RDS3 = /^\\/\\.\\.(\\/|$)/;\n  var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n  function removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n      if (input.match(RDS1)) {\n        input = input.replace(RDS1, \"\");\n      } else if (input.match(RDS2)) {\n        input = input.replace(RDS2, \"/\");\n      } else if (input.match(RDS3)) {\n        input = input.replace(RDS3, \"/\");\n        output.pop();\n      } else if (input === \".\" || input === \"..\") {\n        input = \"\";\n      } else {\n        var im = input.match(RDS5);\n        if (im) {\n          var s = im[0];\n          input = input.slice(s.length);\n          output.push(s);\n        } else {\n          throw new Error(\"Unexpected dot segment condition\");\n        }\n      }\n    }\n    return output.join(\"\");\n  }\n  function serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n      //if host component is an IPv6 address\n      if (protocol.IPV6ADDRESS.test(components.host)) {}\n      //TODO: normalize IPv6 address as per RFC 5952\n\n      //if host component is a domain name\n      else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n        //convert IDN via punycode\n        try {\n          components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n        } catch (e) {\n          components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n        }\n      }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n      uriTokens.push(components.scheme);\n      uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n      if (options.reference !== \"suffix\") {\n        uriTokens.push(\"//\");\n      }\n      uriTokens.push(authority);\n      if (components.path && components.path.charAt(0) !== \"/\") {\n        uriTokens.push(\"/\");\n      }\n    }\n    if (components.path !== undefined) {\n      var s = components.path;\n      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n        s = removeDotSegments(s);\n      }\n      if (authority === undefined) {\n        s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n      }\n      uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n      uriTokens.push(\"?\");\n      uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n      uriTokens.push(\"#\");\n      uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n  }\n  function resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n    var target = {};\n    if (!skipNormalization) {\n      base = parse(serialize(base, options), options); //normalize base components\n      relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n      target.scheme = relative.scheme;\n      //target.authority = relative.authority;\n      target.userinfo = relative.userinfo;\n      target.host = relative.host;\n      target.port = relative.port;\n      target.path = removeDotSegments(relative.path || \"\");\n      target.query = relative.query;\n    } else {\n      if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n      } else {\n        if (!relative.path) {\n          target.path = base.path;\n          if (relative.query !== undefined) {\n            target.query = relative.query;\n          } else {\n            target.query = base.query;\n          }\n        } else {\n          if (relative.path.charAt(0) === \"/\") {\n            target.path = removeDotSegments(relative.path);\n          } else {\n            if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n              target.path = \"/\" + relative.path;\n            } else if (!base.path) {\n              target.path = relative.path;\n            } else {\n              target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n            }\n            target.path = removeDotSegments(target.path);\n          }\n          target.query = relative.query;\n        }\n        //target.authority = base.authority;\n        target.userinfo = base.userinfo;\n        target.host = base.host;\n        target.port = base.port;\n      }\n      target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n  }\n  function resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({\n      scheme: 'null'\n    }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n  }\n  function normalize(uri, options) {\n    if (typeof uri === \"string\") {\n      uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n      uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n  }\n  function equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n      uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n      uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n      uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n      uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n  }\n  function escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n  }\n  function unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n  }\n  var handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n      //report missing host\n      if (!components.host) {\n        components.error = components.error || \"HTTP URIs must have a host.\";\n      }\n      return components;\n    },\n    serialize: function serialize(components, options) {\n      var secure = String(components.scheme).toLowerCase() === \"https\";\n      //normalize the default port\n      if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n        components.port = undefined;\n      }\n      //normalize the empty path\n      if (!components.path) {\n        components.path = \"/\";\n      }\n      //NOTE: We do not parse query strings for HTTP URIs\n      //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n      //and not the HTTP spec.\n      return components;\n    }\n  };\n  var handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n  };\n  function isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n  }\n  //RFC 6455\n  var handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n      var wsComponents = components;\n      //indicate if the secure flag is set\n      wsComponents.secure = isSecure(wsComponents);\n      //construct resouce name\n      wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n      wsComponents.path = undefined;\n      wsComponents.query = undefined;\n      return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n      //normalize the default port\n      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n        wsComponents.port = undefined;\n      }\n      //ensure scheme matches secure flag\n      if (typeof wsComponents.secure === 'boolean') {\n        wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n        wsComponents.secure = undefined;\n      }\n      //reconstruct path from resource name\n      if (wsComponents.resourceName) {\n        var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n          _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n          path = _wsComponents$resourc2[0],\n          query = _wsComponents$resourc2[1];\n        wsComponents.path = path && path !== '/' ? path : undefined;\n        wsComponents.query = query;\n        wsComponents.resourceName = undefined;\n      }\n      //forbid fragment component\n      wsComponents.fragment = undefined;\n      return wsComponents;\n    }\n  };\n  var handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n  };\n  var O = {};\n  var isIRI = true;\n  //RFC 3986\n  var UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\n  var HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\n  var PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n  //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n  //const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n  //const WSP$$ = \"[\\\\x20\\\\x09]\";\n  //const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n  //const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n  //const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n  //const WSP$$ = \"[\\\\x20\\\\x09]\";\n  //const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n  //const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n  //const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n  //const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\n  var ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n  var QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\n  var VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\n  var SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\n  var UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\n  var PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\n  var NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\n  var NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\n  var NOT_HFVALUE = NOT_HFNAME;\n  function decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n  }\n  var handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n      var mailtoComponents = components;\n      var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n      mailtoComponents.path = undefined;\n      if (mailtoComponents.query) {\n        var unknownHeaders = false;\n        var headers = {};\n        var hfields = mailtoComponents.query.split(\"&\");\n        for (var x = 0, xl = hfields.length; x < xl; ++x) {\n          var hfield = hfields[x].split(\"=\");\n          switch (hfield[0]) {\n            case \"to\":\n              var toAddrs = hfield[1].split(\",\");\n              for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                to.push(toAddrs[_x]);\n              }\n              break;\n            case \"subject\":\n              mailtoComponents.subject = unescapeComponent(hfield[1], options);\n              break;\n            case \"body\":\n              mailtoComponents.body = unescapeComponent(hfield[1], options);\n              break;\n            default:\n              unknownHeaders = true;\n              headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n              break;\n          }\n        }\n        if (unknownHeaders) mailtoComponents.headers = headers;\n      }\n      mailtoComponents.query = undefined;\n      for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n        var addr = to[_x2].split(\"@\");\n        addr[0] = unescapeComponent(addr[0]);\n        if (!options.unicodeSupport) {\n          //convert Unicode IDN -> ASCII IDN\n          try {\n            addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n          } catch (e) {\n            mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n          }\n        } else {\n          addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n        }\n        to[_x2] = addr.join(\"@\");\n      }\n      return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n      var components = mailtoComponents;\n      var to = toArray(mailtoComponents.to);\n      if (to) {\n        for (var x = 0, xl = to.length; x < xl; ++x) {\n          var toAddr = String(to[x]);\n          var atIdx = toAddr.lastIndexOf(\"@\");\n          var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n          var domain = toAddr.slice(atIdx + 1);\n          //convert IDN via punycode\n          try {\n            domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n          } catch (e) {\n            components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n          }\n          to[x] = localPart + \"@\" + domain;\n        }\n        components.path = to.join(\",\");\n      }\n      var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n      if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n      if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n      var fields = [];\n      for (var name in headers) {\n        if (headers[name] !== O[name]) {\n          fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n        }\n      }\n      if (fields.length) {\n        components.query = fields.join(\"&\");\n      }\n      return components;\n    }\n  };\n  var URN_PARSE = /^([^\\:]+)\\:(.*)/;\n  //RFC 2141\n  var handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n      var matches = components.path && components.path.match(URN_PARSE);\n      var urnComponents = components;\n      if (matches) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = matches[1].toLowerCase();\n        var nss = matches[2];\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        urnComponents.nid = nid;\n        urnComponents.nss = nss;\n        urnComponents.path = undefined;\n        if (schemeHandler) {\n          urnComponents = schemeHandler.parse(urnComponents, options);\n        }\n      } else {\n        urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n      }\n      return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n      var scheme = options.scheme || urnComponents.scheme || \"urn\";\n      var nid = urnComponents.nid;\n      var urnScheme = scheme + \":\" + (options.nid || nid);\n      var schemeHandler = SCHEMES[urnScheme];\n      if (schemeHandler) {\n        urnComponents = schemeHandler.serialize(urnComponents, options);\n      }\n      var uriComponents = urnComponents;\n      var nss = urnComponents.nss;\n      uriComponents.path = (nid || options.nid) + \":\" + nss;\n      return uriComponents;\n    }\n  };\n  var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n  //RFC 4122\n  var handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n      var uuidComponents = urnComponents;\n      uuidComponents.uuid = uuidComponents.nss;\n      uuidComponents.nss = undefined;\n      if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n        uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n      }\n      return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n      var urnComponents = uuidComponents;\n      //normalize UUID\n      urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n      return urnComponents;\n    }\n  };\n  SCHEMES[handler.scheme] = handler;\n  SCHEMES[handler$1.scheme] = handler$1;\n  SCHEMES[handler$2.scheme] = handler$2;\n  SCHEMES[handler$3.scheme] = handler$3;\n  SCHEMES[handler$4.scheme] = handler$4;\n  SCHEMES[handler$5.scheme] = handler$5;\n  SCHEMES[handler$6.scheme] = handler$6;\n  exports.SCHEMES = SCHEMES;\n  exports.pctEncChar = pctEncChar;\n  exports.pctDecChars = pctDecChars;\n  exports.parse = parse;\n  exports.removeDotSegments = removeDotSegments;\n  exports.serialize = serialize;\n  exports.resolveComponents = resolveComponents;\n  exports.resolve = resolve;\n  exports.normalize = normalize;\n  exports.equal = equal;\n  exports.escapeComponent = escapeComponent;\n  exports.unescapeComponent = unescapeComponent;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["merge","sets","Array","_len","_key","arguments","length","slice","xl","x","join","subexp","str","typeOf","o","undefined","Object","prototype","toString","call","split","pop","shift","toLowerCase","toUpperCase","toArray","obj","setInterval","assign","target","source","key","buildExps","isIRI","ALPHA$$","CR$","DIGIT$$","DQUOTE$$","HEXDIG$$","SP$$","PCT_ENCODED$","SUB_DELIMS$$","RESERVED$$","GEN_DELIMS$$","UCSCHAR$$","SCHEME$","USERINFO$","UNRESERVED$$","DEC_OCTET$","DEC_OCTET_RELAXED$","H16$","LS32$","IPV4ADDRESS$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","ZONEID$","IPV6ADDRESS$","IP_LITERAL$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","HOST$","REG_NAME$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","PATH$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","QUERY$","IPRIVATE$$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","URI_REFERENCE$","ABSOLUTE_URI$","GENERIC_REF$","RELATIVE_REF$","ABSOLUTE_REF$","SAMEDOC_REF$","AUTHORITY_REF$","RegExp","URI_PROTOCOL","IRI_PROTOCOL","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","Math","stringFromCharCode","String","fromCharCode","error$1","error","type","RangeError","map","array","fn","result","mapDomain","string","parts","replace","labels","encoded","ucs2decode","output","counter","value","charCodeAt","extra","push","ucs2encode","fromCodePoint","apply","toConsumableArray","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","decode","input","inputLength","i","n","bias","basic","lastIndexOf","j","index","oldi","w","t","baseMinusT","out","splice","encode","Symbol","iterator","_step","_iteratorNormalCompletion","_iterator","next","done","_currentValue2","basicLength","handledCPCount","m","_step2","_iteratorNormalCompletion2","_iterator2","currentValue","handledCPCountPlusOne","_step3","_iteratorNormalCompletion3","_iterator3","_currentValue","q","qMinusT","toUnicode","test","toASCII","punycode","SCHEMES","pctEncChar","chr","c","e","pctDecChars","newStr","il","parseInt","substr","c2","_c","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","match","UNRESERVED","scheme","PCT_ENCODED","NOT_SCHEME","userinfo","NOT_USERINFO","host","NOT_HOST","path","NOT_PATH","NOT_PATH_NOSCHEME","query","NOT_QUERY","fragment","NOT_FRAGMENT","_stripLeadingZeros","_normalizeIPv4","matches","IPV4ADDRESS","address","_matches","_normalizeIPv6","IPV6ADDRESS","_matches2","zone","reverse","last","_address$toLowerCase$2","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","allZeroFields","reduce","acc","field","lastLongest","longestZeroFields","sort","a","b","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","parse","uriString","options","iri","reference","port","isNaN","indexOf","schemeHandler","unicodeSupport","domainHost","_recomposeAuthority","uriTokens","_","$1","$2","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","s","Error","serialize","authority","charAt","absolutePath","resolveComponents","relative","skipNormalization","tolerant","resolve","baseURI","relativeURI","schemelessOptions","normalize","uri","equal","uriA","uriB","escapeComponent","ESCAPE","unescapeComponent","handler","secure","handler$1","isSecure","wsComponents","handler$2","resourceName","_wsComponents$resourc2","handler$3","O","ATEXT$$","QTEXT$$","VCHAR$$","SOME_DELIMS$$","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","handler$4","parse$$1","mailtoComponents","to","unknownHeaders","headers","hfields","hfield","toAddrs","_x","_xl","subject","body","_x2","_xl2","addr","serialize$$1","toAddr","atIdx","localPart","domain","name","URN_PARSE","handler$5","urnComponents","nid","nss","urnScheme","uriComponents","UUID","handler$6","uuidComponents","uuid"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/index.ts","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/schemes/urn-uuid.ts","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/schemes/urn.ts","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/schemes/mailto.ts","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/schemes/wss.ts","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/schemes/ws.ts","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/schemes/https.ts","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/schemes/http.ts","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/uri.ts","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/node_modules/punycode/punycode.es6.js","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/regexps-iri.ts","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/regexps-uri.ts","/Users/mdabdurrazzak/RadInsu/node_modules/uri-js/src/util.ts"],"sourcesContent":["import { SCHEMES } from \"./uri\";\n\nimport http from \"./schemes/http\";\nSCHEMES[http.scheme] = http;\n\nimport https from \"./schemes/https\";\nSCHEMES[https.scheme] = https;\n\nimport ws from \"./schemes/ws\";\nSCHEMES[ws.scheme] = ws;\n\nimport wss from \"./schemes/wss\";\nSCHEMES[wss.scheme] = wss;\n\nimport mailto from \"./schemes/mailto\";\nSCHEMES[mailto.scheme] = mailto;\n\nimport urn from \"./schemes/urn\";\nSCHEMES[urn.scheme] = urn;\n\nimport uuid from \"./schemes/urn-uuid\";\nSCHEMES[uuid.scheme] = uuid;\n\nexport * from \"./uri\";\n","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { URNComponents } from \"./urn\";\nimport { SCHEMES } from \"../uri\";\n\nexport interface UUIDComponents extends URNComponents {\n\tuuid?: string;\n}\n\nconst UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\nconst UUID_PARSE = /^[0-9A-Fa-f\\-]{36}/;\n\n//RFC 4122\nconst handler:URISchemeHandler<UUIDComponents, URIOptions, URNComponents> = {\n\tscheme : \"urn:uuid\",\n\n\tparse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {\n\t\tconst uuidComponents = urnComponents as UUIDComponents;\n\t\tuuidComponents.uuid = uuidComponents.nss;\n\t\tuuidComponents.nss = undefined;\n\n\t\tif (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n\t\t\tuuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n\t\t}\n\n\t\treturn uuidComponents;\n\t},\n\n\tserialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {\n\t\tconst urnComponents = uuidComponents as URNComponents;\n\t\t//normalize UUID\n\t\turnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n\t\treturn urnComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, SCHEMES } from \"../uri\";\n\nexport interface URNComponents extends URIComponents {\n\tnid?:string;\n\tnss?:string;\n}\n\nexport interface URNOptions extends URIOptions {\n\tnid?:string;\n}\n\nconst NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\";\nconst PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\";\nconst TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\";\nconst NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\";\nconst URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\");\nconst URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\");\nconst URN_PARSE = /^([^\\:]+)\\:(.*)/;\nconst URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g;\n\n//RFC 2141\nconst handler:URISchemeHandler<URNComponents,URNOptions> = {\n\tscheme : \"urn\",\n\n\tparse : function (components:URIComponents, options:URNOptions):URNComponents {\n\t\tconst matches = components.path && components.path.match(URN_PARSE);\n\t\tlet urnComponents = components as URNComponents;\n\n\t\tif (matches) {\n\t\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t\tconst nid = matches[1].toLowerCase();\n\t\t\tconst nss = matches[2];\n\t\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\t\turnComponents.nid = nid;\n\t\t\turnComponents.nss = nss;\n\t\t\turnComponents.path = undefined;\n\n\t\t\tif (schemeHandler) {\n\t\t\t\turnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;\n\t\t\t}\n\t\t} else {\n\t\t\turnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n\t\t}\n\n\t\treturn urnComponents;\n\t},\n\n\tserialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {\n\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\tconst nid = urnComponents.nid;\n\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\tif (schemeHandler) {\n\t\t\turnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;\n\t\t}\n\n\t\tconst uriComponents = urnComponents as URIComponents;\n\t\tconst nss = urnComponents.nss;\n\t\turiComponents.path = `${nid || options.nid}:${nss}`;\n\n\t\treturn uriComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\n\nexport interface MailtoHeaders {\n\t[hfname:string]:string\n}\n\nexport interface MailtoComponents extends URIComponents {\n\tto:Array<string>,\n\theaders?:MailtoHeaders,\n\tsubject?:string,\n\tbody?:string\n}\n\nconst O:MailtoHeaders = {};\nconst isIRI = true;\n\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\";  //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));  //expanded\n\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\";  //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\n\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str:string):string {\n\tconst decStr = pctDecChars(str);\n\treturn (!decStr.match(UNRESERVED) ? str : decStr);\n}\n\nconst handler:URISchemeHandler<MailtoComponents> =  {\n\tscheme : \"mailto\",\n\n\tparse : function (components:URIComponents, options:URIOptions):MailtoComponents {\n\t\tconst mailtoComponents = components as MailtoComponents;\n\t\tconst to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(\",\") : []);\n\t\tmailtoComponents.path = undefined;\n\n\t\tif (mailtoComponents.query) {\n\t\t\tlet unknownHeaders = false\n\t\t\tconst headers:MailtoHeaders = {};\n\t\t\tconst hfields = mailtoComponents.query.split(\"&\");\n\n\t\t\tfor (let x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t\t\tconst hfield = hfields[x].split(\"=\");\n\n\t\t\t\tswitch (hfield[0]) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tconst toAddrs = hfield[1].split(\",\");\n\t\t\t\t\t\tfor (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n\t\t\t\t\t\t\tto.push(toAddrs[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subject\":\n\t\t\t\t\t\tmailtoComponents.subject = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"body\":\n\t\t\t\t\t\tmailtoComponents.body = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunknownHeaders = true;\n\t\t\t\t\t\theaders[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unknownHeaders) mailtoComponents.headers = headers;\n\t\t}\n\n\t\tmailtoComponents.query = undefined;\n\n\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\tconst addr = to[x].split(\"@\");\n\n\t\t\taddr[0] = unescapeComponent(addr[0]);\n\n\t\t\tif (!options.unicodeSupport) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\taddr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tmailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t\t}\n\n\t\t\tto[x] = addr.join(\"@\");\n\t\t}\n\n\t\treturn mailtoComponents;\n\t},\n\n\tserialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {\n\t\tconst components = mailtoComponents as URIComponents;\n\t\tconst to = toArray(mailtoComponents.to);\n\t\tif (to) {\n\t\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\t\tconst toAddr = String(to[x]);\n\t\t\t\tconst atIdx = toAddr.lastIndexOf(\"@\");\n\t\t\t\tconst localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t\t\tlet domain = toAddr.slice(atIdx + 1);\n\n\t\t\t\t//convert IDN via punycode\n\t\t\t\ttry {\n\t\t\t\t\tdomain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t\t}\n\n\t\t\t\tto[x] = localPart + \"@\" + domain;\n\t\t\t}\n\n\t\t\tcomponents.path = to.join(\",\");\n\t\t}\n\n\t\tconst headers = mailtoComponents.headers = mailtoComponents.headers || {};\n\n\t\tif (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n\t\tif (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n\n\t\tconst fields = [];\n\t\tfor (const name in headers) {\n\t\t\tif (headers[name] !== O[name]) {\n\t\t\t\tfields.push(\n\t\t\t\t\tname.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n\t\t\t\t\t\"=\" +\n\t\t\t\t\theaders[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (fields.length) {\n\t\t\tcomponents.query = fields.join(\"&\");\n\t\t}\n\n\t\treturn components;\n\t}\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport ws from \"./ws\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"wss\",\n\tdomainHost : ws.domainHost,\n\tparse : ws.parse,\n\tserialize : ws.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nexport interface WSComponents extends URIComponents {\n\tresourceName?: string;\n\tsecure?: boolean;\n}\n\nfunction isSecure(wsComponents:WSComponents):boolean {\n\treturn typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n\n//RFC 6455\nconst handler:URISchemeHandler = {\n\tscheme : \"ws\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):WSComponents {\n\t\tconst wsComponents = components as WSComponents;\n\n\t\t//indicate if the secure flag is set\n\t\twsComponents.secure = isSecure(wsComponents);\n\n\t\t//construct resouce name\n\t\twsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n\t\twsComponents.path = undefined;\n\t\twsComponents.query = undefined;\n\n\t\treturn wsComponents;\n\t},\n\n\tserialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {\n\t\t//normalize the default port\n\t\tif (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n\t\t\twsComponents.port = undefined;\n\t\t}\n\n\t\t//ensure scheme matches secure flag\n\t\tif (typeof wsComponents.secure === 'boolean') {\n\t\t\twsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');\n\t\t\twsComponents.secure = undefined;\n\t\t}\n\n\t\t//reconstruct path from resource name\n\t\tif (wsComponents.resourceName) {\n\t\t\tconst [path, query] = wsComponents.resourceName.split('?');\n\t\t\twsComponents.path = (path && path !== '/' ? path : undefined);\n\t\t\twsComponents.query = query;\n\t\t\twsComponents.resourceName = undefined;\n\t\t}\n\n\t\t//forbid fragment component\n\t\twsComponents.fragment = undefined;\n\n\t\treturn wsComponents;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport http from \"./http\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"https\",\n\tdomainHost : http.domainHost,\n\tparse : http.parse,\n\tserialize : http.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"http\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//report missing host\n\t\tif (!components.host) {\n\t\t\tcomponents.error = components.error || \"HTTP URIs must have a host.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst secure = String(components.scheme).toLowerCase() === \"https\";\n\n\t\t//normalize the default port\n\t\tif (components.port === (secure ? 443 : 80) || components.port === \"\") {\n\t\t\tcomponents.port = undefined;\n\t\t}\n\t\t\n\t\t//normalize the empty path\n\t\tif (!components.path) {\n\t\t\tcomponents.path = \"/\";\n\t\t}\n\n\t\t//NOTE: We do not parse query strings for HTTP URIs\n\t\t//as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t//and not the HTTP spec.\n\n\t\treturn components;\n\t}\n};\n\nexport default handler;","/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\n\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\n\nexport interface URIComponents {\n\tscheme?:string;\n\tuserinfo?:string;\n\thost?:string;\n\tport?:number|string;\n\tpath?:string;\n\tquery?:string;\n\tfragment?:string;\n\treference?:string;\n\terror?:string;\n}\n\nexport interface URIOptions {\n\tscheme?:string;\n\treference?:string;\n\ttolerant?:boolean;\n\tabsolutePath?:boolean;\n\tiri?:boolean;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n}\n\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n\tscheme:string;\n\tparse(components:ParentComponents, options:Options):Components;\n\tserialize(components:Components, options:Options):ParentComponents;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n\tabsolutePath?:boolean;\n}\n\nexport interface URIRegExps {\n\tNOT_SCHEME : RegExp,\n\tNOT_USERINFO : RegExp,\n\tNOT_HOST : RegExp,\n\tNOT_PATH : RegExp,\n\tNOT_PATH_NOSCHEME : RegExp,\n\tNOT_QUERY : RegExp,\n\tNOT_FRAGMENT : RegExp,\n\tESCAPE : RegExp,\n\tUNRESERVED : RegExp,\n\tOTHER_CHARS : RegExp,\n\tPCT_ENCODED : RegExp,\n\tIPV4ADDRESS : RegExp,\n\tIPV6ADDRESS : RegExp,\n}\n\nexport const SCHEMES:{[scheme:string]:URISchemeHandler} = {};\n\nexport function pctEncChar(chr:string):string {\n\tconst c = chr.charCodeAt(0);\n\tlet e:string;\n\n\tif (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n\telse if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n\telse if (c < 2048) e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\telse e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\n\treturn e;\n}\n\nexport function pctDecChars(str:string):string {\n\tlet newStr = \"\";\n\tlet i = 0;\n\tconst il = str.length;\n\n\twhile (i < il) {\n\t\tconst c = parseInt(str.substr(i + 1, 2), 16);\n\n\t\tif (c < 128) {\n\t\t\tnewStr += String.fromCharCode(c);\n\t\t\ti += 3;\n\t\t}\n\t\telse if (c >= 194 && c < 224) {\n\t\t\tif ((il - i) >= 6) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 6);\n\t\t\t}\n\t\t\ti += 6;\n\t\t}\n\t\telse if (c >= 224) {\n\t\t\tif ((il - i) >= 9) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tconst c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 9);\n\t\t\t}\n\t\t\ti += 9;\n\t\t}\n\t\telse {\n\t\t\tnewStr += str.substr(i, 3);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn newStr;\n}\n\nfunction _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {\n\tfunction decodeUnreserved(str:string):string {\n\t\tconst decStr = pctDecChars(str);\n\t\treturn (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n\t}\n\n\tif (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\tif (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\n\treturn components;\n};\n\nfunction _stripLeadingZeros(str:string):string {\n\treturn str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\n\nfunction _normalizeIPv4(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV4ADDRESS) || [];\n\tconst [, address] = matches;\n\t\n\tif (address) {\n\t\treturn address.split(\".\").map(_stripLeadingZeros).join(\".\");\n\t} else {\n\t\treturn host;\n\t}\n}\n\nfunction _normalizeIPv6(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV6ADDRESS) || [];\n\tconst [, address, zone] = matches;\n\n\tif (address) {\n\t\tconst [last, first] = address.toLowerCase().split('::').reverse();\n\t\tconst firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n\t\tconst lastFields = last.split(\":\").map(_stripLeadingZeros);\n\t\tconst isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n\t\tconst fieldCount = isLastFieldIPv4Address ? 7 : 8;\n\t\tconst lastFieldsStart = lastFields.length - fieldCount;\n\t\tconst fields = Array<string>(fieldCount);\n\n\t\tfor (let x = 0; x < fieldCount; ++x) {\n\t\t\tfields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n\t\t}\n\n\t\tif (isLastFieldIPv4Address) {\n\t\t\tfields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n\t\t}\n\n\t\tconst allZeroFields = fields.reduce<Array<{index:number,length:number}>>((acc, field, index) => {\n\t\t\tif (!field || field === \"0\") {\n\t\t\t\tconst lastLongest = acc[acc.length - 1];\n\t\t\t\tif (lastLongest && lastLongest.index + lastLongest.length === index) {\n\t\t\t\t\tlastLongest.length++;\n\t\t\t\t} else {\n\t\t\t\t\tacc.push({ index, length : 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n\n\t\tlet newHost:string;\n\t\tif (longestZeroFields && longestZeroFields.length > 1) {\n\t\t\tconst newFirst = fields.slice(0, longestZeroFields.index) ;\n\t\t\tconst newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n\t\t\tnewHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n\t\t} else {\n\t\t\tnewHost = fields.join(\":\");\n\t\t}\n\n\t\tif (zone) {\n\t\t\tnewHost += \"%\" + zone;\n\t\t}\n\n\t\treturn newHost;\n\t} else {\n\t\treturn host;\n\t}\n}\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>(\"\").match(/(){0}/))[1] === undefined;\n\nexport function parse(uriString:string, options:URIOptions = {}):URIComponents {\n\tconst components:URIComponents = {};\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\n\tif (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\n\tconst matches = uriString.match(URI_PARSE);\n\n\tif (matches) {\n\t\tif (NO_MATCH_IS_UNDEFINED) {\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1];\n\t\t\tcomponents.userinfo = matches[3];\n\t\t\tcomponents.host = matches[4];\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = matches[7];\n\t\t\tcomponents.fragment = matches[8];\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = matches[5];\n\t\t\t}\n\t\t} else {  //IE FIX for improper RegExp matching\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1] || undefined;\n\t\t\tcomponents.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n\t\t\tcomponents.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n\t\t\tcomponents.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n\t\t\t}\n\t\t}\n\n\t\tif (components.host) {\n\t\t\t//normalize IP hosts\n\t\t\tcomponents.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n\t\t}\n\n\t\t//determine reference type\n\t\tif (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t\tcomponents.reference = \"same-document\";\n\t\t} else if (components.scheme === undefined) {\n\t\t\tcomponents.reference = \"relative\";\n\t\t} else if (components.fragment === undefined) {\n\t\t\tcomponents.reference = \"absolute\";\n\t\t} else {\n\t\t\tcomponents.reference = \"uri\";\n\t\t}\n\n\t\t//check for reference errors\n\t\tif (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t\tcomponents.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t}\n\n\t\t//find scheme handler\n\t\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t\t//check if scheme can't handle IRIs\n\t\tif (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t\t//if host component is a domain name\n\t\t\tif (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\tcomponents.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//convert IRI -> URI\n\t\t\t_normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t} else {\n\t\t\t//normalize encodings\n\t\t\t_normalizeComponentEncoding(components, protocol);\n\t\t}\n\n\t\t//perform scheme specific parsing\n\t\tif (schemeHandler && schemeHandler.parse) {\n\t\t\tschemeHandler.parse(components, options);\n\t\t}\n\t} else {\n\t\tcomponents.error = components.error || \"URI can not be parsed.\";\n\t}\n\n\treturn components;\n};\n\nfunction _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\tif (components.userinfo !== undefined) {\n\t\turiTokens.push(components.userinfo);\n\t\turiTokens.push(\"@\");\n\t}\n\n\tif (components.host !== undefined) {\n\t\t//normalize IP hosts, add brackets and escape zone separator for IPv6\n\t\turiTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n\t}\n\n\tif (typeof components.port === \"number\" || typeof components.port === \"string\") {\n\t\turiTokens.push(\":\");\n\t\turiTokens.push(String(components.port));\n\t}\n\n\treturn uriTokens.length ? uriTokens.join(\"\") : undefined;\n};\n\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\nexport function removeDotSegments(input:string):string {\n\tconst output:Array<string> = [];\n\n\twhile (input.length) {\n\t\tif (input.match(RDS1)) {\n\t\t\tinput = input.replace(RDS1, \"\");\n\t\t} else if (input.match(RDS2)) {\n\t\t\tinput = input.replace(RDS2, \"/\");\n\t\t} else if (input.match(RDS3)) {\n\t\t\tinput = input.replace(RDS3, \"/\");\n\t\t\toutput.pop();\n\t\t} else if (input === \".\" || input === \"..\") {\n\t\t\tinput = \"\";\n\t\t} else {\n\t\t\tconst im = input.match(RDS5);\n\t\t\tif (im) {\n\t\t\t\tconst s = im[0];\n\t\t\t\tinput = input.slice(s.length);\n\t\t\t\toutput.push(s);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected dot segment condition\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.join(\"\");\n};\n\nexport function serialize(components:URIComponents, options:URIOptions = {}):string {\n\tconst protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\t//find scheme handler\n\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t//perform scheme specific serialization\n\tif (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n\tif (components.host) {\n\t\t//if host component is an IPv6 address\n\t\tif (protocol.IPV6ADDRESS.test(components.host)) {\n\t\t\t//TODO: normalize IPv6 address as per RFC 5952\n\t\t}\n\n\t\t//if host component is a domain name\n\t\telse if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n\t\t\t//convert IDN via punycode\n\t\t\ttry {\n\t\t\t\tcomponents.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n\t\t\t} catch (e) {\n\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//normalize encoding\n\t_normalizeComponentEncoding(components, protocol);\n\n\tif (options.reference !== \"suffix\" && components.scheme) {\n\t\turiTokens.push(components.scheme);\n\t\turiTokens.push(\":\");\n\t}\n\n\tconst authority = _recomposeAuthority(components, options);\n\tif (authority !== undefined) {\n\t\tif (options.reference !== \"suffix\") {\n\t\t\turiTokens.push(\"//\");\n\t\t}\n\n\t\turiTokens.push(authority);\n\n\t\tif (components.path && components.path.charAt(0) !== \"/\") {\n\t\t\turiTokens.push(\"/\");\n\t\t}\n\t}\n\n\tif (components.path !== undefined) {\n\t\tlet s = components.path;\n\n\t\tif (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t\ts = removeDotSegments(s);\n\t\t}\n\n\t\tif (authority === undefined) {\n\t\t\ts = s.replace(/^\\/\\//, \"/%2F\");  //don't allow the path to start with \"//\"\n\t\t}\n\n\t\turiTokens.push(s);\n\t}\n\n\tif (components.query !== undefined) {\n\t\turiTokens.push(\"?\");\n\t\turiTokens.push(components.query);\n\t}\n\n\tif (components.fragment !== undefined) {\n\t\turiTokens.push(\"#\");\n\t\turiTokens.push(components.fragment);\n\t}\n\n\treturn uriTokens.join(\"\");  //merge tokens into a string\n};\n\nexport function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {\n\tconst target:URIComponents = {};\n\n\tif (!skipNormalization) {\n\t\tbase = parse(serialize(base, options), options);  //normalize base components\n\t\trelative = parse(serialize(relative, options), options);  //normalize relative components\n\t}\n\toptions = options || {};\n\n\tif (!options.tolerant && relative.scheme) {\n\t\ttarget.scheme = relative.scheme;\n\t\t//target.authority = relative.authority;\n\t\ttarget.userinfo = relative.userinfo;\n\t\ttarget.host = relative.host;\n\t\ttarget.port = relative.port;\n\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\ttarget.query = relative.query;\n\t} else {\n\t\tif (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t\t//target.authority = relative.authority;\n\t\t\ttarget.userinfo = relative.userinfo;\n\t\t\ttarget.host = relative.host;\n\t\t\ttarget.port = relative.port;\n\t\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\t\ttarget.query = relative.query;\n\t\t} else {\n\t\t\tif (!relative.path) {\n\t\t\t\ttarget.path = base.path;\n\t\t\t\tif (relative.query !== undefined) {\n\t\t\t\t\ttarget.query = relative.query;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.query = base.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (relative.path.charAt(0) === \"/\") {\n\t\t\t\t\ttarget.path = removeDotSegments(relative.path);\n\t\t\t\t} else {\n\t\t\t\t\tif ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t\t\t\t\ttarget.path = \"/\" + relative.path;\n\t\t\t\t\t} else if (!base.path) {\n\t\t\t\t\t\ttarget.path = relative.path;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t\t\t\t}\n\t\t\t\t\ttarget.path = removeDotSegments(target.path);\n\t\t\t\t}\n\t\t\t\ttarget.query = relative.query;\n\t\t\t}\n\t\t\t//target.authority = base.authority;\n\t\t\ttarget.userinfo = base.userinfo;\n\t\t\ttarget.host = base.host;\n\t\t\ttarget.port = base.port;\n\t\t}\n\t\ttarget.scheme = base.scheme;\n\t}\n\n\ttarget.fragment = relative.fragment;\n\n\treturn target;\n};\n\nexport function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {\n\tconst schemelessOptions = assign({ scheme : 'null' }, options);\n\treturn serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n};\n\nexport function normalize(uri:string, options?:URIOptions):string;\nexport function normalize(uri:URIComponents, options?:URIOptions):URIComponents;\nexport function normalize(uri:any, options?:URIOptions):any {\n\tif (typeof uri === \"string\") {\n\t\turi = serialize(parse(uri, options), options);\n\t} else if (typeOf(uri) === \"object\") {\n\t\turi = parse(serialize(<URIComponents>uri, options), options);\n\t}\n\n\treturn uri;\n};\n\nexport function equal(uriA:string, uriB:string, options?: URIOptions):boolean;\nexport function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;\nexport function equal(uriA:any, uriB:any, options?:URIOptions):boolean {\n\tif (typeof uriA === \"string\") {\n\t\turiA = serialize(parse(uriA, options), options);\n\t} else if (typeOf(uriA) === \"object\") {\n\t\turiA = serialize(<URIComponents>uriA, options);\n\t}\n\n\tif (typeof uriB === \"string\") {\n\t\turiB = serialize(parse(uriB, options), options);\n\t} else if (typeOf(uriB) === \"object\") {\n\t\turiB = serialize(<URIComponents>uriB, options);\n\t}\n\n\treturn uriA === uriB;\n};\n\nexport function escapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n};\n\nexport function unescapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n};\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport default punycode;\n","import { URIRegExps } from \"./uri\";\nimport { buildExps } from \"./regexps-uri\";\n\nexport default buildExps(true);\n","import { URIRegExps } from \"./uri\";\nimport { merge, subexp } from \"./util\";\n\nexport function buildExps(isIRI:boolean):URIRegExps {\n\tconst\n\t\tALPHA$$ = \"[A-Za-z]\",\n\t\tCR$ = \"[\\\\x0D]\",\n\t\tDIGIT$$ = \"[0-9]\",\n\t\tDQUOTE$$ = \"[\\\\x22]\",\n\t\tHEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),  //case-insensitive\n\t\tLF$$ = \"[\\\\x0A]\",\n\t\tSP$$ = \"[\\\\x20]\",\n\t\tPCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),  //expanded\n\t\tGEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\tSUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\tRESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\tUCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",  //subset, excludes bidi control characters\n\t\tIPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",  //subset\n\t\tUNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\tSCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\tUSERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\tDEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\tDEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),  //relaxed parsing rules\n\t\tIPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n\t\tH16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\tLS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\tIPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n\t\tIPV6ADDRESS2$ = subexp(                                                 \"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n\t\tIPV6ADDRESS3$ = subexp(subexp(                                 H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\tIPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\tIPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\tIPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" +        H16$ + \"\\\\:\"          + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\tIPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\"                                + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\tIPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\"                                + H16$ ), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\tIPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"                                       ), //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\tIPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\tZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),  //RFC 6874\n\t\tIPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),  //RFC 6874\n\t\tIPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),  //RFC 6874, with relaxed parsing rules\n\t\tIPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\tIP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),  //RFC 6874\n\t\tREG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\tHOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\tPORT$ = subexp(DIGIT$$ + \"*\"),\n\t\tAUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\tPCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\tSEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\tSEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\tSEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\tPATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\tPATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),  //simplified\n\t\tPATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\tPATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tQUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\tFRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\tHIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tURI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tRELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\tRELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tURI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\tABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\n\t\tGENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tRELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\tSAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tAUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\"\n\t;\n\n\treturn {\n\t\tNOT_SCHEME : new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\tNOT_USERINFO : new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_HOST : new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH : new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH_NOSCHEME : new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_QUERY : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\tNOT_FRAGMENT : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\tESCAPE : new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tUNRESERVED : new RegExp(UNRESERVED$$, \"g\"),\n\t\tOTHER_CHARS : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\tPCT_ENCODED : new RegExp(PCT_ENCODED$, \"g\"),\n\t\tIPV4ADDRESS : new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n\t\tIPV6ADDRESS : new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\")  //RFC 6874, with relaxed parsing rules\n\t};\n}\n\nexport default buildExps(false);\n","export function merge(...sets:Array<string>):string {\n\tif (sets.length > 1) {\n\t\tsets[0] = sets[0].slice(0, -1);\n\t\tconst xl = sets.length - 1;\n\t\tfor (let x = 1; x < xl; ++x) {\n\t\t\tsets[x] = sets[x].slice(1, -1);\n\t\t}\n\t\tsets[xl] = sets[xl].slice(1);\n\t\treturn sets.join('');\n\t} else {\n\t\treturn sets[0];\n\t}\n}\n\nexport function subexp(str:string):string {\n\treturn \"(?:\" + str + \")\";\n}\n\nexport function typeOf(o:any):string {\n\treturn o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n}\n\nexport function toUpperCase(str:string):string {\n\treturn str.toUpperCase();\n}\n\nexport function toArray(obj:any):Array<any> {\n\treturn obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n}\n\n\nexport function assign(target: object, source: any): any {\n\tconst obj = target as any;\n\tif (source) {\n\t\tfor (const key in source) {\n\t\t\tobj[key] = source[key];\n\t\t}\n\t}\n\treturn obj;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}