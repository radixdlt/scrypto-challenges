{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nexports.__esModule = true;\nvar ISet_1 = require(\"./ISet\");\nvar Vector_1 = require(\"./Vector\");\nvar HashMap_1 = require(\"./HashMap\");\nvar LinkedList_1 = require(\"./LinkedList\");\nvar Option_1 = require(\"./Option\");\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers = require(\"./SeqHelpers\");\nvar Contract_1 = require(\"./Contract\");\nvar Value_1 = require(\"./Value\");\nvar hamt = require(\"hamt_plus\");\n/**\n * An unordered collection of values, where no two values\n * may be equal. A value can only be present once.\n * @param T the item type\n */\nvar HashSet = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function HashSet(hamt) {\n    this.hamt = hamt;\n  }\n  /**\n   * The empty hashset.\n   * @param T the item type\n   */\n  HashSet.empty = function () {\n    return emptyHashSet;\n  };\n  /**\n   * Build a hashset from any iterable, which means also\n   * an array for instance.\n   * @param T the item type\n   */\n  HashSet.ofIterable = function (elts) {\n    return new EmptyHashSet().addAll(elts);\n  };\n  /**\n   * Build a hashset from a series of items (any number, as parameters)\n   * @param T the item type\n   */\n  HashSet.of = function () {\n    var arr = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      arr[_i] = arguments[_i];\n    }\n    return HashSet.ofIterable(arr);\n  };\n  /**\n   * Curried predicate to find out whether the HashSet is empty.\n   *\n   *     Vector.of(HashSet.of(1), HashSet.empty<number>())\n   *         .filter(HashSet.isEmpty)\n   *     => Vector.of(HashSet.empty<number>())\n   */\n  HashSet.isEmpty = function (v) {\n    return v.isEmpty();\n  };\n  /**\n   * Curried predicate to find out whether the HashSet is empty.\n   *\n   *     Vector.of(HashSet.of(1), HashSet.empty<number>())\n   *         .filter(HashSet.isNotEmpty)\n   *     => Vector.of(HashSet.of(1))\n   */\n  HashSet.isNotEmpty = function (v) {\n    return !v.isEmpty();\n  };\n  /**\n   * Implementation of the Iterator interface.\n   */\n  HashSet.prototype[Symbol.iterator] = function () {\n    return this.hamt.keys();\n  };\n  /**\n   * Add an element to this set.\n   */\n  HashSet.prototype.add = function (elt) {\n    return new HashSet(this.hamt.set(elt, elt));\n  };\n  HashSet.prototype.addAllArray = function (elts) {\n    return new HashSet(this.hamt.mutate(function (h) {\n      if (elts.length > 0) {\n        Contract_1.contractTrueEquality(\"Error building a HashSet\", elts[0]);\n      }\n      for (var _i = 0, elts_1 = elts; _i < elts_1.length; _i++) {\n        var val = elts_1[_i];\n        h.set(val, val);\n      }\n    }));\n  };\n  /**\n   * Add multiple elements to this set.\n   */\n  HashSet.prototype.addAll = function (elts) {\n    if (Array.isArray(elts)) {\n      return this.addAllArray(elts);\n    }\n    return new HashSet(this.hamt.mutate(function (h) {\n      var checkedEq = false;\n      var iterator = elts[Symbol.iterator]();\n      var curItem = iterator.next();\n      if (!curItem.done && curItem.value && !checkedEq) {\n        Contract_1.contractTrueEquality(\"Error building a HashSet\", curItem.value);\n        checkedEq = true;\n      }\n      while (!curItem.done) {\n        h.set(curItem.value, curItem.value);\n        curItem = iterator.next();\n      }\n    }));\n  };\n  /**\n   * Returns true if the element you give is present in\n   * the set, false otherwise.\n   */\n  HashSet.prototype.contains = function (elt) {\n    return this.hamt.has(elt);\n  };\n  /**\n   * Return a new collection where each element was transformed\n   * by the mapper function you give.\n   * The resulting set may be smaller than the source.\n   */\n  HashSet.prototype.map = function (mapper) {\n    return this.hamt.fold(function (acc, value, key) {\n      return acc.add(mapper(value));\n    }, HashSet.empty());\n  };\n  /**\n   * Apply the mapper function on every element of this collection.\n   * The mapper function returns an Option; if the Option is a Some,\n   * the value it contains is added to the result Collection, if it's\n   * a None, the value is discarded.\n   *\n   *     HashSet.of(1,2,6).mapOption(x => x%2===0 ?\n   *         Option.of(x+1) : Option.none<number>())\n   *     => HashSet.of(3, 7)\n   */\n  HashSet.prototype.mapOption = function (mapper) {\n    return this.hamt.fold(function (acc, value, key) {\n      var val = mapper(value);\n      return val.isSome() ? acc.add(val.get()) : acc;\n    }, HashSet.empty());\n  };\n  /**\n   * Call a function for element in the collection.\n   */\n  HashSet.prototype.forEach = function (fun) {\n    var iterator = this.hamt.values();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      fun(curItem.value);\n      curItem = iterator.next();\n    }\n    return this;\n  };\n  /**\n   * Calls the function you give for each item in the set,\n   * your function returns a set, all the sets are\n   * merged.\n   */\n  HashSet.prototype.flatMap = function (mapper) {\n    return this.foldLeft(HashSet.empty(), function (soFar, cur) {\n      return soFar.addAll(mapper(cur));\n    });\n  };\n  HashSet.prototype.filter = function (predicate) {\n    var _this = this;\n    return new HashSet(hamt.make({\n      hash: this.hamt._config.hash,\n      keyEq: this.hamt._config.keyEq\n    }).mutate(function (h) {\n      var iterator = _this.hamt.values();\n      var curItem = iterator.next();\n      while (!curItem.done) {\n        if (predicate(curItem.value)) {\n          h.set(curItem.value, curItem.value);\n        }\n        curItem = iterator.next();\n      }\n    }));\n  };\n  /**\n   * Search for an item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   * We name the method findAny instead of find to emphasize\n   * that there is not ordering in a hashset.\n   *\n   *     HashSet.of(1,2,3).findAny(x => x>=3)\n   *     => Option.of(3)\n   *\n   *     HashSet.of(1,2,3).findAny(x => x>=4)\n   *     => Option.none<number>()\n   */\n  HashSet.prototype.findAny = function (predicate) {\n    var iterator = this.hamt.values();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (predicate(curItem.value)) {\n        return Option_1.Option.of(curItem.value);\n      }\n      curItem = iterator.next();\n    }\n    return Option_1.Option.none();\n  };\n  /**\n   * Reduces the collection to a single value using the\n   * associative binary function you give. Since the function\n   * is associative, order of application doesn't matter.\n   *\n   * Example:\n   *\n   *     HashSet.of(1,2,3).fold(0, (a,b) => a + b);\n   *     => 6\n   */\n  HashSet.prototype.fold = function (zero, fn) {\n    return this.foldLeft(zero, fn);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Left-associative.\n   * No guarantees for the order of items in a hashset!\n   *\n   * Example:\n   *\n   *     HashSet.of(\"a\", \"bb\", \"ccc\").foldLeft(0, (soFar,item) => soFar+item.length);\n   *     => 6\n   *\n   * @param zero The initial value\n   * @param fn A function taking the previous value and\n   *           the current collection item, and returning\n   *           an updated value.\n   */\n  HashSet.prototype.foldLeft = function (zero, fn) {\n    return this.hamt.fold(function (acc, v, k) {\n      return fn(acc, v);\n    }, zero);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Right-associative.\n   * No guarantees for the order of items in a hashset!\n   *\n   * Example:\n   *\n   *     HashSet.of(\"a\", \"bb\", \"ccc\").foldRight(0, (item,soFar) => soFar+item.length);\n   *     => 6\n   *\n   * @param zero The initial value\n   * @param fn A function taking the current collection item and\n   *           the previous value , and returning\n   *           an updated value.\n   */\n  HashSet.prototype.foldRight = function (zero, fn) {\n    return this.foldLeft(zero, function (cur, soFar) {\n      return fn(soFar, cur);\n    });\n  };\n  /**\n   * Converts this set to an array. Since a Set is not ordered\n   * and since this method returns a JS array, it can be awkward\n   * to get an array sorted in the way you'd like. So you can pass\n   * an optional sorting function too.\n   *\n   *     HashSet.of(1,2,3).toArray().sort()\n   *     => [1,2,3]\n   *\n   *     HashSet.of(1,2,3).toArray({sortOn:x=>x})\n   *     => [1,2,3]\n   *\n   *     HashSet.of(1,2,3).toArray({sortBy:(x,y)=>x-y})\n   *     => [1,2,3]\n   *\n   * You can also pass an array in sortOn, listing lambdas to\n   * several fields to sort by those fields, and also {desc:lambda}\n   * to sort by some fields descending.\n   */\n  HashSet.prototype.toArray = function (sort) {\n    var _a;\n    if (!sort) {\n      return Array.from(this.hamt.keys());\n    }\n    if (ISet_1.isSortOnSpec(sort)) {\n      var sortOn = sort.sortOn instanceof Array ? sort.sortOn : [sort.sortOn];\n      return (_a = Vector_1.Vector.ofIterable(this.hamt.keys())).sortOn.apply(_a, sortOn).toArray();\n    }\n    return Array.from(this.hamt.keys()).sort(sort.sortBy);\n  };\n  /**\n   * Converts this set to an vector\n   */\n  HashSet.prototype.toVector = function () {\n    return Vector_1.Vector.ofIterable(this.hamt.keys());\n  };\n  /**\n   * Converts this set to an list\n   */\n  HashSet.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.ofIterable(this.hamt.keys());\n  };\n  /**\n   * Returns the number of elements in the set.\n   */\n  HashSet.prototype.length = function () {\n    return this.hamt.size;\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  HashSet.prototype.single = function () {\n    return this.hamt.size === 1 ? Option_1.Option.of(this.hamt.keys().next().value) : Option_1.Option.none();\n  };\n  /**\n   * true if the set is empty, false otherwise.\n   */\n  HashSet.prototype.isEmpty = function () {\n    return this.hamt.size === 0;\n  };\n  /**\n   * Returns a new Set containing the difference\n   * between this set and the other Set passed as parameter.\n   * also see [[HashSet.intersect]]\n   */\n  HashSet.prototype.diff = function (elts) {\n    return new HashSet(this.hamt.fold(function (acc, v, k) {\n      return elts.contains(k) ? acc : acc.set(k, k);\n    }, hamt.empty));\n  };\n  /**\n   * Returns a new Set containing the intersection\n   * of this set and the other Set passed as parameter\n   * (the elements which are common to both sets)\n   * also see [[HashSet.diff]]\n   */\n  HashSet.prototype.intersect = function (other) {\n    return new HashSet(this.hamt.fold(function (acc, v, k) {\n      return other.contains(k) ? acc.set(k, k) : acc;\n    }, hamt.empty));\n  };\n  HashSet.prototype.isSubsetOf = function (other) {\n    return this.allMatch(function (x) {\n      return other.contains(x);\n    });\n  };\n  /**\n   * Returns a new set with the element you give removed\n   * if it was present in the set.\n   */\n  HashSet.prototype.remove = function (elt) {\n    return new HashSet(this.hamt.remove(elt));\n  };\n  /**\n   * Returns a new set with all the elements of the current\n   * Set, minus the elements of the iterable you give as a parameter.\n   * If you call this function with a HashSet as parameter,\n   * rather call 'diff', as it'll be faster.\n   */\n  HashSet.prototype.removeAll = function (elts) {\n    return this.diff(HashSet.ofIterable(elts));\n  };\n  HashSet.prototype.allMatch = function (predicate) {\n    var iterator = this.hamt.values();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (!predicate(curItem.value)) {\n        return false;\n      }\n      curItem = iterator.next();\n    }\n    return true;\n  };\n  /**\n   * Returns true if there the predicate returns true for any\n   * element in the collection.\n   */\n  HashSet.prototype.anyMatch = function (predicate) {\n    var iterator = this.hamt.values();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (predicate(curItem.value)) {\n        return true;\n      }\n      curItem = iterator.next();\n    }\n    return false;\n  };\n  /**\n   * Group elements in the collection using a classifier function.\n   * Elements are then organized in a map. The key is the value of\n   * the classifier, and in value we get the list of elements\n   * matching that value.\n   *\n   * also see [[HashSet.arrangeBy]]\n   */\n  HashSet.prototype.groupBy = function (classifier) {\n    var _this = this;\n    // make a singleton set with the same equality as this\n    var singletonHamtSet = function (v) {\n      return hamt.make({\n        hash: _this.hamt._config.hash,\n        keyEq: _this.hamt._config.keyEq\n      }).set(v, v);\n    };\n    // merge two mutable hamt sets, but I know the second has only 1 elt\n    var mergeSets = function (v1, v2) {\n      var k = v2.keys().next().value;\n      v1.set(k, k);\n      return v1;\n    };\n    return this.hamt.fold(\n    // fold operation: combine a new value from the set with the accumulator\n    function (acc, v, k) {\n      return acc.putWithMerge(classifier(v), singletonHamtSet(v).beginMutation(), mergeSets);\n    },\n    // fold accumulator: the empty hashmap\n    HashMap_1.HashMap.empty()).mapValues(function (h) {\n      return new HashSet(h.endMutation());\n    });\n  };\n  /**\n   * Matches each element with a unique key that you extract from it.\n   * If the same key is present twice, the function will return None.\n   *\n   * also see [[HashSet.groupBy]]\n   */\n  HashSet.prototype.arrangeBy = function (getKey) {\n    return SeqHelpers.arrangeBy(this, getKey);\n  };\n  HashSet.prototype.partition = function (predicate) {\n    var r1 = hamt.make({\n      hash: this.hamt._config.hash,\n      keyEq: this.hamt._config.keyEq\n    }).beginMutation();\n    var r2 = hamt.make({\n      hash: this.hamt._config.hash,\n      keyEq: this.hamt._config.keyEq\n    }).beginMutation();\n    var iterator = this.hamt.values();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (predicate(curItem.value)) {\n        r1.set(curItem.value, curItem.value);\n      } else {\n        r2.set(curItem.value, curItem.value);\n      }\n      curItem = iterator.next();\n    }\n    return [new HashSet(r1), new HashSet(r2)];\n  };\n  /**\n   * Reduces the collection to a single value by repeatedly\n   * calling the combine function.\n   * No starting value. The order in which the elements are\n   * passed to the combining function is undetermined.\n   */\n  HashSet.prototype.reduce = function (combine) {\n    return SeqHelpers.reduce(this, combine);\n  };\n  /**\n   * Compare values in the collection and return the smallest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[HashSet.minOn]]\n   */\n  HashSet.prototype.minBy = function (compare) {\n    return SeqHelpers.minBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the smallest.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[HashSet.minBy]]\n   */\n  HashSet.prototype.minOn = function (getOrderable) {\n    return SeqHelpers.minOn(this, getOrderable);\n  };\n  /**\n   * Compare values in the collection and return the largest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[HashSet.maxOn]]\n   */\n  HashSet.prototype.maxBy = function (compare) {\n    return SeqHelpers.maxBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the largest.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[HashSet.maxBy]]\n   */\n  HashSet.prototype.maxOn = function (getOrderable) {\n    return SeqHelpers.maxOn(this, getOrderable);\n  };\n  /**\n   * Call the function you give for each element in the collection\n   * and sum all the numbers, return that sum.\n   * Will return 0 if the collection is empty.\n   *\n   *     HashSet.of(1,2,3).sumOn(x=>x)\n   *     => 6\n   */\n  HashSet.prototype.sumOn = function (getNumber) {\n    return SeqHelpers.sumOn(this, getNumber);\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  HashSet.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  HashSet.prototype.toJsSet = function (keyConvert) {\n    return this.foldLeft(new Set(), function (sofar, cur) {\n      return sofar.add(keyConvert(cur));\n    });\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  HashSet.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    var sz = this.hamt.size;\n    if (other === emptyHashSet && sz === 0) {\n      // we could get that i'm not the empty map\n      // but my size is zero, after some filtering and such.\n      return true;\n    }\n    if (!other || !other.hamt) {\n      return false;\n    }\n    if (sz !== other.hamt.size) {\n      return false;\n    }\n    Contract_1.contractTrueEquality(\"HashSet.equals\", this, other);\n    var keys = Array.from(this.hamt.keys());\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var k = keys_1[_i];\n      var hisVal = other.hamt.get(k);\n      if (hisVal === undefined) {\n        return false;\n      }\n      if (!Comparison_1.areEqual(k, hisVal)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  HashSet.prototype.hashCode = function () {\n    return this.hamt.fold(function (acc, value, key) {\n      return acc + Comparison_1.getHashCode(key);\n    }, 0);\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   *\n   * Also see [[HashSet.mkString]]\n   */\n  HashSet.prototype.toString = function () {\n    return \"HashSet(\" + this.hamt.fold(function (acc, value, key) {\n      acc.push(SeqHelpers.toStringHelper(key));\n      return acc;\n    }, []).join(\", \") + \")\";\n  };\n  HashSet.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  /**\n   * Joins elements of the collection by a separator.\n   * Example:\n   *\n   *     HashSet.of(1,2,3).mkString(\", \")\n   *     => \"1, 2, 3\"\n   *\n   * (of course, order is not guaranteed)\n   */\n  HashSet.prototype.mkString = function (separator) {\n    return this.hamt.fold(function (acc, value, key) {\n      acc.push(SeqHelpers.toStringHelper(key, {\n        quoteStrings: false\n      }));\n      return acc;\n    }, []).join(separator);\n  };\n  return HashSet;\n}();\nexports.HashSet = HashSet;\n// we need to override the empty hashmap\n// because i don't know how to get the hash & keyset\n// functions for the keys without a key value to get\n// the functions from\nvar EmptyHashSet = /** @class */function (_super) {\n  __extends(EmptyHashSet, _super);\n  function EmptyHashSet() {\n    return _super.call(this, {}) || this;\n  }\n  EmptyHashSet.prototype.add = function (elt) {\n    Contract_1.contractTrueEquality(\"Error building a HashSet\", elt);\n    if (!elt) {\n      // special case if we get null for the first element...\n      // less optimized variant because we don't know\n      // if we should use '===' or 'equals'\n      return new HashSet(hamt.make({\n        hash: function (v) {\n          return Comparison_1.getHashCode(v);\n        },\n        keyEq: function (a, b) {\n          return Comparison_1.areEqual(a, b);\n        }\n      }).set(elt, elt));\n    }\n    // if the element is not null, save a if later by finding\n    // out right now whether we should call equals or ===\n    if (Comparison_1.hasEquals(elt)) {\n      return new HashSet(hamt.make({\n        hash: function (v) {\n          return v.hashCode();\n        },\n        keyEq: function (a, b) {\n          return a.equals(b);\n        }\n      }).set(elt, elt));\n    }\n    return new HashSet(hamt.make().set(elt, elt));\n  };\n  EmptyHashSet.prototype.addAll = function (elts) {\n    var _a;\n    var it = elts[Symbol.iterator]();\n    var curItem = it.next();\n    if (curItem.done) {\n      return emptyHashSet;\n    }\n    return this.add(curItem.value).addAll((_a = {}, _a[Symbol.iterator] = function () {\n      return it;\n    }, _a));\n  };\n  EmptyHashSet.prototype.contains = function (elt) {\n    return false;\n  };\n  EmptyHashSet.prototype.map = function (mapper) {\n    return emptyHashSet;\n  };\n  EmptyHashSet.prototype.mapOption = function (mapper) {\n    return emptyHashSet;\n  };\n  EmptyHashSet.prototype.forEach = function (fun) {\n    return this;\n  };\n  EmptyHashSet.prototype.filter = function (predicate) {\n    return this;\n  };\n  EmptyHashSet.prototype.findAny = function (predicate) {\n    return Option_1.Option.none();\n  };\n  EmptyHashSet.prototype.foldLeft = function (zero, fn) {\n    return zero;\n  };\n  EmptyHashSet.prototype.toArray = function (sort) {\n    return [];\n  };\n  EmptyHashSet.prototype.toVector = function () {\n    return Vector_1.Vector.empty();\n  };\n  EmptyHashSet.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.empty();\n  };\n  EmptyHashSet.prototype[Symbol.iterator] = function () {\n    return {\n      next: function () {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  };\n  EmptyHashSet.prototype.length = function () {\n    return 0;\n  };\n  EmptyHashSet.prototype.isEmpty = function () {\n    return true;\n  };\n  EmptyHashSet.prototype.diff = function (elts) {\n    return this;\n  };\n  EmptyHashSet.prototype.intersect = function (other) {\n    return this;\n  };\n  EmptyHashSet.prototype.anyMatch = function (predicate) {\n    return false;\n  };\n  EmptyHashSet.prototype.groupBy = function (classifier) {\n    return HashMap_1.HashMap.empty();\n  };\n  EmptyHashSet.prototype.allMatch = function (predicate) {\n    return true;\n  };\n  EmptyHashSet.prototype.partition = function (predicate) {\n    return [this, this];\n  };\n  EmptyHashSet.prototype.remove = function (elt) {\n    return this;\n  };\n  EmptyHashSet.prototype.equals = function (other) {\n    if (!other || !other.length) {\n      return false;\n    }\n    return other === emptyHashSet || other.length() === 0;\n  };\n  EmptyHashSet.prototype.hashCode = function () {\n    return 0;\n  };\n  EmptyHashSet.prototype.toString = function () {\n    return \"HashSet()\";\n  };\n  EmptyHashSet.prototype.mkString = function (separator) {\n    return \"\";\n  };\n  return EmptyHashSet;\n}(HashSet);\nvar emptyHashSet = new EmptyHashSet();","map":{"version":3,"names":["ISet_1","require","Vector_1","HashMap_1","LinkedList_1","Option_1","Comparison_1","SeqHelpers","Contract_1","Value_1","hamt","HashSet","empty","emptyHashSet","ofIterable","elts","EmptyHashSet","addAll","of","arr","_i","arguments","length","isEmpty","v","isNotEmpty","prototype","Symbol","iterator","keys","add","elt","set","addAllArray","mutate","h","contractTrueEquality","elts_1","val","Array","isArray","checkedEq","curItem","next","done","value","contains","has","map","mapper","fold","acc","key","mapOption","isSome","get","forEach","fun","values","flatMap","foldLeft","soFar","cur","filter","predicate","_this","make","hash","_config","keyEq","findAny","Option","none","zero","fn","k","foldRight","toArray","sort","from","isSortOnSpec","sortOn","_a","Vector","apply","sortBy","toVector","toLinkedList","LinkedList","size","single","diff","intersect","other","isSubsetOf","allMatch","x","remove","removeAll","anyMatch","groupBy","classifier","singletonHamtSet","mergeSets","v1","v2","putWithMerge","beginMutation","HashMap","mapValues","endMutation","arrangeBy","getKey","partition","r1","r2","reduce","combine","minBy","compare","minOn","getOrderable","maxBy","maxOn","sumOn","getNumber","transform","converter","toJsSet","keyConvert","Set","sofar","equals","sz","keys_1","hisVal","undefined","areEqual","hashCode","getHashCode","toString","push","toStringHelper","join","inspect","mkString","separator","quoteStrings","exports","_super","__extends","call","a","b","hasEquals","it"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/HashSet.ts"],"sourcesContent":["import { ISet,\n         SortOnSpec, SortBySpec, isSortOnSpec } from \"./ISet\";\nimport { Vector } from \"./Vector\";\nimport { HashMap } from \"./HashMap\";\nimport { LinkedList } from \"./LinkedList\";\nimport { Option } from \"./Option\";\nimport { WithEquality, hasEquals, HasEquals,\n         getHashCode, areEqual, Ordering, ToOrderable  } from \"./Comparison\";\nimport * as SeqHelpers from \"./SeqHelpers\";\nimport { contractTrueEquality } from \"./Contract\";\nimport { inspect } from \"./Value\";\nconst hamt: any = require(\"hamt_plus\");\n\n/**\n * An unordered collection of values, where no two values\n * may be equal. A value can only be present once.\n * @param T the item type\n */\nexport class HashSet<T> implements ISet<T> {\n\n    /**\n     * @hidden\n     */\n    protected constructor(private hamt: any) {}\n\n    /**\n     * The empty hashset.\n     * @param T the item type\n     */\n    static empty<T>(): HashSet<T> {\n        return <EmptyHashSet<T>>emptyHashSet;\n    }\n\n    /**\n     * Build a hashset from any iterable, which means also\n     * an array for instance.\n     * @param T the item type\n     */\n    static ofIterable<T>(elts: Iterable<T & WithEquality>): HashSet<T> {\n        return new EmptyHashSet<T>().addAll(elts);\n    }\n\n    /**\n     * Build a hashset from a series of items (any number, as parameters)\n     * @param T the item type\n     */\n    static of<T>(...arr: Array<T & WithEquality>): HashSet<T> {\n        return HashSet.ofIterable(arr);\n    }\n\n    /**\n     * Curried predicate to find out whether the HashSet is empty.\n     *\n     *     Vector.of(HashSet.of(1), HashSet.empty<number>())\n     *         .filter(HashSet.isEmpty)\n     *     => Vector.of(HashSet.empty<number>())\n     */\n    static isEmpty<T>(v: HashSet<T>): boolean {\n        return v.isEmpty();\n    }\n\n    /**\n     * Curried predicate to find out whether the HashSet is empty.\n     *\n     *     Vector.of(HashSet.of(1), HashSet.empty<number>())\n     *         .filter(HashSet.isNotEmpty)\n     *     => Vector.of(HashSet.of(1))\n     */\n    static isNotEmpty<T>(v: HashSet<T>): boolean {\n        return !v.isEmpty();\n    }\n\n    /**\n     * Implementation of the Iterator interface.\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.hamt.keys();\n    }\n\n    /**\n     * Add an element to this set.\n     */\n    add(elt: T & WithEquality): HashSet<T> {\n        return new HashSet<T>(this.hamt.set(elt,elt));\n    }\n\n    private addAllArray(elts: Array<T&WithEquality>): HashSet<T> {\n        return new HashSet<T>(this.hamt.mutate((h:any) => {\n            if (elts.length > 0) {\n                contractTrueEquality(\"Error building a HashSet\", elts[0]);\n            }\n            for (const val of elts) {\n                h.set(val, val);\n            }\n        }));\n    }\n\n    /**\n     * Add multiple elements to this set.\n     */\n    addAll(elts: Iterable<T & WithEquality>): HashSet<T> {\n        if (Array.isArray(elts)) {\n            return this.addAllArray(elts);\n        }\n        return new HashSet<T>(this.hamt.mutate((h:any) => {\n            let checkedEq = false;\n            const iterator = elts[Symbol.iterator]();\n            let curItem = iterator.next();\n            if (!curItem.done && curItem.value && !checkedEq) {\n                contractTrueEquality(\"Error building a HashSet\", curItem.value);\n                checkedEq = true;\n            }\n            while (!curItem.done) {\n                h.set(curItem.value, curItem.value);\n                curItem = iterator.next();\n            }\n        }));\n    }\n\n    /**\n     * Returns true if the element you give is present in\n     * the set, false otherwise.\n     */\n    contains(elt: T & WithEquality): boolean {\n        return this.hamt.has(elt);\n    }\n\n    /**\n     * Return a new collection where each element was transformed\n     * by the mapper function you give.\n     * The resulting set may be smaller than the source.\n     */\n    map<U>(mapper:(v:T)=>U&WithEquality): HashSet<U> {\n        return this.hamt.fold(\n            (acc: HashSet<U>, value: T&WithEquality, key: T&WithEquality) => {\n                return acc.add(mapper(value));\n            }, HashSet.empty());\n    }\n\n    /**\n     * Apply the mapper function on every element of this collection.\n     * The mapper function returns an Option; if the Option is a Some,\n     * the value it contains is added to the result Collection, if it's\n     * a None, the value is discarded.\n     *\n     *     HashSet.of(1,2,6).mapOption(x => x%2===0 ?\n     *         Option.of(x+1) : Option.none<number>())\n     *     => HashSet.of(3, 7)\n     */\n    mapOption<U>(mapper:(v:T)=>Option<U&WithEquality>): HashSet<U> {\n        return this.hamt.fold(\n            (acc: HashSet<U>, value: T&WithEquality, key: T&WithEquality) => {\n                const val = mapper(value);\n                return val.isSome() ? acc.add(val.get()) : acc\n            }, HashSet.empty());\n    }\n\n    /**\n     * Call a function for element in the collection.\n     */\n    forEach(fun:(x:T)=>void): HashSet<T> {\n        const iterator: Iterator<T> = this.hamt.values();\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            fun(curItem.value);\n            curItem = iterator.next();\n        }\n        return this;\n    }\n\n    /**\n     * Calls the function you give for each item in the set,\n     * your function returns a set, all the sets are\n     * merged.\n     */\n    flatMap<U>(mapper:(v:T)=>HashSet<U&WithEquality>): HashSet<U> {\n        return this.foldLeft(HashSet.empty<U>(),\n                             (soFar,cur) => soFar.addAll(mapper(cur)));\n    }\n\n    /**\n     * Call a predicate for each element in the collection,\n     * build a new collection holding only the elements\n     * for which the predicate returned true.\n     */\n    filter<U extends T>(fn:(v:T)=>v is U): HashSet<U>;\n    filter(predicate:(v:T)=>boolean): HashSet<T>;\n    filter(predicate:(v:T)=>boolean): HashSet<T> {\n        return new HashSet<T>(\n            hamt.make({hash:this.hamt._config.hash, keyEq:this.hamt._config.keyEq}).mutate((h:any) => {\n                const iterator: Iterator<T> = this.hamt.values();\n                let curItem = iterator.next();\n                while (!curItem.done) {\n                    if (predicate(curItem.value)) {\n                        h.set(curItem.value, curItem.value);\n                    }\n                    curItem = iterator.next();\n                }\n            }));\n    }\n\n    /**\n     * Search for an item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     * We name the method findAny instead of find to emphasize\n     * that there is not ordering in a hashset.\n     *\n     *     HashSet.of(1,2,3).findAny(x => x>=3)\n     *     => Option.of(3)\n     *\n     *     HashSet.of(1,2,3).findAny(x => x>=4)\n     *     => Option.none<number>()\n     */\n    findAny(predicate:(v:T)=>boolean): Option<T> {\n        const iterator: Iterator<T> = this.hamt.values();\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            if (predicate(curItem.value)) {\n                return Option.of(curItem.value);\n            }\n            curItem = iterator.next();\n        }\n        return Option.none<T>();\n    }\n\n    /**\n     * Reduces the collection to a single value using the\n     * associative binary function you give. Since the function\n     * is associative, order of application doesn't matter.\n     *\n     * Example:\n     *\n     *     HashSet.of(1,2,3).fold(0, (a,b) => a + b);\n     *     => 6\n     */\n    fold(zero:T, fn:(v1:T,v2:T)=>T): T {\n        return this.foldLeft(zero, fn);\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Left-associative.\n     * No guarantees for the order of items in a hashset!\n     *\n     * Example:\n     *\n     *     HashSet.of(\"a\", \"bb\", \"ccc\").foldLeft(0, (soFar,item) => soFar+item.length);\n     *     => 6\n     *\n     * @param zero The initial value\n     * @param fn A function taking the previous value and\n     *           the current collection item, and returning\n     *           an updated value.\n     */\n    foldLeft<U>(zero: U, fn:(soFar:U,cur:T)=>U): U {\n        return this.hamt.fold(\n            (acc: U, v: T&WithEquality, k: T&WithEquality) =>\n                fn(acc, v), zero);\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Right-associative.\n     * No guarantees for the order of items in a hashset!\n     *\n     * Example:\n     *\n     *     HashSet.of(\"a\", \"bb\", \"ccc\").foldRight(0, (item,soFar) => soFar+item.length);\n     *     => 6\n     *\n     * @param zero The initial value\n     * @param fn A function taking the current collection item and\n     *           the previous value , and returning\n     *           an updated value.\n     */\n    foldRight<U>(zero: U, fn:(cur:T, soFar:U)=>U): U {\n        return this.foldLeft(zero, (cur, soFar) => fn(soFar, cur));\n    }\n\n    /**\n     * Converts this set to an array. Since a Set is not ordered\n     * and since this method returns a JS array, it can be awkward\n     * to get an array sorted in the way you'd like. So you can pass\n     * an optional sorting function too.\n     *\n     *     HashSet.of(1,2,3).toArray().sort()\n     *     => [1,2,3]\n     *\n     *     HashSet.of(1,2,3).toArray({sortOn:x=>x})\n     *     => [1,2,3]\n     *\n     *     HashSet.of(1,2,3).toArray({sortBy:(x,y)=>x-y})\n     *     => [1,2,3]\n     *\n     * You can also pass an array in sortOn, listing lambdas to\n     * several fields to sort by those fields, and also {desc:lambda}\n     * to sort by some fields descending.\n     */\n    toArray(sort?: SortOnSpec<T> | SortBySpec<T>): Array<T & WithEquality> {\n        if (!sort) {\n            return Array.from<T&WithEquality>(this.hamt.keys());\n        }\n        if (isSortOnSpec(sort)) {\n            const sortOn = sort.sortOn instanceof Array ? sort.sortOn : [sort.sortOn];\n            return Vector.ofIterable<T&WithEquality>(this.hamt.keys())\n                .sortOn(...sortOn)\n                .toArray();\n        }\n        return Array.from<T&WithEquality>(this.hamt.keys()).sort(sort.sortBy);\n    }\n\n    /**\n     * Converts this set to an vector\n     */\n    toVector(): Vector<T & WithEquality> {\n        return Vector.ofIterable<T&WithEquality>(this.hamt.keys());\n    }\n\n    /**\n     * Converts this set to an list\n     */\n    toLinkedList(): LinkedList<T & WithEquality> {\n        return LinkedList.ofIterable<T&WithEquality>(this.hamt.keys());\n    }\n\n    /**\n     * Returns the number of elements in the set.\n     */\n    length(): number {\n        return this.hamt.size;\n    }\n\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    single(): Option<T> {\n        return this.hamt.size === 1\n            ? Option.of(this.hamt.keys().next().value)\n            : Option.none();\n    }\n\n    /**\n     * true if the set is empty, false otherwise.\n     */\n    isEmpty(): boolean {\n        return this.hamt.size === 0;\n    }\n\n    /**\n     * Returns a new Set containing the difference\n     * between this set and the other Set passed as parameter.\n     * also see [[HashSet.intersect]]\n     */\n    diff(elts: ISet<T&WithEquality>): HashSet<T> {\n        return new HashSet<T>(this.hamt.fold(\n            (acc: any, v: T&WithEquality, k: T&WithEquality) =>\n                elts.contains(k) ? acc : acc.set(k,k), hamt.empty));\n    }\n\n    /**\n     * Returns a new Set containing the intersection\n     * of this set and the other Set passed as parameter\n     * (the elements which are common to both sets)\n     * also see [[HashSet.diff]]\n     */\n    intersect(other: ISet<T&WithEquality>): HashSet<T> {\n        return new HashSet<T>(this.hamt.fold(\n            (acc: any, v: T&WithEquality, k: T&WithEquality) =>\n                other.contains(k) ? acc.set(k,k) : acc, hamt.empty));\n    }\n\n    isSubsetOf(other: ISet<T&WithEquality>): boolean {\n        return this.allMatch((x:T) => other.contains(<T&WithEquality>x));\n    }\n\n    /**\n     * Returns a new set with the element you give removed\n     * if it was present in the set.\n     */\n    remove(elt: T&WithEquality): HashSet<T> {\n        return new HashSet<T>(this.hamt.remove(elt));\n    }\n\n    /**\n     * Returns a new set with all the elements of the current\n     * Set, minus the elements of the iterable you give as a parameter.\n     * If you call this function with a HashSet as parameter,\n     * rather call 'diff', as it'll be faster.\n     */\n    removeAll(elts: Iterable<T&WithEquality>): HashSet<T> {\n        return this.diff(HashSet.ofIterable<T&WithEquality>(elts));\n    }\n\n    /**\n     * Returns true if the predicate returns true for all the\n     * elements in the collection.\n     */\n    allMatch<U extends T>(predicate:(v:T)=>v is U): this is HashSet<U>;\n    allMatch(predicate:(v:T)=>boolean): boolean;\n    allMatch(predicate:(v:T)=>boolean): boolean {\n        const iterator: Iterator<T> = this.hamt.values();\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            if (!predicate(curItem.value)) {\n                return false;\n            }\n            curItem = iterator.next();\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    anyMatch(predicate:(v:T)=>boolean): boolean {\n        const iterator: Iterator<T> = this.hamt.values();\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            if (predicate(curItem.value)) {\n                return true;\n            }\n            curItem = iterator.next();\n        }\n        return false;\n    }\n\n    /**\n     * Group elements in the collection using a classifier function.\n     * Elements are then organized in a map. The key is the value of\n     * the classifier, and in value we get the list of elements\n     * matching that value.\n     *\n     * also see [[HashSet.arrangeBy]]\n     */\n    groupBy<C>(classifier: (v:T)=>C&WithEquality): HashMap<C,HashSet<T>> {\n        // make a singleton set with the same equality as this\n        const singletonHamtSet = (v:T) => hamt.make({\n            hash:this.hamt._config.hash, keyEq:this.hamt._config.keyEq\n        }).set(v,v);\n        // merge two mutable hamt sets, but I know the second has only 1 elt\n        const mergeSets = (v1:any,v2:any)=> {\n            const k = v2.keys().next().value;\n            v1.set(k,k);\n            return v1;\n        };\n        return this.hamt.fold(\n            // fold operation: combine a new value from the set with the accumulator\n            (acc: HashMap<C,any>, v:T&WithEquality, k:T&WithEquality) =>\n                acc.putWithMerge(\n                    classifier(v), singletonHamtSet(v).beginMutation(),\n                    mergeSets),\n            // fold accumulator: the empty hashmap\n            HashMap.empty())\n            .mapValues((h:any) => new HashSet<T>(h.endMutation()));\n    }\n\n    /**\n     * Matches each element with a unique key that you extract from it.\n     * If the same key is present twice, the function will return None.\n     *\n     * also see [[HashSet.groupBy]]\n     */\n    arrangeBy<K>(getKey: (v:T)=>K&WithEquality): Option<HashMap<K,T>> {\n        return SeqHelpers.arrangeBy<T,K>(this, getKey);\n    }\n\n    /**\n     * Returns a pair of two sets; the first one\n     * will only contain the items from this sets for\n     * which the predicate you give returns true, the second\n     * will only contain the items from this collection where\n     * the predicate returns false.\n     *\n     *     HashSet.of(1,2,3,4).partition(x => x%2===0)\n     *     => [HashSet.of(2,4), HashSet.of(1,3)]\n     */\n    partition<U extends T>(predicate:(v:T)=>v is U): [HashSet<U>,HashSet<Exclude<T,U>>];\n    partition(predicate:(x:T)=>boolean): [HashSet<T>,HashSet<T>];\n    partition(predicate:(v:T)=>boolean): [HashSet<T>,HashSet<T>] {\n        let r1 = hamt.make({\n            hash:this.hamt._config.hash, keyEq:this.hamt._config.keyEq\n        }).beginMutation();\n        let r2 = hamt.make({\n            hash:this.hamt._config.hash, keyEq:this.hamt._config.keyEq\n        }).beginMutation();\n        const iterator: Iterator<T&WithEquality> = this.hamt.values();\n        let curItem = iterator.next();\n        while (!curItem.done) {\n            if (predicate(curItem.value)) {\n                r1.set(curItem.value, curItem.value);\n            } else {\n                r2.set(curItem.value, curItem.value);\n            }\n            curItem = iterator.next();\n        }\n        return [new HashSet<T>(r1), new HashSet<T>(r2)];\n    }\n\n    /**\n     * Reduces the collection to a single value by repeatedly\n     * calling the combine function.\n     * No starting value. The order in which the elements are\n     * passed to the combining function is undetermined.\n     */\n    reduce(combine: (v1:T,v2:T)=>T): Option<T> {\n        return SeqHelpers.reduce(this, combine);\n    }\n\n    /**\n     * Compare values in the collection and return the smallest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[HashSet.minOn]]\n     */\n    minBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return SeqHelpers.minBy(this, compare);\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the smallest.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[HashSet.minBy]]\n     */\n    minOn(getOrderable: ToOrderable<T>): Option<T> {\n        return SeqHelpers.minOn(this, getOrderable);\n    }\n\n    /**\n     * Compare values in the collection and return the largest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[HashSet.maxOn]]\n     */\n    maxBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return SeqHelpers.maxBy(this, compare);\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the largest.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[HashSet.maxBy]]\n     */\n    maxOn(getOrderable: ToOrderable<T>): Option<T> {\n        return SeqHelpers.maxOn(this, getOrderable);\n    }\n\n    /**\n     * Call the function you give for each element in the collection\n     * and sum all the numbers, return that sum.\n     * Will return 0 if the collection is empty.\n     *\n     *     HashSet.of(1,2,3).sumOn(x=>x)\n     *     => 6\n     */\n    sumOn(getNumber: (v:T)=>number): number {\n        return SeqHelpers.sumOn(this, getNumber);\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:HashSet<T>)=>U): U {\n        return converter(this);\n    }\n\n    /**\n     * Convert to an ES6 Set.\n     * You must provide a function to convert the\n     * key to a string, number or boolean, because\n     * with other types equality is not correctly\n     * managed by JS.\n     * https://stackoverflow.com/questions/29759480/how-to-customize-object-equality-for-javascript-set\n     * https://esdiscuss.org/topic/maps-with-object-keys\n     *\n     *     HashSet.of(\"a\", \"b\").toJsSet(x=>x);\n     *     => new Set([\"a\", \"b\"])\n     */\n    toJsSet(keyConvert:(k:T)=>string): Set<string>;\n    toJsSet(keyConvert:(k:T)=>number): Set<number>;\n    toJsSet(keyConvert:(k:T)=>boolean): Set<boolean>;\n    toJsSet<K extends string|number|boolean>(keyConvert:(k:T)=>K): Set<K> {\n        return this.foldLeft(new Set<K>(), (sofar,cur) => sofar.add(keyConvert(cur)));\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other: HashSet<T>): boolean {\n        if (<any>other === this) {\n            return true;\n        }\n        const sz = this.hamt.size;\n        if (other === <EmptyHashSet<T>>emptyHashSet && sz === 0) {\n            // we could get that i'm not the empty map\n            // but my size is zero, after some filtering and such.\n            return true;\n        }\n        if (!other || !other.hamt) {\n            return false;\n        }\n        if (sz !== other.hamt.size) {\n            return false;\n        }\n        contractTrueEquality(\"HashSet.equals\", this, other);\n        const keys: Array<T & WithEquality> = Array.from<T & WithEquality>(this.hamt.keys());\n        for (let k of keys) {\n            const hisVal: T & WithEquality|null|undefined = other.hamt.get(k);\n            if (hisVal === undefined) {\n                return false;\n            }\n            if (!areEqual(k, hisVal)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        return this.hamt.fold(\n            (acc: number, value: T & WithEquality, key: T & WithEquality) =>\n                acc + getHashCode(key), 0);\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     *\n     * Also see [[HashSet.mkString]]\n     */\n    toString(): string {\n        return \"HashSet(\" +\n            this.hamt.fold(\n                (acc: string[], value: T, key: T) =>\n                    {acc.push(SeqHelpers.toStringHelper(key)); return acc;}, []).join(\", \")\n            + \")\";\n    }\n\n    [inspect](): string {\n        return this.toString();\n    }\n\n    /**\n     * Joins elements of the collection by a separator.\n     * Example:\n     *\n     *     HashSet.of(1,2,3).mkString(\", \")\n     *     => \"1, 2, 3\"\n     *\n     * (of course, order is not guaranteed)\n     */\n    mkString(separator: string): string {\n        return this.hamt.fold(\n            (acc: string[], value: T, key: T) =>\n                {acc.push(SeqHelpers.toStringHelper(key, {quoteStrings: false})); return acc;}, []).join(separator);\n    }\n}\n\n// we need to override the empty hashmap\n// because i don't know how to get the hash & keyset\n// functions for the keys without a key value to get\n// the functions from\nclass EmptyHashSet<T> extends HashSet<T> {\n\n    constructor() {\n        super({}); // we must override all the functions\n    }\n\n    add(elt: T & WithEquality): HashSet<T> {\n        contractTrueEquality(\"Error building a HashSet\", elt);\n        if (!elt) {\n            // special case if we get null for the first element...\n            // less optimized variant because we don't know\n            // if we should use '===' or 'equals'\n            return new HashSet<T>(hamt.make({\n                hash: (v: T & HasEquals) => getHashCode(v),\n                keyEq: (a: T & HasEquals, b: T & HasEquals) => areEqual(a, b)\n            }).set(elt,elt));\n        }\n        // if the element is not null, save a if later by finding\n        // out right now whether we should call equals or ===\n        if (hasEquals(elt)) {\n            return new HashSet<T>(hamt.make({\n                hash: (v: T & HasEquals) => v.hashCode(),\n                keyEq: (a: T & HasEquals, b: T & HasEquals) => a.equals(b)\n            }).set(elt,elt));\n        }\n        return new HashSet<T>(hamt.make().set(elt,elt));\n    }\n\n    addAll(elts: Iterable<T & WithEquality>): HashSet<T> {\n        const it = elts[Symbol.iterator]();\n        let curItem = it.next();\n        if (curItem.done) {\n            return <EmptyHashSet<T>>emptyHashSet;\n        }\n        return this.add(curItem.value).addAll({[Symbol.iterator]: () => it});\n    }\n\n    contains(elt: T & WithEquality): boolean {\n        return false;\n    }\n\n    map<U>(mapper:(v:T)=>U&WithEquality): HashSet<U> {\n        return <EmptyHashSet<U>>emptyHashSet;\n    }\n\n    mapOption<U>(mapper:(v:T)=>Option<U&WithEquality>): HashSet<U> {\n        return <EmptyHashSet<U>>emptyHashSet;\n    }\n\n    forEach(fun:(x:T)=>void): HashSet<T> {\n        return this;\n    }\n\n    filter<U extends T>(fn:(v:T)=>v is U): HashSet<U>;\n    filter(predicate:(v:T)=>boolean): HashSet<T>;\n    filter(predicate:(v:T)=>boolean): HashSet<T> {\n        return this;\n    }\n\n    findAny(predicate:(v:T)=>boolean): Option<T> {\n        return Option.none();\n    }\n\n    foldLeft<U>(zero: U, fn:(soFar:U,cur:T)=>U): U {\n        return zero;\n    }\n\n    toArray(sort?: SortOnSpec<T> | SortBySpec<T>): Array<T & WithEquality> {\n        return [];\n    }\n\n    toVector(): Vector<T & WithEquality> {\n        return Vector.empty<T&WithEquality>();\n    }\n\n    toLinkedList(): LinkedList<T & WithEquality> {\n        return LinkedList.empty<T&WithEquality>();\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return { next: () => ({ done: true, value: <any>undefined }) };\n    }\n\n    length(): number {\n        return 0;\n    }\n\n    isEmpty(): boolean {\n        return true;\n    }\n\n    diff(elts: ISet<T&WithEquality>): HashSet<T> {\n        return this;\n    }\n\n    intersect(other: ISet<T&WithEquality>): HashSet<T> {\n        return this;\n    }\n\n    anyMatch(predicate:(v:T)=>boolean): boolean {\n        return false;\n    }\n\n    groupBy<C>(classifier: (v:T)=>C&WithEquality): HashMap<C,HashSet<T>> {\n        return HashMap.empty();\n    }\n\n    allMatch<U extends T>(predicate:(v:T)=>v is U): this is HashSet<U>;\n    allMatch(predicate:(v:T)=>boolean): boolean;\n    allMatch(predicate:(v:T)=>boolean): boolean {\n        return true;\n    }\n\n    partition<U extends T>(predicate:(v:T)=>v is U): [HashSet<U>,HashSet<Exclude<T,U>>];\n    partition(predicate:(x:T)=>boolean): [HashSet<T>,HashSet<T>];\n    partition<U extends T>(predicate:(v:T)=>boolean): [HashSet<U>,HashSet<any>] {\n        return [<any>this, <any>this];\n    }\n\n    remove(elt: T&WithEquality): HashSet<T> {\n        return this;\n    }\n\n    equals(other: HashSet<T>): boolean {\n        if (!other || !other.length) {\n            return false;\n        }\n        return <any>other === emptyHashSet || other.length() === 0;\n    }\n\n    hashCode(): number {\n        return 0;\n    }\n\n    toString(): string {\n        return \"HashSet()\";\n    }\n\n    mkString(separator: string): string {\n        return \"\";\n    }\n}\n\nconst emptyHashSet = new EmptyHashSet<any>();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}