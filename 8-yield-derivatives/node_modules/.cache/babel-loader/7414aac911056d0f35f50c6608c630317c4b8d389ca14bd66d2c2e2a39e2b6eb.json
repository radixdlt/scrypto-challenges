{"ast":null,"code":"/**\n * Responsible for sequentially executing actions on the database\n */\n\nvar async = require('async');\nfunction Executor() {\n  this.buffer = [];\n  this.ready = false;\n\n  // This queue will execute all commands, one-by-one in order\n  this.queue = async.queue(function (task, cb) {\n    var newArguments = [];\n\n    // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array\n    for (var i = 0; i < task.arguments.length; i += 1) {\n      newArguments.push(task.arguments[i]);\n    }\n    var lastArg = task.arguments[task.arguments.length - 1];\n\n    // Always tell the queue task is complete. Execute callback if any was given.\n    if (typeof lastArg === 'function') {\n      // Callback was supplied\n      newArguments[newArguments.length - 1] = function () {\n        if (typeof setImmediate === 'function') {\n          setImmediate(cb);\n        } else {\n          process.nextTick(cb);\n        }\n        lastArg.apply(null, arguments);\n      };\n    } else if (!lastArg && task.arguments.length !== 0) {\n      // false/undefined/null supplied as callbback\n      newArguments[newArguments.length - 1] = function () {\n        cb();\n      };\n    } else {\n      // Nothing supplied as callback\n      newArguments.push(function () {\n        cb();\n      });\n    }\n    task.fn.apply(task.this, newArguments);\n  }, 1);\n}\n\n/**\n * If executor is ready, queue task (and process it immediately if executor was idle)\n * If not, buffer task for later processing\n * @param {Object} task\n *                 task.this - Object to use as this\n *                 task.fn - Function to execute\n *                 task.arguments - Array of arguments, IMPORTANT: only the last argument may be a function (the callback)\n *                                                                 and the last argument cannot be false/undefined/null\n * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready\n */\nExecutor.prototype.push = function (task, forceQueuing) {\n  if (this.ready || forceQueuing) {\n    this.queue.push(task);\n  } else {\n    this.buffer.push(task);\n  }\n};\n\n/**\n * Queue all tasks in buffer (in the same order they came in)\n * Automatically sets executor as ready\n */\nExecutor.prototype.processBuffer = function () {\n  var i;\n  this.ready = true;\n  for (i = 0; i < this.buffer.length; i += 1) {\n    this.queue.push(this.buffer[i]);\n  }\n  this.buffer = [];\n};\n\n// Interface\nmodule.exports = Executor;","map":{"version":3,"names":["async","require","Executor","buffer","ready","queue","task","cb","newArguments","i","arguments","length","push","lastArg","setImmediate","process","nextTick","apply","fn","this","prototype","forceQueuing","processBuffer","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/nedb/lib/executor.js"],"sourcesContent":["/**\n * Responsible for sequentially executing actions on the database\n */\n\nvar async = require('async')\n  ;\n\nfunction Executor () {\n  this.buffer = [];\n  this.ready = false;\n\n  // This queue will execute all commands, one-by-one in order\n  this.queue = async.queue(function (task, cb) {\n    var newArguments = [];\n\n    // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array\n    for (var i = 0; i < task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }\n    var lastArg = task.arguments[task.arguments.length - 1];\n\n    // Always tell the queue task is complete. Execute callback if any was given.\n    if (typeof lastArg === 'function') {\n      // Callback was supplied\n      newArguments[newArguments.length - 1] = function () {\n        if (typeof setImmediate === 'function') {\n           setImmediate(cb);\n        } else {\n          process.nextTick(cb);\n        }\n        lastArg.apply(null, arguments);\n      };\n    } else if (!lastArg && task.arguments.length !== 0) {\n      // false/undefined/null supplied as callbback\n      newArguments[newArguments.length - 1] = function () { cb(); };\n    } else {\n      // Nothing supplied as callback\n      newArguments.push(function () { cb(); });\n    }\n\n\n    task.fn.apply(task.this, newArguments);\n  }, 1);\n}\n\n\n/**\n * If executor is ready, queue task (and process it immediately if executor was idle)\n * If not, buffer task for later processing\n * @param {Object} task\n *                 task.this - Object to use as this\n *                 task.fn - Function to execute\n *                 task.arguments - Array of arguments, IMPORTANT: only the last argument may be a function (the callback)\n *                                                                 and the last argument cannot be false/undefined/null\n * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready\n */\nExecutor.prototype.push = function (task, forceQueuing) {\n  if (this.ready || forceQueuing) {\n    this.queue.push(task);\n  } else {\n    this.buffer.push(task);\n  }\n};\n\n\n/**\n * Queue all tasks in buffer (in the same order they came in)\n * Automatically sets executor as ready\n */\nExecutor.prototype.processBuffer = function () {\n  var i;\n  this.ready = true;\n  for (i = 0; i < this.buffer.length; i += 1) { this.queue.push(this.buffer[i]); }\n  this.buffer = [];\n};\n\n\n\n// Interface\nmodule.exports = Executor;\n"],"mappings":"AAAA;AACA;AACA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAG5B,SAASC,QAAQA,CAAA,EAAI;EACnB,IAAI,CAACC,MAAM,GAAG,EAAE;EAChB,IAAI,CAACC,KAAK,GAAG,KAAK;;EAElB;EACA,IAAI,CAACC,KAAK,GAAGL,KAAK,CAACK,KAAK,CAAC,UAAUC,IAAI,EAAEC,EAAE,EAAE;IAC3C,IAAIC,YAAY,GAAG,EAAE;;IAErB;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACI,SAAS,CAACC,MAAM,EAAEF,CAAC,IAAI,CAAC,EAAE;MAAED,YAAY,CAACI,IAAI,CAACN,IAAI,CAACI,SAAS,CAACD,CAAC,CAAC,CAAC;IAAE;IAC3F,IAAII,OAAO,GAAGP,IAAI,CAACI,SAAS,CAACJ,IAAI,CAACI,SAAS,CAACC,MAAM,GAAG,CAAC,CAAC;;IAEvD;IACA,IAAI,OAAOE,OAAO,KAAK,UAAU,EAAE;MACjC;MACAL,YAAY,CAACA,YAAY,CAACG,MAAM,GAAG,CAAC,CAAC,GAAG,YAAY;QAClD,IAAI,OAAOG,YAAY,KAAK,UAAU,EAAE;UACrCA,YAAY,CAACP,EAAE,CAAC;QACnB,CAAC,MAAM;UACLQ,OAAO,CAACC,QAAQ,CAACT,EAAE,CAAC;QACtB;QACAM,OAAO,CAACI,KAAK,CAAC,IAAI,EAAEP,SAAS,CAAC;MAChC,CAAC;IACH,CAAC,MAAM,IAAI,CAACG,OAAO,IAAIP,IAAI,CAACI,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MAClD;MACAH,YAAY,CAACA,YAAY,CAACG,MAAM,GAAG,CAAC,CAAC,GAAG,YAAY;QAAEJ,EAAE,CAAC,CAAC;MAAE,CAAC;IAC/D,CAAC,MAAM;MACL;MACAC,YAAY,CAACI,IAAI,CAAC,YAAY;QAAEL,EAAE,CAAC,CAAC;MAAE,CAAC,CAAC;IAC1C;IAGAD,IAAI,CAACY,EAAE,CAACD,KAAK,CAACX,IAAI,CAACa,IAAI,EAAEX,YAAY,CAAC;EACxC,CAAC,EAAE,CAAC,CAAC;AACP;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAN,QAAQ,CAACkB,SAAS,CAACR,IAAI,GAAG,UAAUN,IAAI,EAAEe,YAAY,EAAE;EACtD,IAAI,IAAI,CAACjB,KAAK,IAAIiB,YAAY,EAAE;IAC9B,IAAI,CAAChB,KAAK,CAACO,IAAI,CAACN,IAAI,CAAC;EACvB,CAAC,MAAM;IACL,IAAI,CAACH,MAAM,CAACS,IAAI,CAACN,IAAI,CAAC;EACxB;AACF,CAAC;;AAGD;AACA;AACA;AACA;AACAJ,QAAQ,CAACkB,SAAS,CAACE,aAAa,GAAG,YAAY;EAC7C,IAAIb,CAAC;EACL,IAAI,CAACL,KAAK,GAAG,IAAI;EACjB,KAAKK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACN,MAAM,CAACQ,MAAM,EAAEF,CAAC,IAAI,CAAC,EAAE;IAAE,IAAI,CAACJ,KAAK,CAACO,IAAI,CAAC,IAAI,CAACT,MAAM,CAACM,CAAC,CAAC,CAAC;EAAE;EAC/E,IAAI,CAACN,MAAM,GAAG,EAAE;AAClB,CAAC;;AAID;AACAoB,MAAM,CAACC,OAAO,GAAGtB,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}