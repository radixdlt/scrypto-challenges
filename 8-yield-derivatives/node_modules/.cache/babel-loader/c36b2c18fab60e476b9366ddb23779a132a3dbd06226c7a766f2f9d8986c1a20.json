{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nexport function delay(delay, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n  var absoluteDelay = isDate(delay);\n  var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);\n  return function (source) {\n    return source.lift(new DelayOperator(delayFor, scheduler));\n  };\n}\nvar DelayOperator = /*@__PURE__*/function () {\n  function DelayOperator(delay, scheduler) {\n    this.delay = delay;\n    this.scheduler = scheduler;\n  }\n  DelayOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n  };\n  return DelayOperator;\n}();\nvar DelaySubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(DelaySubscriber, _super);\n  function DelaySubscriber(destination, delay, scheduler) {\n    var _this = _super.call(this, destination) || this;\n    _this.delay = delay;\n    _this.scheduler = scheduler;\n    _this.queue = [];\n    _this.active = false;\n    _this.errored = false;\n    return _this;\n  }\n  DelaySubscriber.dispatch = function (state) {\n    var source = state.source;\n    var queue = source.queue;\n    var scheduler = state.scheduler;\n    var destination = state.destination;\n    while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n    if (queue.length > 0) {\n      var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay_1);\n    } else {\n      this.unsubscribe();\n      source.active = false;\n    }\n  };\n  DelaySubscriber.prototype._schedule = function (scheduler) {\n    this.active = true;\n    var destination = this.destination;\n    destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n      source: this,\n      destination: this.destination,\n      scheduler: scheduler\n    }));\n  };\n  DelaySubscriber.prototype.scheduleNotification = function (notification) {\n    if (this.errored === true) {\n      return;\n    }\n    var scheduler = this.scheduler;\n    var message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  };\n  DelaySubscriber.prototype._next = function (value) {\n    this.scheduleNotification(Notification.createNext(value));\n  };\n  DelaySubscriber.prototype._error = function (err) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n    this.unsubscribe();\n  };\n  DelaySubscriber.prototype._complete = function () {\n    this.scheduleNotification(Notification.createComplete());\n    this.unsubscribe();\n  };\n  return DelaySubscriber;\n}(Subscriber);\nvar DelayMessage = /*@__PURE__*/function () {\n  function DelayMessage(time, notification) {\n    this.time = time;\n    this.notification = notification;\n  }\n  return DelayMessage;\n}();","map":{"version":3,"names":["tslib_1","async","isDate","Subscriber","Notification","delay","scheduler","absoluteDelay","delayFor","now","Math","abs","source","lift","DelayOperator","prototype","call","subscriber","subscribe","DelaySubscriber","_super","__extends","destination","_this","active","errored","dispatch","state","queue","length","time","shift","notification","observe","delay_1","max","schedule","unsubscribe","_schedule","add","scheduleNotification","message","DelayMessage","push","_next","value","createNext","_error","err","error","_complete","createComplete"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/radixdlt/node_modules/rxjs/src/internal/operators/delay.ts"],"sourcesContent":["import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Notification } from '../Notification';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * ![](delay.png)\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * ## Examples\n * Delay each click by one second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { delay } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * Delay all clicks until a future date happens\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { delay } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nexport function delay<T>(delay: number|Date,\n                         scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  const absoluteDelay = isDate(delay);\n  const delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(<number>delay);\n  return (source: Observable<T>) => source.lift(new DelayOperator(delayFor, scheduler));\n}\n\nclass DelayOperator<T> implements Operator<T, T> {\n  constructor(private delay: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n  }\n}\n\ninterface DelayState<T> {\n  source: DelaySubscriber<T>;\n  destination: PartialObserver<T>;\n  scheduler: SchedulerLike;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DelaySubscriber<T> extends Subscriber<T> {\n  private queue: Array<DelayMessage<T>> = [];\n  private active: boolean = false;\n  private errored: boolean = false;\n\n  private static dispatch<T>(this: SchedulerAction<DelayState<T>>, state: DelayState<T>): void {\n    const source = state.source;\n    const queue = source.queue;\n    const scheduler = state.scheduler;\n    const destination = state.destination;\n\n    while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n\n    if (queue.length > 0) {\n      const delay = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay);\n    } else {\n      this.unsubscribe();\n      source.active = false;\n    }\n  }\n\n  constructor(destination: Subscriber<T>,\n              private delay: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n  }\n\n  private _schedule(scheduler: SchedulerLike): void {\n    this.active = true;\n    const destination = this.destination as Subscription;\n    destination.add(scheduler.schedule<DelayState<T>>(DelaySubscriber.dispatch, this.delay, {\n      source: this, destination: this.destination, scheduler: scheduler\n    }));\n  }\n\n  private scheduleNotification(notification: Notification<T>): void {\n    if (this.errored === true) {\n      return;\n    }\n\n    const scheduler = this.scheduler;\n    const message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  }\n\n  protected _next(value: T) {\n    this.scheduleNotification(Notification.createNext(value));\n  }\n\n  protected _error(err: any) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete() {\n    this.scheduleNotification(Notification.createComplete());\n    this.unsubscribe();\n  }\n}\n\nclass DelayMessage<T> {\n  constructor(public readonly time: number,\n              public readonly notification: Notification<T>) {\n  }\n}\n"],"mappings":";AAAA,OAAO,KAAEA,OAAO,MAAM;AACtB,SAASC,KAAA,QAAQ,oBAAuB;AAExC,SAASC,MAAA,QAAY,gBAAM;AAE3B,SAASC,UAAA,QAAc,eAAM;AAsD7B,SAAMC,YAAe,QACI,iBAAgC;OAAhC,SAAAC,WAAA,EAAAC,SAAA;EACvB,IAAMA,SAAA,KAAa,KAAG,GAAM;IACtBA,SAAQ,GAAGL,KAAA;EACjB;EACD,IAAAM,aAAA,GAAAL,MAAA,CAAAG,KAAA;EAED,IAAAG,QAAA,GAAAD,aAAA,IAAAF,KAAA,GAAAC,SAAA,CAAAG,GAAA,KAAAC,IAAA,CAAAC,GAAA,CAAAN,KAAA;EACE,iBAAAO,MAAoB;IAAA,OACAA,MAAwB,CAAAC,IAAA,KAAAC,aAAA,CAAAN,QAAA,EAAAF,SAAA;EAAA;;iBAAxB,gBAAwB;EAC5C,SAACQ,cAAAT,KAAA,EAAAC,SAAA;IAED,KAAAD,KAAA,GAAAA,KAAA;IACE,KAAAC,SAAc,GAAAA,SAAU;EAC1B;EACFQ,aAAA,CAAAC,SAAC,CAAAC,IAAA,aAAAC,UAAA,EAAAL,MAAA;IAAA,OAAAA,MAAA,CAAAM,SAAA,KAAAC,eAAA,CAAAF,UAAA,OAAAZ,KAAA,OAAAC,SAAA;EAaD;EAAiC,OAAAQ,aAAA;GAwB/B;mBAAA,GAGE,uBAAMM,MAAY;SAFA,CAAAC,SAAK,CAALF,eAAa,EAAAC,MAAA;WACbD,gBAAAG,WAAwB,EAAAjB,KAAA,EAAAC,SAAA;IAzBpC,IAAAiB,KAAA,GAAKH,MAA8B,CAAAJ,IAAA,OAAAM,WAAA;IACnCC,KAAA,CAAAlB,KAAA,GAAMA,KAAY;IAClBkB,KAAA,CAAAjB,SAAO,GAAYA,SAAM;;IAyBhCiB,KAAA,CAAAC,MAAA;IAvBcD,KAAA,CAAAE,OAAA,QAAQ;IACrB,OAAMF,KAAM;;iBAEN,CAAAG,QAAY,GAAM,UAAUC,KAAA;IAClC,IAAMf,MAAA,GAAAe,KAAc,CAAAf,MAAM;IAE1B,IAAAgB,KAAO,GAAKhB,MAAC,CAAMgB,KAAI;QACrBtB,SAAM,GAAKqB,KAAG,CAAArB,SAAa;QAC5BgB,WAAA,GAAAK,KAAA,CAAAL,WAAA;IAED,OAAIM,KAAM,CAAAC,MAAS,GAAG,KAAAD,KAAA,IAAAE,IAAA,GAAAxB,SAAA,CAAAG,GAAA;MACpBmB,KAAM,CAAAG,KAAK,GAAGC,YAAY,CAAAC,OAAQ,CAACX,WAAO;;QAE3CM,KAAA,CAAAC,MAAA;UAAMK,OAAA,GAAAxB,IAAA,CAAAyB,GAAA,IAAAP,KAAA,IAAAE,IAAA,GAAAxB,SAAA,CAAAG,GAAA;MACL,IAAI,CAAC2B,QAAA,CAAAT,KAAc,EAAAO,OAAA;WAEpB;MACF,KAAAG,WAAA;MAQOzB,MAAA,CAAAY,MAAA;IACN;;iBAEW,CAACT,SAAI,CAAAuB,SAAU,GAAQ,UAAgBhC,SAAgB;QAChE,CAAAkB,MAAM,GAAE,IAAM;QACZF,WAAA,QAAAA,WAAA;IACLA,WAAA,CAAAiB,GAAA,CAAAjC,SAAA,CAAA8B,QAAA,CAAAjB,eAAA,CAAAO,QAAA,OAAArB,KAAA;MAEOO,MAAA;MAAAU,WAAA,OAAAA,WAAR;MAAAhB,SAA6B,EAAAA;IAC3B;;iBAEC,CAAAS,SAAA,CAAAyB,oBAAA,aAAAR,YAAA;IAED,IAAM,KAAAP,OAAY,KAAK;MACjB;IACN;IAEA,IAAInB,SAAK,GAAM,IAAK,CAAAA,SAAO;QACzBmC,OAAK,OAASC,YAAY,CAAApC,SAAA,CAAAG,GAAA,UAAAJ,KAAA,EAAA2B,YAAA;QAC3B,CAAAJ,KAAA,CAAAe,IAAA,CAAAF,OAAA;IACF,SAAAjB,MAAA;MAES,KAAAc,SAAA,CAAAhC,SAAK;IACb;EACF,CAAC;EAESa,eAAA,CAAAJ,SAAA,CAAA6B,KAAA,GAAM,UAAhBC,KAAyB;IACvB,IAAI,CAACL,oBAAe,CAAApC,YAAA,CAAA0C,UAAA,CAAAD,KAAA;;iBAEf,CAAA9B,SAAY,CAAKgC,MAAM,aAAAC,GAAA;IAC5B,IAAI,CAACvB,OAAA,OAAc;IACpB,KAAAG,KAAA;IAES,KAAAN,WAAA,CAAA2B,KAAA,CAAAD,GAAA;IACR,IAAI,CAACX,WAAA;;EAEPlB,eAAC,CAAAJ,SAAA,CAAAmC,SAAA;IACH,KAAAV,oBAAC,CAAApC,YAAA,CAAA+C,cAAA;IAnEgC,IAAU,CAAAd,WAmE1C;EAED;EACE,OAAAlB,eAA4B;YAAA;gBACA,4BAA6B;EACzD,SAACuB,aAAAZ,IAAA,EAAAE,YAAA;IACH,KAAAF,IAAA,GAAAA,IAAC;IAAA,KAAAE,YAAA,GAAAA,YAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}