{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.byteToBuffer = exports.firstByteFromBuffer = exports.firstByteOfNumber = exports.fitsInUInt8 = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\nconst fitsInUInt8 = number => {\n  const isNotTooBig = number <= 255;\n  const isNonNegative = number >= 0;\n  return isNotTooBig && isNonNegative;\n};\nexports.fitsInUInt8 = fitsInUInt8;\nconst firstByteOfNumber = n => exports.firstByteFromBuffer(Buffer.from([n]));\nexports.firstByteOfNumber = firstByteOfNumber;\nconst firstByteFromBuffer = buffer => {\n  const firstByte = Uint8Array.from(buffer)[0];\n  return byteFromNumber(firstByte)._unsafeUnwrap();\n};\nexports.firstByteFromBuffer = firstByteFromBuffer;\nconst byteFromNumber = n => {\n  if (!Number.isInteger(n) || !exports.fitsInUInt8(n)) {\n    return neverthrow_1.err(new RangeError('Number is out of Uint8 range'));\n  }\n  const byte = n;\n  return neverthrow_1.ok(byte);\n};\nconst byteToBuffer = byte => Buffer.from([byteToNumber(byte)]);\nexports.byteToBuffer = byteToBuffer;\nconst byteToNumber = byte => byte;","map":{"version":3,"names":["neverthrow_1","require","fitsInUInt8","number","isNotTooBig","isNonNegative","exports","firstByteOfNumber","n","firstByteFromBuffer","Buffer","from","buffer","firstByte","Uint8Array","byteFromNumber","_unsafeUnwrap","Number","isInteger","err","RangeError","byte","ok","byteToBuffer","byteToNumber"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/util/src/byte.ts"],"sourcesContent":["import { Byte } from './_types'\nimport { Result, err, ok } from 'neverthrow'\n\nexport const fitsInUInt8 = (number: number): boolean => {\n\tconst isNotTooBig = number <= 255\n\tconst isNonNegative = number >= 0\n\treturn isNotTooBig && isNonNegative\n}\n\nexport const firstByteOfNumber = (n: number): Byte =>\n\tfirstByteFromBuffer(Buffer.from([n]))\n\nexport const firstByteFromBuffer = (buffer: Buffer): Byte => {\n\tconst firstByte = Uint8Array.from(buffer)[0]\n\treturn byteFromNumber(firstByte)._unsafeUnwrap()\n}\n\nconst byteFromNumber = (n: number): Result<Byte, Error> => {\n\tif (!Number.isInteger(n) || !fitsInUInt8(n)) {\n\t\treturn err(new RangeError('Number is out of Uint8 range'))\n\t}\n\tconst byte = n as Byte\n\treturn ok(byte)\n}\n\nexport const byteToBuffer = (byte: Byte): Buffer =>\n\tBuffer.from([byteToNumber(byte)])\n\nconst byteToNumber = (byte: Byte): number => byte as number\n"],"mappings":";;;;;;AACA,MAAAA,YAAA,GAAAC,OAAA;AAEO,MAAMC,WAAW,GAAIC,MAAc,IAAa;EACtD,MAAMC,WAAW,GAAGD,MAAM,IAAI,GAAG;EACjC,MAAME,aAAa,GAAGF,MAAM,IAAI,CAAC;EACjC,OAAOC,WAAW,IAAIC,aAAa;AACpC,CAAC;AAJYC,OAAA,CAAAJ,WAAW,GAAAA,WAAA;AAMjB,MAAMK,iBAAiB,GAAIC,CAAS,IAC1CF,OAAA,CAAAG,mBAAmB,CAACC,MAAM,CAACC,IAAI,CAAC,CAACH,CAAC,CAAC,CAAC,CAAC;AADzBF,OAAA,CAAAC,iBAAiB,GAAAA,iBAAA;AAGvB,MAAME,mBAAmB,GAAIG,MAAc,IAAU;EAC3D,MAAMC,SAAS,GAAGC,UAAU,CAACH,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;EAC5C,OAAOG,cAAc,CAACF,SAAS,CAAC,CAACG,aAAa,EAAE;AACjD,CAAC;AAHYV,OAAA,CAAAG,mBAAmB,GAAAA,mBAAA;AAKhC,MAAMM,cAAc,GAAIP,CAAS,IAAyB;EACzD,IAAI,CAACS,MAAM,CAACC,SAAS,CAACV,CAAC,CAAC,IAAI,CAACF,OAAA,CAAAJ,WAAW,CAACM,CAAC,CAAC,EAAE;IAC5C,OAAOR,YAAA,CAAAmB,GAAG,CAAC,IAAIC,UAAU,CAAC,8BAA8B,CAAC,CAAC;;EAE3D,MAAMC,IAAI,GAAGb,CAAS;EACtB,OAAOR,YAAA,CAAAsB,EAAE,CAACD,IAAI,CAAC;AAChB,CAAC;AAEM,MAAME,YAAY,GAAIF,IAAU,IACtCX,MAAM,CAACC,IAAI,CAAC,CAACa,YAAY,CAACH,IAAI,CAAC,CAAC,CAAC;AADrBf,OAAA,CAAAiB,YAAY,GAAAA,YAAA;AAGzB,MAAMC,YAAY,GAAIH,IAAU,IAAaA,IAAc","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}