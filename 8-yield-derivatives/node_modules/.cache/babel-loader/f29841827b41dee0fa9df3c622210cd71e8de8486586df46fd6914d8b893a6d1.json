{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccountAddress = exports.isAccountAddressOrUnsafeInput = exports.isAccountAddress = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\nconst crypto_1 = require(\"@radixdlt/crypto\");\nconst bech32_1 = require(\"../bech32\");\nconst abstractAddress_1 = require(\"./abstractAddress\");\nconst util_1 = require(\"@radixdlt/util\");\nconst _types_1 = require(\"./_types\");\nconst primitives_1 = require(\"@radixdlt/primitives\");\nconst isAccountAddress = something => {\n  if (!(0, abstractAddress_1.isAbstractAddress)(something)) return false;\n  return something.addressType === _types_1.AddressTypeT.ACCOUNT;\n};\nexports.isAccountAddress = isAccountAddress;\nconst maxLength = 300; // arbitrarily chosen\nconst versionByte = Buffer.from([0x04]);\nconst encoding = bech32_1.Encoding.BECH32;\nconst hrpFromNetwork = network => primitives_1.HRP[network].account;\nconst networkFromHRP = hrp => hrp === primitives_1.HRP.mainnet.account ? (0, neverthrow_1.ok)(primitives_1.Network.MAINNET) : hrp === primitives_1.HRP.stokenet.account ? (0, neverthrow_1.ok)(primitives_1.Network.STOKENET) : hrp === primitives_1.HRP.localnet.account ? (0, neverthrow_1.ok)(primitives_1.Network.LOCALNET) : hrp === primitives_1.HRP.releasenet.account ? (0, neverthrow_1.ok)(primitives_1.Network.RELEASENET) : hrp === primitives_1.HRP.rcnet.account ? (0, neverthrow_1.ok)(primitives_1.Network.RCNET) : hrp === primitives_1.HRP.milestonenet.account ? (0, neverthrow_1.ok)(primitives_1.Network.MILESTONENET) : hrp === primitives_1.HRP.testnet6.account ? (0, neverthrow_1.ok)(primitives_1.Network.TESTNET6) : hrp === primitives_1.HRP.sandpitnet.account ? (0, neverthrow_1.ok)(primitives_1.Network.SANDPITNET) : (0, neverthrow_1.err)(Error(`Failed to parse network from HRP ${hrp} for AccountAddress.`));\nconst formatDataToBech32Convert = data => Buffer.concat([versionByte, data]);\nconst validateDataAndExtractPubKeyBytes = data => {\n  const receivedVersionByte = data.slice(0, 1);\n  if (!(0, util_1.buffersEquals)(versionByte, receivedVersionByte)) {\n    const errMsg = `Wrong version byte, expected '${versionByte.toString('hex')}', but got: '${receivedVersionByte.toString('hex')}'`;\n    console.error(errMsg);\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n  return (0, neverthrow_1.ok)(data.slice(1, data.length));\n};\nconst fromPublicKeyAndNetwork = input => abstractAddress_1.AbstractAddress.byFormattingPublicKeyDataAndBech32ConvertingIt(Object.assign(Object.assign({}, input), {\n  network: input.network,\n  hrpFromNetwork,\n  addressType: _types_1.AddressTypeT.ACCOUNT,\n  typeguard: exports.isAccountAddress,\n  formatDataToBech32Convert,\n  encoding,\n  maxLength\n})).orElse(e => {\n  throw new Error(`Expected to always be able to create AccountAddress from publicKey and network, but got error: ${e.message}`);\n})._unsafeUnwrap({\n  withStackTrace: true\n});\nconst fromString = bechString => abstractAddress_1.AbstractAddress.fromString({\n  bechString,\n  addressType: _types_1.AddressTypeT.ACCOUNT,\n  networkFromHRP,\n  typeguard: exports.isAccountAddress,\n  validateDataAndExtractPubKeyBytes,\n  encoding,\n  maxLength\n});\nconst fromBuffer = buffer => {\n  const fromBuf = buf => crypto_1.PublicKey.fromBuffer(buf).map(publicKey => fromPublicKeyAndNetwork({\n    publicKey,\n    network: primitives_1.Network.MAINNET // yikes!\n  }));\n  if (buffer.length === 34 && buffer[0] === 0x04) {\n    const sliced = buffer.slice(1);\n    if (sliced.length !== 33) {\n      return (0, neverthrow_1.err)(new Error('Failed to slice buffer.'));\n    }\n    return fromBuf(sliced);\n  } else if (buffer.length === 33) {\n    return fromBuf(buffer);\n  } else {\n    return (0, neverthrow_1.err)(new Error(`Bad length of buffer, got #${buffer.length} bytes, but expected 33.`));\n  }\n};\nconst isAccountAddressUnsafeInput = something => typeof something === 'string' || Buffer.isBuffer(something);\nconst isAccountAddressOrUnsafeInput = something => (0, exports.isAccountAddress)(something) || isAccountAddressUnsafeInput(something);\nexports.isAccountAddressOrUnsafeInput = isAccountAddressOrUnsafeInput;\nconst fromUnsafe = input => (0, exports.isAccountAddress)(input) ? (0, neverthrow_1.ok)(input) : typeof input === 'string' ? fromString(input) : fromBuffer(input);\nexports.AccountAddress = {\n  isAccountAddress: exports.isAccountAddress,\n  fromUnsafe,\n  fromPublicKeyAndNetwork\n};","map":{"version":3,"names":["neverthrow_1","require","crypto_1","bech32_1","abstractAddress_1","util_1","_types_1","primitives_1","isAccountAddress","something","isAbstractAddress","addressType","AddressTypeT","ACCOUNT","exports","maxLength","versionByte","Buffer","from","encoding","Encoding","BECH32","hrpFromNetwork","network","HRP","account","networkFromHRP","hrp","mainnet","ok","Network","MAINNET","stokenet","STOKENET","localnet","LOCALNET","releasenet","RELEASENET","rcnet","RCNET","milestonenet","MILESTONENET","testnet6","TESTNET6","sandpitnet","SANDPITNET","err","Error","formatDataToBech32Convert","data","concat","validateDataAndExtractPubKeyBytes","receivedVersionByte","slice","buffersEquals","errMsg","toString","console","error","length","fromPublicKeyAndNetwork","input","AbstractAddress","byFormattingPublicKeyDataAndBech32ConvertingIt","Object","assign","typeguard","orElse","e","message","_unsafeUnwrap","withStackTrace","fromString","bechString","fromBuffer","buffer","fromBuf","buf","PublicKey","map","publicKey","sliced","isAccountAddressUnsafeInput","isBuffer","isAccountAddressOrUnsafeInput","fromUnsafe","AccountAddress"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/account/src/addresses/accountAddress.ts"],"sourcesContent":["import { err, ok, Result } from 'neverthrow'\nimport { PublicKey, PublicKeyT } from '@radixdlt/crypto'\nimport { Encoding } from '../bech32'\nimport {\n\tAbstractAddress,\n\tFormatDataToBech32Convert,\n\tHRPFromNetwork,\n\tisAbstractAddress,\n\tNetworkFromHRP,\n\tValidateDataAndExtractPubKeyBytes,\n} from './abstractAddress'\nimport { buffersEquals } from '@radixdlt/util'\nimport { AccountAddressT, AddressTypeT } from './_types'\nimport { HRP, Network } from '@radixdlt/primitives'\n\nexport const isAccountAddress = (\n\tsomething: unknown,\n): something is AccountAddressT => {\n\tif (!isAbstractAddress(something)) return false\n\treturn something.addressType === AddressTypeT.ACCOUNT\n}\n\nconst maxLength = 300 // arbitrarily chosen\nconst versionByte = Buffer.from([0x04])\nconst encoding = Encoding.BECH32\n\nconst hrpFromNetwork = (network: Network) => HRP[network].account\n\nconst networkFromHRP: NetworkFromHRP = hrp =>\n\thrp === HRP.mainnet.account\n\t\t? ok(Network.MAINNET)\n\t\t: hrp === HRP.stokenet.account\n\t\t? ok(Network.STOKENET)\n\t\t: hrp === HRP.localnet.account\n\t\t? ok(Network.LOCALNET)\n\t\t: hrp === HRP.releasenet.account\n\t\t? ok(Network.RELEASENET)\n\t\t: hrp === HRP.rcnet.account\n\t\t? ok(Network.RCNET)\n\t\t: hrp === HRP.milestonenet.account\n\t\t? ok(Network.MILESTONENET)\n\t\t: hrp === HRP.testnet6.account\n\t\t? ok(Network.TESTNET6)\n\t\t: hrp === HRP.sandpitnet.account\n\t\t? ok(Network.SANDPITNET)\n\t\t: err(\n\t\t\t\tError(\n\t\t\t\t\t`Failed to parse network from HRP ${hrp} for AccountAddress.`,\n\t\t\t\t),\n\t\t  )\n\nconst formatDataToBech32Convert: FormatDataToBech32Convert = data =>\n\tBuffer.concat([versionByte, data])\n\nconst validateDataAndExtractPubKeyBytes: ValidateDataAndExtractPubKeyBytes = (\n\tdata: Buffer,\n): Result<Buffer, Error> => {\n\tconst receivedVersionByte = data.slice(0, 1)\n\tif (!buffersEquals(versionByte, receivedVersionByte)) {\n\t\tconst errMsg = `Wrong version byte, expected '${versionByte.toString(\n\t\t\t'hex',\n\t\t)}', but got: '${receivedVersionByte.toString('hex')}'`\n\t\tconsole.error(errMsg)\n\t\treturn err(new Error(errMsg))\n\t}\n\treturn ok(data.slice(1, data.length))\n}\n\nconst fromPublicKeyAndNetwork = (\n\tinput: Readonly<{\n\t\tpublicKey: PublicKeyT\n\t\tnetwork: Network\n\t}>,\n): AccountAddressT =>\n\tAbstractAddress.byFormattingPublicKeyDataAndBech32ConvertingIt({\n\t\t...input,\n\t\tnetwork: input.network,\n\t\thrpFromNetwork,\n\t\taddressType: AddressTypeT.ACCOUNT,\n\t\ttypeguard: isAccountAddress,\n\t\tformatDataToBech32Convert,\n\t\tencoding,\n\t\tmaxLength,\n\t})\n\t\t.orElse(e => {\n\t\t\tthrow new Error(\n\t\t\t\t`Expected to always be able to create AccountAddress from publicKey and network, but got error: ${e.message}`,\n\t\t\t)\n\t\t})\n\t\t._unsafeUnwrap({ withStackTrace: true })\n\nconst fromString = (bechString: string): Result<AccountAddressT, Error> =>\n\tAbstractAddress.fromString({\n\t\tbechString,\n\t\taddressType: AddressTypeT.ACCOUNT,\n\t\tnetworkFromHRP,\n\t\ttypeguard: isAccountAddress,\n\t\tvalidateDataAndExtractPubKeyBytes,\n\t\tencoding,\n\t\tmaxLength,\n\t})\n\nconst fromBuffer = (buffer: Buffer): Result<AccountAddressT, Error> => {\n\tconst fromBuf = (buf: Buffer): Result<AccountAddressT, Error> =>\n\t\tPublicKey.fromBuffer(buf).map(publicKey =>\n\t\t\tfromPublicKeyAndNetwork({\n\t\t\t\tpublicKey,\n\t\t\t\tnetwork: Network.MAINNET, // yikes!\n\t\t\t}),\n\t\t)\n\n\tif (buffer.length === 34 && buffer[0] === 0x04) {\n\t\tconst sliced = buffer.slice(1)\n\t\tif (sliced.length !== 33) {\n\t\t\treturn err(new Error('Failed to slice buffer.'))\n\t\t}\n\t\treturn fromBuf(sliced)\n\t} else if (buffer.length === 33) {\n\t\treturn fromBuf(buffer)\n\t} else {\n\t\treturn err(\n\t\t\tnew Error(\n\t\t\t\t`Bad length of buffer, got #${buffer.length} bytes, but expected 33.`,\n\t\t\t),\n\t\t)\n\t}\n}\n\nexport type AccountAddressUnsafeInput = string | Buffer\n\nconst isAccountAddressUnsafeInput = (\n\tsomething: unknown,\n): something is AccountAddressUnsafeInput =>\n\ttypeof something === 'string' || Buffer.isBuffer(something)\n\nexport type AddressOrUnsafeInput = AccountAddressUnsafeInput | AccountAddressT\n\nexport const isAccountAddressOrUnsafeInput = (\n\tsomething: unknown,\n): something is AddressOrUnsafeInput =>\n\tisAccountAddress(something) || isAccountAddressUnsafeInput(something)\n\nconst fromUnsafe = (\n\tinput: AddressOrUnsafeInput,\n): Result<AccountAddressT, Error> =>\n\tisAccountAddress(input)\n\t\t? ok(input)\n\t\t: typeof input === 'string'\n\t\t? fromString(input)\n\t\t: fromBuffer(input)\n\nexport const AccountAddress = {\n\tisAccountAddress,\n\tfromUnsafe,\n\tfromPublicKeyAndNetwork,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}