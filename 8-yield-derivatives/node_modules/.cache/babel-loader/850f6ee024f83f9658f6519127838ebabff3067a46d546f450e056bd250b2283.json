{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ECPointOnCurve = exports.__pointOnCurveFromEllipticShortPoint = void 0;\nconst uint256_1 = require(\"@radixdlt/uint256\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst elliptic_1 = require(\"elliptic\");\nconst primitives_1 = require(\"@radixdlt/primitives\");\nconst util_1 = require(\"@radixdlt/util\");\nconst thirdPartyLibEllipticSecp256k1 = new elliptic_1.ec('secp256k1');\nconst pointFromCoordinates = input => {\n  const otherX = (0, primitives_1.bnFromUInt256)(input.x);\n  const otherY = (0, primitives_1.bnFromUInt256)(input.y);\n  const shortWeirestrassCurve = thirdPartyLibEllipticSecp256k1.curve;\n  return shortWeirestrassCurve.point(otherX, otherY);\n};\nconst pointFromOther = other => pointFromCoordinates({\n  x: other.x,\n  y: other.y\n});\nconst incorrectImplementationECPointInvalid = new Error('Incorrect implementation, EC point is invalid');\nconst ecPointOnCurveFromCoordinates = input => {\n  var _a;\n  const {\n    x,\n    y\n  } = input;\n  const shortPoint = (_a = input.shortPoint) !== null && _a !== void 0 ? _a : pointFromCoordinates(input);\n  const multiplyByScalar = by => {\n    const factorShortPoint = shortPoint.mul((0, primitives_1.bnFromUInt256)(by));\n    // using recursion here!\n    const factorPoint = (0, exports.__pointOnCurveFromEllipticShortPoint)(factorShortPoint);\n    // This should not happen, the internals of the EC lib `Elliptic` should always be\n    // able to perform multiplication between point and a scalar.\n    if (!factorPoint.isOk()) throw incorrectImplementationECPointInvalid;\n    return factorPoint.value;\n  };\n  const u256ToBuf = n => Buffer.from(n.toString(16), 'hex');\n  const toBuffer = includePrefixByte => Buffer.concat([includePrefixByte ? Buffer.from([0x04]) : Buffer.alloc(0), u256ToBuf(x), u256ToBuf(y)]);\n  const toString = includePrefixByte => toBuffer(includePrefixByte).toString('hex');\n  return {\n    x,\n    y,\n    toBuffer,\n    toString,\n    equals: other => other.x.eq(x) && other.y.eq(y),\n    add: other => {\n      const sumShortPoint = shortPoint.add(pointFromOther(other));\n      // using recursion here!\n      const sumPoint = (0, exports.__pointOnCurveFromEllipticShortPoint)(sumShortPoint);\n      // This should not happen, the internals of the EC lib `Elliptic` should always be\n      // able to perform EC point addition.\n      if (!sumPoint.isOk()) throw incorrectImplementationECPointInvalid;\n      return sumPoint.value;\n    },\n    multiply: multiplyByScalar,\n    multiplyWithPrivateKey: privateKey => multiplyByScalar(privateKey.scalar)\n  };\n};\nconst __pointOnCurveFromEllipticShortPoint = shortPoint => {\n  const validateOnCurve = somePoint => {\n    if (!somePoint.validate()) return (0, neverthrow_1.err)(new Error('Not point on curve!'));\n    return (0, neverthrow_1.ok)({\n      witness: 'Point is on curve.'\n    });\n  };\n  return validateOnCurve(shortPoint).andThen(_ => (0, neverthrow_1.combine)([(0, primitives_1.uint256FromBN)(shortPoint.getX()), (0, primitives_1.uint256FromBN)(shortPoint.getY())]).map(xNy => {\n    const x = xNy[0];\n    const y = xNy[1];\n    return ecPointOnCurveFromCoordinates({\n      x,\n      y,\n      shortPoint\n    });\n  }));\n};\nexports.__pointOnCurveFromEllipticShortPoint = __pointOnCurveFromEllipticShortPoint;\nconst fromXY = input => (0, exports.__pointOnCurveFromEllipticShortPoint)(pointFromCoordinates(input));\nconst fromBuffer = buffer => {\n  let bytes = buffer;\n  if (bytes.length === 65) {\n    const firstByte = parseInt(bytes.slice(0, 1).toString('hex'), 16);\n    if (firstByte !== 0x04) {\n      const errMsg = `For buffers with length 65 bytes we expect the first byte to be 0x04, but got: ${firstByte.toString(16)}`;\n      util_1.log.error(errMsg);\n      return (0, neverthrow_1.err)(new Error(errMsg));\n    }\n    bytes = bytes.slice(1);\n  }\n  const expectedByteCount = 64;\n  if (bytes.length !== expectedByteCount) {\n    const errMsg = `Expected #${expectedByteCount} bytes, but got: ${bytes.length}`;\n    util_1.log.error(errMsg);\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n  const xBuf = bytes.slice(0, expectedByteCount / 2);\n  const yBuf = bytes.slice(expectedByteCount / 2);\n  const x = new uint256_1.UInt256(xBuf.toString('hex'), 16);\n  const y = new uint256_1.UInt256(yBuf.toString('hex'), 16);\n  return fromXY({\n    x,\n    y\n  });\n};\nexports.ECPointOnCurve = {\n  fromXY,\n  fromBuffer\n};","map":{"version":3,"names":["uint256_1","require","neverthrow_1","elliptic_1","primitives_1","util_1","thirdPartyLibEllipticSecp256k1","ec","pointFromCoordinates","input","otherX","bnFromUInt256","x","otherY","y","shortWeirestrassCurve","curve","point","pointFromOther","other","incorrectImplementationECPointInvalid","Error","ecPointOnCurveFromCoordinates","shortPoint","_a","multiplyByScalar","by","factorShortPoint","mul","factorPoint","exports","__pointOnCurveFromEllipticShortPoint","isOk","value","u256ToBuf","n","Buffer","from","toString","toBuffer","includePrefixByte","concat","alloc","equals","eq","add","sumShortPoint","sumPoint","multiply","multiplyWithPrivateKey","privateKey","scalar","validateOnCurve","somePoint","validate","err","ok","witness","andThen","_","combine","uint256FromBN","getX","getY","map","xNy","fromXY","fromBuffer","buffer","bytes","length","firstByte","parseInt","slice","errMsg","log","error","expectedByteCount","xBuf","yBuf","UInt256","ECPointOnCurve"],"sources":["../../src/elliptic-curve/ecPointOnCurve.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}