{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.secureRandomGenerator = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\n/* eslint-disable */\n/**\n * randomBytes\n *\n * Uses JS-native CSPRNG to generate a specified number of bytes.\n *\n * @param {number} byteCount number of bytes to generate\n * @returns {Result<Buffer, Error>} result of random byte generation.\n */\nconst randomBytes = byteCount => {\n  let buffer = Buffer.alloc(byteCount);\n  if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {\n    const bytes = window.crypto.getRandomValues(new Uint8Array(byteCount));\n    buffer = Buffer.from(bytes);\n  } else if (typeof require !== 'undefined') {\n    const sodium = require('sodium-native');\n    sodium.randombytes_buf(buffer);\n  } else {\n    return neverthrow_1.err(new Error('Unable to generate safe random numbers.'));\n  }\n  const byteArray = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n  let byteString = '';\n  for (let i = 0; i < byteCount; i++) {\n    byteString += ('00' + byteArray[i].toString(16)).slice(-2);\n  }\n  return neverthrow_1.ok(byteString);\n};\nexports.secureRandomGenerator = {\n  randomSecureBytes: byteCount => randomBytes(byteCount)._unsafeUnwrap()\n};","map":{"version":3,"names":["neverthrow_1","require","randomBytes","byteCount","buffer","Buffer","alloc","window","crypto","getRandomValues","bytes","Uint8Array","from","sodium","randombytes_buf","err","Error","byteArray","byteOffset","byteLength","BYTES_PER_ELEMENT","byteString","i","toString","slice","ok","exports","secureRandomGenerator","randomSecureBytes","_unsafeUnwrap"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/util/src/secureRandomGenerator.ts"],"sourcesContent":["import { SecureRandom } from './_types'\nimport { Result, ok, err } from 'neverthrow'\n\n/* eslint-disable */\n\n/**\n * randomBytes\n *\n * Uses JS-native CSPRNG to generate a specified number of bytes.\n *\n * @param {number} byteCount number of bytes to generate\n * @returns {Result<Buffer, Error>} result of random byte generation.\n */\nconst randomBytes = (byteCount: number): Result<string, Error> => {\n\tlet buffer: Buffer = Buffer.alloc(byteCount)\n\tif (\n\t\ttypeof window !== 'undefined' &&\n\t\twindow.crypto &&\n\t\twindow.crypto.getRandomValues\n\t) {\n\t\tconst bytes = window.crypto.getRandomValues(new Uint8Array(byteCount))\n\t\tbuffer = Buffer.from(bytes)\n\t} else if (typeof require !== 'undefined') {\n\t\tconst sodium = require('sodium-native')\n\t\tsodium.randombytes_buf(buffer)\n\t} else {\n\t\treturn err(new Error('Unable to generate safe random numbers.'))\n\t}\n\n\tconst byteArray = new Uint8Array(\n\t\tbuffer.buffer,\n\t\tbuffer.byteOffset,\n\t\tbuffer.byteLength / Uint8Array.BYTES_PER_ELEMENT,\n\t)\n\tlet byteString = ''\n\tfor (let i = 0; i < byteCount; i++) {\n\t\tbyteString += ('00' + byteArray[i].toString(16)).slice(-2)\n\t}\n\n\treturn ok(byteString)\n}\n\nexport const secureRandomGenerator: SecureRandom = {\n\trandomSecureBytes: (byteCount: number) =>\n\t\trandomBytes(byteCount)._unsafeUnwrap(),\n}\n"],"mappings":";;;;;;AACA,MAAAA,YAAA,GAAAC,OAAA;AAEA;AAEA;;;;;;;;AAQA,MAAMC,WAAW,GAAIC,SAAiB,IAA2B;EAChE,IAAIC,MAAM,GAAWC,MAAM,CAACC,KAAK,CAACH,SAAS,CAAC;EAC5C,IACC,OAAOI,MAAM,KAAK,WAAW,IAC7BA,MAAM,CAACC,MAAM,IACbD,MAAM,CAACC,MAAM,CAACC,eAAe,EAC5B;IACD,MAAMC,KAAK,GAAGH,MAAM,CAACC,MAAM,CAACC,eAAe,CAAC,IAAIE,UAAU,CAACR,SAAS,CAAC,CAAC;IACtEC,MAAM,GAAGC,MAAM,CAACO,IAAI,CAACF,KAAK,CAAC;GAC3B,MAAM,IAAI,OAAOT,OAAO,KAAK,WAAW,EAAE;IAC1C,MAAMY,MAAM,GAAGZ,OAAO,CAAC,eAAe,CAAC;IACvCY,MAAM,CAACC,eAAe,CAACV,MAAM,CAAC;GAC9B,MAAM;IACN,OAAOJ,YAAA,CAAAe,GAAG,CAAC,IAAIC,KAAK,CAAC,yCAAyC,CAAC,CAAC;;EAGjE,MAAMC,SAAS,GAAG,IAAIN,UAAU,CAC/BP,MAAM,CAACA,MAAM,EACbA,MAAM,CAACc,UAAU,EACjBd,MAAM,CAACe,UAAU,GAAGR,UAAU,CAACS,iBAAiB,CAChD;EACD,IAAIC,UAAU,GAAG,EAAE;EACnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,SAAS,EAAEmB,CAAC,EAAE,EAAE;IACnCD,UAAU,IAAI,CAAC,IAAI,GAAGJ,SAAS,CAACK,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,EAAEC,KAAK,CAAC,CAAC,CAAC,CAAC;;EAG3D,OAAOxB,YAAA,CAAAyB,EAAE,CAACJ,UAAU,CAAC;AACtB,CAAC;AAEYK,OAAA,CAAAC,qBAAqB,GAAiB;EAClDC,iBAAiB,EAAGzB,SAAiB,IACpCD,WAAW,CAACC,SAAS,CAAC,CAAC0B,aAAa;CACrC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}