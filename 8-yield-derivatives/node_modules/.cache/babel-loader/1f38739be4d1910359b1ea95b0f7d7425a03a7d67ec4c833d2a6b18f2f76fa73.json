{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar Value_1 = require(\"./Value\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\n/**\n * Represent a lazily evaluated value. You give a function which\n * will return a value; that function is only called when the value\n * is requested from Lazy, but it will be computed at most once.\n * If the value is requested again, the previously computed result\n * will be returned: Lazy is memoizing.\n */\nvar Lazy = /** @class */function () {\n  function Lazy(thunk) {\n    this.thunk = thunk;\n  }\n  /**\n   * Build a Lazy from a computation returning a value.\n   * The computation will be called at most once.\n   */\n  Lazy.of = function (thunk) {\n    return new Lazy(thunk);\n  };\n  /**\n   * Evaluate the value, cache its value, and return it, or return the\n   * previously computed value.\n   */\n  Lazy.prototype.get = function () {\n    if (this.thunk) {\n      this.value = this.thunk();\n      this.thunk = undefined;\n    }\n    return this.value;\n  };\n  /**\n   * Returns true if the computation underlying this Lazy was already\n   * performed, false otherwise.\n   */\n  Lazy.prototype.isEvaluated = function () {\n    return this.thunk === undefined;\n  };\n  /**\n   * Return a new lazy where the element was transformed\n   * by the mapper function you give.\n   */\n  Lazy.prototype.map = function (mapper) {\n    var _this = this;\n    return new Lazy(function () {\n      return mapper(_this.get());\n    });\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   */\n  Lazy.prototype.toString = function () {\n    return this.isEvaluated() ? \"Lazy(\" + SeqHelpers_1.toStringHelper(this.get()) + \")\" : \"Lazy(?)\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   * Most of the time should be the same as toString()\n   */\n  Lazy.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return Lazy;\n}();\nexports.Lazy = Lazy;","map":{"version":3,"names":["Value_1","require","SeqHelpers_1","Lazy","thunk","of","prototype","get","value","undefined","isEvaluated","map","mapper","_this","toString","toStringHelper","inspect","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/Lazy.ts"],"sourcesContent":["import { inspect } from \"./Value\";\nimport { toStringHelper } from \"./SeqHelpers\";\n\n/**\n * Represent a lazily evaluated value. You give a function which\n * will return a value; that function is only called when the value\n * is requested from Lazy, but it will be computed at most once.\n * If the value is requested again, the previously computed result\n * will be returned: Lazy is memoizing.\n */\nexport class Lazy<T> {\n\n    private thunk: (()=>T)|undefined;\n    private value: T|undefined;\n\n    private constructor(thunk: ()=>T) {\n        this.thunk = thunk;\n    }\n    \n    /**\n     * Build a Lazy from a computation returning a value.\n     * The computation will be called at most once.\n     */\n    static of<T>(thunk: ()=>T) {\n        return new Lazy(thunk);\n    }\n\n    /**\n     * Evaluate the value, cache its value, and return it, or return the\n     * previously computed value.\n     */\n    get(): T {\n        if (this.thunk) {\n            this.value = this.thunk();\n            this.thunk = undefined;\n        }\n        return <T>this.value;\n    }\n\n    /**\n     * Returns true if the computation underlying this Lazy was already\n     * performed, false otherwise.\n     */\n    isEvaluated(): boolean {\n        return this.thunk === undefined;\n    }\n\n    /**\n     * Return a new lazy where the element was transformed\n     * by the mapper function you give.\n     */\n    map<U>(mapper:(v:T)=>U): Lazy<U> {\n        return new Lazy(()=>mapper(this.get()));\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     */\n    toString(): string {\n        return this.isEvaluated() ?\n            `Lazy(${toStringHelper(this.get())})` :\n            \"Lazy(?)\";\n    }\n\n    /**\n     * Used by the node REPL to display values.\n     * Most of the time should be the same as toString()\n     */\n    [inspect](): string {\n        return this.toString();\n    }\n}\n"],"mappings":";;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,YAAA,GAAAD,OAAA;AAEA;;;;;;;AAOA,IAAAE,IAAA;EAKI,SAAAA,KAAoBC,KAAY;IAC5B,IAAI,CAACA,KAAK,GAAGA,KAAK;EACtB;EAEA;;;;EAIOD,IAAA,CAAAE,EAAE,GAAT,UAAaD,KAAY;IACrB,OAAO,IAAID,IAAI,CAACC,KAAK,CAAC;EAC1B,CAAC;EAED;;;;EAIAD,IAAA,CAAAG,SAAA,CAAAC,GAAG,GAAH;IACI,IAAI,IAAI,CAACH,KAAK,EAAE;MACZ,IAAI,CAACI,KAAK,GAAG,IAAI,CAACJ,KAAK,EAAE;MACzB,IAAI,CAACA,KAAK,GAAGK,SAAS;;IAE1B,OAAU,IAAI,CAACD,KAAK;EACxB,CAAC;EAED;;;;EAIAL,IAAA,CAAAG,SAAA,CAAAI,WAAW,GAAX;IACI,OAAO,IAAI,CAACN,KAAK,KAAKK,SAAS;EACnC,CAAC;EAED;;;;EAIAN,IAAA,CAAAG,SAAA,CAAAK,GAAG,GAAH,UAAOC,MAAe;IAAtB,IAAAC,KAAA;IACI,OAAO,IAAIV,IAAI,CAAC;MAAI,OAAAS,MAAM,CAACC,KAAI,CAACN,GAAG,EAAE,CAAC;IAAlB,CAAkB,CAAC;EAC3C,CAAC;EAED;;;EAGAJ,IAAA,CAAAG,SAAA,CAAAQ,QAAQ,GAAR;IACI,OAAO,IAAI,CAACJ,WAAW,EAAE,GACrB,UAAQR,YAAA,CAAAa,cAAc,CAAC,IAAI,CAACR,GAAG,EAAE,CAAC,MAAG,GACrC,SAAS;EACjB,CAAC;EAED;;;;EAIAJ,IAAA,CAAAG,SAAA,CAACN,OAAA,CAAAgB,OAAO,CAAC,GAAT;IACI,OAAO,IAAI,CAACF,QAAQ,EAAE;EAC1B,CAAC;EACL,OAAAX,IAAC;AAAD,CAAC,CA7DD;AAAac,OAAA,CAAAd,IAAA,GAAAA,IAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}