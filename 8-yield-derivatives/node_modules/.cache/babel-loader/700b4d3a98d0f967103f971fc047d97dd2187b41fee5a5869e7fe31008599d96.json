{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\nvar preludeTsContractViolationCb = function (msg) {\n  throw new Error(msg);\n};\n/**\n * Some programmatic errors are only detectable at runtime\n * (for instance trying to setup a <code>HashSet</code> of <code>Option&lt;number[]&gt;</code>: you\n * can't reliably compare a <code>number[]</code> therefore you can't compare\n * an <code>Option&lt;number[]&gt;</code>.. but we can't detect this error at compile-time\n * in typescript). So when we detect them at runtime, prelude-ts throws\n * an exception by default.\n * This function allows you to change that default action\n * (for instance, you could display an error message in the console,\n * or log the error)\n *\n * You can reproduce the issue easily by running for instance:\n *\n *  HashSet.of(Option.of([1]))\n *  => throws\n */\nfunction setContractViolationAction(action) {\n  preludeTsContractViolationCb = action;\n}\nexports.setContractViolationAction = setContractViolationAction;\n/**\n * @hidden\n */\nfunction reportContractViolation(msg) {\n  preludeTsContractViolationCb(msg);\n}\nexports.reportContractViolation = reportContractViolation;\n/**\n * @hidden\n */\nfunction contractTrueEquality(context) {\n  var vals = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    vals[_i - 1] = arguments[_i];\n  }\n  for (var _a = 0, vals_1 = vals; _a < vals_1.length; _a++) {\n    var val = vals_1[_a];\n    if (val) {\n      if (val.hasTrueEquality && !val.hasTrueEquality()) {\n        reportContractViolation(context + \": element doesn't support true equality: \" + SeqHelpers_1.toStringHelper(val));\n      }\n      if (!Comparison_1.hasTrueEquality(val).getOrThrow()) {\n        reportContractViolation(context + \": element doesn't support equality: \" + SeqHelpers_1.toStringHelper(val));\n      }\n      // the first element i find is looking good, aborting\n      return;\n    }\n  }\n}\nexports.contractTrueEquality = contractTrueEquality;","map":{"version":3,"names":["Comparison_1","require","SeqHelpers_1","preludeTsContractViolationCb","msg","Error","setContractViolationAction","action","exports","reportContractViolation","contractTrueEquality","context","vals","_i","arguments","length","_a","vals_1","val","hasTrueEquality","toStringHelper","getOrThrow"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/Contract.ts"],"sourcesContent":["import { hasTrueEquality } from \"./Comparison\";\nimport { toStringHelper } from \"./SeqHelpers\";\n\nlet preludeTsContractViolationCb = (msg:string):void => { throw new Error(msg); };\n\n/**\n * Some programmatic errors are only detectable at runtime\n * (for instance trying to setup a <code>HashSet</code> of <code>Option&lt;number[]&gt;</code>: you\n * can't reliably compare a <code>number[]</code> therefore you can't compare\n * an <code>Option&lt;number[]&gt;</code>.. but we can't detect this error at compile-time\n * in typescript). So when we detect them at runtime, prelude-ts throws\n * an exception by default.\n * This function allows you to change that default action\n * (for instance, you could display an error message in the console,\n * or log the error)\n *\n * You can reproduce the issue easily by running for instance:\n *\n *  HashSet.of(Option.of([1]))\n *  => throws\n */\nexport function setContractViolationAction(action: (msg:string)=>void) {\n    preludeTsContractViolationCb = action;\n}\n\n/**\n * @hidden\n */\nexport function reportContractViolation(msg: string): void {\n    preludeTsContractViolationCb(msg);\n}\n\n/**\n * @hidden\n */\nexport function contractTrueEquality(context: string, ...vals: Array<any>) {\n    for (const val of vals) {\n        if (val) {\n            if (val.hasTrueEquality && (!val.hasTrueEquality())) {\n                reportContractViolation(\n                    context + \": element doesn't support true equality: \" + toStringHelper(val));\n            }\n            if (!hasTrueEquality(val).getOrThrow()) {\n                reportContractViolation(\n                    context + \": element doesn't support equality: \" + toStringHelper(val));\n            }\n            // the first element i find is looking good, aborting\n            return;\n        }\n    }\n}\n"],"mappings":";;;AAAA,IAAAA,YAAA,GAAAC,OAAA;AACA,IAAAC,YAAA,GAAAD,OAAA;AAEA,IAAIE,4BAA4B,GAAG,SAAAA,CAACC,GAAU;EAAY,MAAM,IAAIC,KAAK,CAACD,GAAG,CAAC;AAAE,CAAC;AAEjF;;;;;;;;;;;;;;;;AAgBA,SAAgBE,0BAA0BA,CAACC,MAA0B;EACjEJ,4BAA4B,GAAGI,MAAM;AACzC;AAFAC,OAAA,CAAAF,0BAAA,GAAAA,0BAAA;AAIA;;;AAGA,SAAgBG,uBAAuBA,CAACL,GAAW;EAC/CD,4BAA4B,CAACC,GAAG,CAAC;AACrC;AAFAI,OAAA,CAAAC,uBAAA,GAAAA,uBAAA;AAIA;;;AAGA,SAAgBC,oBAAoBA,CAACC,OAAe;EAAE,IAAAC,IAAA;OAAA,IAAAC,EAAA,IAAmB,EAAnBA,EAAA,GAAAC,SAAA,CAAAC,MAAmB,EAAnBF,EAAA,EAAmB;IAAnBD,IAAA,CAAAC,EAAA,QAAAC,SAAA,CAAAD,EAAA;;EAClD,KAAkB,IAAAG,EAAA,IAAI,EAAJC,MAAA,GAAAL,IAAI,EAAJI,EAAA,GAAAC,MAAA,CAAAF,MAAI,EAAJC,EAAA,EAAI,EAAE;IAAnB,IAAME,GAAG,GAAAD,MAAA,CAAAD,EAAA;IACV,IAAIE,GAAG,EAAE;MACL,IAAIA,GAAG,CAACC,eAAe,IAAK,CAACD,GAAG,CAACC,eAAe,EAAG,EAAE;QACjDV,uBAAuB,CACnBE,OAAO,GAAG,2CAA2C,GAAGT,YAAA,CAAAkB,cAAc,CAACF,GAAG,CAAC,CAAC;;MAEpF,IAAI,CAAClB,YAAA,CAAAmB,eAAe,CAACD,GAAG,CAAC,CAACG,UAAU,EAAE,EAAE;QACpCZ,uBAAuB,CACnBE,OAAO,GAAG,sCAAsC,GAAGT,YAAA,CAAAkB,cAAc,CAACF,GAAG,CAAC,CAAC;;MAE/E;MACA;;;AAGZ;AAfAV,OAAA,CAAAE,oBAAA,GAAAA,oBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}