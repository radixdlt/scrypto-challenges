{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResourceIdentifier = exports.isResourceIdentifierOrUnsafeInput = exports.isResourceIdentifierUnsafeInput = exports.isResourceIdentifier = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\nconst util_1 = require(\"@radixdlt/util\");\nconst crypto_1 = require(\"@radixdlt/crypto\");\nconst primitives_1 = require(\"@radixdlt/primitives\");\nconst bech32_1 = require(\"../bech32\");\nconst encoding = bech32_1.Encoding.BECH32;\nconst maxLength = undefined; // arbitrarily chosen\nconst versionByteNativeToken = 0x01;\nconst versionByteNonNativeToken = 0x03;\nconst hrpSuffixFromNetwork = network => primitives_1.HRP[network].RRI_suffix;\nconst networkFromHRPSuffix = hrp => hrp === primitives_1.HRP.mainnet.RRI_suffix ? (0, neverthrow_1.ok)(primitives_1.Network.MAINNET) : hrp === primitives_1.HRP.stokenet.RRI_suffix ? (0, neverthrow_1.ok)(primitives_1.Network.STOKENET) : hrp === primitives_1.HRP.localnet.RRI_suffix ? (0, neverthrow_1.ok)(primitives_1.Network.LOCALNET) : hrp === primitives_1.HRP.releasenet.RRI_suffix ? (0, neverthrow_1.ok)(primitives_1.Network.RELEASENET) : hrp === primitives_1.HRP.rcnet.RRI_suffix ? (0, neverthrow_1.ok)(primitives_1.Network.RCNET) : hrp === primitives_1.HRP.milestonenet.RRI_suffix ? (0, neverthrow_1.ok)(primitives_1.Network.MILESTONENET) : hrp === primitives_1.HRP.testnet6.RRI_suffix ? (0, neverthrow_1.ok)(primitives_1.Network.TESTNET6) : hrp === primitives_1.HRP.sandpitnet.RRI_suffix ? (0, neverthrow_1.ok)(primitives_1.Network.SANDPITNET) : (0, neverthrow_1.err)(new Error(\"Failed to parse network from HRP \".concat(hrp, \" for ValidatorAddress.\")));\nconst __create = input => Object.assign(Object.assign({}, input), {\n  __witness: 'isRRI',\n  equals: other => {\n    if (!(0, exports.isResourceIdentifier)(other)) return false;\n    const same = other.name === input.name && (0, util_1.buffersEquals)(other.hash, input.hash) && input.network === other.network;\n    if (same) {\n      if (other.toString() !== input.toString()) {\n        const errMsg = \"ResourceIdentifiers believed to be equal, but return different values when calling toString, (this)'\".concat(input.toString(), \"' vs other: '\").concat(other.toString(), \"'\");\n        console.error(errMsg);\n        throw new Error(errMsg);\n      }\n    }\n    return same;\n  }\n});\nconst fromBech32String = bechString => {\n  // const hrpSuffix = hrpBetanetSuffix // TODO make dependent on Network!\n  const decodingResult = bech32_1.Bech32.decode({\n    bechString,\n    encoding,\n    maxLength\n  });\n  if (!decodingResult.isOk()) {\n    const errMsg = \"Failed to Bech32 decode RRI, underlying error: \".concat((0, util_1.msgFromError)(decodingResult.error));\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n  const decoded = decodingResult.value;\n  const hrp = decoded.hrp;\n  if (!Object.keys(primitives_1.HRP).some(network => hrp.endsWith(primitives_1.HRP[network].RRI_suffix))) {\n    const errMsg = \"suffix found for hrp \\\"\".concat(hrp, \"\\\" not supported.\");\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n  const nameToValidate = hrp.split('_')[0];\n  const hrpSuffix = '_' + hrp.split('_')[1];\n  const networkResult = networkFromHRPSuffix(hrpSuffix);\n  if (!networkResult.isOk()) {\n    const errMsg = \"Expected to get network from HRP suffix '\".concat(hrpSuffix, \"', but failed to get it.\");\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n  const network = networkResult.value;\n  const nameValidationResult = validateCharsInName(nameToValidate);\n  if (!nameValidationResult.isOk()) {\n    return (0, neverthrow_1.err)(nameValidationResult.error);\n  }\n  const name = nameValidationResult.value;\n  const processed = decoded.data;\n  const combinedDataResult = bech32_1.Bech32.convertDataFromBech32(processed);\n  if (!combinedDataResult.isOk()) {\n    const errMsg = \"Failed to convertDataFromBech32 data, underlying error: \".concat((0, util_1.msgFromError)(combinedDataResult.error));\n    console.error(errMsg);\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n  const combinedData = combinedDataResult.value;\n  if (combinedData.length === 0) {\n    const errMsg = \"The data part of RRI should NEVER be empty, must at least contain 1 version byte ('\".concat(versionByteNativeToken, \"' for native token, or '\").concat(versionByteNonNativeToken, \"' for other tokens)\");\n    console.error(errMsg);\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n  const versionByte = combinedData[0];\n  if (!(versionByte === versionByteNativeToken || versionByte === versionByteNonNativeToken)) {\n    const errMsg = \"The version byte must be either: '\".concat(versionByteNativeToken, \"' for native token, or '\").concat(versionByteNonNativeToken, \"' for other tokens, but got: \").concat(versionByte, \", bechString: '\").concat(bechString, \"'\");\n    console.error(errMsg);\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n  const isNativeToken = versionByte === versionByteNativeToken;\n  if (isNativeToken) {\n    if (combinedData.length > 1) {\n      const errMsg = \"Expected data to be empty for native token, but got: #\".concat(combinedData.length - 1 // minus 1 because we substract the 'versionByte'\n      , \" bytes\");\n      console.error(errMsg);\n      return (0, neverthrow_1.err)(new Error(errMsg));\n    }\n  } else {\n    if (combinedData.length <= 1) {\n      const errMsg = \"Expected data to be non empty for non native token\";\n      console.error(errMsg);\n      return (0, neverthrow_1.err)(new Error(errMsg));\n    }\n  }\n  return (0, neverthrow_1.ok)(__create({\n    hash: combinedData,\n    network,\n    name,\n    toString: () => bechString\n  }));\n};\nconst validateCharsInName = name => {\n  const regexLowerAlphaNumerics = new RegExp('^[a-z0-9]+$');\n  if (!regexLowerAlphaNumerics.test(name)) {\n    const errMsg = \"Illegal characters found in name\";\n    // console.error(errMsg)\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n  return (0, neverthrow_1.ok)(name);\n};\nconst withNameRawDataAndVersionByte = input => {\n  const {\n    versionByte,\n    hash,\n    network\n  } = input;\n  const hrpSuffix = hrpSuffixFromNetwork(network);\n  return validateCharsInName(input.name).andThen(name => {\n    const hrp = \"\".concat(name).concat(hrpSuffix);\n    const combinedData = Buffer.concat([Buffer.from([versionByte]), hash]);\n    return bech32_1.Bech32.convertDataToBech32(combinedData).andThen(processed => bech32_1.Bech32.encode({\n      data: processed,\n      hrp,\n      encoding,\n      maxLength\n    })).map(bech32 => __create({\n      hash,\n      network,\n      name,\n      toString: () => bech32.toString()\n    }));\n  });\n};\nconst systemRRIForNetwork = input => withNameRawDataAndVersionByte(Object.assign(Object.assign({}, input), {\n  versionByte: versionByteNativeToken,\n  hash: Buffer.alloc(0)\n}));\nconst hashByteCount = 26;\nconst pkToHash = input => {\n  const {\n    name,\n    publicKey\n  } = input;\n  const nameBytes = Buffer.from(name, 'utf8');\n  const pubKeyBytes = publicKey.asData({\n    compressed: true\n  });\n  const dataToHash = Buffer.concat([pubKeyBytes, nameBytes]);\n  const hash = (0, crypto_1.sha256Twice)(dataToHash);\n  return hash.slice(-hashByteCount); // last bytes\n};\nconst fromPublicKeyAndNameAndNetwork = input => withNameRawDataAndVersionByte(Object.assign(Object.assign({}, input), {\n  versionByte: versionByteNonNativeToken,\n  hash: pkToHash(input)\n}));\nconst fromBuffer = buffer => {\n  if (buffer.length === 1 && buffer[0] === 0x01) {\n    return systemRRIForNetwork({\n      name: 'xrd',\n      network: primitives_1.Network.MAINNET // Yikes!\n    });\n  }\n  return (0, neverthrow_1.err)(new Error('Failed to create non XRD RRI because we do not have access to the HRP.'));\n};\nconst isResourceIdentifier = something => {\n  const inspection = something;\n  return (\n    // inspection.hash !== undefined &&\n    inspection.__witness !== undefined && inspection.__witness === 'isRRI' && inspection.name !== undefined && inspection.toString !== undefined && inspection.equals !== undefined\n  );\n};\nexports.isResourceIdentifier = isResourceIdentifier;\nconst isResourceIdentifierUnsafeInput = something => typeof something === 'string' || Buffer.isBuffer(something);\nexports.isResourceIdentifierUnsafeInput = isResourceIdentifierUnsafeInput;\nconst isResourceIdentifierOrUnsafeInput = something => (0, exports.isResourceIdentifier)(something) || (0, exports.isResourceIdentifierUnsafeInput)(something);\nexports.isResourceIdentifierOrUnsafeInput = isResourceIdentifierOrUnsafeInput;\nconst fromUnsafe = input => (0, exports.isResourceIdentifier)(input) ? (0, neverthrow_1.ok)(input) : typeof input === 'string' ? fromBech32String(input) : fromBuffer(input);\nexports.ResourceIdentifier = {\n  systemRRIForNetwork,\n  fromPublicKeyAndNameAndNetwork,\n  fromUnsafe\n};","map":{"version":3,"names":["neverthrow_1","require","util_1","crypto_1","primitives_1","bech32_1","encoding","Encoding","BECH32","maxLength","undefined","versionByteNativeToken","versionByteNonNativeToken","hrpSuffixFromNetwork","network","HRP","RRI_suffix","networkFromHRPSuffix","hrp","mainnet","ok","Network","MAINNET","stokenet","STOKENET","localnet","LOCALNET","releasenet","RELEASENET","rcnet","RCNET","milestonenet","MILESTONENET","testnet6","TESTNET6","sandpitnet","SANDPITNET","err","Error","concat","__create","input","Object","assign","__witness","equals","other","exports","isResourceIdentifier","same","name","buffersEquals","hash","toString","errMsg","console","error","fromBech32String","bechString","decodingResult","Bech32","decode","isOk","msgFromError","decoded","value","keys","some","endsWith","nameToValidate","split","hrpSuffix","networkResult","nameValidationResult","validateCharsInName","processed","data","combinedDataResult","convertDataFromBech32","combinedData","length","versionByte","isNativeToken","regexLowerAlphaNumerics","RegExp","test","withNameRawDataAndVersionByte","andThen","Buffer","from","convertDataToBech32","encode","map","bech32","systemRRIForNetwork","alloc","hashByteCount","pkToHash","publicKey","nameBytes","pubKeyBytes","asData","compressed","dataToHash","sha256Twice","slice","fromPublicKeyAndNameAndNetwork","fromBuffer","buffer","something","inspection","isResourceIdentifierUnsafeInput","isBuffer","isResourceIdentifierOrUnsafeInput","fromUnsafe","ResourceIdentifier"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/account/src/addresses/resourceIdentifier.ts"],"sourcesContent":["import { err, ok, Result } from 'neverthrow'\nimport { buffersEquals, msgFromError } from '@radixdlt/util'\nimport { PublicKeyT, sha256Twice } from '@radixdlt/crypto'\nimport { HRP, hrpFullSuffixLength, Network } from '@radixdlt/primitives'\nimport { Bech32, Encoding } from '../bech32'\nimport { ResourceIdentifierT } from './_types'\n\nconst encoding = Encoding.BECH32\nconst maxLength: number | undefined = undefined // arbitrarily chosen\n\nconst versionByteNativeToken = 0x01\nconst versionByteNonNativeToken = 0x03\n\nconst hrpSuffixFromNetwork = (network: Network) => HRP[network].RRI_suffix\n\nconst networkFromHRPSuffix = (hrp: string): Result<Network, Error> =>\n\thrp === HRP.mainnet.RRI_suffix\n\t\t? ok(Network.MAINNET)\n\t\t: hrp === HRP.stokenet.RRI_suffix\n\t\t? ok(Network.STOKENET)\n\t\t: hrp === HRP.localnet.RRI_suffix\n\t\t? ok(Network.LOCALNET)\n\t\t: hrp === HRP.releasenet.RRI_suffix\n\t\t? ok(Network.RELEASENET)\n\t\t: hrp === HRP.rcnet.RRI_suffix\n\t\t? ok(Network.RCNET)\n\t\t: hrp === HRP.milestonenet.RRI_suffix\n\t\t? ok(Network.MILESTONENET)\n\t\t: hrp === HRP.testnet6.RRI_suffix\n\t\t? ok(Network.TESTNET6)\n\t\t: hrp === HRP.sandpitnet.RRI_suffix\n\t\t? ok(Network.SANDPITNET)\n\t\t: err(\n\t\t\t\tnew Error(\n\t\t\t\t\t`Failed to parse network from HRP ${hrp} for ValidatorAddress.`,\n\t\t\t\t),\n\t\t  )\n\nconst __create = (input: {\n\thash: Buffer\n\tname: string\n\tnetwork: Network\n\ttoString: () => string\n}): ResourceIdentifierT => ({\n\t...input,\n\t__witness: 'isRRI',\n\tequals: (other): boolean => {\n\t\tif (!isResourceIdentifier(other)) return false\n\t\tconst same =\n\t\t\tother.name === input.name &&\n\t\t\tbuffersEquals(other.hash, input.hash) &&\n\t\t\tinput.network === other.network\n\t\tif (same) {\n\t\t\tif (other.toString() !== input.toString()) {\n\t\t\t\tconst errMsg = `ResourceIdentifiers believed to be equal, but return different values when calling toString, (this)'${input.toString()}' vs other: '${other.toString()}'`\n\t\t\t\tconsole.error(errMsg)\n\t\t\t\tthrow new Error(errMsg)\n\t\t\t}\n\t\t}\n\t\treturn same\n\t},\n})\n\nconst fromBech32String = (\n\tbechString: string,\n): Result<ResourceIdentifierT, Error> => {\n\t// const hrpSuffix = hrpBetanetSuffix // TODO make dependent on Network!\n\n\tconst decodingResult = Bech32.decode({ bechString, encoding, maxLength })\n\n\tif (!decodingResult.isOk()) {\n\t\tconst errMsg = `Failed to Bech32 decode RRI, underlying error: ${msgFromError(\n\t\t\tdecodingResult.error,\n\t\t)}`\n\t\treturn err(new Error(errMsg))\n\t}\n\tconst decoded = decodingResult.value\n\tconst hrp = decoded.hrp\n\n\tif (\n\t\t!Object.keys(HRP).some(network =>\n\t\t\thrp.endsWith(HRP[network as Network].RRI_suffix),\n\t\t)\n\t) {\n\t\tconst errMsg = `suffix found for hrp \"${hrp}\" not supported.`\n\t\treturn err(new Error(errMsg))\n\t}\n\n\tconst nameToValidate = hrp.split('_')[0]\n\tconst hrpSuffix = '_' + hrp.split('_')[1]\n\tconst networkResult = networkFromHRPSuffix(hrpSuffix)\n\n\tif (!networkResult.isOk()) {\n\t\tconst errMsg = `Expected to get network from HRP suffix '${hrpSuffix}', but failed to get it.`\n\t\treturn err(new Error(errMsg))\n\t}\n\tconst network = networkResult.value\n\n\tconst nameValidationResult = validateCharsInName(nameToValidate)\n\n\tif (!nameValidationResult.isOk()) {\n\t\treturn err(nameValidationResult.error)\n\t}\n\tconst name = nameValidationResult.value\n\n\tconst processed = decoded.data\n\tconst combinedDataResult = Bech32.convertDataFromBech32(processed)\n\n\tif (!combinedDataResult.isOk()) {\n\t\tconst errMsg = `Failed to convertDataFromBech32 data, underlying error: ${msgFromError(\n\t\t\tcombinedDataResult.error,\n\t\t)}`\n\t\tconsole.error(errMsg)\n\t\treturn err(new Error(errMsg))\n\t}\n\n\tconst combinedData = combinedDataResult.value\n\n\tif (combinedData.length === 0) {\n\t\tconst errMsg = `The data part of RRI should NEVER be empty, must at least contain 1 version byte ('${versionByteNativeToken}' for native token, or '${versionByteNonNativeToken}' for other tokens)`\n\t\tconsole.error(errMsg)\n\t\treturn err(new Error(errMsg))\n\t}\n\n\tconst versionByte = combinedData[0]\n\n\tif (\n\t\t!(\n\t\t\tversionByte === versionByteNativeToken ||\n\t\t\tversionByte === versionByteNonNativeToken\n\t\t)\n\t) {\n\t\tconst errMsg = `The version byte must be either: '${versionByteNativeToken}' for native token, or '${versionByteNonNativeToken}' for other tokens, but got: ${versionByte}, bechString: '${bechString}'`\n\t\tconsole.error(errMsg)\n\t\treturn err(new Error(errMsg))\n\t}\n\n\tconst isNativeToken = versionByte === versionByteNativeToken\n\n\tif (isNativeToken) {\n\t\tif (combinedData.length > 1) {\n\t\t\tconst errMsg = `Expected data to be empty for native token, but got: #${\n\t\t\t\tcombinedData.length - 1 // minus 1 because we substract the 'versionByte'\n\t\t\t} bytes`\n\t\t\tconsole.error(errMsg)\n\t\t\treturn err(new Error(errMsg))\n\t\t}\n\t} else {\n\t\tif (combinedData.length <= 1) {\n\t\t\tconst errMsg = `Expected data to be non empty for non native token`\n\t\t\tconsole.error(errMsg)\n\t\t\treturn err(new Error(errMsg))\n\t\t}\n\t}\n\n\treturn ok(\n\t\t__create({\n\t\t\thash: combinedData,\n\t\t\tnetwork,\n\t\t\tname,\n\t\t\ttoString: () => bechString,\n\t\t}),\n\t)\n}\n\nconst validateCharsInName = (name: string): Result<string, Error> => {\n\tconst regexLowerAlphaNumerics = new RegExp('^[a-z0-9]+$')\n\tif (!regexLowerAlphaNumerics.test(name)) {\n\t\tconst errMsg = `Illegal characters found in name`\n\t\t// console.error(errMsg)\n\t\treturn err(new Error(errMsg))\n\t}\n\treturn ok(name)\n}\n\nconst withNameRawDataAndVersionByte = (\n\tinput: Readonly<{\n\t\thash: Buffer\n\t\tnetwork: Network\n\t\tversionByte: number\n\t\tname: string\n\t}>,\n): Result<ResourceIdentifierT, Error> => {\n\tconst { versionByte, hash, network } = input\n\tconst hrpSuffix = hrpSuffixFromNetwork(network)\n\n\treturn validateCharsInName(input.name).andThen(name => {\n\t\tconst hrp = `${name}${hrpSuffix}`\n\n\t\tconst combinedData = Buffer.concat([Buffer.from([versionByte]), hash])\n\n\t\treturn Bech32.convertDataToBech32(combinedData)\n\t\t\t.andThen(processed =>\n\t\t\t\tBech32.encode({\n\t\t\t\t\tdata: processed,\n\t\t\t\t\thrp,\n\t\t\t\t\tencoding,\n\t\t\t\t\tmaxLength,\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.map(bech32 =>\n\t\t\t\t__create({\n\t\t\t\t\thash,\n\t\t\t\t\tnetwork,\n\t\t\t\t\tname,\n\t\t\t\t\ttoString: () => bech32.toString(),\n\t\t\t\t}),\n\t\t\t)\n\t})\n}\n\nconst systemRRIForNetwork = (\n\tinput: Readonly<{\n\t\tname: string\n\t\tnetwork: Network\n\t}>,\n): Result<ResourceIdentifierT, Error> =>\n\twithNameRawDataAndVersionByte({\n\t\t...input,\n\t\tversionByte: versionByteNativeToken,\n\t\thash: Buffer.alloc(0),\n\t})\n\nconst hashByteCount = 26\n\nconst pkToHash = (\n\tinput: Readonly<{\n\t\tname: string\n\t\tpublicKey: PublicKeyT\n\t}>,\n): Buffer => {\n\tconst { name, publicKey } = input\n\tconst nameBytes = Buffer.from(name, 'utf8')\n\tconst pubKeyBytes = publicKey.asData({ compressed: true })\n\tconst dataToHash = Buffer.concat([pubKeyBytes, nameBytes])\n\tconst hash = sha256Twice(dataToHash)\n\treturn hash.slice(-hashByteCount) // last bytes\n}\n\nconst fromPublicKeyAndNameAndNetwork = (\n\tinput: Readonly<{\n\t\tpublicKey: PublicKeyT\n\t\tname: string\n\t\tnetwork: Network\n\t}>,\n): Result<ResourceIdentifierT, Error> =>\n\twithNameRawDataAndVersionByte({\n\t\t...input,\n\t\tversionByte: versionByteNonNativeToken,\n\t\thash: pkToHash(input),\n\t})\n\nconst fromBuffer = (buffer: Buffer): Result<ResourceIdentifierT, Error> => {\n\tif (buffer.length === 1 && buffer[0] === 0x01) {\n\t\treturn systemRRIForNetwork({\n\t\t\tname: 'xrd',\n\t\t\tnetwork: Network.MAINNET, // Yikes!\n\t\t})\n\t}\n\treturn err(\n\t\tnew Error(\n\t\t\t'Failed to create non XRD RRI because we do not have access to the HRP.',\n\t\t),\n\t)\n}\n\nexport const isResourceIdentifier = (\n\tsomething: ResourceIdentifierT | unknown,\n): something is ResourceIdentifierT => {\n\tconst inspection = something as ResourceIdentifierT\n\treturn (\n\t\t// inspection.hash !== undefined &&\n\t\tinspection.__witness !== undefined &&\n\t\tinspection.__witness === 'isRRI' &&\n\t\tinspection.name !== undefined &&\n\t\tinspection.toString !== undefined &&\n\t\tinspection.equals !== undefined\n\t)\n}\n\nexport type ResourceIdentifierUnsafeInput = string | Buffer\n\nexport const isResourceIdentifierUnsafeInput = (\n\tsomething: unknown,\n): something is ResourceIdentifierUnsafeInput =>\n\ttypeof something === 'string' || Buffer.isBuffer(something)\n\nexport type ResourceIdentifierOrUnsafeInput =\n\t| ResourceIdentifierT\n\t| ResourceIdentifierUnsafeInput\n\nexport const isResourceIdentifierOrUnsafeInput = (\n\tsomething: unknown,\n): something is ResourceIdentifierOrUnsafeInput =>\n\tisResourceIdentifier(something) ||\n\tisResourceIdentifierUnsafeInput(something)\n\nconst fromUnsafe = (\n\tinput: ResourceIdentifierOrUnsafeInput,\n): Result<ResourceIdentifierT, Error> =>\n\tisResourceIdentifier(input)\n\t\t? ok(input)\n\t\t: typeof input === 'string'\n\t\t? fromBech32String(input)\n\t\t: fromBuffer(input)\n\nexport const ResourceIdentifier = {\n\tsystemRRIForNetwork,\n\tfromPublicKeyAndNameAndNetwork,\n\tfromUnsafe,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}