{"ast":null,"code":"/**\n * Javascript implementation of PKCS#12.\n *\n * @author Dave Longley\n * @author Stefan Siegl <stesie@brokenpipe.de>\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * The ASN.1 representation of PKCS#12 is as follows\n * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\n *\n * PFX ::= SEQUENCE {\n *   version  INTEGER {v3(3)}(v3,...),\n *   authSafe ContentInfo,\n *   macData  MacData OPTIONAL\n * }\n *\n * MacData ::= SEQUENCE {\n *   mac DigestInfo,\n *   macSalt OCTET STRING,\n *   iterations INTEGER DEFAULT 1\n * }\n * Note: The iterations default is for historical reasons and its use is\n * deprecated. A higher value, like 1024, is recommended.\n *\n * DigestInfo is defined in PKCS#7 as follows:\n *\n * DigestInfo ::= SEQUENCE {\n *   digestAlgorithm DigestAlgorithmIdentifier,\n *   digest Digest\n * }\n *\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of SHA1 there is none.\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *    algorithm OBJECT IDENTIFIER,\n *    parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * Digest ::= OCTET STRING\n *\n *\n * ContentInfo ::= SEQUENCE {\n *   contentType ContentType,\n *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\n * }\n *\n * ContentType ::= OBJECT IDENTIFIER\n *\n * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\n * -- Data if unencrypted\n * -- EncryptedData if password-encrypted\n * -- EnvelopedData if public key-encrypted\n *\n *\n * SafeContents ::= SEQUENCE OF SafeBag\n *\n * SafeBag ::= SEQUENCE {\n *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\n *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\n *   bagAttributes SET OF PKCS12Attribute OPTIONAL\n * }\n *\n * PKCS12Attribute ::= SEQUENCE {\n *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\n *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\n * } -- This type is compatible with the X.500 type 'Attribute'\n *\n * PKCS12AttrSet ATTRIBUTE ::= {\n *   friendlyName | -- from PKCS #9\n *   localKeyId, -- from PKCS #9\n *   ... -- Other attributes are allowed\n * }\n *\n * CertBag ::= SEQUENCE {\n *   certId    BAG-TYPE.&id   ({CertTypes}),\n *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\n * }\n *\n * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\n *   -- DER-encoded X.509 certificate stored in OCTET STRING\n *\n * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\n * -- Base64-encoded SDSI certificate stored in IA5String\n *\n * CertTypes BAG-TYPE ::= {\n *   x509Certificate |\n *   sdsiCertificate,\n *   ... -- For future extensions\n * }\n */\nvar forge = require('./forge');\nrequire('./asn1');\nrequire('./hmac');\nrequire('./oids');\nrequire('./pkcs7asn1');\nrequire('./pbe');\nrequire('./random');\nrequire('./rsa');\nrequire('./sha1');\nrequire('./util');\nrequire('./x509');\n\n// shortcut for asn.1 & PKI API\nvar asn1 = forge.asn1;\nvar pki = forge.pki;\n\n// shortcut for PKCS#12 API\nvar p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\nvar contentInfoValidator = {\n  name: 'ContentInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  // a ContentInfo\n  constructed: true,\n  value: [{\n    name: 'ContentInfo.contentType',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'contentType'\n  }, {\n    name: 'ContentInfo.content',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'content'\n  }]\n};\nvar pfxValidator = {\n  name: 'PFX',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'PFX.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  }, contentInfoValidator, {\n    name: 'PFX.macData',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    optional: true,\n    captureAsn1: 'mac',\n    value: [{\n      name: 'PFX.macData.mac',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      // DigestInfo\n      constructed: true,\n      value: [{\n        name: 'PFX.macData.mac.digestAlgorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        // DigestAlgorithmIdentifier\n        constructed: true,\n        value: [{\n          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: 'macAlgorithm'\n        }, {\n          name: 'PFX.macData.mac.digestAlgorithm.parameters',\n          tagClass: asn1.Class.UNIVERSAL,\n          captureAsn1: 'macAlgorithmParameters'\n        }]\n      }, {\n        name: 'PFX.macData.mac.digest',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: 'macDigest'\n      }]\n    }, {\n      name: 'PFX.macData.macSalt',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: 'macSalt'\n    }, {\n      name: 'PFX.macData.iterations',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      optional: true,\n      capture: 'macIterations'\n    }]\n  }]\n};\nvar safeBagValidator = {\n  name: 'SafeBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'SafeBag.bagId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'bagId'\n  }, {\n    name: 'SafeBag.bagValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'bagValue'\n  }, {\n    name: 'SafeBag.bagAttributes',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    optional: true,\n    capture: 'bagAttributes'\n  }]\n};\nvar attributeValidator = {\n  name: 'Attribute',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'Attribute.attrId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'oid'\n  }, {\n    name: 'Attribute.attrValues',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    capture: 'values'\n  }]\n};\nvar certBagValidator = {\n  name: 'CertBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'CertBag.certId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'certId'\n  }, {\n    name: 'CertBag.certValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    /* So far we only support X.509 certificates (which are wrapped in\n       an OCTET STRING, hence hard code that here). */\n    value: [{\n      name: 'CertBag.certValue[0]',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.OCTETSTRING,\n      constructed: false,\n      capture: 'cert'\n    }]\n  }]\n};\n\n/**\n * Search SafeContents structure for bags with matching attributes.\n *\n * The search can optionally be narrowed by a certain bag type.\n *\n * @param safeContents the SafeContents structure to search in.\n * @param attrName the name of the attribute to compare against.\n * @param attrValue the attribute value to search for.\n * @param [bagType] bag type to narrow search by.\n *\n * @return an array of matching bags.\n */\nfunction _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\n  var result = [];\n  for (var i = 0; i < safeContents.length; i++) {\n    for (var j = 0; j < safeContents[i].safeBags.length; j++) {\n      var bag = safeContents[i].safeBags[j];\n      if (bagType !== undefined && bag.type !== bagType) {\n        continue;\n      }\n      // only filter by bag type, no attribute specified\n      if (attrName === null) {\n        result.push(bag);\n        continue;\n      }\n      if (bag.attributes[attrName] !== undefined && bag.attributes[attrName].indexOf(attrValue) >= 0) {\n        result.push(bag);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\n *\n * @param obj The PKCS#12 PFX in ASN.1 notation.\n * @param strict true to use strict DER decoding, false not to (default: true).\n * @param {String} password Password to decrypt with (optional).\n *\n * @return PKCS#12 PFX object.\n */\np12.pkcs12FromAsn1 = function (obj, strict, password) {\n  // handle args\n  if (typeof strict === 'string') {\n    password = strict;\n    strict = true;\n  } else if (strict === undefined) {\n    strict = true;\n  }\n\n  // validate PFX and capture data\n  var capture = {};\n  var errors = [];\n  if (!asn1.validate(obj, pfxValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#12 PFX. ' + 'ASN.1 object is not an PKCS#12 PFX.');\n    error.errors = error;\n    throw error;\n  }\n  var pfx = {\n    version: capture.version.charCodeAt(0),\n    safeContents: [],\n    /**\n     * Gets bags with matching attributes.\n     *\n     * @param filter the attributes to filter by:\n     *          [localKeyId] the localKeyId to search for.\n     *          [localKeyIdHex] the localKeyId in hex to search for.\n     *          [friendlyName] the friendly name to search for.\n     *          [bagType] bag type to narrow each attribute search by.\n     *\n     * @return a map of attribute type to an array of matching bags or, if no\n     *           attribute was given but a bag type, the map key will be the\n     *           bag type.\n     */\n    getBags: function (filter) {\n      var rval = {};\n      var localKeyId;\n      if ('localKeyId' in filter) {\n        localKeyId = filter.localKeyId;\n      } else if ('localKeyIdHex' in filter) {\n        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\n      }\n\n      // filter on bagType only\n      if (localKeyId === undefined && !('friendlyName' in filter) && 'bagType' in filter) {\n        rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);\n      }\n      if (localKeyId !== undefined) {\n        rval.localKeyId = _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, filter.bagType);\n      }\n      if ('friendlyName' in filter) {\n        rval.friendlyName = _getBagsByAttribute(pfx.safeContents, 'friendlyName', filter.friendlyName, filter.bagType);\n      }\n      return rval;\n    },\n    /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching friendlyName attribute.\n     *\n     * @param friendlyName the friendly name to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching friendlyName attribute.\n     */\n    getBagsByFriendlyName: function (friendlyName, bagType) {\n      return _getBagsByAttribute(pfx.safeContents, 'friendlyName', friendlyName, bagType);\n    },\n    /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching localKeyId attribute.\n     *\n     * @param localKeyId the localKeyId to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching localKeyId attribute.\n     */\n    getBagsByLocalKeyId: function (localKeyId, bagType) {\n      return _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, bagType);\n    }\n  };\n  if (capture.version.charCodeAt(0) !== 3) {\n    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\n    error.version = capture.version.charCodeAt(0);\n    throw error;\n  }\n  if (asn1.derToOid(capture.contentType) !== pki.oids.data) {\n    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\n    error.oid = asn1.derToOid(capture.contentType);\n    throw error;\n  }\n  var data = capture.content.value[0];\n  if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\n  }\n  data = _decodePkcs7Data(data);\n\n  // check for MAC\n  if (capture.mac) {\n    var md = null;\n    var macKeyBytes = 0;\n    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\n    switch (macAlgorithm) {\n      case pki.oids.sha1:\n        md = forge.md.sha1.create();\n        macKeyBytes = 20;\n        break;\n      case pki.oids.sha256:\n        md = forge.md.sha256.create();\n        macKeyBytes = 32;\n        break;\n      case pki.oids.sha384:\n        md = forge.md.sha384.create();\n        macKeyBytes = 48;\n        break;\n      case pki.oids.sha512:\n        md = forge.md.sha512.create();\n        macKeyBytes = 64;\n        break;\n      case pki.oids.md5:\n        md = forge.md.md5.create();\n        macKeyBytes = 16;\n        break;\n    }\n    if (md === null) {\n      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\n    }\n\n    // verify MAC (iterations default to 1)\n    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\n    var macIterations = 'macIterations' in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;\n    var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);\n    var mac = forge.hmac.create();\n    mac.start(md, macKey);\n    mac.update(data.value);\n    var macValue = mac.getMac();\n    if (macValue.getBytes() !== capture.macDigest) {\n      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\n    }\n  }\n  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\n  return pfx;\n};\n\n/**\n * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\n * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\n * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\n * function transforms this corner-case into the usual simple,\n * non-composed/constructed OCTET STRING.\n *\n * This function may be moved to ASN.1 at some point to better deal with\n * more BER-encoding issues, should they arise.\n *\n * @param data the ASN.1 Data object to transform.\n */\nfunction _decodePkcs7Data(data) {\n  // handle special case of \"chunked\" data content: an octet string composed\n  // of other octet strings\n  if (data.composed || data.constructed) {\n    var value = forge.util.createBuffer();\n    for (var i = 0; i < data.value.length; ++i) {\n      value.putBytes(data.value[i].value);\n    }\n    data.composed = data.constructed = false;\n    data.value = value.getBytes();\n  }\n  return data;\n}\n\n/**\n * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\n *\n * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\n *\n * @param pfx The PKCS#12 PFX object to fill.\n * @param {String} authSafe BER-encoded AuthenticatedSafe.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n */\nfunction _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\n  authSafe = asn1.fromDer(authSafe, strict); /* actually it's BER encoded */\n\n  if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {\n    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' + 'SEQUENCE OF ContentInfo');\n  }\n  for (var i = 0; i < authSafe.value.length; i++) {\n    var contentInfo = authSafe.value[i];\n\n    // validate contentInfo and capture data\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\n      var error = new Error('Cannot read ContentInfo.');\n      error.errors = errors;\n      throw error;\n    }\n    var obj = {\n      encrypted: false\n    };\n    var safeContents = null;\n    var data = capture.content.value[0];\n    switch (asn1.derToOid(capture.contentType)) {\n      case pki.oids.data:\n        if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n          throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\n        }\n        safeContents = _decodePkcs7Data(data).value;\n        break;\n      case pki.oids.encryptedData:\n        safeContents = _decryptSafeContents(data, password);\n        obj.encrypted = true;\n        break;\n      default:\n        var error = new Error('Unsupported PKCS#12 contentType.');\n        error.contentType = asn1.derToOid(capture.contentType);\n        throw error;\n    }\n    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\n    pfx.safeContents.push(obj);\n  }\n}\n\n/**\n * Decrypt PKCS#7 EncryptedData structure.\n *\n * @param data ASN.1 encoded EncryptedContentInfo object.\n * @param password The user-provided password.\n *\n * @return The decrypted SafeContents (ASN.1 object).\n */\nfunction _decryptSafeContents(data, password) {\n  var capture = {};\n  var errors = [];\n  if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\n    var error = new Error('Cannot read EncryptedContentInfo.');\n    error.errors = errors;\n    throw error;\n  }\n  var oid = asn1.derToOid(capture.contentType);\n  if (oid !== pki.oids.data) {\n    var error = new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.');\n    error.oid = oid;\n    throw error;\n  }\n\n  // get cipher\n  oid = asn1.derToOid(capture.encAlgorithm);\n  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);\n\n  // get encrypted data\n  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\n  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\n  cipher.update(encrypted);\n  if (!cipher.finish()) {\n    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\n  }\n  return cipher.output.getBytes();\n}\n\n/**\n * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\n *\n * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\n *\n * @param {String} safeContents BER-encoded safeContents.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n *\n * @return {Array} Array of Bag objects.\n */\nfunction _decodeSafeContents(safeContents, strict, password) {\n  // if strict and no safe contents, return empty safes\n  if (!strict && safeContents.length === 0) {\n    return [];\n  }\n\n  // actually it's BER-encoded\n  safeContents = asn1.fromDer(safeContents, strict);\n  if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {\n    throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\n  }\n  var res = [];\n  for (var i = 0; i < safeContents.value.length; i++) {\n    var safeBag = safeContents.value[i];\n\n    // validate SafeBag and capture data\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\n      var error = new Error('Cannot read SafeBag.');\n      error.errors = errors;\n      throw error;\n    }\n\n    /* Create bag object and push to result array. */\n    var bag = {\n      type: asn1.derToOid(capture.bagId),\n      attributes: _decodeBagAttributes(capture.bagAttributes)\n    };\n    res.push(bag);\n    var validator, decoder;\n    var bagAsn1 = capture.bagValue.value[0];\n    switch (bag.type) {\n      case pki.oids.pkcs8ShroudedKeyBag:\n        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\n           Afterwards we can handle it like a keyBag,\n           which is a PrivateKeyInfo. */\n        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\n        if (bagAsn1 === null) {\n          throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\n        }\n\n      /* fall through */\n      case pki.oids.keyBag:\n        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\n           PKI module, hence we don't have to do validation/capturing here,\n           just pass what we already got. */\n        try {\n          bag.key = pki.privateKeyFromAsn1(bagAsn1);\n        } catch (e) {\n          // ignore unknown key type, pass asn1 value\n          bag.key = null;\n          bag.asn1 = bagAsn1;\n        }\n        continue;\n      /* Nothing more to do. */\n\n      case pki.oids.certBag:\n        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\n           Therefore put the SafeBag content through another validator to\n           capture the fields.  Afterwards check & store the results. */\n        validator = certBagValidator;\n        decoder = function () {\n          if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\n            var error = new Error('Unsupported certificate type, only X.509 supported.');\n            error.oid = asn1.derToOid(capture.certId);\n            throw error;\n          }\n\n          // true=produce cert hash\n          var certAsn1 = asn1.fromDer(capture.cert, strict);\n          try {\n            bag.cert = pki.certificateFromAsn1(certAsn1, true);\n          } catch (e) {\n            // ignore unknown cert type, pass asn1 value\n            bag.cert = null;\n            bag.asn1 = certAsn1;\n          }\n        };\n        break;\n      default:\n        var error = new Error('Unsupported PKCS#12 SafeBag type.');\n        error.oid = bag.type;\n        throw error;\n    }\n\n    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\n    if (validator !== undefined && !asn1.validate(bagAsn1, validator, capture, errors)) {\n      var error = new Error('Cannot read PKCS#12 ' + validator.name);\n      error.errors = errors;\n      throw error;\n    }\n\n    /* Call decoder function from above to store the results. */\n    decoder();\n  }\n  return res;\n}\n\n/**\n * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\n *\n * @param attributes SET OF PKCS12Attribute (ASN.1 object).\n *\n * @return the decoded attributes.\n */\nfunction _decodeBagAttributes(attributes) {\n  var decodedAttrs = {};\n  if (attributes !== undefined) {\n    for (var i = 0; i < attributes.length; ++i) {\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\n        var error = new Error('Cannot read PKCS#12 BagAttribute.');\n        error.errors = errors;\n        throw error;\n      }\n      var oid = asn1.derToOid(capture.oid);\n      if (pki.oids[oid] === undefined) {\n        // unsupported attribute type, ignore.\n        continue;\n      }\n      decodedAttrs[pki.oids[oid]] = [];\n      for (var j = 0; j < capture.values.length; ++j) {\n        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\n      }\n    }\n  }\n  return decodedAttrs;\n}\n\n/**\n * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\n * password is provided then the private key will be encrypted.\n *\n * An entire certificate chain may also be included. To do this, pass\n * an array for the \"cert\" parameter where the first certificate is\n * the one that is paired with the private key and each subsequent one\n * verifies the previous one. The certificates may be in PEM format or\n * have been already parsed by Forge.\n *\n * @todo implement password-based-encryption for the whole package\n *\n * @param key the private key.\n * @param cert the certificate (may be an array of certificates in order\n *          to specify a certificate chain).\n * @param password the password to use, null for none.\n * @param options:\n *          algorithm the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\n *          count the iteration count to use.\n *          saltSize the salt size to use.\n *          useMac true to include a MAC, false not to, defaults to true.\n *          localKeyId the local key ID to use, in hex.\n *          friendlyName the friendly name to use.\n *          generateLocalKeyId true to generate a random local key ID,\n *            false not to, defaults to true.\n *\n * @return the PKCS#12 PFX ASN.1 object.\n */\np12.toPkcs12Asn1 = function (key, cert, password, options) {\n  // set default options\n  options = options || {};\n  options.saltSize = options.saltSize || 8;\n  options.count = options.count || 2048;\n  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\n  if (!('useMac' in options)) {\n    options.useMac = true;\n  }\n  if (!('localKeyId' in options)) {\n    options.localKeyId = null;\n  }\n  if (!('generateLocalKeyId' in options)) {\n    options.generateLocalKeyId = true;\n  }\n  var localKeyId = options.localKeyId;\n  var bagAttrs;\n  if (localKeyId !== null) {\n    localKeyId = forge.util.hexToBytes(localKeyId);\n  } else if (options.generateLocalKeyId) {\n    // use SHA-1 of paired cert, if available\n    if (cert) {\n      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\n      if (typeof pairedCert === 'string') {\n        pairedCert = pki.certificateFromPem(pairedCert);\n      }\n      var sha1 = forge.md.sha1.create();\n      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\n      localKeyId = sha1.digest().getBytes();\n    } else {\n      // FIXME: consider using SHA-1 of public key (which can be generated\n      // from private key components), see: cert.generateSubjectKeyIdentifier\n      // generate random bytes\n      localKeyId = forge.random.getBytes(20);\n    }\n  }\n  var attrs = [];\n  if (localKeyId !== null) {\n    attrs.push(\n    // localKeyID\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // attrId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()),\n    // attrValues\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)])]));\n  }\n  if ('friendlyName' in options) {\n    attrs.push(\n    // friendlyName\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // attrId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()),\n    // attrValues\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)])]));\n  }\n  if (attrs.length > 0) {\n    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\n  }\n\n  // collect contents for AuthenticatedSafe\n  var contents = [];\n\n  // create safe bag(s) for certificate chain\n  var chain = [];\n  if (cert !== null) {\n    if (forge.util.isArray(cert)) {\n      chain = cert;\n    } else {\n      chain = [cert];\n    }\n  }\n  var certSafeBags = [];\n  for (var i = 0; i < chain.length; ++i) {\n    // convert cert from PEM as necessary\n    cert = chain[i];\n    if (typeof cert === 'string') {\n      cert = pki.certificateFromPem(cert);\n    }\n\n    // SafeBag\n    var certBagAttrs = i === 0 ? bagAttrs : undefined;\n    var certAsn1 = pki.certificateToAsn1(cert);\n    var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // bagId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()),\n    // bagValue\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n    // CertBag\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // certId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()),\n    // certValue (x509Certificate)\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())])])]),\n    // bagAttributes (OPTIONAL)\n    certBagAttrs]);\n    certSafeBags.push(certSafeBag);\n  }\n  if (certSafeBags.length > 0) {\n    // SafeContents\n    var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);\n\n    // ContentInfo\n    var certCI =\n    // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // contentType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n    // OID for the content type is 'data'\n    asn1.oidToDer(pki.oids.data).getBytes()),\n    // content\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())])]);\n    contents.push(certCI);\n  }\n\n  // create safe contents for private key\n  var keyBag = null;\n  if (key !== null) {\n    // SafeBag\n    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\n    if (password === null) {\n      // no encryption\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // bagId\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()),\n      // bagValue\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n      // PrivateKeyInfo\n      pkAsn1]),\n      // bagAttributes (OPTIONAL)\n      bagAttrs]);\n    } else {\n      // encrypted PrivateKeyInfo\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // bagId\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),\n      // bagValue\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n      // EncryptedPrivateKeyInfo\n      pki.encryptPrivateKeyInfo(pkAsn1, password, options)]),\n      // bagAttributes (OPTIONAL)\n      bagAttrs]);\n    }\n\n    // SafeContents\n    var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);\n\n    // ContentInfo\n    var keyCI =\n    // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // contentType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n    // OID for the content type is 'data'\n    asn1.oidToDer(pki.oids.data).getBytes()),\n    // content\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())])]);\n    contents.push(keyCI);\n  }\n\n  // create AuthenticatedSafe by stringing together the contents\n  var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\n  var macData;\n  if (options.useMac) {\n    // MacData\n    var sha1 = forge.md.sha1.create();\n    var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));\n    var count = options.count;\n    // 160-bit key\n    var key = p12.generateKey(password, macSalt, 3, count, 20);\n    var mac = forge.hmac.create();\n    mac.start(sha1, key);\n    mac.update(asn1.toDer(safe).getBytes());\n    var macValue = mac.getMac();\n    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // mac DigestInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // digestAlgorithm\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // algorithm = SHA-1\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()),\n    // parameters = Null\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]),\n    // digest\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())]),\n    // macSalt OCTET STRING\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),\n    // iterations INTEGER (XXX: Only support count < 65536)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())]);\n  }\n\n  // PFX\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n  // version (3)\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()),\n  // PKCS#7 ContentInfo\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n  // contentType\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n  // OID for the content type is 'data'\n  asn1.oidToDer(pki.oids.data).getBytes()),\n  // content\n  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())])]), macData]);\n};\n\n/**\n * Derives a PKCS#12 key.\n *\n * @param password the password to derive the key material from, null or\n *          undefined for none.\n * @param salt the salt, as a ByteBuffer, to use.\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\n * @param iter the iteration count.\n * @param n the number of bytes to derive from the password.\n * @param md the message digest to use, defaults to SHA-1.\n *\n * @return a ByteBuffer with the bytes derived from the password.\n */\np12.generateKey = forge.pbe.generatePkcs12Key;","map":{"version":3,"names":["forge","require","asn1","pki","p12","module","exports","pkcs12","contentInfoValidator","name","tagClass","Class","UNIVERSAL","type","Type","SEQUENCE","constructed","value","OID","capture","CONTEXT_SPECIFIC","captureAsn1","pfxValidator","INTEGER","optional","OCTETSTRING","safeBagValidator","SET","attributeValidator","certBagValidator","_getBagsByAttribute","safeContents","attrName","attrValue","bagType","result","i","length","j","safeBags","bag","undefined","push","attributes","indexOf","pkcs12FromAsn1","obj","strict","password","errors","validate","error","Error","pfx","version","charCodeAt","getBags","filter","rval","localKeyId","util","hexToBytes","localKeyIdHex","friendlyName","getBagsByFriendlyName","getBagsByLocalKeyId","derToOid","contentType","oids","data","oid","content","_decodePkcs7Data","mac","md","macKeyBytes","macAlgorithm","sha1","create","sha256","sha384","sha512","md5","macSalt","ByteBuffer","macIterations","parseInt","bytesToHex","macKey","generateKey","hmac","start","update","macValue","getMac","getBytes","macDigest","_decodeAuthenticatedSafe","composed","createBuffer","putBytes","authSafe","fromDer","contentInfo","encrypted","encryptedData","_decryptSafeContents","_decodeSafeContents","pkcs7","encryptedDataValidator","encAlgorithm","cipher","pbe","getCipher","encParameter","encryptedContentAsn1","finish","output","res","safeBag","bagId","_decodeBagAttributes","bagAttributes","validator","decoder","bagAsn1","bagValue","pkcs8ShroudedKeyBag","decryptPrivateKeyInfo","keyBag","key","privateKeyFromAsn1","e","certBag","certId","x509Certificate","certAsn1","cert","certificateFromAsn1","decodedAttrs","values","toPkcs12Asn1","options","saltSize","count","algorithm","useMac","generateLocalKeyId","bagAttrs","pairedCert","isArray","certificateFromPem","toDer","certificateToAsn1","digest","random","attrs","oidToDer","BMPSTRING","contents","chain","certSafeBags","certBagAttrs","certSafeBag","certSafeContents","certCI","pkAsn1","wrapRsaPrivateKey","privateKeyToAsn1","encryptPrivateKeyInfo","keySafeContents","keyCI","safe","macData","NULL","integerToDer","generatePkcs12Key"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/node-forge/lib/pkcs12.js"],"sourcesContent":["/**\n * Javascript implementation of PKCS#12.\n *\n * @author Dave Longley\n * @author Stefan Siegl <stesie@brokenpipe.de>\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * The ASN.1 representation of PKCS#12 is as follows\n * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\n *\n * PFX ::= SEQUENCE {\n *   version  INTEGER {v3(3)}(v3,...),\n *   authSafe ContentInfo,\n *   macData  MacData OPTIONAL\n * }\n *\n * MacData ::= SEQUENCE {\n *   mac DigestInfo,\n *   macSalt OCTET STRING,\n *   iterations INTEGER DEFAULT 1\n * }\n * Note: The iterations default is for historical reasons and its use is\n * deprecated. A higher value, like 1024, is recommended.\n *\n * DigestInfo is defined in PKCS#7 as follows:\n *\n * DigestInfo ::= SEQUENCE {\n *   digestAlgorithm DigestAlgorithmIdentifier,\n *   digest Digest\n * }\n *\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of SHA1 there is none.\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *    algorithm OBJECT IDENTIFIER,\n *    parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * Digest ::= OCTET STRING\n *\n *\n * ContentInfo ::= SEQUENCE {\n *   contentType ContentType,\n *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\n * }\n *\n * ContentType ::= OBJECT IDENTIFIER\n *\n * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\n * -- Data if unencrypted\n * -- EncryptedData if password-encrypted\n * -- EnvelopedData if public key-encrypted\n *\n *\n * SafeContents ::= SEQUENCE OF SafeBag\n *\n * SafeBag ::= SEQUENCE {\n *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\n *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\n *   bagAttributes SET OF PKCS12Attribute OPTIONAL\n * }\n *\n * PKCS12Attribute ::= SEQUENCE {\n *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\n *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\n * } -- This type is compatible with the X.500 type 'Attribute'\n *\n * PKCS12AttrSet ATTRIBUTE ::= {\n *   friendlyName | -- from PKCS #9\n *   localKeyId, -- from PKCS #9\n *   ... -- Other attributes are allowed\n * }\n *\n * CertBag ::= SEQUENCE {\n *   certId    BAG-TYPE.&id   ({CertTypes}),\n *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\n * }\n *\n * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\n *   -- DER-encoded X.509 certificate stored in OCTET STRING\n *\n * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\n * -- Base64-encoded SDSI certificate stored in IA5String\n *\n * CertTypes BAG-TYPE ::= {\n *   x509Certificate |\n *   sdsiCertificate,\n *   ... -- For future extensions\n * }\n */\nvar forge = require('./forge');\nrequire('./asn1');\nrequire('./hmac');\nrequire('./oids');\nrequire('./pkcs7asn1');\nrequire('./pbe');\nrequire('./random');\nrequire('./rsa');\nrequire('./sha1');\nrequire('./util');\nrequire('./x509');\n\n// shortcut for asn.1 & PKI API\nvar asn1 = forge.asn1;\nvar pki = forge.pki;\n\n// shortcut for PKCS#12 API\nvar p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\n\nvar contentInfoValidator = {\n  name: 'ContentInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,  // a ContentInfo\n  constructed: true,\n  value: [{\n    name: 'ContentInfo.contentType',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'contentType'\n  }, {\n    name: 'ContentInfo.content',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'content'\n  }]\n};\n\nvar pfxValidator = {\n  name: 'PFX',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'PFX.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  },\n  contentInfoValidator, {\n    name: 'PFX.macData',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    optional: true,\n    captureAsn1: 'mac',\n    value: [{\n      name: 'PFX.macData.mac',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,  // DigestInfo\n      constructed: true,\n      value: [{\n        name: 'PFX.macData.mac.digestAlgorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,  // DigestAlgorithmIdentifier\n        constructed: true,\n        value: [{\n          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: 'macAlgorithm'\n        }, {\n          name: 'PFX.macData.mac.digestAlgorithm.parameters',\n          tagClass: asn1.Class.UNIVERSAL,\n          captureAsn1: 'macAlgorithmParameters'\n        }]\n      }, {\n        name: 'PFX.macData.mac.digest',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: 'macDigest'\n      }]\n    }, {\n      name: 'PFX.macData.macSalt',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: 'macSalt'\n    }, {\n      name: 'PFX.macData.iterations',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      optional: true,\n      capture: 'macIterations'\n    }]\n  }]\n};\n\nvar safeBagValidator = {\n  name: 'SafeBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'SafeBag.bagId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'bagId'\n  }, {\n    name: 'SafeBag.bagValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'bagValue'\n  }, {\n    name: 'SafeBag.bagAttributes',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    optional: true,\n    capture: 'bagAttributes'\n  }]\n};\n\nvar attributeValidator = {\n  name: 'Attribute',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'Attribute.attrId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'oid'\n  }, {\n    name: 'Attribute.attrValues',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    capture: 'values'\n  }]\n};\n\nvar certBagValidator = {\n  name: 'CertBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'CertBag.certId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'certId'\n  }, {\n    name: 'CertBag.certValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    /* So far we only support X.509 certificates (which are wrapped in\n       an OCTET STRING, hence hard code that here). */\n    value: [{\n      name: 'CertBag.certValue[0]',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.OCTETSTRING,\n      constructed: false,\n      capture: 'cert'\n    }]\n  }]\n};\n\n/**\n * Search SafeContents structure for bags with matching attributes.\n *\n * The search can optionally be narrowed by a certain bag type.\n *\n * @param safeContents the SafeContents structure to search in.\n * @param attrName the name of the attribute to compare against.\n * @param attrValue the attribute value to search for.\n * @param [bagType] bag type to narrow search by.\n *\n * @return an array of matching bags.\n */\nfunction _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\n  var result = [];\n\n  for(var i = 0; i < safeContents.length; i++) {\n    for(var j = 0; j < safeContents[i].safeBags.length; j++) {\n      var bag = safeContents[i].safeBags[j];\n      if(bagType !== undefined && bag.type !== bagType) {\n        continue;\n      }\n      // only filter by bag type, no attribute specified\n      if(attrName === null) {\n        result.push(bag);\n        continue;\n      }\n      if(bag.attributes[attrName] !== undefined &&\n        bag.attributes[attrName].indexOf(attrValue) >= 0) {\n        result.push(bag);\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\n *\n * @param obj The PKCS#12 PFX in ASN.1 notation.\n * @param strict true to use strict DER decoding, false not to (default: true).\n * @param {String} password Password to decrypt with (optional).\n *\n * @return PKCS#12 PFX object.\n */\np12.pkcs12FromAsn1 = function(obj, strict, password) {\n  // handle args\n  if(typeof strict === 'string') {\n    password = strict;\n    strict = true;\n  } else if(strict === undefined) {\n    strict = true;\n  }\n\n  // validate PFX and capture data\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(obj, pfxValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#12 PFX. ' +\n      'ASN.1 object is not an PKCS#12 PFX.');\n    error.errors = error;\n    throw error;\n  }\n\n  var pfx = {\n    version: capture.version.charCodeAt(0),\n    safeContents: [],\n\n    /**\n     * Gets bags with matching attributes.\n     *\n     * @param filter the attributes to filter by:\n     *          [localKeyId] the localKeyId to search for.\n     *          [localKeyIdHex] the localKeyId in hex to search for.\n     *          [friendlyName] the friendly name to search for.\n     *          [bagType] bag type to narrow each attribute search by.\n     *\n     * @return a map of attribute type to an array of matching bags or, if no\n     *           attribute was given but a bag type, the map key will be the\n     *           bag type.\n     */\n    getBags: function(filter) {\n      var rval = {};\n\n      var localKeyId;\n      if('localKeyId' in filter) {\n        localKeyId = filter.localKeyId;\n      } else if('localKeyIdHex' in filter) {\n        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\n      }\n\n      // filter on bagType only\n      if(localKeyId === undefined && !('friendlyName' in filter) &&\n        'bagType' in filter) {\n        rval[filter.bagType] = _getBagsByAttribute(\n          pfx.safeContents, null, null, filter.bagType);\n      }\n\n      if(localKeyId !== undefined) {\n        rval.localKeyId = _getBagsByAttribute(\n          pfx.safeContents, 'localKeyId',\n          localKeyId, filter.bagType);\n      }\n      if('friendlyName' in filter) {\n        rval.friendlyName = _getBagsByAttribute(\n          pfx.safeContents, 'friendlyName',\n          filter.friendlyName, filter.bagType);\n      }\n\n      return rval;\n    },\n\n    /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching friendlyName attribute.\n     *\n     * @param friendlyName the friendly name to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching friendlyName attribute.\n     */\n    getBagsByFriendlyName: function(friendlyName, bagType) {\n      return _getBagsByAttribute(\n        pfx.safeContents, 'friendlyName', friendlyName, bagType);\n    },\n\n    /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching localKeyId attribute.\n     *\n     * @param localKeyId the localKeyId to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching localKeyId attribute.\n     */\n    getBagsByLocalKeyId: function(localKeyId, bagType) {\n      return _getBagsByAttribute(\n        pfx.safeContents, 'localKeyId', localKeyId, bagType);\n    }\n  };\n\n  if(capture.version.charCodeAt(0) !== 3) {\n    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\n    error.version = capture.version.charCodeAt(0);\n    throw error;\n  }\n\n  if(asn1.derToOid(capture.contentType) !== pki.oids.data) {\n    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\n    error.oid = asn1.derToOid(capture.contentType);\n    throw error;\n  }\n\n  var data = capture.content.value[0];\n  if(data.tagClass !== asn1.Class.UNIVERSAL ||\n     data.type !== asn1.Type.OCTETSTRING) {\n    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\n  }\n  data = _decodePkcs7Data(data);\n\n  // check for MAC\n  if(capture.mac) {\n    var md = null;\n    var macKeyBytes = 0;\n    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\n    switch(macAlgorithm) {\n    case pki.oids.sha1:\n      md = forge.md.sha1.create();\n      macKeyBytes = 20;\n      break;\n    case pki.oids.sha256:\n      md = forge.md.sha256.create();\n      macKeyBytes = 32;\n      break;\n    case pki.oids.sha384:\n      md = forge.md.sha384.create();\n      macKeyBytes = 48;\n      break;\n    case pki.oids.sha512:\n      md = forge.md.sha512.create();\n      macKeyBytes = 64;\n      break;\n    case pki.oids.md5:\n      md = forge.md.md5.create();\n      macKeyBytes = 16;\n      break;\n    }\n    if(md === null) {\n      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\n    }\n\n    // verify MAC (iterations default to 1)\n    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\n    var macIterations = (('macIterations' in capture) ?\n      parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1);\n    var macKey = p12.generateKey(\n      password, macSalt, 3, macIterations, macKeyBytes, md);\n    var mac = forge.hmac.create();\n    mac.start(md, macKey);\n    mac.update(data.value);\n    var macValue = mac.getMac();\n    if(macValue.getBytes() !== capture.macDigest) {\n      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\n    }\n  }\n\n  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\n  return pfx;\n};\n\n/**\n * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\n * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\n * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\n * function transforms this corner-case into the usual simple,\n * non-composed/constructed OCTET STRING.\n *\n * This function may be moved to ASN.1 at some point to better deal with\n * more BER-encoding issues, should they arise.\n *\n * @param data the ASN.1 Data object to transform.\n */\nfunction _decodePkcs7Data(data) {\n  // handle special case of \"chunked\" data content: an octet string composed\n  // of other octet strings\n  if(data.composed || data.constructed) {\n    var value = forge.util.createBuffer();\n    for(var i = 0; i < data.value.length; ++i) {\n      value.putBytes(data.value[i].value);\n    }\n    data.composed = data.constructed = false;\n    data.value = value.getBytes();\n  }\n  return data;\n}\n\n/**\n * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\n *\n * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\n *\n * @param pfx The PKCS#12 PFX object to fill.\n * @param {String} authSafe BER-encoded AuthenticatedSafe.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n */\nfunction _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\n  authSafe = asn1.fromDer(authSafe, strict);  /* actually it's BER encoded */\n\n  if(authSafe.tagClass !== asn1.Class.UNIVERSAL ||\n     authSafe.type !== asn1.Type.SEQUENCE ||\n     authSafe.constructed !== true) {\n    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' +\n      'SEQUENCE OF ContentInfo');\n  }\n\n  for(var i = 0; i < authSafe.value.length; i++) {\n    var contentInfo = authSafe.value[i];\n\n    // validate contentInfo and capture data\n    var capture = {};\n    var errors = [];\n    if(!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\n      var error = new Error('Cannot read ContentInfo.');\n      error.errors = errors;\n      throw error;\n    }\n\n    var obj = {\n      encrypted: false\n    };\n    var safeContents = null;\n    var data = capture.content.value[0];\n    switch(asn1.derToOid(capture.contentType)) {\n    case pki.oids.data:\n      if(data.tagClass !== asn1.Class.UNIVERSAL ||\n         data.type !== asn1.Type.OCTETSTRING) {\n        throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\n      }\n      safeContents = _decodePkcs7Data(data).value;\n      break;\n    case pki.oids.encryptedData:\n      safeContents = _decryptSafeContents(data, password);\n      obj.encrypted = true;\n      break;\n    default:\n      var error = new Error('Unsupported PKCS#12 contentType.');\n      error.contentType = asn1.derToOid(capture.contentType);\n      throw error;\n    }\n\n    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\n    pfx.safeContents.push(obj);\n  }\n}\n\n/**\n * Decrypt PKCS#7 EncryptedData structure.\n *\n * @param data ASN.1 encoded EncryptedContentInfo object.\n * @param password The user-provided password.\n *\n * @return The decrypted SafeContents (ASN.1 object).\n */\nfunction _decryptSafeContents(data, password) {\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(\n    data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\n    var error = new Error('Cannot read EncryptedContentInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  var oid = asn1.derToOid(capture.contentType);\n  if(oid !== pki.oids.data) {\n    var error = new Error(\n      'PKCS#12 EncryptedContentInfo ContentType is not Data.');\n    error.oid = oid;\n    throw error;\n  }\n\n  // get cipher\n  oid = asn1.derToOid(capture.encAlgorithm);\n  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);\n\n  // get encrypted data\n  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\n  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\n\n  cipher.update(encrypted);\n  if(!cipher.finish()) {\n    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\n  }\n\n  return cipher.output.getBytes();\n}\n\n/**\n * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\n *\n * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\n *\n * @param {String} safeContents BER-encoded safeContents.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n *\n * @return {Array} Array of Bag objects.\n */\nfunction _decodeSafeContents(safeContents, strict, password) {\n  // if strict and no safe contents, return empty safes\n  if(!strict && safeContents.length === 0) {\n    return [];\n  }\n\n  // actually it's BER-encoded\n  safeContents = asn1.fromDer(safeContents, strict);\n\n  if(safeContents.tagClass !== asn1.Class.UNIVERSAL ||\n    safeContents.type !== asn1.Type.SEQUENCE ||\n    safeContents.constructed !== true) {\n    throw new Error(\n      'PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\n  }\n\n  var res = [];\n  for(var i = 0; i < safeContents.value.length; i++) {\n    var safeBag = safeContents.value[i];\n\n    // validate SafeBag and capture data\n    var capture = {};\n    var errors = [];\n    if(!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\n      var error = new Error('Cannot read SafeBag.');\n      error.errors = errors;\n      throw error;\n    }\n\n    /* Create bag object and push to result array. */\n    var bag = {\n      type: asn1.derToOid(capture.bagId),\n      attributes: _decodeBagAttributes(capture.bagAttributes)\n    };\n    res.push(bag);\n\n    var validator, decoder;\n    var bagAsn1 = capture.bagValue.value[0];\n    switch(bag.type) {\n      case pki.oids.pkcs8ShroudedKeyBag:\n        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\n           Afterwards we can handle it like a keyBag,\n           which is a PrivateKeyInfo. */\n        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\n        if(bagAsn1 === null) {\n          throw new Error(\n            'Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\n        }\n\n        /* fall through */\n      case pki.oids.keyBag:\n        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\n           PKI module, hence we don't have to do validation/capturing here,\n           just pass what we already got. */\n        try {\n          bag.key = pki.privateKeyFromAsn1(bagAsn1);\n        } catch(e) {\n          // ignore unknown key type, pass asn1 value\n          bag.key = null;\n          bag.asn1 = bagAsn1;\n        }\n        continue;  /* Nothing more to do. */\n\n      case pki.oids.certBag:\n        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\n           Therefore put the SafeBag content through another validator to\n           capture the fields.  Afterwards check & store the results. */\n        validator = certBagValidator;\n        decoder = function() {\n          if(asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\n            var error = new Error(\n              'Unsupported certificate type, only X.509 supported.');\n            error.oid = asn1.derToOid(capture.certId);\n            throw error;\n          }\n\n          // true=produce cert hash\n          var certAsn1 = asn1.fromDer(capture.cert, strict);\n          try {\n            bag.cert = pki.certificateFromAsn1(certAsn1, true);\n          } catch(e) {\n            // ignore unknown cert type, pass asn1 value\n            bag.cert = null;\n            bag.asn1 = certAsn1;\n          }\n        };\n        break;\n\n      default:\n        var error = new Error('Unsupported PKCS#12 SafeBag type.');\n        error.oid = bag.type;\n        throw error;\n    }\n\n    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\n    if(validator !== undefined &&\n       !asn1.validate(bagAsn1, validator, capture, errors)) {\n      var error = new Error('Cannot read PKCS#12 ' + validator.name);\n      error.errors = errors;\n      throw error;\n    }\n\n    /* Call decoder function from above to store the results. */\n    decoder();\n  }\n\n  return res;\n}\n\n/**\n * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\n *\n * @param attributes SET OF PKCS12Attribute (ASN.1 object).\n *\n * @return the decoded attributes.\n */\nfunction _decodeBagAttributes(attributes) {\n  var decodedAttrs = {};\n\n  if(attributes !== undefined) {\n    for(var i = 0; i < attributes.length; ++i) {\n      var capture = {};\n      var errors = [];\n      if(!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\n        var error = new Error('Cannot read PKCS#12 BagAttribute.');\n        error.errors = errors;\n        throw error;\n      }\n\n      var oid = asn1.derToOid(capture.oid);\n      if(pki.oids[oid] === undefined) {\n        // unsupported attribute type, ignore.\n        continue;\n      }\n\n      decodedAttrs[pki.oids[oid]] = [];\n      for(var j = 0; j < capture.values.length; ++j) {\n        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\n      }\n    }\n  }\n\n  return decodedAttrs;\n}\n\n/**\n * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\n * password is provided then the private key will be encrypted.\n *\n * An entire certificate chain may also be included. To do this, pass\n * an array for the \"cert\" parameter where the first certificate is\n * the one that is paired with the private key and each subsequent one\n * verifies the previous one. The certificates may be in PEM format or\n * have been already parsed by Forge.\n *\n * @todo implement password-based-encryption for the whole package\n *\n * @param key the private key.\n * @param cert the certificate (may be an array of certificates in order\n *          to specify a certificate chain).\n * @param password the password to use, null for none.\n * @param options:\n *          algorithm the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\n *          count the iteration count to use.\n *          saltSize the salt size to use.\n *          useMac true to include a MAC, false not to, defaults to true.\n *          localKeyId the local key ID to use, in hex.\n *          friendlyName the friendly name to use.\n *          generateLocalKeyId true to generate a random local key ID,\n *            false not to, defaults to true.\n *\n * @return the PKCS#12 PFX ASN.1 object.\n */\np12.toPkcs12Asn1 = function(key, cert, password, options) {\n  // set default options\n  options = options || {};\n  options.saltSize = options.saltSize || 8;\n  options.count = options.count || 2048;\n  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\n  if(!('useMac' in options)) {\n    options.useMac = true;\n  }\n  if(!('localKeyId' in options)) {\n    options.localKeyId = null;\n  }\n  if(!('generateLocalKeyId' in options)) {\n    options.generateLocalKeyId = true;\n  }\n\n  var localKeyId = options.localKeyId;\n  var bagAttrs;\n  if(localKeyId !== null) {\n    localKeyId = forge.util.hexToBytes(localKeyId);\n  } else if(options.generateLocalKeyId) {\n    // use SHA-1 of paired cert, if available\n    if(cert) {\n      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\n      if(typeof pairedCert === 'string') {\n        pairedCert = pki.certificateFromPem(pairedCert);\n      }\n      var sha1 = forge.md.sha1.create();\n      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\n      localKeyId = sha1.digest().getBytes();\n    } else {\n      // FIXME: consider using SHA-1 of public key (which can be generated\n      // from private key components), see: cert.generateSubjectKeyIdentifier\n      // generate random bytes\n      localKeyId = forge.random.getBytes(20);\n    }\n  }\n\n  var attrs = [];\n  if(localKeyId !== null) {\n    attrs.push(\n      // localKeyID\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // attrId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.localKeyId).getBytes()),\n        // attrValues\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n            localKeyId)\n        ])\n      ]));\n  }\n  if('friendlyName' in options) {\n    attrs.push(\n      // friendlyName\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // attrId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.friendlyName).getBytes()),\n        // attrValues\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false,\n            options.friendlyName)\n        ])\n      ]));\n  }\n\n  if(attrs.length > 0) {\n    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\n  }\n\n  // collect contents for AuthenticatedSafe\n  var contents = [];\n\n  // create safe bag(s) for certificate chain\n  var chain = [];\n  if(cert !== null) {\n    if(forge.util.isArray(cert)) {\n      chain = cert;\n    } else {\n      chain = [cert];\n    }\n  }\n\n  var certSafeBags = [];\n  for(var i = 0; i < chain.length; ++i) {\n    // convert cert from PEM as necessary\n    cert = chain[i];\n    if(typeof cert === 'string') {\n      cert = pki.certificateFromPem(cert);\n    }\n\n    // SafeBag\n    var certBagAttrs = (i === 0) ? bagAttrs : undefined;\n    var certAsn1 = pki.certificateToAsn1(cert);\n    var certSafeBag =\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // bagId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.certBag).getBytes()),\n        // bagValue\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          // CertBag\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // certId\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n              asn1.oidToDer(pki.oids.x509Certificate).getBytes()),\n            // certValue (x509Certificate)\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n              asn1.create(\n                asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n                asn1.toDer(certAsn1).getBytes())\n            ])])]),\n        // bagAttributes (OPTIONAL)\n        certBagAttrs\n      ]);\n    certSafeBags.push(certSafeBag);\n  }\n\n  if(certSafeBags.length > 0) {\n    // SafeContents\n    var certSafeContents = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);\n\n    // ContentInfo\n    var certCI =\n      // PKCS#7 ContentInfo\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // contentType\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          // OID for the content type is 'data'\n          asn1.oidToDer(pki.oids.data).getBytes()),\n        // content\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          asn1.create(\n            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n            asn1.toDer(certSafeContents).getBytes())\n        ])\n      ]);\n    contents.push(certCI);\n  }\n\n  // create safe contents for private key\n  var keyBag = null;\n  if(key !== null) {\n    // SafeBag\n    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\n    if(password === null) {\n      // no encryption\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // bagId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.keyBag).getBytes()),\n        // bagValue\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          // PrivateKeyInfo\n          pkAsn1\n        ]),\n        // bagAttributes (OPTIONAL)\n        bagAttrs\n      ]);\n    } else {\n      // encrypted PrivateKeyInfo\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // bagId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),\n        // bagValue\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          // EncryptedPrivateKeyInfo\n          pki.encryptPrivateKeyInfo(pkAsn1, password, options)\n        ]),\n        // bagAttributes (OPTIONAL)\n        bagAttrs\n      ]);\n    }\n\n    // SafeContents\n    var keySafeContents =\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);\n\n    // ContentInfo\n    var keyCI =\n      // PKCS#7 ContentInfo\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // contentType\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          // OID for the content type is 'data'\n          asn1.oidToDer(pki.oids.data).getBytes()),\n        // content\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          asn1.create(\n            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n            asn1.toDer(keySafeContents).getBytes())\n        ])\n      ]);\n    contents.push(keyCI);\n  }\n\n  // create AuthenticatedSafe by stringing together the contents\n  var safe = asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\n\n  var macData;\n  if(options.useMac) {\n    // MacData\n    var sha1 = forge.md.sha1.create();\n    var macSalt = new forge.util.ByteBuffer(\n      forge.random.getBytes(options.saltSize));\n    var count = options.count;\n    // 160-bit key\n    var key = p12.generateKey(password, macSalt, 3, count, 20);\n    var mac = forge.hmac.create();\n    mac.start(sha1, key);\n    mac.update(asn1.toDer(safe).getBytes());\n    var macValue = mac.getMac();\n    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // mac DigestInfo\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // digestAlgorithm\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // algorithm = SHA-1\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n            asn1.oidToDer(pki.oids.sha1).getBytes()),\n          // parameters = Null\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n        ]),\n        // digest\n        asn1.create(\n          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,\n          false, macValue.getBytes())\n      ]),\n      // macSalt OCTET STRING\n      asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),\n      // iterations INTEGER (XXX: Only support count < 65536)\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n        asn1.integerToDer(count).getBytes()\n      )\n    ]);\n  }\n\n  // PFX\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // version (3)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      asn1.integerToDer(3).getBytes()),\n    // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // contentType\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        // OID for the content type is 'data'\n        asn1.oidToDer(pki.oids.data).getBytes()),\n      // content\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n        asn1.create(\n          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n          asn1.toDer(safe).getBytes())\n      ])\n    ]),\n    macData\n  ]);\n};\n\n/**\n * Derives a PKCS#12 key.\n *\n * @param password the password to derive the key material from, null or\n *          undefined for none.\n * @param salt the salt, as a ByteBuffer, to use.\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\n * @param iter the iteration count.\n * @param n the number of bytes to derive from the password.\n * @param md the message digest to use, defaults to SHA-1.\n *\n * @return a ByteBuffer with the bytes derived from the password.\n */\np12.generateKey = forge.pbe.generatePkcs12Key;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAS,CAAC;AAC9BA,OAAO,CAAC,QAAQ,CAAC;AACjBA,OAAO,CAAC,QAAQ,CAAC;AACjBA,OAAO,CAAC,QAAQ,CAAC;AACjBA,OAAO,CAAC,aAAa,CAAC;AACtBA,OAAO,CAAC,OAAO,CAAC;AAChBA,OAAO,CAAC,UAAU,CAAC;AACnBA,OAAO,CAAC,OAAO,CAAC;AAChBA,OAAO,CAAC,QAAQ,CAAC;AACjBA,OAAO,CAAC,QAAQ,CAAC;AACjBA,OAAO,CAAC,QAAQ,CAAC;;AAEjB;AACA,IAAIC,IAAI,GAAGF,KAAK,CAACE,IAAI;AACrB,IAAIC,GAAG,GAAGH,KAAK,CAACG,GAAG;;AAEnB;AACA,IAAIC,GAAG,GAAGC,MAAM,CAACC,OAAO,GAAGN,KAAK,CAACO,MAAM,GAAGP,KAAK,CAACO,MAAM,IAAI,CAAC,CAAC;AAE5D,IAAIC,oBAAoB,GAAG;EACzBC,IAAI,EAAE,aAAa;EACnBC,QAAQ,EAAER,IAAI,CAACS,KAAK,CAACC,SAAS;EAC9BC,IAAI,EAAEX,IAAI,CAACY,IAAI,CAACC,QAAQ;EAAG;EAC3BC,WAAW,EAAE,IAAI;EACjBC,KAAK,EAAE,CAAC;IACNR,IAAI,EAAE,yBAAyB;IAC/BC,QAAQ,EAAER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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}