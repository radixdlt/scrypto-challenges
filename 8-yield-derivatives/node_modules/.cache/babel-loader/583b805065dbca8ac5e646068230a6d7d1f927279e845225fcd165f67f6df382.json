{"ast":null,"code":"var BinarySearchTree = require('binary-search-tree').AVLTree,\n  model = require('./model'),\n  _ = require('underscore'),\n  util = require('util');\n\n/**\n * Two indexed pointers are equal iif they point to the same place\n */\nfunction checkValueEquality(a, b) {\n  return a === b;\n}\n\n/**\n * Type-aware projection\n */\nfunction projectForUnique(elt) {\n  if (elt === null) {\n    return '$null';\n  }\n  if (typeof elt === 'string') {\n    return '$string' + elt;\n  }\n  if (typeof elt === 'boolean') {\n    return '$boolean' + elt;\n  }\n  if (typeof elt === 'number') {\n    return '$number' + elt;\n  }\n  if (util.isArray(elt)) {\n    return '$date' + elt.getTime();\n  }\n  return elt; // Arrays and objects, will check for pointer equality\n}\n\n/**\n * Create a new index\n * All methods on an index guarantee that either the whole operation was successful and the index changed\n * or the operation was unsuccessful and an error is thrown while the index is unchanged\n * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)\n * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)\n * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)\n */\nfunction Index(options) {\n  this.fieldName = options.fieldName;\n  this.unique = options.unique || false;\n  this.sparse = options.sparse || false;\n  this.treeOptions = {\n    unique: this.unique,\n    compareKeys: model.compareThings,\n    checkValueEquality: checkValueEquality\n  };\n  this.reset(); // No data in the beginning\n}\n\n/**\n * Reset an index\n * @param {Document or Array of documents} newData Optional, data to initialize the index with\n *                                                 If an error is thrown during insertion, the index is not modified\n */\nIndex.prototype.reset = function (newData) {\n  this.tree = new BinarySearchTree(this.treeOptions);\n  if (newData) {\n    this.insert(newData);\n  }\n};\n\n/**\n * Insert a new document in the index\n * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\n * O(log(n))\n */\nIndex.prototype.insert = function (doc) {\n  var key,\n    self = this,\n    keys,\n    i,\n    failingI,\n    error;\n  if (util.isArray(doc)) {\n    this.insertMultipleDocs(doc);\n    return;\n  }\n  key = model.getDotValue(doc, this.fieldName);\n\n  // We don't index documents that don't contain the field if the index is sparse\n  if (key === undefined && this.sparse) {\n    return;\n  }\n  if (!util.isArray(key)) {\n    this.tree.insert(key, doc);\n  } else {\n    // If an insert fails due to a unique constraint, roll back all inserts before it\n    keys = _.uniq(key, projectForUnique);\n    for (i = 0; i < keys.length; i += 1) {\n      try {\n        this.tree.insert(keys[i], doc);\n      } catch (e) {\n        error = e;\n        failingI = i;\n        break;\n      }\n    }\n    if (error) {\n      for (i = 0; i < failingI; i += 1) {\n        this.tree.delete(keys[i], doc);\n      }\n      throw error;\n    }\n  }\n};\n\n/**\n * Insert an array of documents in the index\n * If a constraint is violated, the changes should be rolled back and an error thrown\n *\n * @API private\n */\nIndex.prototype.insertMultipleDocs = function (docs) {\n  var i, error, failingI;\n  for (i = 0; i < docs.length; i += 1) {\n    try {\n      this.insert(docs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(docs[i]);\n    }\n    throw error;\n  }\n};\n\n/**\n * Remove a document from the index\n * If an array is passed, we remove all its elements\n * The remove operation is safe with regards to the 'unique' constraint\n * O(log(n))\n */\nIndex.prototype.remove = function (doc) {\n  var key,\n    self = this;\n  if (util.isArray(doc)) {\n    doc.forEach(function (d) {\n      self.remove(d);\n    });\n    return;\n  }\n  key = model.getDotValue(doc, this.fieldName);\n  if (key === undefined && this.sparse) {\n    return;\n  }\n  if (!util.isArray(key)) {\n    this.tree.delete(key, doc);\n  } else {\n    _.uniq(key, projectForUnique).forEach(function (_key) {\n      self.tree.delete(_key, doc);\n    });\n  }\n};\n\n/**\n * Update a document in the index\n * If a constraint is violated, changes are rolled back and an error thrown\n * Naive implementation, still in O(log(n))\n */\nIndex.prototype.update = function (oldDoc, newDoc) {\n  if (util.isArray(oldDoc)) {\n    this.updateMultipleDocs(oldDoc);\n    return;\n  }\n  this.remove(oldDoc);\n  try {\n    this.insert(newDoc);\n  } catch (e) {\n    this.insert(oldDoc);\n    throw e;\n  }\n};\n\n/**\n * Update multiple documents in the index\n * If a constraint is violated, the changes need to be rolled back\n * and an error thrown\n * @param {Array of oldDoc, newDoc pairs} pairs\n *\n * @API private\n */\nIndex.prototype.updateMultipleDocs = function (pairs) {\n  var i, failingI, error;\n  for (i = 0; i < pairs.length; i += 1) {\n    this.remove(pairs[i].oldDoc);\n  }\n  for (i = 0; i < pairs.length; i += 1) {\n    try {\n      this.insert(pairs[i].newDoc);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  // If an error was raised, roll back changes in the inverse order\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(pairs[i].newDoc);\n    }\n    for (i = 0; i < pairs.length; i += 1) {\n      this.insert(pairs[i].oldDoc);\n    }\n    throw error;\n  }\n};\n\n/**\n * Revert an update\n */\nIndex.prototype.revertUpdate = function (oldDoc, newDoc) {\n  var revert = [];\n  if (!util.isArray(oldDoc)) {\n    this.update(newDoc, oldDoc);\n  } else {\n    oldDoc.forEach(function (pair) {\n      revert.push({\n        oldDoc: pair.newDoc,\n        newDoc: pair.oldDoc\n      });\n    });\n    this.update(revert);\n  }\n};\n\n/**\n * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\n * @param {Thing} value Value to match the key against\n * @return {Array of documents}\n */\nIndex.prototype.getMatching = function (value) {\n  var self = this;\n  if (!util.isArray(value)) {\n    return self.tree.search(value);\n  } else {\n    var _res = {},\n      res = [];\n    value.forEach(function (v) {\n      self.getMatching(v).forEach(function (doc) {\n        _res[doc._id] = doc;\n      });\n    });\n    Object.keys(_res).forEach(function (_id) {\n      res.push(_res[_id]);\n    });\n    return res;\n  }\n};\n\n/**\n * Get all documents in index whose key is between bounds are they are defined by query\n * Documents are sorted by key\n * @param {Query} query\n * @return {Array of documents}\n */\nIndex.prototype.getBetweenBounds = function (query) {\n  return this.tree.betweenBounds(query);\n};\n\n/**\n * Get all elements in the index\n * @return {Array of documents}\n */\nIndex.prototype.getAll = function () {\n  var res = [];\n  this.tree.executeOnEveryNode(function (node) {\n    var i;\n    for (i = 0; i < node.data.length; i += 1) {\n      res.push(node.data[i]);\n    }\n  });\n  return res;\n};\n\n// Interface\nmodule.exports = Index;","map":{"version":3,"names":["BinarySearchTree","require","AVLTree","model","_","util","checkValueEquality","a","b","projectForUnique","elt","isArray","getTime","Index","options","fieldName","unique","sparse","treeOptions","compareKeys","compareThings","reset","prototype","newData","tree","insert","doc","key","self","keys","i","failingI","error","insertMultipleDocs","getDotValue","undefined","uniq","length","e","delete","docs","remove","forEach","d","_key","update","oldDoc","newDoc","updateMultipleDocs","pairs","revertUpdate","revert","pair","push","getMatching","value","search","_res","res","v","_id","Object","getBetweenBounds","query","betweenBounds","getAll","executeOnEveryNode","node","data","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/nedb/lib/indexes.js"],"sourcesContent":["var BinarySearchTree = require('binary-search-tree').AVLTree\n  , model = require('./model')\n  , _ = require('underscore')\n  , util = require('util')\n  ;\n\n/**\n * Two indexed pointers are equal iif they point to the same place\n */\nfunction checkValueEquality (a, b) {\n  return a === b;\n}\n\n/**\n * Type-aware projection\n */\nfunction projectForUnique (elt) {\n  if (elt === null) { return '$null'; }\n  if (typeof elt === 'string') { return '$string' + elt; }\n  if (typeof elt === 'boolean') { return '$boolean' + elt; }\n  if (typeof elt === 'number') { return '$number' + elt; }\n  if (util.isArray(elt)) { return '$date' + elt.getTime(); }\n\n  return elt;   // Arrays and objects, will check for pointer equality\n}\n\n\n/**\n * Create a new index\n * All methods on an index guarantee that either the whole operation was successful and the index changed\n * or the operation was unsuccessful and an error is thrown while the index is unchanged\n * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)\n * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)\n * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)\n */\nfunction Index (options) {\n  this.fieldName = options.fieldName;\n  this.unique = options.unique || false;\n  this.sparse = options.sparse || false;\n\n  this.treeOptions = { unique: this.unique, compareKeys: model.compareThings, checkValueEquality: checkValueEquality };\n\n  this.reset();   // No data in the beginning\n}\n\n\n/**\n * Reset an index\n * @param {Document or Array of documents} newData Optional, data to initialize the index with\n *                                                 If an error is thrown during insertion, the index is not modified\n */\nIndex.prototype.reset = function (newData) {\n  this.tree = new BinarySearchTree(this.treeOptions);\n\n  if (newData) { this.insert(newData); }\n};\n\n\n/**\n * Insert a new document in the index\n * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\n * O(log(n))\n */\nIndex.prototype.insert = function (doc) {\n  var key, self = this\n    , keys, i, failingI, error\n    ;\n\n  if (util.isArray(doc)) { this.insertMultipleDocs(doc); return; }\n\n  key = model.getDotValue(doc, this.fieldName);\n\n  // We don't index documents that don't contain the field if the index is sparse\n  if (key === undefined && this.sparse) { return; }\n\n  if (!util.isArray(key)) {\n    this.tree.insert(key, doc);\n  } else {\n    // If an insert fails due to a unique constraint, roll back all inserts before it\n    keys = _.uniq(key, projectForUnique);\n\n    for (i = 0; i < keys.length; i += 1) {\n      try {\n        this.tree.insert(keys[i], doc);\n      } catch (e) {\n        error = e;\n        failingI = i;\n        break;\n      }\n    }\n\n    if (error) {\n      for (i = 0; i < failingI; i += 1) {\n        this.tree.delete(keys[i], doc);\n      }\n\n      throw error;\n    }\n  }\n};\n\n\n/**\n * Insert an array of documents in the index\n * If a constraint is violated, the changes should be rolled back and an error thrown\n *\n * @API private\n */\nIndex.prototype.insertMultipleDocs = function (docs) {\n  var i, error, failingI;\n\n  for (i = 0; i < docs.length; i += 1) {\n    try {\n      this.insert(docs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(docs[i]);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Remove a document from the index\n * If an array is passed, we remove all its elements\n * The remove operation is safe with regards to the 'unique' constraint\n * O(log(n))\n */\nIndex.prototype.remove = function (doc) {\n  var key, self = this;\n\n  if (util.isArray(doc)) { doc.forEach(function (d) { self.remove(d); }); return; }\n\n  key = model.getDotValue(doc, this.fieldName);\n\n  if (key === undefined && this.sparse) { return; }\n\n  if (!util.isArray(key)) {\n    this.tree.delete(key, doc);\n  } else {\n    _.uniq(key, projectForUnique).forEach(function (_key) {\n      self.tree.delete(_key, doc);\n    });\n  }\n};\n\n\n/**\n * Update a document in the index\n * If a constraint is violated, changes are rolled back and an error thrown\n * Naive implementation, still in O(log(n))\n */\nIndex.prototype.update = function (oldDoc, newDoc) {\n  if (util.isArray(oldDoc)) { this.updateMultipleDocs(oldDoc); return; }\n\n  this.remove(oldDoc);\n\n  try {\n    this.insert(newDoc);\n  } catch (e) {\n    this.insert(oldDoc);\n    throw e;\n  }\n};\n\n\n/**\n * Update multiple documents in the index\n * If a constraint is violated, the changes need to be rolled back\n * and an error thrown\n * @param {Array of oldDoc, newDoc pairs} pairs\n *\n * @API private\n */\nIndex.prototype.updateMultipleDocs = function (pairs) {\n  var i, failingI, error;\n\n  for (i = 0; i < pairs.length; i += 1) {\n    this.remove(pairs[i].oldDoc);\n  }\n\n  for (i = 0; i < pairs.length; i += 1) {\n    try {\n      this.insert(pairs[i].newDoc);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  // If an error was raised, roll back changes in the inverse order\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(pairs[i].newDoc);\n    }\n\n    for (i = 0; i < pairs.length; i += 1) {\n      this.insert(pairs[i].oldDoc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Revert an update\n */\nIndex.prototype.revertUpdate = function (oldDoc, newDoc) {\n  var revert = [];\n\n  if (!util.isArray(oldDoc)) {\n    this.update(newDoc, oldDoc);\n  } else {\n    oldDoc.forEach(function (pair) {\n      revert.push({ oldDoc: pair.newDoc, newDoc: pair.oldDoc });\n    });\n    this.update(revert);\n  }\n};\n\n\n/**\n * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\n * @param {Thing} value Value to match the key against\n * @return {Array of documents}\n */\nIndex.prototype.getMatching = function (value) {\n  var self = this;\n\n  if (!util.isArray(value)) {\n    return self.tree.search(value);\n  } else {\n    var _res = {}, res = [];\n\n    value.forEach(function (v) {\n      self.getMatching(v).forEach(function (doc) {\n        _res[doc._id] = doc;\n      });\n    });\n\n    Object.keys(_res).forEach(function (_id) {\n      res.push(_res[_id]);\n    });\n\n    return res;\n  }\n};\n\n\n/**\n * Get all documents in index whose key is between bounds are they are defined by query\n * Documents are sorted by key\n * @param {Query} query\n * @return {Array of documents}\n */\nIndex.prototype.getBetweenBounds = function (query) {\n  return this.tree.betweenBounds(query);\n};\n\n\n/**\n * Get all elements in the index\n * @return {Array of documents}\n */\nIndex.prototype.getAll = function () {\n  var res = [];\n\n  this.tree.executeOnEveryNode(function (node) {\n    var i;\n\n    for (i = 0; i < node.data.length; i += 1) {\n      res.push(node.data[i]);\n    }\n  });\n\n  return res;\n};\n\n\n\n\n// Interface\nmodule.exports = Index;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}