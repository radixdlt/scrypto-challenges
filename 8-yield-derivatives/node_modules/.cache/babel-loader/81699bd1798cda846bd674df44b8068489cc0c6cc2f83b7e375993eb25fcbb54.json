{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigningKeyTypeIdentifier = exports.HDSigningKeyTypeIdentifier = void 0;\nvar HDSigningKeyTypeIdentifier;\n(function (HDSigningKeyTypeIdentifier) {\n  HDSigningKeyTypeIdentifier[\"LOCAL\"] = \"LOCAL\";\n  HDSigningKeyTypeIdentifier[\"HARDWARE_OR_REMOTE\"] = \"HARDWARE_OR_REMOTE\";\n})(HDSigningKeyTypeIdentifier = exports.HDSigningKeyTypeIdentifier || (exports.HDSigningKeyTypeIdentifier = {}));\nvar SigningKeyTypeIdentifier;\n(function (SigningKeyTypeIdentifier) {\n  SigningKeyTypeIdentifier[\"HD_SIGNING_KEY\"] = \"HD_SIGNING_KEY\";\n  SigningKeyTypeIdentifier[\"NON_HD_SIGNING_KEY\"] = \"NON_HD_SIGNING_KEY\";\n})(SigningKeyTypeIdentifier = exports.SigningKeyTypeIdentifier || (exports.SigningKeyTypeIdentifier = {}));","map":{"version":3,"names":["HDSigningKeyTypeIdentifier","exports","SigningKeyTypeIdentifier"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/account/src/_types.ts"],"sourcesContent":["import { Observable } from 'rxjs'\nimport { Option } from 'prelude-ts'\nimport {\n\tDiffieHellman,\n\tEncryptedMessageT,\n\tHDPathRadixT,\n\tMnemomicT,\n\tPrivateKeyT,\n\tPublicKeyT,\n\tSignatureT,\n} from '@radixdlt/crypto'\nimport { HardwareWalletT } from '@radixdlt/hardware-wallet'\nimport { BuiltTransactionReadyToSign } from '@radixdlt/primitives'\n\nexport type Signing = Readonly<{\n\tsignHash: (hashedMessage: Buffer) => Observable<SignatureT>\n\tsign: (\n\t\ttx: BuiltTransactionReadyToSign,\n\t\tnonXrdHRP?: string,\n\t) => Observable<SignatureT>\n}>\n\nexport type SigningKeyEncryptionInput = Readonly<{\n\tplaintext: Buffer | string\n\tpublicKeyOfOtherParty: PublicKeyT\n}>\n\nexport type Encrypting = Readonly<{\n\tencrypt: (input: SigningKeyEncryptionInput) => Observable<EncryptedMessageT>\n}>\n\nexport type SigningKeyDecryptionInput = Readonly<{\n\tencryptedMessage: Buffer | EncryptedMessageT\n\tpublicKeyOfOtherParty: PublicKeyT\n}>\n\nexport type Decrypting = Readonly<{\n\tdecrypt: (input: SigningKeyDecryptionInput) => Observable<string>\n}>\n\nexport enum HDSigningKeyTypeIdentifier {\n\tLOCAL = 'LOCAL',\n\tHARDWARE_OR_REMOTE = 'HARDWARE_OR_REMOTE',\n}\n\nexport enum SigningKeyTypeIdentifier {\n\tHD_SIGNING_KEY = 'HD_SIGNING_KEY',\n\tNON_HD_SIGNING_KEY = 'NON_HD_SIGNING_KEY',\n}\n\nexport type BaseSigningKeyTypeT<T extends SigningKeyTypeIdentifier> = Readonly<{\n\ttypeIdentifier: T\n\tisHDSigningKey: boolean\n\tisHardwareSigningKey: boolean\n\tuniqueKey: string\n}>\n\nexport type SigningKeyTypeHDT = BaseSigningKeyTypeT<SigningKeyTypeIdentifier.HD_SIGNING_KEY> &\n\tReadonly<{\n\t\thdSigningKeyType: HDSigningKeyTypeIdentifier\n\t\thdPath: HDPathRadixT\n\t}>\n\nexport type SigningKeyTypeNonHDT = BaseSigningKeyTypeT<SigningKeyTypeIdentifier.NON_HD_SIGNING_KEY> &\n\tReadonly<{\n\t\tname?: string\n\t}>\n\nexport type SigningKeyTypeT = SigningKeyTypeHDT | SigningKeyTypeNonHDT\n\nexport type PrivateKeyToSigningKeyInput = Readonly<{\n\tprivateKey: PrivateKeyT\n\tname?: string\n}>\n\nexport type HWSigningKeyDerivation = 'next' | HDPathRadixT\nexport type DeriveHWSigningKeyInput = Readonly<{\n\tkeyDerivation: HWSigningKeyDerivation\n\thardwareWalletConnection: Observable<HardwareWalletT>\n\talsoSwitchTo: boolean\n\tverificationPrompt?: boolean\n}>\n\nexport type SigningKeyT = Signing &\n\tEncrypting &\n\tDecrypting &\n\tReadonly<{\n\t\t// useful for testing.\n\t\t__diffieHellman: DiffieHellman\n\n\t\t// Type of signingKey: `SigningKeyTypeHDT` or `SigningKeyTypeNonHDT`, where HD has `hdSigningKeyType` which can be `LOCAL` or `HARDWARE_OR_REMOTE` (e.g. Ledger Nano)\n\t\ttype: SigningKeyTypeT\n\t\tpublicKey: PublicKeyT\n\n\t\t// Only relevant for Hardware accounts. Like property `publicKey` but a function and omits BIP32 path on HW display\n\t\t// For NON-Hardware accounts this will just return the cached `publicKey` property.\n\t\tgetPublicKeyDisplayOnlyAddress: () => Observable<PublicKeyT>\n\n\t\t// sugar for `type.uniqueKey`\n\t\tuniqueIdentifier: string\n\n\t\t// Useful for debugging.\n\t\ttoString: () => string\n\n\t\t// Sugar for thisSigningKey.publicKey.equals(other.publicKey)\n\t\tequals: (other: SigningKeyT) => boolean\n\n\t\t// Sugar for `type.hdPath`, iff, type.typeIdentifier === SigningKeyTypeHDT\n\t\thdPath?: HDPathRadixT\n\n\t\t// Sugar for `type.isHDSigningKey`\n\t\tisHDSigningKey: boolean\n\t\t// Sugar for `type.isHardwareSigningKey`\n\t\tisHardwareSigningKey: boolean\n\t\t// Sugar for `isHDSigningKey && !isHardwareSigningKey`\n\t\tisLocalHDSigningKey: boolean\n\t}>\n\nexport type SigningKeysT = Readonly<{\n\ttoString: () => string\n\tequals: (other: SigningKeysT) => boolean\n\n\t// Get only HD signingKey, by its path\n\tgetHDSigningKeyByHDPath: (hdPath: HDPathRadixT) => Option<SigningKeyT>\n\t// Get any signingKey by its public key\n\tgetAnySigningKeyByPublicKey: (publicKey: PublicKeyT) => Option<SigningKeyT>\n\n\tall: SigningKeyT[]\n\n\thdSigningKeys: () => SigningKeyT[]\n\tlocalHDSigningKeys: () => SigningKeyT[]\n\thardwareHDSigningKeys: () => SigningKeyT[]\n\tnonHDSigningKeys: () => SigningKeyT[]\n\n\t// size of `all.\n\tsize: () => number\n}>\n\nexport type SwitchToSigningKey = Readonly<{ toSigningKey: SigningKeyT }>\nexport type SwitchToIndex = Readonly<{ toIndex: number }>\n\nexport type SwitchSigningKeyInput =\n\t| 'first'\n\t| 'last'\n\t| SwitchToSigningKey\n\t| SwitchToIndex\n\nexport type DeriveNextInput =\n\t| undefined\n\t| Readonly<{\n\t\t\tisHardened?: boolean // defaults to true\n\t\t\talsoSwitchTo?: boolean // defaults to false\n\t  }>\n\nexport type AddSigningKeyByPrivateKeyInput = PrivateKeyToSigningKeyInput & {\n\talsoSwitchTo?: boolean\n}\n\nexport type SigningKeychainT = Signing &\n\tReadonly<{\n\t\t// should only be used for testing\n\t\t__unsafeGetSigningKey: () => SigningKeyT\n\n\t\trevealMnemonic: () => MnemomicT\n\n\t\trestoreLocalHDSigningKeysUpToIndex: (\n\t\t\tindex: number,\n\t\t) => Observable<SigningKeysT>\n\n\t\tderiveNextLocalHDSigningKey: (\n\t\t\tinput?: DeriveNextInput,\n\t\t) => Observable<SigningKeyT>\n\n\t\tderiveHWSigningKey: (\n\t\t\tinput: DeriveHWSigningKeyInput,\n\t\t) => Observable<SigningKeyT>\n\n\t\taddSigningKeyFromPrivateKey: (\n\t\t\tinput: AddSigningKeyByPrivateKeyInput,\n\t\t) => SigningKeyT\n\n\t\tswitchSigningKey: (input: SwitchSigningKeyInput) => SigningKeyT\n\n\t\tobserveActiveSigningKey: () => Observable<SigningKeyT>\n\t\tobserveSigningKeys: () => Observable<SigningKeysT>\n\t}>\n"],"mappings":";;;;;;AAwCA,IAAYA,0BAGX;AAHD,WAAYA,0BAA0B;EACrCA,0BAAA,mBAAe;EACfA,0BAAA,6CAAyC;AAC1C,CAAC,EAHWA,0BAA0B,GAA1BC,OAAA,CAAAD,0BAA0B,KAA1BC,OAAA,CAAAD,0BAA0B;AAKtC,IAAYE,wBAGX;AAHD,WAAYA,wBAAwB;EACnCA,wBAAA,qCAAiC;EACjCA,wBAAA,6CAAyC;AAC1C,CAAC,EAHWA,wBAAwB,GAAxBD,OAAA,CAAAC,wBAAwB,KAAxBD,OAAA,CAAAC,wBAAwB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}