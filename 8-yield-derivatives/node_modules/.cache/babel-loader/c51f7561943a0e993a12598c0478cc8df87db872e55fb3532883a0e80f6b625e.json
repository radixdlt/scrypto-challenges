{"ast":null,"code":"import { WebSocketSubject } from './WebSocketSubject';\nexport function webSocket(urlConfigOrSource) {\n  return new WebSocketSubject(urlConfigOrSource);\n}","map":{"version":3,"names":["WebSocketSubject","webSocket","urlConfigOrSource"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/rxjs/src/internal/observable/dom/webSocket.ts"],"sourcesContent":["import { WebSocketSubject, WebSocketSubjectConfig } from './WebSocketSubject';\n\n/**\n * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n *\n * <span class=\"informal\">{@link Subject} that communicates with a server via WebSocket</span>\n *\n * `webSocket` is a factory function that produces a `WebSocketSubject`,\n * which can be used to make WebSocket connection with an arbitrary endpoint.\n * `webSocket` accepts as an argument either a string with url of WebSocket endpoint, or an\n * {@link WebSocketSubjectConfig} object for providing additional configuration, as\n * well as Observers for tracking lifecycle of WebSocket connection.\n *\n * When `WebSocketSubject` is subscribed, it attempts to make a socket connection,\n * unless there is one made already. This means that many subscribers will always listen\n * on the same socket, thus saving resources. If however, two instances are made of `WebSocketSubject`,\n * even if these two were provided with the same url, they will attempt to make separate\n * connections. When consumer of a `WebSocketSubject` unsubscribes, socket connection is closed,\n * only if there are no more subscribers still listening. If after some time a consumer starts\n * subscribing again, connection is reestablished.\n *\n * Once connection is made, whenever a new message comes from the server, `WebSocketSubject` will emit that\n * message as a value in the stream. By default, a message from the socket is parsed via `JSON.parse`. If you\n * want to customize how deserialization is handled (if at all), you can provide custom `resultSelector`\n * function in {@link WebSocketSubject}. When connection closes, stream will complete, provided it happened without\n * any errors. If at any point (starting, maintaining or closing a connection) there is an error,\n * stream will also error with whatever WebSocket API has thrown.\n *\n * By virtue of being a {@link Subject}, `WebSocketSubject` allows for receiving and sending messages from the server. In order\n * to communicate with a connected endpoint, use `next`, `error` and `complete` methods. `next` sends a value to the server, so bear in mind\n * that this value will not be serialized beforehand. Because of This, `JSON.stringify` will have to be called on a value by hand,\n * before calling `next` with a result. Note also that if at the moment of nexting value\n * there is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection\n * is finally established. `complete` method closes socket connection. `error` does the same,\n * as well as notifying the server that something went wrong via status code and string with details of what happened.\n * Since status code is required in WebSocket API, `WebSocketSubject` does not allow, like regular `Subject`,\n * arbitrary values being passed to the `error` method. It needs to be called with an object that has `code`\n * property with status code number and optional `reason` property with string describing details\n * of an error.\n *\n * Calling `next` does not affect subscribers of `WebSocketSubject` - they have no\n * information that something was sent to the server (unless of course the server\n * responds somehow to a message). On the other hand, since calling `complete` triggers\n * an attempt to close socket connection. If that connection is closed without any errors, stream will\n * complete, thus notifying all subscribers. And since calling `error` closes\n * socket connection as well, just with a different status code for the server, if closing itself proceeds\n * without errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases\n * (calling `complete` or `error`), if process of closing socket connection results in some errors, *then* stream\n * will error.\n *\n * **Multiplexing**\n *\n * `WebSocketSubject` has an additional operator, not found in other Subjects. It is called `multiplex` and it is\n * used to simulate opening several socket connections, while in reality maintaining only one.\n * For example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions,\n * it would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket\n * endpoints, running on separate machines with only GUI combining them together. Having a socket connection\n * for each functionality could become too resource expensive. It is a common pattern to have single\n * WebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services).\n * Even though there is a single connection in a client app, having the ability to manipulate streams as if it\n * were two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for\n * given service and filter out messages of interest. This is exactly what `multiplex` method is for.\n *\n * Method accepts three parameters. First two are functions returning subscription and unsubscription messages\n * respectively. These are messages that will be sent to the server, whenever consumer of resulting Observable\n * subscribes and unsubscribes. Server can use them to verify that some kind of messages should start or stop\n * being forwarded to the client. In case of the above example application, after getting subscription message with proper identifier,\n * gateway server can decide that it should connect to real sport news service and start forwarding messages from it.\n * Note that both messages will be sent as returned by the functions, they are by default serialized using JSON.stringify, just\n * as messages pushed via `next`. Also bear in mind that these messages will be sent on *every* subscription and\n * unsubscription. This is potentially dangerous, because one consumer of an Observable may unsubscribe and the server\n * might stop sending messages, since it got unsubscription message. This needs to be handled\n * on the server or using {@link publish} on a Observable returned from 'multiplex'.\n *\n * Last argument to `multiplex` is a `messageFilter` function which should return a boolean. It is used to filter out messages\n * sent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these\n * messages with some kind of string identifier on a message object and `messageFilter` would return `true`\n * if there is such identifier on an object emitted by the socket. Messages which returns `false` in `messageFilter` are simply skipped,\n * and are not passed down the stream.\n *\n * Return value of `multiplex` is an Observable with messages incoming from emulated socket connection. Note that this\n * is not a `WebSocketSubject`, so calling `next` or `multiplex` again will fail. For pushing values to the\n * server, use root `WebSocketSubject`.\n *\n * ### Examples\n * #### Listening for messages from the server\n * ```ts\n * import { webSocket } from \"rxjs/webSocket\";\n * const subject = webSocket(\"ws://localhost:8081\");\n *\n * subject.subscribe(\n *    msg => console.log('message received: ' + msg), // Called whenever there is a message from the server.\n *    err => console.log(err), // Called if at any point WebSocket API signals some kind of error.\n *    () => console.log('complete') // Called when connection is closed (for whatever reason).\n *  );\n * ```\n *\n * #### Pushing messages to the server\n * ```ts\n * import { webSocket } from \"rxjs/webSocket\";\n * const subject = webSocket('ws://localhost:8081');\n *\n * subject.subscribe();\n * // Note that at least one consumer has to subscribe to the created subject - otherwise \"nexted\" values will be just buffered and not sent,\n * // since no connection was established!\n *\n * subject.next({message: 'some message'});\n * // This will send a message to the server once a connection is made. Remember value is serialized with JSON.stringify by default!\n *\n * subject.complete(); // Closes the connection.\n *\n * subject.error({code: 4000, reason: 'I think our app just broke!'});\n * // Also closes the connection, but let's the server know that this closing is caused by some error.\n * ```\n *\n * #### Multiplexing WebSocket\n * ```ts\n * import { webSocket } from \"rxjs/webSocket\";\n * const subject = webSocket('ws://localhost:8081');\n *\n * const observableA = subject.multiplex(\n *   () => ({subscribe: 'A'}), // When server gets this message, it will start sending messages for 'A'...\n *   () => ({unsubscribe: 'A'}), // ...and when gets this one, it will stop.\n *   message => message.type === 'A' // If the function returns `true` message is passed down the stream. Skipped if the function returns false.\n * );\n *\n * const observableB = subject.multiplex( // And the same goes for 'B'.\n *   () => ({subscribe: 'B'}),\n *   () => ({unsubscribe: 'B'}),\n *   message => message.type === 'B'\n * );\n *\n * const subA = observableA.subscribe(messageForA => console.log(messageForA));\n * // At this moment WebSocket connection is established. Server gets '{\"subscribe\": \"A\"}' message and starts sending messages for 'A',\n * // which we log here.\n *\n * const subB = observableB.subscribe(messageForB => console.log(messageForB));\n * // Since we already have a connection, we just send '{\"subscribe\": \"B\"}' message to the server. It starts sending messages for 'B',\n * // which we log here.\n *\n * subB.unsubscribe();\n * // Message '{\"unsubscribe\": \"B\"}' is sent to the server, which stops sending 'B' messages.\n *\n * subA.unsubscribe();\n * // Message '{\"unsubscribe\": \"A\"}' makes the server stop sending messages for 'A'. Since there is no more subscribers to root Subject,\n * // socket connection closes.\n * ```\n *\n *\n * @param {string|WebSocketSubjectConfig} urlConfigOrSource The WebSocket endpoint as an url or an object with\n * configuration and additional Observers.\n * @return {WebSocketSubject} Subject which allows to both send and receive messages via WebSocket connection.\n */\nexport function webSocket<T>(urlConfigOrSource: string | WebSocketSubjectConfig<T>): WebSocketSubject<T> {\n  return new WebSocketSubject<T>(urlConfigOrSource);\n}\n"],"mappings":"AAAA,SAASA,gBAAgB,QAAgC,oBAAoB;AAyJ7E,OAAM,SAAUC,SAASA,CAAIC,iBAAqD;EAChF,OAAO,IAAIF,gBAAgB,CAAIE,iBAAiB,CAAC;AACnD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}