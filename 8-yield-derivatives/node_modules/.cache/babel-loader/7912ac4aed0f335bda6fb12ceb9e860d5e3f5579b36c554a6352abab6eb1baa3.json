{"ast":null,"code":"import { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { from } from '../observable/from';\nimport { operate } from '../util/lift';\nexport function share(options) {\n  options = options || {};\n  var _a = options.connector,\n    connector = _a === void 0 ? function () {\n      return new Subject();\n    } : _a,\n    _b = options.resetOnComplete,\n    resetOnComplete = _b === void 0 ? true : _b,\n    _c = options.resetOnError,\n    resetOnError = _c === void 0 ? true : _c,\n    _d = options.resetOnRefCountZero,\n    resetOnRefCountZero = _d === void 0 ? true : _d;\n  var connection = null;\n  var subject = null;\n  var refCount = 0;\n  var hasCompleted = false;\n  var hasErrored = false;\n  var reset = function () {\n    connection = subject = null;\n    hasCompleted = hasErrored = false;\n  };\n  return operate(function (source, subscriber) {\n    refCount++;\n    subject = subject !== null && subject !== void 0 ? subject : connector();\n    subject.subscribe(subscriber);\n    if (!connection) {\n      connection = new SafeSubscriber({\n        next: function (value) {\n          return subject.next(value);\n        },\n        error: function (err) {\n          hasErrored = true;\n          var dest = subject;\n          if (resetOnError) {\n            reset();\n          }\n          dest.error(err);\n        },\n        complete: function () {\n          hasCompleted = true;\n          var dest = subject;\n          if (resetOnComplete) {\n            reset();\n          }\n          dest.complete();\n        }\n      });\n      from(source).subscribe(connection);\n    }\n    return function () {\n      refCount--;\n      if (resetOnRefCountZero && !refCount && !hasErrored && !hasCompleted) {\n        var conn = connection;\n        reset();\n        conn === null || conn === void 0 ? void 0 : conn.unsubscribe();\n      }\n    };\n  });\n}","map":{"version":3,"names":["Subject","SafeSubscriber","from","operate","share","options","_a","connector","_b","resetOnComplete","_c","resetOnError","_d","resetOnRefCountZero","connection","subject","refCount","hasCompleted","hasErrored","reset","source","subscriber","subscribe","next","value","error","err","dest","complete","conn","unsubscribe"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/rxjs/src/internal/operators/share.ts"],"sourcesContent":["import { Subject } from '../Subject';\nimport { MonoTypeOperatorFunction, OperatorFunction, SubjectLike } from '../types';\nimport { SafeSubscriber } from '../Subscriber';\nimport { from } from '../observable/from';\nimport { operate } from '../util/lift';\n\nexport interface ShareConfig<T> {\n  /**\n   * The factory used to create the subject that will connect the source observable to\n   * multicast consumers.\n   */\n  connector?: () => SubjectLike<T>;\n  /**\n   * If true, the resulting observable will reset internal state on error from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"retried\" in the event of an error.\n   * If false, when an error comes from the source it will push the error into the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent retries\n   * or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however\n   * {@link ReplaySubject} will also push its buffered values before pushing the error.\n   */\n  resetOnError?: boolean;\n  /**\n   * If true, the resulting observable will reset internal state on completion from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"repeated\" after it is done.\n   * If false, when the source completes, it will push the completion through the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent repeats\n   * or resubscriptions will resubscribe to that same subject.\n   */\n  resetOnComplete?: boolean;\n  /**\n   * If true, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the\n   * internal state will be reset and the resulting observable will return to a \"cold\" state. This means that the next\n   * time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to\n   * again.\n   * If false, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject\n   * will remain connected to the source, and new subscriptions to the result will be connected through that same subject.\n   */\n  resetOnRefCountZero?: boolean;\n}\n\nexport function share<T>(): MonoTypeOperatorFunction<T>;\n\nexport function share<T>(options: ShareConfig<T>): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * ![](share.png)\n *\n * ## Example\n * Generate new multicast Observable from the source Observable value\n * ```ts\n * import { interval } from 'rxjs';\n * import { share, map } from 'rxjs/operators';\n *\n * const source = interval(1000)\n *   .pipe(\n *         map((x: number) => {\n *             console.log('Processing: ', x);\n *             return x*x;\n *         }),\n *         share()\n * );\n *\n * source.subscribe(x => console.log('subscription 1: ', x));\n * source.subscribe(x => console.log('subscription 1: ', x));\n *\n * // Logs:\n * // Processing:  0\n * // subscription 1:  0\n * // subscription 1:  0\n * // Processing:  1\n * // subscription 1:  1\n * // subscription 1:  1\n * // Processing:  2\n * // subscription 1:  4\n * // subscription 1:  4\n * // Processing:  3\n * // subscription 1:  9\n * // subscription 1:  9\n * // ... and so on\n * ```\n *\n * @see {@link api/index/function/interval}\n * @see {@link map}\n *\n * @return A function that returns an Observable that mirrors the source.\n */\nexport function share<T>(options?: ShareConfig<T>): OperatorFunction<T, T> {\n  options = options || {};\n  const { connector = () => new Subject<T>(), resetOnComplete = true, resetOnError = true, resetOnRefCountZero = true } = options;\n\n  let connection: SafeSubscriber<T> | null = null;\n  let subject: SubjectLike<T> | null = null;\n  let refCount = 0;\n  let hasCompleted = false;\n  let hasErrored = false;\n\n  // Used to reset the internal state to a \"cold\"\n  // state, as though it had never been subscribed to.\n  const reset = () => {\n    connection = subject = null;\n    hasCompleted = hasErrored = false;\n  };\n\n  return operate((source, subscriber) => {\n    refCount++;\n\n    // Create the subject if we don't have one yet.\n    subject = subject ?? connector();\n\n    // The following line adds the subscription to the subscriber passed.\n    // Basically, `subscriber === subject.subscribe(subscriber)` is `true`.\n    subject.subscribe(subscriber);\n\n    if (!connection) {\n      // We need to create a subscriber here - rather than pass an observer and\n      // assign the returned subscription to connection - because it's possible\n      // for reentrant subscriptions to the shared observable to occur and in\n      // those situations we want connection to be already-assigned so that we\n      // don't create another connection to the source.\n      connection = new SafeSubscriber({\n        next: (value: T) => subject!.next(value),\n        error: (err: any) => {\n          hasErrored = true;\n          // We need to capture the subject before\n          // we reset (if we need to reset).\n          const dest = subject!;\n          if (resetOnError) {\n            reset();\n          }\n          dest.error(err);\n        },\n        complete: () => {\n          hasCompleted = true;\n          const dest = subject!;\n          // We need to capture the subject before\n          // we reset (if we need to reset).\n          if (resetOnComplete) {\n            reset();\n          }\n          dest.complete();\n        },\n      });\n      from(source).subscribe(connection);\n    }\n\n    // This is also added to `subscriber`, technically.\n    return () => {\n      refCount--;\n\n      // If we're resetting on refCount === 0, and it's 0, we only want to do\n      // that on \"unsubscribe\", really. Resetting on error or completion is a different\n      // configuration.\n      if (resetOnRefCountZero && !refCount && !hasErrored && !hasCompleted) {\n        // We need to capture the connection before\n        // we reset (if we need to reset).\n        const conn = connection;\n        reset();\n        conn?.unsubscribe();\n      }\n    };\n  });\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,YAAY;AAEpC,SAASC,cAAc,QAAQ,eAAe;AAC9C,SAASC,IAAI,QAAQ,oBAAoB;AACzC,SAASC,OAAO,QAAQ,cAAc;AAuFtC,OAAM,SAAUC,KAAKA,CAAIC,OAAwB;EAC/CA,OAAO,GAAGA,OAAO,IAAI,EAAE;EACf,IAAAC,EAAA,GAAgHD,OAAO,CAAAE,SAArF;IAAlCA,SAAS,GAAAD,EAAA,cAAG;MAAM,WAAIN,OAAO,EAAK;IAAhB,CAAgB,GAAAM,EAAA;IAAEE,EAAA,GAA4EH,OAAO,CAAAI,eAA7D;IAAtBA,eAAe,GAAAD,EAAA,cAAG,IAAI,GAAAA,EAAA;IAAEE,EAAA,GAAoDL,OAAO,CAAAM,YAAxC;IAAnBA,YAAY,GAAAD,EAAA,cAAG,IAAI,GAAAA,EAAA;IAAEE,EAAA,GAA+BP,OAAO,CAAAQ,mBAAZ;IAA1BA,mBAAmB,GAAAD,EAAA,cAAG,IAAI,GAAAA,EAAA;EAEnH,IAAIE,UAAU,GAA6B,IAAI;EAC/C,IAAIC,OAAO,GAA0B,IAAI;EACzC,IAAIC,QAAQ,GAAG,CAAC;EAChB,IAAIC,YAAY,GAAG,KAAK;EACxB,IAAIC,UAAU,GAAG,KAAK;EAItB,IAAMC,KAAK,GAAG,SAAAA,CAAA;IACZL,UAAU,GAAGC,OAAO,GAAG,IAAI;IAC3BE,YAAY,GAAGC,UAAU,GAAG,KAAK;EACnC,CAAC;EAED,OAAOf,OAAO,CAAC,UAACiB,MAAM,EAAEC,UAAU;IAChCL,QAAQ,EAAE;IAGVD,OAAO,GAAGA,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAIR,SAAS,EAAE;IAIhCQ,OAAO,CAACO,SAAS,CAACD,UAAU,CAAC;IAE7B,IAAI,CAACP,UAAU,EAAE;MAMfA,UAAU,GAAG,IAAIb,cAAc,CAAC;QAC9BsB,IAAI,EAAE,SAAAA,CAACC,KAAQ;UAAK,OAAAT,OAAQ,CAACQ,IAAI,CAACC,KAAK,CAAC;QAApB,CAAoB;QACxCC,KAAK,EAAE,SAAAA,CAACC,GAAQ;UACdR,UAAU,GAAG,IAAI;UAGjB,IAAMS,IAAI,GAAGZ,OAAQ;UACrB,IAAIJ,YAAY,EAAE;YAChBQ,KAAK,EAAE;;UAETQ,IAAI,CAACF,KAAK,CAACC,GAAG,CAAC;QACjB,CAAC;QACDE,QAAQ,EAAE,SAAAA,CAAA;UACRX,YAAY,GAAG,IAAI;UACnB,IAAMU,IAAI,GAAGZ,OAAQ;UAGrB,IAAIN,eAAe,EAAE;YACnBU,KAAK,EAAE;;UAETQ,IAAI,CAACC,QAAQ,EAAE;QACjB;OACD,CAAC;MACF1B,IAAI,CAACkB,MAAM,CAAC,CAACE,SAAS,CAACR,UAAU,CAAC;;IAIpC,OAAO;MACLE,QAAQ,EAAE;MAKV,IAAIH,mBAAmB,IAAI,CAACG,QAAQ,IAAI,CAACE,UAAU,IAAI,CAACD,YAAY,EAAE;QAGpE,IAAMY,IAAI,GAAGf,UAAU;QACvBK,KAAK,EAAE;QACPU,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEC,WAAW,EAAE;;IAEvB,CAAC;EACH,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}