{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Radix = void 0;\nconst tslib_1 = require(\"tslib\");\nconst account_1 = require(\"@radixdlt/account\");\nconst networking_1 = require(\"@radixdlt/networking\");\nconst api_1 = require(\"./api\");\nconst operators_1 = require(\"rxjs/operators\");\nconst rxjs_1 = require(\"rxjs\");\nconst crypto_1 = require(\"@radixdlt/crypto\");\nconst errors_1 = require(\"./errors\");\nconst util_1 = require(\"@radixdlt/util\");\nconst dto_1 = require(\"./dto\");\nconst actions_1 = require(\"./actions\");\nconst wallet_1 = require(\"./wallet\");\nconst _1 = require(\".\");\nconst utils_1 = require(\"./api/utils\");\nconst txTypeFromActions = input => {\n  const {\n    activeAddress\n  } = input;\n  const myAddress = activeAddress.toString();\n  const fromUnique = (0, dto_1.flatMapAddressesOf)(Object.assign(Object.assign({}, input), {\n    includeTo: false\n  })).map(a => a.toString());\n  const toUnique = (0, dto_1.flatMapAddressesOf)(Object.assign(Object.assign({}, input), {\n    includeFrom: false\n  })).map(a => a.toString());\n  const toMe = toUnique.includes(myAddress);\n  const fromMe = fromUnique.includes(myAddress);\n  if (toMe && fromMe) {\n    return dto_1.TransactionType.FROM_ME_TO_ME;\n  } else if (toMe) {\n    return dto_1.TransactionType.INCOMING;\n  } else if (fromMe) {\n    return dto_1.TransactionType.OUTGOING;\n  } else {\n    return dto_1.TransactionType.UNRELATED;\n  }\n};\nconst decorateSimpleExecutedTransactionWithType = (simpleExecutedTX, activeAddress) => Object.assign(Object.assign({}, simpleExecutedTX), {\n  transactionType: txTypeFromActions({\n    actions: simpleExecutedTX.actions,\n    activeAddress\n  })\n});\nconst shouldConfirmTransactionAutomatically = confirmationScheme => confirmationScheme === 'skip';\nconst create = () => {\n  const subs = new rxjs_1.Subscription();\n  const radixLog = util_1.log; // TODO configure child loggers\n  const nodeSubject = new rxjs_1.ReplaySubject();\n  const coreAPISubject = new rxjs_1.ReplaySubject();\n  const walletSubject = new rxjs_1.ReplaySubject();\n  const errorNotificationSubject = new rxjs_1.Subject();\n  const deriveNextLocalHDAccountSubject = new rxjs_1.Subject();\n  const addAccountByPrivateKeySubject = new rxjs_1.Subject();\n  const switchAccountSubject = new rxjs_1.Subject();\n  const tokenBalanceFetchSubject = new rxjs_1.Subject();\n  const stakingFetchSubject = new rxjs_1.Subject();\n  const wallet$ = walletSubject.asObservable();\n  const networkSubject = new rxjs_1.ReplaySubject();\n  const nativeTokenSubject = new rxjs_1.ReplaySubject();\n  let walletSubscription;\n  const coreAPIViaNode$ = nodeSubject.asObservable().pipe((0, operators_1.map)(n => (0, api_1.radixCoreAPI)(n, (0, api_1.nodeAPI)(n.url))));\n  const coreAPI$ = (0, rxjs_1.merge)(coreAPIViaNode$, coreAPISubject.asObservable()).pipe((0, operators_1.shareReplay)(1));\n  // Forwards calls to RadixCoreAPI, return type is a function: `(input?: I) => Observable<O>`\n  const fwdAPICall = (pickFn, errorFn) => function () {\n    for (var _len = arguments.length, input = new Array(_len), _key = 0; _key < _len; _key++) {\n      input[_key] = arguments[_key];\n    }\n    return coreAPI$.pipe((0, operators_1.mergeMap)(a => pickFn(a)(...input)), (0, operators_1.take)(1),\n    // Important!\n    (0, operators_1.catchError)(error => {\n      throw errorFn((0, util_1.isArray)(error) ? error[0] : error);\n    }));\n  };\n  const api = {\n    networkId: fwdAPICall(a => a.networkId, m => (0, errors_1.networkIdErr)(m)),\n    tokenBalancesForAddress: fwdAPICall(a => a.tokenBalancesForAddress, m => (0, errors_1.tokenBalancesErr)(m)),\n    transactionHistory: fwdAPICall(a => a.transactionHistory, m => (0, errors_1.transactionHistoryErr)(m)),\n    recentTransactions: fwdAPICall(a => a.recentTransactions, m => (0, errors_1.recentTransactionsErr)(m)),\n    nativeToken: fwdAPICall(a => a.nativeToken, m => (0, errors_1.nativeTokenErr)(m)),\n    tokenInfo: fwdAPICall(a => a.tokenInfo, m => (0, _1.tokenInfoErr)(m)),\n    stakesForAddress: fwdAPICall(a => a.stakesForAddress, m => (0, errors_1.stakesForAddressErr)(m)),\n    unstakesForAddress: fwdAPICall(a => a.unstakesForAddress, m => (0, errors_1.unstakesForAddressErr)(m)),\n    validators: fwdAPICall(a => a.validators, m => (0, errors_1.validatorsErr)(m)),\n    lookupValidator: fwdAPICall(a => a.lookupValidator, m => (0, errors_1.lookupValidatorErr)(m)),\n    getTransaction: fwdAPICall(a => a.transactionStatus, m => (0, errors_1.lookupTxErr)(m)),\n    buildTransaction: fwdAPICall(a => a.buildTransaction, m => (0, errors_1.buildTxFromIntentErr)(m)),\n    finalizeTransaction: fwdAPICall(a => a.finalizeTransaction, m => (0, errors_1.finalizeTxErr)(m)),\n    submitSignedTransaction: fwdAPICall(a => a.submitSignedTransaction, m => (0, errors_1.submitSignedTxErr)(m))\n  };\n  const activeAddress = wallet$.pipe((0, operators_1.mergeMap)(a => a.observeActiveAccount()), (0, operators_1.map)(a => a.address), (0, operators_1.shareReplay)(1));\n  const revealMnemonic = () => wallet$.pipe((0, operators_1.map)(wallet => wallet.revealMnemonic()));\n  const activeAddressToAPIObservableWithTrigger = (trigger, pickFn, errorFn) => (0, rxjs_1.merge)(trigger.pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.map)(result => result[1])), activeAddress).pipe((0, operators_1.withLatestFrom)(coreAPI$), (0, operators_1.switchMap)(_ref => {\n    let [address, api] = _ref;\n    return pickFn(api)(address).pipe((0, operators_1.catchError)(error => {\n      console.error(error);\n      errorNotificationSubject.next(errorFn(error));\n      return rxjs_1.EMPTY;\n    }));\n  }), (0, operators_1.shareReplay)(1));\n  const tokenBalances = activeAddressToAPIObservableWithTrigger(tokenBalanceFetchSubject, a => a.tokenBalancesForAddress, errors_1.tokenBalancesErr);\n  /*\n      const decorateSimpleTokenBalanceWithTokenInfo = (\n          simpleTokenBalance: SimpleTokenBalance,\n      ): Observable<TokenBalance> =>\n          api.tokenInfo(simpleTokenBalance.tokenIdentifier).pipe(\n              map(\n                  (tokenInfo: Token): TokenBalance => ({\n                      amount: simpleTokenBalance.amount,\n                      token: tokenInfo,\n                  }),\n              ),\n          )\n  */\n  const stakingPositions = activeAddressToAPIObservableWithTrigger(stakingFetchSubject, a => a.stakesForAddress, errors_1.stakesForAddressErr);\n  const unstakingPositions = activeAddressToAPIObservableWithTrigger(stakingFetchSubject, a => a.unstakesForAddress, errors_1.unstakesForAddressErr);\n  const transactionHistory = input => activeAddress.pipe((0, operators_1.take)(1), (0, operators_1.switchMap)(activeAddress => api.transactionHistory(Object.assign(Object.assign({}, input), {\n    address: activeAddress\n  })).pipe((0, operators_1.map)(simpleTxHistory => Object.assign(Object.assign({}, simpleTxHistory), {\n    transactions: simpleTxHistory.transactions.map(simpleExecutedTX => decorateSimpleExecutedTransactionWithType(simpleExecutedTX, activeAddress))\n  })))));\n  const node$ = (0, rxjs_1.merge)(nodeSubject.asObservable(), coreAPISubject.asObservable().pipe((0, operators_1.map)(api => api.node)));\n  const activeAccount = wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.observeActiveAccount()), (0, operators_1.shareReplay)(1), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.equals(cur)));\n  const accounts = wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.observeAccounts()), (0, operators_1.shareReplay)(1));\n  const __makeTransactionFromIntent = (transactionIntent$, options) => {\n    var _a;\n    const txLog = radixLog; // TODO configure child loggers\n    const txSubs = new rxjs_1.Subscription();\n    txLog.debug(\"Start of transaction flow, inside constructor of 'TransactionTracking'.\");\n    const signUnsignedTx = unsignedTx => {\n      txLog.debug('Starting signing transaction (async).');\n      return (0, rxjs_1.combineLatest)(transactionIntent$, activeAccount.pipe((0, operators_1.take)(1))).pipe((0, operators_1.mergeMap)(_ref2 => {\n        let [transactionIntent, account] = _ref2;\n        const nonXRDHRPsOfRRIsInTx = transactionIntent.actions.filter(a => a.type === actions_1.ActionType.TOKEN_TRANSFER).map(a => a).filter(t => t.rri.name !== 'xrd').map(t => t.rri.name);\n        const uniquenonXRDHRPsOfRRIsInTx = [...new Set(nonXRDHRPsOfRRIsInTx)];\n        if (uniquenonXRDHRPsOfRRIsInTx.length > 1) {\n          const errMsg = \"Error cannot sign transction with multiple non-XRD RRIs. Unsupported by Ledger app.\";\n          util_1.log.error(errMsg);\n          return (0, rxjs_1.throwError)(new Error(errMsg));\n        }\n        const nonXRDHrp = uniquenonXRDHRPsOfRRIsInTx.length === 1 ? uniquenonXRDHRPsOfRRIsInTx[0] : undefined;\n        return account.sign(unsignedTx.transaction, nonXRDHrp).pipe((0, operators_1.map)(signature => {\n          const publicKeyOfSigner = account.publicKey;\n          txLog.debug(\"Finished signing transaction\");\n          return {\n            transaction: unsignedTx.transaction,\n            signature,\n            publicKeyOfSigner\n          };\n        }));\n      }));\n    };\n    const pendingTXSubject = new rxjs_1.Subject();\n    const askUserToConfirmSubject = new rxjs_1.ReplaySubject();\n    const userDidConfirmTransactionSubject = new rxjs_1.ReplaySubject();\n    if (shouldConfirmTransactionAutomatically(options.userConfirmation)) {\n      txLog.debug('Transaction has been setup to be automatically confirmed, requiring no final confirmation input from user.');\n      txSubs.add(askUserToConfirmSubject.subscribe(() => {\n        txLog.debug(\"askUserToConfirmSubject got 'next', calling 'next' on 'userDidConfirmTransactionSubject'\");\n        userDidConfirmTransactionSubject.next(0);\n      }));\n    } else {\n      txLog.debug(\"Transaction has been setup so that it requires a manual final confirmation from user before being finalized.\");\n      const twoWayConfirmationSubject = options.userConfirmation;\n      txSubs.add(askUserToConfirmSubject.subscribe(ux => {\n        txLog.info(\"Forwarding signedUnconfirmedTX and 'userDidConfirmTransactionSubject' to subject 'twoWayConfirmationSubject' now (inside subscribe to 'askUserToConfirmSubject')\");\n        const confirmation = {\n          txToConfirm: ux,\n          confirm: () => userDidConfirmTransactionSubject.next(0)\n        };\n        twoWayConfirmationSubject.next(confirmation);\n      }));\n    }\n    const trackingSubject = new rxjs_1.ReplaySubject();\n    const track = event => {\n      trackingSubject.next(event);\n    };\n    const completionSubject = new rxjs_1.Subject();\n    const trackError = input => {\n      const errorEvent = {\n        eventUpdateType: input.inStep,\n        error: input.error\n      };\n      txLog.debug(\"Forwarding error to 'errorSubject'\");\n      track(errorEvent);\n      completionSubject.error(errorEvent.error);\n    };\n    const builtTransaction$ = transactionIntent$.pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.switchMap)(_ref3 => {\n      let [intent, address] = _ref3;\n      txLog.debug('Transaction intent created => requesting ðŸ›° API to build it now.');\n      track({\n        transactionState: intent,\n        eventUpdateType: dto_1.TransactionTrackingEventType.INITIATED\n      });\n      return api.buildTransaction(intent, address);\n    }), (0, operators_1.catchError)(e => {\n      txLog.error(\"API failed to build transaction\");\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.BUILT_FROM_INTENT\n      });\n      return rxjs_1.EMPTY;\n    }), (0, operators_1.tap)(builtTx => {\n      txLog.debug('TX built by API => asking for confirmation to sign...');\n      track({\n        transactionState: builtTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.BUILT_FROM_INTENT\n      });\n      askUserToConfirmSubject.next(builtTx);\n    }), (0, operators_1.tap)(builtTx => {\n      track({\n        transactionState: builtTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.ASKED_FOR_CONFIRMATION\n      });\n    }));\n    const signedTransaction$ = (0, rxjs_1.combineLatest)([builtTransaction$, userDidConfirmTransactionSubject]).pipe((0, operators_1.map)(_ref4 => {\n      let [signedTx, _] = _ref4;\n      return signedTx;\n    }), (0, operators_1.tap)(unsignedTx => {\n      track({\n        transactionState: unsignedTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.CONFIRMED\n      });\n    }), (0, operators_1.mergeMap)(unsignedTx => signUnsignedTx(unsignedTx)), (0, operators_1.shareReplay)(1), (0, operators_1.catchError)(e => {\n      txLog.error(\"API failed to sign transaction, error: \".concat(JSON.stringify(e, null, 4)));\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.SIGNED\n      });\n      return rxjs_1.EMPTY;\n    }));\n    const finalizedTx$ = signedTransaction$.pipe((0, operators_1.mergeMap)(signedTx => {\n      txLog.debug(\"Finished signing tx => submitting it to \\uD83D\\uDEF0  API.\");\n      track({\n        transactionState: signedTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.SIGNED\n      });\n      return networkSubject.pipe((0, operators_1.mergeMap)(network => api.finalizeTransaction(network, signedTx)));\n    }), (0, operators_1.catchError)(e => {\n      txLog.error(\"API failed to submit transaction, error: \".concat(JSON.stringify(e, null, 4)));\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.FINALIZED\n      });\n      return rxjs_1.EMPTY;\n    }), (0, operators_1.tap)(finalizedTx => {\n      track({\n        transactionState: finalizedTx,\n        eventUpdateType: dto_1.TransactionTrackingEventType.FINALIZED\n      });\n    }));\n    txSubs.add(finalizedTx$.pipe((0, operators_1.mergeMap)(finalizedTx => networkSubject.pipe((0, operators_1.mergeMap)(network => api.submitSignedTransaction(network, {\n      blob: finalizedTx.blob,\n      txID: finalizedTx.txID\n    })))), (0, operators_1.catchError)(e => {\n      txLog.error(\"API failed to submit transaction, error: \".concat(JSON.stringify(e, null, 4)));\n      trackError({\n        error: e,\n        inStep: dto_1.TransactionTrackingEventType.SUBMITTED\n      });\n      return rxjs_1.EMPTY;\n    }), (0, operators_1.tap)({\n      next: pendingTx => {\n        txLog.debug(\"Submitted transaction with txID='\".concat(pendingTx.txID.toString(), \"', it is now pending.\"));\n        track({\n          transactionState: pendingTx,\n          eventUpdateType: dto_1.TransactionTrackingEventType.SUBMITTED\n        });\n        pendingTXSubject.next(pendingTx);\n      },\n      error: submitTXError => {\n        // TODO would be great to have access to txID here, hopefully API includes it in error msg?\n        txLog.error(\"Submission of signed transaction to API failed with error: \".concat(submitTXError.message));\n        pendingTXSubject.error(submitTXError);\n      }\n    })).subscribe());\n    const pollTxStatusTrigger = ((_a = options.pollTXStatusTrigger) !== null && _a !== void 0 ? _a : (0, rxjs_1.interval)(1000)).pipe((0, operators_1.share)());\n    const transactionStatus$ = (0, rxjs_1.combineLatest)([pollTxStatusTrigger, pendingTXSubject]).pipe((0, operators_1.mergeMap)(_ref5 => {\n      let [_, pendingTx] = _ref5;\n      txLog.debug(\"Asking API for status of transaction with txID: \".concat(pendingTx.txID.toString()));\n      return networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(pendingTx.txID, network).pipe((0, operators_1.retryWhen)((0, utils_1.retryOnErrorCode)({\n        maxRetryAttempts: 3,\n        errorCodes: [404]\n      })))));\n    }), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.status === cur.status), (0, operators_1.share)());\n    const transactionCompletedWithStatusConfirmed$ = transactionStatus$.pipe((0, operators_1.skipWhile)(_ref6 => {\n      let {\n        status\n      } = _ref6;\n      return status !== dto_1.TransactionStatus.CONFIRMED;\n    }), (0, operators_1.take)(1));\n    const transactionCompletedWithStatusFailed$ = transactionStatus$.pipe((0, operators_1.skipWhile)(_ref7 => {\n      let {\n        status\n      } = _ref7;\n      return status !== dto_1.TransactionStatus.FAILED;\n    }), (0, operators_1.take)(1));\n    txSubs.add(transactionStatus$.subscribe({\n      next: statusOfTransaction => {\n        const {\n          status,\n          txID\n        } = statusOfTransaction;\n        txLog.debug(\"Status \".concat(status.toString(), \" of transaction with txID='\").concat(txID.toString(), \"'\"));\n        track({\n          transactionState: statusOfTransaction,\n          eventUpdateType: dto_1.TransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX\n        });\n      },\n      error: transactionStatusError => {\n        // TODO hmm how to get txID here?\n        txLog.error(\"Failed to get status of transaction\", transactionStatusError);\n      }\n    }));\n    txSubs.add(transactionCompletedWithStatusConfirmed$.subscribe({\n      next: statusOfTransaction => {\n        const {\n          txID\n        } = statusOfTransaction;\n        txLog.info(\"Transaction with txID='\".concat(txID.toString(), \"' has completed succesfully.\"));\n        track({\n          transactionState: statusOfTransaction,\n          eventUpdateType: dto_1.TransactionTrackingEventType.COMPLETED\n        });\n        completionSubject.next(txID);\n        completionSubject.complete();\n        txSubs.unsubscribe();\n      }\n    }));\n    txSubs.add(transactionCompletedWithStatusFailed$.subscribe(status => {\n      const errMsg = \"API status of tx with id=\".concat(status.txID.toString(), \" returned 'FAILED'\");\n      txLog.error(errMsg);\n      trackError({\n        error: new Error(errMsg),\n        inStep: dto_1.TransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX\n      });\n      txSubs.unsubscribe();\n    }));\n    return {\n      completion: completionSubject.asObservable(),\n      events: trackingSubject.asObservable()\n    };\n  };\n  const __makeTransactionFromBuilder = (transactionIntentBuilderT, makeTXOptions, builderOptions) => {\n    radixLog.debug(\"make transaction from builder\");\n    const intent$ = transactionIntentBuilderT.build(builderOptions !== null && builderOptions !== void 0 ? builderOptions : {\n      skipEncryptionOfMessageIfAny: {\n        spendingSender: activeAddress.pipe((0, operators_1.take)(1)) // IMPORTANT !\n      }\n    });\n    return __makeTransactionFromIntent(intent$, makeTXOptions);\n  };\n  const transferTokens = input => {\n    radixLog.debug(\"transferTokens\");\n    const builder = dto_1.TransactionIntentBuilder.create().transferTokens(input.transferInput);\n    let encryptMsgIfAny = false;\n    if (input.message) {\n      builder.message(input.message);\n      encryptMsgIfAny = input.message.encrypt;\n    }\n    return __makeTransactionFromBuilder(builder, Object.assign({}, input), encryptMsgIfAny ? {\n      encryptMessageIfAnyWithAccount: activeAccount.pipe((0, operators_1.take)(1))\n    } : undefined);\n  };\n  const stakeTokens = input => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n    radixLog.debug('stake');\n    const nativeToken = yield (0, rxjs_1.firstValueFrom)(nativeTokenSubject);\n    return __makeTransactionFromBuilder(dto_1.TransactionIntentBuilder.create().stakeTokens(Object.assign(Object.assign({}, input.stakeInput), {\n      tokenIdentifier: nativeToken.rri\n    })), Object.assign({}, input));\n  });\n  const unstakeTokens = input => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n    radixLog.debug('unstake');\n    const nativeToken = yield (0, rxjs_1.firstValueFrom)(nativeTokenSubject);\n    return __makeTransactionFromBuilder(dto_1.TransactionIntentBuilder.create().unstakeTokens(Object.assign(Object.assign({}, input.unstakeInput), {\n      tokenIdentifier: nativeToken.rri\n    })), Object.assign({}, input));\n  });\n  const decryptTransaction = input => {\n    radixLog.debug(\"Trying to decrypt transaction with txID=\".concat(input.txID.toString()));\n    if (!input.message) {\n      const noMsg = \"TX contains no message, nothing to decrypt (txID=\".concat(input.txID.toString(), \").\");\n      radixLog.info(noMsg);\n      return (0, rxjs_1.throwError)(() => new Error(noMsg));\n    }\n    const messageBuffer = Buffer.from(input.message, 'hex');\n    const encryptedMessageResult = crypto_1.Message.fromBuffer(messageBuffer);\n    if (!encryptedMessageResult.isOk()) {\n      const errMessage = \"Failed to parse message as 'EncryptedMessage' type, underlying error: '\".concat((0, util_1.msgFromError)(encryptedMessageResult.error), \"'. Might not have been encrypted? Try decode string as UTF-8 string.\");\n      util_1.log.warn(errMessage);\n      return (0, rxjs_1.throwError)(new Error(errMessage));\n    }\n    const encryptedMessage = encryptedMessageResult.value;\n    if (encryptedMessage.kind !== 'ENCRYPTED') return (0, rxjs_1.of)(encryptedMessage.plaintext);\n    return activeAccount.pipe((0, operators_1.take)(1), (0, operators_1.mergeMap)(account => {\n      const myPublicKey = account.publicKey;\n      util_1.log.debug(\"Trying to decrypt message with activeSigningKey with pubKey=\".concat(myPublicKey.toString()));\n      const publicKeyOfOtherPartyResult = (0, dto_1.singleRecipientFromActions)(myPublicKey, input.actions);\n      if (!publicKeyOfOtherPartyResult.isOk()) {\n        return (0, rxjs_1.throwError)(new Error((0, util_1.msgFromError)(publicKeyOfOtherPartyResult.error)));\n      }\n      util_1.log.debug(\"Trying to decrypt message with publicKeyOfOtherPartyResult=\".concat(publicKeyOfOtherPartyResult.toString()));\n      return account.decrypt({\n        encryptedMessage,\n        publicKeyOfOtherParty: publicKeyOfOtherPartyResult.value\n      });\n    }), (0, operators_1.take)(1));\n  };\n  const restoreLocalHDAccountsToIndex = index => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.restoreLocalHDAccountsToIndex(index)));\n  subs.add(deriveNextLocalHDAccountSubject.pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.mergeMap)(_ref8 => {\n    let [derivation, wallet] = _ref8;\n    return wallet.deriveNextLocalHDAccount(derivation);\n  })).subscribe());\n  subs.add(addAccountByPrivateKeySubject.pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.mergeMap)(_ref9 => {\n    let [privateKeyInput, wallet] = _ref9;\n    return wallet.addAccountFromPrivateKey(privateKeyInput);\n  })).subscribe());\n  subs.add(switchAccountSubject.pipe((0, operators_1.withLatestFrom)(wallet$), (0, operators_1.tap)(_ref10 => {\n    let [switchTo, wallet] = _ref10;\n    return wallet.switchAccount(switchTo);\n  })).subscribe());\n  let headerSub;\n  const methods = {\n    // we forward the full `RadixAPI`, but we also provide some convenience methods based on active account/address.\n    ledger: Object.assign({}, api),\n    __wallet: wallet$,\n    __node: node$,\n    __reset: () => subs.unsubscribe(),\n    // Primarily useful for testing\n    __withNodeConnection: node$ => {\n      subs.add(node$.subscribe(n => {\n        radixLog.debug(\"Using node \".concat(n.url.toString()));\n        nodeSubject.next(n);\n      }, error => {\n        errorNotificationSubject.next((0, errors_1.nodeError)(error));\n      }));\n      return methods;\n    },\n    __withAPI: radixCoreAPI$ => {\n      subs.add(radixCoreAPI$.subscribe(a => coreAPISubject.next(a)));\n      return methods;\n    },\n    __withWallet: wallet => {\n      walletSubject.next(wallet);\n      return methods;\n    },\n    __withKeychain: signingKeychain => {\n      (0, rxjs_1.firstValueFrom)(networkSubject).then(network => {\n        const wallet = wallet_1.Wallet.create({\n          signingKeychain,\n          network\n        });\n        methods.__withWallet(wallet);\n      });\n      return methods;\n    },\n    connect: url => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n      methods.__withNodeConnection((0, rxjs_1.of)({\n        url: new URL(url)\n      }));\n      const networkId = yield (0, rxjs_1.firstValueFrom)(api.networkId());\n      const nativeToken = yield (0, rxjs_1.firstValueFrom)(api.nativeToken(networkId));\n      networkSubject.next(networkId);\n      nativeTokenSubject.next(nativeToken);\n    }),\n    login: (password, loadKeystore) => {\n      walletSubscription === null || walletSubscription === void 0 ? void 0 : walletSubscription.unsubscribe();\n      void account_1.SigningKeychain.byLoadingAndDecryptingKeystore({\n        password,\n        load: loadKeystore\n      }).then(signingKeychainResult => {\n        signingKeychainResult.match(signingKeychain => {\n          walletSubscription = networkSubject.subscribe(network => {\n            const wallet = wallet_1.Wallet.create({\n              signingKeychain,\n              network\n            });\n            methods.__withWallet(wallet);\n          });\n        }, error => {\n          errorNotificationSubject.next((0, errors_1.walletError)(error));\n        });\n      });\n      return methods;\n    },\n    errors: errorNotificationSubject.asObservable(),\n    deriveNextAccount: input => {\n      const derivation = input !== null && input !== void 0 ? input : {};\n      deriveNextLocalHDAccountSubject.next(derivation);\n      return methods;\n    },\n    deriveHWAccount: input => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.deriveHWAccount(input))),\n    displayAddressForActiveHWAccountOnHWDeviceForVerification: () => wallet$.pipe((0, operators_1.mergeMap)(wallet => wallet.displayAddressForActiveHWAccountOnHWDeviceForVerification())),\n    addAccountFromPrivateKey: input => {\n      addAccountByPrivateKeySubject.next(input);\n      return methods;\n    },\n    switchAccount: input => {\n      switchAccountSubject.next(input);\n      return methods;\n    },\n    restoreLocalHDAccountsToIndex,\n    decryptTransaction: decryptTransaction,\n    logLevel: level => {\n      util_1.log.setLevel(level);\n      return methods;\n    },\n    transactionStatus: (txID, trigger) => trigger.pipe((0, operators_1.withLatestFrom)(networkSubject), (0, operators_1.mergeMap)(_ref11 => {\n      let [_, network] = _ref11;\n      return api.getTransaction(txID, network);\n    }), (0, operators_1.distinctUntilChanged)((prev, cur) => prev.status === cur.status), (0, operators_1.filter)(_ref12 => {\n      let {\n        txID\n      } = _ref12;\n      return txID.equals(txID);\n    }), (0, operators_1.tap)(_ref13 => {\n      let {\n        status\n      } = _ref13;\n      return radixLog.info(\"Got transaction status \".concat(status.toString(), \" for txID: \").concat(txID.toString()));\n    })),\n    withTokenBalanceFetchTrigger: trigger => {\n      subs.add(trigger.subscribe(tokenBalanceFetchSubject));\n      return methods;\n    },\n    withStakingFetchTrigger: trigger => {\n      subs.add(trigger.subscribe(stakingFetchSubject));\n      return methods;\n    },\n    // Wallet APIs\n    revealMnemonic,\n    activeAddress,\n    activeAccount,\n    accounts,\n    // Active AccountAddress/Account APIs\n    tokenBalances,\n    stakingPositions,\n    unstakingPositions,\n    lookupTransaction: txID => networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(txID, network).pipe((0, operators_1.withLatestFrom)(activeAddress), (0, operators_1.map)(_ref14 => {\n      let [simpleTx, aa] = _ref14;\n      return decorateSimpleExecutedTransactionWithType(simpleTx, aa);\n    })))),\n    transactionHistory,\n    transferTokens,\n    stakeTokens,\n    unstakeTokens,\n    getTransaction: txID => networkSubject.pipe((0, operators_1.mergeMap)(network => api.getTransaction(txID, network))),\n    validators: () => networkSubject.pipe((0, operators_1.mergeMap)(network => api.validators(network))),\n    setHeaders: headers => {\n      headerSub.unsubscribe();\n      headerSub = coreAPI$.subscribe(api => api.setHeaders(headers));\n    },\n    targetApiVersion: networking_1.apiVersion\n  };\n  return methods;\n};\nexports.Radix = {\n  create\n};","map":{"version":3,"names":["account_1","require","networking_1","api_1","operators_1","rxjs_1","crypto_1","errors_1","util_1","dto_1","actions_1","wallet_1","_1","utils_1","txTypeFromActions","input","activeAddress","myAddress","toString","fromUnique","flatMapAddressesOf","Object","assign","includeTo","map","a","toUnique","includeFrom","toMe","includes","fromMe","TransactionType","FROM_ME_TO_ME","INCOMING","OUTGOING","UNRELATED","decorateSimpleExecutedTransactionWithType","simpleExecutedTX","transactionType","actions","shouldConfirmTransactionAutomatically","confirmationScheme","create","subs","Subscription","radixLog","log","nodeSubject","ReplaySubject","coreAPISubject","walletSubject","errorNotificationSubject","Subject","deriveNextLocalHDAccountSubject","addAccountByPrivateKeySubject","switchAccountSubject","tokenBalanceFetchSubject","stakingFetchSubject","wallet$","asObservable","networkSubject","nativeTokenSubject","walletSubscription","coreAPIViaNode$","pipe","n","radixCoreAPI","nodeAPI","url","coreAPI$","merge","shareReplay","fwdAPICall","pickFn","errorFn","_len","arguments","length","Array","_key","mergeMap","take","catchError","error","isArray","api","networkId","m","networkIdErr","tokenBalancesForAddress","tokenBalancesErr","transactionHistory","transactionHistoryErr","recentTransactions","recentTransactionsErr","nativeToken","nativeTokenErr","tokenInfo","tokenInfoErr","stakesForAddress","stakesForAddressErr","unstakesForAddress","unstakesForAddressErr","validators","validatorsErr","lookupValidator","lookupValidatorErr","getTransaction","transactionStatus","lookupTxErr","buildTransaction","buildTxFromIntentErr","finalizeTransaction","finalizeTxErr","submitSignedTransaction","submitSignedTxErr","observeActiveAccount","address","revealMnemonic","wallet","activeAddressToAPIObservableWithTrigger","trigger","withLatestFrom","result","switchMap","_ref","console","next","EMPTY","tokenBalances","stakingPositions","unstakingPositions","simpleTxHistory","transactions","node$","node","activeAccount","distinctUntilChanged","prev","cur","equals","accounts","observeAccounts","__makeTransactionFromIntent","transactionIntent$","options","txLog","txSubs","debug","signUnsignedTx","unsignedTx","combineLatest","_ref2","transactionIntent","account","nonXRDHRPsOfRRIsInTx","filter","type","ActionType","TOKEN_TRANSFER","t","rri","name","uniquenonXRDHRPsOfRRIsInTx","Set","errMsg","throwError","Error","nonXRDHrp","undefined","sign","transaction","signature","publicKeyOfSigner","publicKey","pendingTXSubject","askUserToConfirmSubject","userDidConfirmTransactionSubject","userConfirmation","add","subscribe","twoWayConfirmationSubject","ux","info","confirmation","txToConfirm","confirm","trackingSubject","track","event","completionSubject","trackError","errorEvent","eventUpdateType","inStep","builtTransaction$","_ref3","intent","transactionState","TransactionTrackingEventType","INITIATED","e","BUILT_FROM_INTENT","tap","builtTx","ASKED_FOR_CONFIRMATION","signedTransaction$","_ref4","signedTx","_","CONFIRMED","concat","JSON","stringify","SIGNED","finalizedTx$","network","FINALIZED","finalizedTx","blob","txID","SUBMITTED","pendingTx","submitTXError","message","pollTxStatusTrigger","_a","pollTXStatusTrigger","interval","share","transactionStatus$","_ref5","retryWhen","retryOnErrorCode","maxRetryAttempts","errorCodes","status","transactionCompletedWithStatusConfirmed$","skipWhile","_ref6","TransactionStatus","transactionCompletedWithStatusFailed$","_ref7","FAILED","statusOfTransaction","UPDATE_OF_STATUS_OF_PENDING_TX","transactionStatusError","COMPLETED","complete","unsubscribe","completion","events","__makeTransactionFromBuilder","transactionIntentBuilderT","makeTXOptions","builderOptions","intent$","build","skipEncryptionOfMessageIfAny","spendingSender","transferTokens","builder","TransactionIntentBuilder","transferInput","encryptMsgIfAny","encrypt","encryptMessageIfAnyWithAccount","stakeTokens","tslib_1","__awaiter","firstValueFrom","stakeInput","tokenIdentifier","unstakeTokens","unstakeInput","decryptTransaction","noMsg","messageBuffer","Buffer","from","encryptedMessageResult","Message","fromBuffer","isOk","errMessage","msgFromError","warn","encryptedMessage","value","kind","of","plaintext","myPublicKey","publicKeyOfOtherPartyResult","singleRecipientFromActions","decrypt","publicKeyOfOtherParty","restoreLocalHDAccountsToIndex","index","_ref8","derivation","deriveNextLocalHDAccount","_ref9","privateKeyInput","addAccountFromPrivateKey","_ref10","switchTo","switchAccount","headerSub","methods","ledger","__wallet","__node","__reset","__withNodeConnection","nodeError","__withAPI","radixCoreAPI$","__withWallet","__withKeychain","signingKeychain","then","Wallet","connect","URL","login","password","loadKeystore","SigningKeychain","byLoadingAndDecryptingKeystore","load","signingKeychainResult","match","walletError","errors","deriveNextAccount","deriveHWAccount","displayAddressForActiveHWAccountOnHWDeviceForVerification","logLevel","level","setLevel","_ref11","_ref12","_ref13","withTokenBalanceFetchTrigger","withStakingFetchTrigger","lookupTransaction","_ref14","simpleTx","aa","setHeaders","headers","targetApiVersion","apiVersion","exports","Radix"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/application/src/radix.ts"],"sourcesContent":["import {\n\tAccountAddressT,\n\tDeriveHWSigningKeyInput,\n\tDeriveNextInput,\n\tSigningKeychain,\n\tSigningKeychainT,\n} from '@radixdlt/account'\nimport { Network } from '@radixdlt/primitives'\nimport { apiVersion } from '@radixdlt/networking'\nimport { nodeAPI, NodeT, radixCoreAPI, RadixCoreAPI } from './api'\n\nimport {\n\tcatchError,\n\tdistinctUntilChanged,\n\tfilter,\n\tmap,\n\tmergeMap,\n\tretryWhen,\n\tshare,\n\tshareReplay,\n\tskipWhile,\n\tswitchMap,\n\ttake,\n\ttap,\n\twithLatestFrom,\n} from 'rxjs/operators'\nimport {\n\tcombineLatest,\n\tEMPTY,\n\tfirstValueFrom,\n\tinterval,\n\tmerge,\n\tObservable,\n\tof,\n\tReplaySubject,\n\tSubject,\n\tSubscription,\n\tthrowError,\n} from 'rxjs'\nimport { KeystoreT, Message, MnemomicT } from '@radixdlt/crypto'\nimport {\n\tAddAccountByPrivateKeyInput,\n\tAccountsT,\n\tWalletT,\n\tAccountT,\n\tMakeTransactionOptions,\n\tManualUserConfirmTX,\n\tSwitchAccountInput,\n\tTransactionConfirmationBeforeFinalization,\n\tTransferTokensOptions,\n} from './_types'\nimport {\n\tAPIError,\n\tAPIErrorObject,\n\tbuildTxFromIntentErr,\n\tfinalizeTxErr,\n\tlookupTxErr,\n\tlookupValidatorErr,\n\tnativeTokenErr,\n\tnetworkIdErr,\n\tnodeError,\n\trecentTransactionsErr,\n\tstakesForAddressErr,\n\tsubmitSignedTxErr,\n\ttokenBalancesErr,\n\ttransactionHistoryErr,\n\tunstakesForAddressErr,\n\tvalidatorsErr,\n\twalletError,\n} from './errors'\nimport { log, LogLevel, msgFromError, isArray } from '@radixdlt/util'\nimport {\n\tBuiltTransaction,\n\tExecutedTransaction,\n\tFinalizedTransaction,\n\tflatMapAddressesOf,\n\tPendingTransaction,\n\tSignedTransaction,\n\tSimpleExecutedTransaction,\n\tSimpleTransactionHistory,\n\tsingleRecipientFromActions,\n\tToken,\n\tTransactionHistory,\n\tTransactionHistoryActiveAccountRequestInput,\n\tTransactionIdentifierT,\n\tTransactionIntent,\n\tTransactionIntentBuilder,\n\tTransactionIntentBuilderOptions,\n\tTransactionIntentBuilderT,\n\tTransactionStateError,\n\tTransactionStateUpdate,\n\tTransactionTracking,\n\tTransactionTrackingEventType,\n\tTransactionType,\n\tTransactionStatus,\n} from './dto'\nimport {\n\tActionType,\n\tExecutedAction,\n\tTransferTokensAction,\n\tStakeTokensInput,\n\tUnstakeTokensInput,\n} from './actions'\nimport { Wallet } from './wallet'\nimport { tokenInfoErr } from '.'\nimport { retryOnErrorCode } from './api/utils'\n\nconst txTypeFromActions = (\n\tinput: Readonly<{\n\t\tactions: ExecutedAction[]\n\t\tactiveAddress: AccountAddressT\n\t}>,\n): TransactionType => {\n\tconst { activeAddress } = input\n\tconst myAddress = activeAddress.toString()\n\tconst fromUnique = flatMapAddressesOf({\n\t\t...input,\n\t\tincludeTo: false,\n\t}).map(a => a.toString())\n\tconst toUnique = flatMapAddressesOf({\n\t\t...input,\n\t\tincludeFrom: false,\n\t}).map(a => a.toString())\n\n\tconst toMe = toUnique.includes(myAddress)\n\tconst fromMe = fromUnique.includes(myAddress)\n\n\tif (toMe && fromMe) {\n\t\treturn TransactionType.FROM_ME_TO_ME\n\t} else if (toMe) {\n\t\treturn TransactionType.INCOMING\n\t} else if (fromMe) {\n\t\treturn TransactionType.OUTGOING\n\t} else {\n\t\treturn TransactionType.UNRELATED\n\t}\n}\n\nconst decorateSimpleExecutedTransactionWithType = (\n\tsimpleExecutedTX: SimpleExecutedTransaction,\n\tactiveAddress: AccountAddressT,\n): ExecutedTransaction => ({\n\t...simpleExecutedTX,\n\ttransactionType: txTypeFromActions({\n\t\tactions: simpleExecutedTX.actions,\n\t\tactiveAddress,\n\t}),\n})\n\nconst shouldConfirmTransactionAutomatically = (\n\tconfirmationScheme: TransactionConfirmationBeforeFinalization,\n): confirmationScheme is 'skip' => confirmationScheme === 'skip'\n\nconst create = () => {\n\tconst subs = new Subscription()\n\tconst radixLog = log // TODO configure child loggers\n\n\tconst nodeSubject = new ReplaySubject<NodeT>()\n\tconst coreAPISubject = new ReplaySubject<RadixCoreAPI>()\n\tconst walletSubject = new ReplaySubject<WalletT>()\n\tconst errorNotificationSubject = new Subject<APIError>()\n\n\tconst deriveNextLocalHDAccountSubject = new Subject<DeriveNextInput>()\n\tconst addAccountByPrivateKeySubject = new Subject<AddAccountByPrivateKeyInput>()\n\tconst switchAccountSubject = new Subject<SwitchAccountInput>()\n\n\tconst tokenBalanceFetchSubject = new Subject<number>()\n\tconst stakingFetchSubject = new Subject<number>()\n\tconst wallet$ = walletSubject.asObservable()\n\n\tconst networkSubject = new ReplaySubject<Network>()\n\tconst nativeTokenSubject = new ReplaySubject<Token>()\n\n\tlet walletSubscription: Subscription\n\n\tconst coreAPIViaNode$ = nodeSubject\n\t\t.asObservable()\n\t\t.pipe(map((n: NodeT) => radixCoreAPI(n, nodeAPI(n.url))))\n\n\tconst coreAPI$ = merge(coreAPIViaNode$, coreAPISubject.asObservable()).pipe(\n\t\tshareReplay(1),\n\t)\n\t// Forwards calls to RadixCoreAPI, return type is a function: `(input?: I) => Observable<O>`\n\tconst fwdAPICall = <I extends unknown[], O>(\n\t\tpickFn: (api: RadixCoreAPI) => (...input: I) => Observable<O>,\n\t\terrorFn: (error: APIErrorObject) => APIError,\n\t) => (...input: I) =>\n\t\tcoreAPI$.pipe(\n\t\t\tmergeMap(a => pickFn(a)(...input)),\n\t\t\ttake(1), // Important!\n\t\t\tcatchError((error: unknown) => {\n\t\t\t\tthrow errorFn(isArray(error) ? (error as any)[0] : error)\n\t\t\t}),\n\t\t)\n\n\tconst api = {\n\t\tnetworkId: fwdAPICall(\n\t\t\ta => a.networkId,\n\t\t\tm => networkIdErr(m),\n\t\t),\n\n\t\ttokenBalancesForAddress: fwdAPICall(\n\t\t\ta => a.tokenBalancesForAddress,\n\t\t\tm => tokenBalancesErr(m),\n\t\t),\n\n\t\ttransactionHistory: fwdAPICall(\n\t\t\ta => a.transactionHistory,\n\t\t\tm => transactionHistoryErr(m),\n\t\t),\n\n\t\trecentTransactions: fwdAPICall(\n\t\t\ta => a.recentTransactions,\n\t\t\tm => recentTransactionsErr(m),\n\t\t),\n\n\t\tnativeToken: fwdAPICall(\n\t\t\ta => a.nativeToken,\n\t\t\tm => nativeTokenErr(m),\n\t\t),\n\n\t\ttokenInfo: fwdAPICall(\n\t\t\ta => a.tokenInfo,\n\t\t\tm => tokenInfoErr(m),\n\t\t),\n\n\t\tstakesForAddress: fwdAPICall(\n\t\t\ta => a.stakesForAddress,\n\t\t\tm => stakesForAddressErr(m),\n\t\t),\n\n\t\tunstakesForAddress: fwdAPICall(\n\t\t\ta => a.unstakesForAddress,\n\t\t\tm => unstakesForAddressErr(m),\n\t\t),\n\n\t\tvalidators: fwdAPICall(\n\t\t\ta => a.validators,\n\t\t\tm => validatorsErr(m),\n\t\t),\n\n\t\tlookupValidator: fwdAPICall(\n\t\t\ta => a.lookupValidator,\n\t\t\tm => lookupValidatorErr(m),\n\t\t),\n\n\t\tgetTransaction: fwdAPICall(\n\t\t\ta => a.transactionStatus,\n\t\t\tm => lookupTxErr(m),\n\t\t),\n\t\tbuildTransaction: fwdAPICall(\n\t\t\ta => a.buildTransaction,\n\t\t\tm => buildTxFromIntentErr(m),\n\t\t),\n\n\t\tfinalizeTransaction: fwdAPICall(\n\t\t\ta => a.finalizeTransaction,\n\t\t\tm => finalizeTxErr(m),\n\t\t),\n\t\tsubmitSignedTransaction: fwdAPICall(\n\t\t\ta => a.submitSignedTransaction,\n\t\t\tm => submitSignedTxErr(m),\n\t\t),\n\t}\n\n\tconst activeAddress = wallet$.pipe(\n\t\tmergeMap(a => a.observeActiveAccount()),\n\t\tmap(a => a.address),\n\t\tshareReplay(1),\n\t)\n\n\tconst revealMnemonic = (): Observable<MnemomicT> =>\n\t\twallet$.pipe(\n\t\t\tmap((wallet: WalletT): MnemomicT => wallet.revealMnemonic()),\n\t\t)\n\n\tconst activeAddressToAPIObservableWithTrigger = <O>(\n\t\ttrigger: Observable<number>,\n\t\tpickFn: (\n\t\t\tapi: RadixCoreAPI,\n\t\t) => (address: AccountAddressT) => Observable<O>,\n\t\terrorFn: (error: APIErrorObject) => APIError,\n\t): Observable<O> =>\n\t\tmerge(\n\t\t\ttrigger.pipe(\n\t\t\t\twithLatestFrom(activeAddress),\n\t\t\t\tmap(result => result[1]),\n\t\t\t),\n\t\t\tactiveAddress,\n\t\t).pipe(\n\t\t\twithLatestFrom(coreAPI$),\n\t\t\tswitchMap(([address, api]) =>\n\t\t\t\tpickFn(api)(address).pipe(\n\t\t\t\t\tcatchError(error => {\n\t\t\t\t\t\tconsole.error(error)\n\t\t\t\t\t\terrorNotificationSubject.next(errorFn(error))\n\t\t\t\t\t\treturn EMPTY\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t),\n\t\t\tshareReplay(1),\n\t\t)\n\n\tconst tokenBalances = activeAddressToAPIObservableWithTrigger(\n\t\ttokenBalanceFetchSubject,\n\t\ta => a.tokenBalancesForAddress,\n\t\ttokenBalancesErr,\n\t)\n\n\t/*\n\t\tconst decorateSimpleTokenBalanceWithTokenInfo = (\n\t\t\tsimpleTokenBalance: SimpleTokenBalance,\n\t\t): Observable<TokenBalance> =>\n\t\t\tapi.tokenInfo(simpleTokenBalance.tokenIdentifier).pipe(\n\t\t\t\tmap(\n\t\t\t\t\t(tokenInfo: Token): TokenBalance => ({\n\t\t\t\t\t\tamount: simpleTokenBalance.amount,\n\t\t\t\t\t\ttoken: tokenInfo,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t)\n\t*/\n\tconst stakingPositions = activeAddressToAPIObservableWithTrigger(\n\t\tstakingFetchSubject,\n\t\ta => a.stakesForAddress,\n\t\tstakesForAddressErr,\n\t)\n\n\tconst unstakingPositions = activeAddressToAPIObservableWithTrigger(\n\t\tstakingFetchSubject,\n\t\ta => a.unstakesForAddress,\n\t\tunstakesForAddressErr,\n\t)\n\n\tconst transactionHistory = (\n\t\tinput: TransactionHistoryActiveAccountRequestInput,\n\t): Observable<TransactionHistory> =>\n\t\tactiveAddress.pipe(\n\t\t\ttake(1),\n\t\t\tswitchMap(activeAddress =>\n\t\t\t\tapi\n\t\t\t\t\t.transactionHistory({ ...input, address: activeAddress })\n\t\t\t\t\t.pipe(\n\t\t\t\t\t\tmap(\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tsimpleTxHistory: SimpleTransactionHistory,\n\t\t\t\t\t\t\t): TransactionHistory => ({\n\t\t\t\t\t\t\t\t...simpleTxHistory,\n\t\t\t\t\t\t\t\ttransactions: simpleTxHistory.transactions.map(\n\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\tsimpleExecutedTX: SimpleExecutedTransaction,\n\t\t\t\t\t\t\t\t\t): ExecutedTransaction =>\n\t\t\t\t\t\t\t\t\t\tdecorateSimpleExecutedTransactionWithType(\n\t\t\t\t\t\t\t\t\t\t\tsimpleExecutedTX,\n\t\t\t\t\t\t\t\t\t\t\tactiveAddress,\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\tconst node$ = merge(\n\t\tnodeSubject.asObservable(),\n\t\tcoreAPISubject.asObservable().pipe(map(api => api.node)),\n\t)\n\n\tconst activeAccount: Observable<AccountT> = wallet$.pipe(\n\t\tmergeMap(wallet => wallet.observeActiveAccount()),\n\t\tshareReplay(1),\n\t\tdistinctUntilChanged((prev, cur) => prev.equals(cur)),\n\t)\n\n\tconst accounts = wallet$.pipe(\n\t\tmergeMap(wallet => wallet.observeAccounts()),\n\t\tshareReplay(1),\n\t)\n\n\tconst __makeTransactionFromIntent = (\n\t\ttransactionIntent$: Observable<TransactionIntent>,\n\t\toptions: MakeTransactionOptions,\n\t): TransactionTracking => {\n\t\tconst txLog = radixLog // TODO configure child loggers\n\t\tconst txSubs = new Subscription()\n\n\t\ttxLog.debug(\n\t\t\t`Start of transaction flow, inside constructor of 'TransactionTracking'.`,\n\t\t)\n\n\t\tconst signUnsignedTx = (\n\t\t\tunsignedTx: BuiltTransaction,\n\t\t): Observable<SignedTransaction> => {\n\t\t\ttxLog.debug('Starting signing transaction (async).')\n\t\t\treturn combineLatest(\n\t\t\t\ttransactionIntent$,\n\t\t\t\tactiveAccount.pipe(take(1)),\n\t\t\t).pipe(\n\t\t\t\tmergeMap(\n\t\t\t\t\t([\n\t\t\t\t\t\ttransactionIntent,\n\t\t\t\t\t\taccount,\n\t\t\t\t\t]): Observable<SignedTransaction> => {\n\t\t\t\t\t\tconst nonXRDHRPsOfRRIsInTx: string[] = transactionIntent.actions\n\t\t\t\t\t\t\t.filter(a => a.type === ActionType.TOKEN_TRANSFER)\n\t\t\t\t\t\t\t.map(a => a as TransferTokensAction)\n\t\t\t\t\t\t\t.filter(t => t.rri.name !== 'xrd')\n\t\t\t\t\t\t\t.map(t => t.rri.name)\n\n\t\t\t\t\t\tconst uniquenonXRDHRPsOfRRIsInTx = [\n\t\t\t\t\t\t\t...new Set(nonXRDHRPsOfRRIsInTx),\n\t\t\t\t\t\t]\n\n\t\t\t\t\t\tif (uniquenonXRDHRPsOfRRIsInTx.length > 1) {\n\t\t\t\t\t\t\tconst errMsg = `Error cannot sign transction with multiple non-XRD RRIs. Unsupported by Ledger app.`\n\t\t\t\t\t\t\tlog.error(errMsg)\n\t\t\t\t\t\t\treturn throwError(new Error(errMsg))\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst nonXRDHrp =\n\t\t\t\t\t\t\tuniquenonXRDHRPsOfRRIsInTx.length === 1\n\t\t\t\t\t\t\t\t? uniquenonXRDHRPsOfRRIsInTx[0]\n\t\t\t\t\t\t\t\t: undefined\n\n\t\t\t\t\t\treturn account\n\t\t\t\t\t\t\t.sign(unsignedTx.transaction, nonXRDHrp)\n\t\t\t\t\t\t\t.pipe(\n\t\t\t\t\t\t\t\tmap(\n\t\t\t\t\t\t\t\t\t(signature): SignedTransaction => {\n\t\t\t\t\t\t\t\t\t\tconst publicKeyOfSigner =\n\t\t\t\t\t\t\t\t\t\t\taccount.publicKey\n\t\t\t\t\t\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Finished signing transaction`,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttransaction: unsignedTx.transaction,\n\t\t\t\t\t\t\t\t\t\t\tsignature,\n\t\t\t\t\t\t\t\t\t\t\tpublicKeyOfSigner,\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tconst pendingTXSubject = new Subject<PendingTransaction>()\n\n\t\tconst askUserToConfirmSubject = new ReplaySubject<BuiltTransaction>()\n\t\tconst userDidConfirmTransactionSubject = new ReplaySubject<0>()\n\n\t\tif (shouldConfirmTransactionAutomatically(options.userConfirmation)) {\n\t\t\ttxLog.debug(\n\t\t\t\t'Transaction has been setup to be automatically confirmed, requiring no final confirmation input from user.',\n\t\t\t)\n\t\t\ttxSubs.add(\n\t\t\t\taskUserToConfirmSubject.subscribe(() => {\n\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t`askUserToConfirmSubject got 'next', calling 'next' on 'userDidConfirmTransactionSubject'`,\n\t\t\t\t\t)\n\t\t\t\t\tuserDidConfirmTransactionSubject.next(0)\n\t\t\t\t}),\n\t\t\t)\n\t\t} else {\n\t\t\ttxLog.debug(\n\t\t\t\t`Transaction has been setup so that it requires a manual final confirmation from user before being finalized.`,\n\t\t\t)\n\t\t\tconst twoWayConfirmationSubject: Subject<ManualUserConfirmTX> =\n\t\t\t\toptions.userConfirmation\n\n\t\t\ttxSubs.add(\n\t\t\t\taskUserToConfirmSubject.subscribe(ux => {\n\t\t\t\t\ttxLog.info(\n\t\t\t\t\t\t`Forwarding signedUnconfirmedTX and 'userDidConfirmTransactionSubject' to subject 'twoWayConfirmationSubject' now (inside subscribe to 'askUserToConfirmSubject')`,\n\t\t\t\t\t)\n\n\t\t\t\t\tconst confirmation: ManualUserConfirmTX = {\n\t\t\t\t\t\ttxToConfirm: ux,\n\t\t\t\t\t\tconfirm: () => userDidConfirmTransactionSubject.next(0),\n\t\t\t\t\t}\n\t\t\t\t\ttwoWayConfirmationSubject.next(confirmation)\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\n\t\tconst trackingSubject = new ReplaySubject<TransactionStateUpdate>()\n\n\t\tconst track = (event: TransactionStateUpdate): void => {\n\t\t\ttrackingSubject.next(event)\n\t\t}\n\n\t\tconst completionSubject = new Subject<TransactionIdentifierT>()\n\n\t\tconst trackError = (\n\t\t\tinput: Readonly<{\n\t\t\t\terror: Error\n\t\t\t\tinStep: TransactionTrackingEventType\n\t\t\t}>,\n\t\t): void => {\n\t\t\tconst errorEvent: TransactionStateError = {\n\t\t\t\teventUpdateType: input.inStep,\n\t\t\t\terror: input.error,\n\t\t\t}\n\t\t\ttxLog.debug(`Forwarding error to 'errorSubject'`)\n\t\t\ttrack(errorEvent)\n\t\t\tcompletionSubject.error(errorEvent.error)\n\t\t}\n\n\t\tconst builtTransaction$ = transactionIntent$.pipe(\n\t\t\twithLatestFrom(activeAddress),\n\t\t\tswitchMap(\n\t\t\t\t([intent, address]): Observable<BuiltTransaction> => {\n\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t'Transaction intent created => requesting ðŸ›° API to build it now.',\n\t\t\t\t\t)\n\t\t\t\t\ttrack({\n\t\t\t\t\t\ttransactionState: intent,\n\t\t\t\t\t\teventUpdateType: TransactionTrackingEventType.INITIATED,\n\t\t\t\t\t})\n\t\t\t\t\treturn api.buildTransaction(intent, address)\n\t\t\t\t},\n\t\t\t),\n\t\t\tcatchError((e: Error) => {\n\t\t\t\ttxLog.error(`API failed to build transaction`)\n\t\t\t\ttrackError({\n\t\t\t\t\terror: e,\n\t\t\t\t\tinStep: TransactionTrackingEventType.BUILT_FROM_INTENT,\n\t\t\t\t})\n\t\t\t\treturn EMPTY\n\t\t\t}),\n\t\t\ttap(builtTx => {\n\t\t\t\ttxLog.debug(\n\t\t\t\t\t'TX built by API => asking for confirmation to sign...',\n\t\t\t\t)\n\t\t\t\ttrack({\n\t\t\t\t\ttransactionState: builtTx,\n\t\t\t\t\teventUpdateType:\n\t\t\t\t\t\tTransactionTrackingEventType.BUILT_FROM_INTENT,\n\t\t\t\t})\n\t\t\t\taskUserToConfirmSubject.next(builtTx)\n\t\t\t}),\n\t\t\ttap(builtTx => {\n\t\t\t\ttrack({\n\t\t\t\t\ttransactionState: builtTx,\n\t\t\t\t\teventUpdateType:\n\t\t\t\t\t\tTransactionTrackingEventType.ASKED_FOR_CONFIRMATION,\n\t\t\t\t})\n\t\t\t}),\n\t\t)\n\n\t\tconst signedTransaction$ = combineLatest([\n\t\t\tbuiltTransaction$,\n\t\t\tuserDidConfirmTransactionSubject,\n\t\t]).pipe(\n\t\t\tmap(([signedTx, _]) => signedTx),\n\t\t\ttap(unsignedTx => {\n\t\t\t\ttrack({\n\t\t\t\t\ttransactionState: unsignedTx,\n\t\t\t\t\teventUpdateType: TransactionTrackingEventType.CONFIRMED,\n\t\t\t\t})\n\t\t\t}),\n\t\t\tmergeMap(unsignedTx => signUnsignedTx(unsignedTx)),\n\t\t\tshareReplay(1),\n\t\t\tcatchError((e: Error) => {\n\t\t\t\ttxLog.error(\n\t\t\t\t\t`API failed to sign transaction, error: ${JSON.stringify(\n\t\t\t\t\t\te,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t4,\n\t\t\t\t\t)}`,\n\t\t\t\t)\n\t\t\t\ttrackError({\n\t\t\t\t\terror: e,\n\t\t\t\t\tinStep: TransactionTrackingEventType.SIGNED,\n\t\t\t\t})\n\t\t\t\treturn EMPTY\n\t\t\t}),\n\t\t)\n\n\t\tconst finalizedTx$ = signedTransaction$.pipe(\n\t\t\tmergeMap(\n\t\t\t\t(\n\t\t\t\t\tsignedTx: SignedTransaction,\n\t\t\t\t): Observable<FinalizedTransaction> => {\n\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t`Finished signing tx => submitting it to ðŸ›°  API.`,\n\t\t\t\t\t)\n\t\t\t\t\ttrack({\n\t\t\t\t\t\ttransactionState: signedTx,\n\t\t\t\t\t\teventUpdateType: TransactionTrackingEventType.SIGNED,\n\t\t\t\t\t})\n\t\t\t\t\treturn networkSubject.pipe(\n\t\t\t\t\t\tmergeMap(network =>\n\t\t\t\t\t\t\tapi.finalizeTransaction(network, signedTx),\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t),\n\t\t\tcatchError((e: Error) => {\n\t\t\t\ttxLog.error(\n\t\t\t\t\t`API failed to submit transaction, error: ${JSON.stringify(\n\t\t\t\t\t\te,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t4,\n\t\t\t\t\t)}`,\n\t\t\t\t)\n\t\t\t\ttrackError({\n\t\t\t\t\terror: e,\n\t\t\t\t\tinStep: TransactionTrackingEventType.FINALIZED,\n\t\t\t\t})\n\t\t\t\treturn EMPTY\n\t\t\t}),\n\t\t\ttap<FinalizedTransaction>(finalizedTx => {\n\t\t\t\ttrack({\n\t\t\t\t\ttransactionState: finalizedTx,\n\t\t\t\t\teventUpdateType: TransactionTrackingEventType.FINALIZED,\n\t\t\t\t})\n\t\t\t}),\n\t\t)\n\n\t\ttxSubs.add(\n\t\t\tfinalizedTx$\n\t\t\t\t.pipe(\n\t\t\t\t\tmergeMap(\n\t\t\t\t\t\t(finalizedTx): Observable<PendingTransaction> =>\n\t\t\t\t\t\t\tnetworkSubject.pipe(\n\t\t\t\t\t\t\t\tmergeMap(network =>\n\t\t\t\t\t\t\t\t\tapi.submitSignedTransaction(network, {\n\t\t\t\t\t\t\t\t\t\tblob: finalizedTx.blob,\n\t\t\t\t\t\t\t\t\t\ttxID: finalizedTx.txID,\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\tcatchError((e: Error) => {\n\t\t\t\t\t\ttxLog.error(\n\t\t\t\t\t\t\t`API failed to submit transaction, error: ${JSON.stringify(\n\t\t\t\t\t\t\t\te,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t\ttrackError({\n\t\t\t\t\t\t\terror: e,\n\t\t\t\t\t\t\tinStep: TransactionTrackingEventType.SUBMITTED,\n\t\t\t\t\t\t})\n\t\t\t\t\t\treturn EMPTY\n\t\t\t\t\t}),\n\t\t\t\t\ttap({\n\t\t\t\t\t\tnext: (pendingTx: PendingTransaction) => {\n\t\t\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t\t\t`Submitted transaction with txID='${pendingTx.txID.toString()}', it is now pending.`,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\ttrack({\n\t\t\t\t\t\t\t\ttransactionState: pendingTx,\n\t\t\t\t\t\t\t\teventUpdateType:\n\t\t\t\t\t\t\t\t\tTransactionTrackingEventType.SUBMITTED,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tpendingTXSubject.next(pendingTx)\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: (submitTXError: Error) => {\n\t\t\t\t\t\t\t// TODO would be great to have access to txID here, hopefully API includes it in error msg?\n\t\t\t\t\t\t\ttxLog.error(\n\t\t\t\t\t\t\t\t`Submission of signed transaction to API failed with error: ${submitTXError.message}`,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tpendingTXSubject.error(submitTXError)\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.subscribe(),\n\t\t)\n\n\t\tconst pollTxStatusTrigger = (\n\t\t\toptions.pollTXStatusTrigger ?? interval(1000)\n\t\t).pipe(share())\n\n\t\tconst transactionStatus$ = combineLatest([\n\t\t\tpollTxStatusTrigger,\n\t\t\tpendingTXSubject,\n\t\t]).pipe(\n\t\t\tmergeMap(([_, pendingTx]) => {\n\t\t\t\ttxLog.debug(\n\t\t\t\t\t`Asking API for status of transaction with txID: ${pendingTx.txID.toString()}`,\n\t\t\t\t)\n\t\t\t\treturn networkSubject.pipe(\n\t\t\t\t\tmergeMap(network =>\n\t\t\t\t\t\tapi.getTransaction(pendingTx.txID, network).pipe(\n\t\t\t\t\t\t\tretryWhen(\n\t\t\t\t\t\t\t\tretryOnErrorCode({\n\t\t\t\t\t\t\t\t\tmaxRetryAttempts: 3,\n\t\t\t\t\t\t\t\t\terrorCodes: [404],\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t}),\n\t\t\tdistinctUntilChanged((prev, cur) => prev.status === cur.status),\n\t\t\tshare(),\n\t\t)\n\n\t\tconst transactionCompletedWithStatusConfirmed$ = transactionStatus$.pipe(\n\t\t\tskipWhile(({ status }) => status !== TransactionStatus.CONFIRMED),\n\t\t\ttake(1),\n\t\t)\n\n\t\tconst transactionCompletedWithStatusFailed$ = transactionStatus$.pipe(\n\t\t\tskipWhile(({ status }) => status !== TransactionStatus.FAILED),\n\t\t\ttake(1),\n\t\t)\n\n\t\ttxSubs.add(\n\t\t\ttransactionStatus$.subscribe({\n\t\t\t\tnext: statusOfTransaction => {\n\t\t\t\t\tconst { status, txID } = statusOfTransaction\n\t\t\t\t\ttxLog.debug(\n\t\t\t\t\t\t`Status ${status.toString()} of transaction with txID='${txID.toString()}'`,\n\t\t\t\t\t)\n\t\t\t\t\ttrack({\n\t\t\t\t\t\ttransactionState: statusOfTransaction,\n\t\t\t\t\t\teventUpdateType:\n\t\t\t\t\t\t\tTransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX,\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\terror: (transactionStatusError: Error) => {\n\t\t\t\t\t// TODO hmm how to get txID here?\n\t\t\t\t\ttxLog.error(\n\t\t\t\t\t\t`Failed to get status of transaction`,\n\t\t\t\t\t\ttransactionStatusError,\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t}),\n\t\t)\n\n\t\ttxSubs.add(\n\t\t\ttransactionCompletedWithStatusConfirmed$.subscribe({\n\t\t\t\tnext: statusOfTransaction => {\n\t\t\t\t\tconst { txID } = statusOfTransaction\n\t\t\t\t\ttxLog.info(\n\t\t\t\t\t\t`Transaction with txID='${txID.toString()}' has completed succesfully.`,\n\t\t\t\t\t)\n\t\t\t\t\ttrack({\n\t\t\t\t\t\ttransactionState: statusOfTransaction,\n\t\t\t\t\t\teventUpdateType: TransactionTrackingEventType.COMPLETED,\n\t\t\t\t\t})\n\n\t\t\t\t\tcompletionSubject.next(txID)\n\t\t\t\t\tcompletionSubject.complete()\n\t\t\t\t\ttxSubs.unsubscribe()\n\t\t\t\t},\n\t\t\t}),\n\t\t)\n\n\t\ttxSubs.add(\n\t\t\ttransactionCompletedWithStatusFailed$.subscribe(status => {\n\t\t\t\tconst errMsg = `API status of tx with id=${status.txID.toString()} returned 'FAILED'`\n\t\t\t\ttxLog.error(errMsg)\n\t\t\t\ttrackError({\n\t\t\t\t\terror: new Error(errMsg),\n\t\t\t\t\tinStep:\n\t\t\t\t\t\tTransactionTrackingEventType.UPDATE_OF_STATUS_OF_PENDING_TX,\n\t\t\t\t})\n\t\t\t\ttxSubs.unsubscribe()\n\t\t\t}),\n\t\t)\n\n\t\treturn {\n\t\t\tcompletion: completionSubject.asObservable(),\n\t\t\tevents: trackingSubject.asObservable(),\n\t\t}\n\t}\n\n\tconst __makeTransactionFromBuilder = (\n\t\ttransactionIntentBuilderT: TransactionIntentBuilderT,\n\t\tmakeTXOptions: MakeTransactionOptions,\n\t\tbuilderOptions?: TransactionIntentBuilderOptions,\n\t): TransactionTracking => {\n\t\tradixLog.debug(`make transaction from builder`)\n\t\tconst intent$ = transactionIntentBuilderT.build(\n\t\t\tbuilderOptions ?? {\n\t\t\t\tskipEncryptionOfMessageIfAny: {\n\t\t\t\t\tspendingSender: activeAddress.pipe(take(1)), // IMPORTANT !\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\t\treturn __makeTransactionFromIntent(intent$, makeTXOptions)\n\t}\n\n\tconst transferTokens = (\n\t\tinput: Omit<TransferTokensOptions, 'from_account'>,\n\t): TransactionTracking => {\n\t\tradixLog.debug(`transferTokens`)\n\t\tconst builder = TransactionIntentBuilder.create().transferTokens(\n\t\t\tinput.transferInput,\n\t\t)\n\n\t\tlet encryptMsgIfAny = false\n\t\tif (input.message) {\n\t\t\tbuilder.message(input.message)\n\t\t\tencryptMsgIfAny = input.message.encrypt\n\t\t}\n\n\t\treturn __makeTransactionFromBuilder(\n\t\t\tbuilder,\n\t\t\t{ ...input },\n\t\t\tencryptMsgIfAny\n\t\t\t\t? {\n\t\t\t\t\t\tencryptMessageIfAnyWithAccount: activeAccount.pipe(\n\t\t\t\t\t\t\ttake(1), // Important !\n\t\t\t\t\t\t),\n\t\t\t\t  }\n\t\t\t\t: undefined,\n\t\t)\n\t}\n\n\tconst stakeTokens = async (\n\t\tinput: MakeTransactionOptions & {\n\t\t\tstakeInput: Omit<StakeTokensInput, 'tokenIdentifier'>\n\t\t},\n\t) => {\n\t\tradixLog.debug('stake')\n\t\tconst nativeToken = await firstValueFrom(nativeTokenSubject)\n\t\treturn __makeTransactionFromBuilder(\n\t\t\tTransactionIntentBuilder.create().stakeTokens({\n\t\t\t\t...input.stakeInput,\n\t\t\t\ttokenIdentifier: nativeToken.rri,\n\t\t\t}),\n\t\t\t{ ...input },\n\t\t)\n\t}\n\n\tconst unstakeTokens = async (\n\t\tinput: MakeTransactionOptions & {\n\t\t\tunstakeInput: Omit<UnstakeTokensInput, 'tokenIdentifier'>\n\t\t},\n\t) => {\n\t\tradixLog.debug('unstake')\n\t\tconst nativeToken = await firstValueFrom(nativeTokenSubject)\n\t\treturn __makeTransactionFromBuilder(\n\t\t\tTransactionIntentBuilder.create().unstakeTokens({\n\t\t\t\t...input.unstakeInput,\n\t\t\t\ttokenIdentifier: nativeToken.rri,\n\t\t\t}),\n\t\t\t{ ...input },\n\t\t)\n\t}\n\n\tconst decryptTransaction = (\n\t\tinput: SimpleExecutedTransaction,\n\t): Observable<string> => {\n\t\tradixLog.debug(\n\t\t\t`Trying to decrypt transaction with txID=${input.txID.toString()}`,\n\t\t)\n\n\t\tif (!input.message) {\n\t\t\tconst noMsg = `TX contains no message, nothing to decrypt (txID=${input.txID.toString()}).`\n\t\t\tradixLog.info(noMsg)\n\t\t\treturn throwError(() => new Error(noMsg))\n\t\t}\n\n\t\tconst messageBuffer = Buffer.from(input.message, 'hex')\n\n\t\tconst encryptedMessageResult = Message.fromBuffer(messageBuffer)\n\n\t\tif (!encryptedMessageResult.isOk()) {\n\t\t\tconst errMessage = `Failed to parse message as 'EncryptedMessage' type, underlying error: '${msgFromError(\n\t\t\t\tencryptedMessageResult.error,\n\t\t\t)}'. Might not have been encrypted? Try decode string as UTF-8 string.`\n\t\t\tlog.warn(errMessage)\n\t\t\treturn throwError(new Error(errMessage))\n\t\t}\n\n\t\tconst encryptedMessage = encryptedMessageResult.value\n\n\t\tif (encryptedMessage.kind !== 'ENCRYPTED')\n\t\t\treturn of(encryptedMessage.plaintext)\n\n\t\treturn activeAccount.pipe(\n\t\t\ttake(1),\n\t\t\tmergeMap((account: AccountT) => {\n\t\t\t\tconst myPublicKey = account.publicKey\n\t\t\t\tlog.debug(\n\t\t\t\t\t`Trying to decrypt message with activeSigningKey with pubKey=${myPublicKey.toString()}`,\n\t\t\t\t)\n\t\t\t\tconst publicKeyOfOtherPartyResult = singleRecipientFromActions(\n\t\t\t\t\tmyPublicKey,\n\t\t\t\t\tinput.actions,\n\t\t\t\t)\n\t\t\t\tif (!publicKeyOfOtherPartyResult.isOk()) {\n\t\t\t\t\treturn throwError(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\tmsgFromError(publicKeyOfOtherPartyResult.error),\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tlog.debug(\n\t\t\t\t\t`Trying to decrypt message with publicKeyOfOtherPartyResult=${publicKeyOfOtherPartyResult.toString()}`,\n\t\t\t\t)\n\n\t\t\t\treturn account.decrypt({\n\t\t\t\t\tencryptedMessage,\n\t\t\t\t\tpublicKeyOfOtherParty: publicKeyOfOtherPartyResult.value,\n\t\t\t\t})\n\t\t\t}),\n\t\t\ttake(1),\n\t\t)\n\t}\n\n\tconst restoreLocalHDAccountsToIndex = (\n\t\tindex: number,\n\t): Observable<AccountsT> =>\n\t\twallet$.pipe(\n\t\t\tmergeMap(wallet => wallet.restoreLocalHDAccountsToIndex(index)),\n\t\t)\n\n\tsubs.add(\n\t\tderiveNextLocalHDAccountSubject\n\t\t\t.pipe(\n\t\t\t\twithLatestFrom(wallet$),\n\t\t\t\tmergeMap(([derivation, wallet]) =>\n\t\t\t\t\twallet.deriveNextLocalHDAccount(derivation),\n\t\t\t\t),\n\t\t\t)\n\t\t\t.subscribe(),\n\t)\n\n\tsubs.add(\n\t\taddAccountByPrivateKeySubject\n\t\t\t.pipe(\n\t\t\t\twithLatestFrom(wallet$),\n\t\t\t\tmergeMap(([privateKeyInput, wallet]) =>\n\t\t\t\t\twallet.addAccountFromPrivateKey(privateKeyInput),\n\t\t\t\t),\n\t\t\t)\n\t\t\t.subscribe(),\n\t)\n\n\tsubs.add(\n\t\tswitchAccountSubject\n\t\t\t.pipe(\n\t\t\t\twithLatestFrom(wallet$),\n\t\t\t\ttap(([switchTo, wallet]) => wallet.switchAccount(switchTo)),\n\t\t\t)\n\t\t\t.subscribe(),\n\t)\n\n\tlet headerSub: Subscription\n\n\tconst methods = {\n\t\t// we forward the full `RadixAPI`, but we also provide some convenience methods based on active account/address.\n\t\tledger: {\n\t\t\t...api,\n\t\t},\n\n\t\t__wallet: wallet$,\n\t\t__node: node$,\n\n\t\t__reset: () => subs.unsubscribe(),\n\n\t\t// Primarily useful for testing\n\t\t__withNodeConnection: (node$: Observable<NodeT>) => {\n\t\t\tsubs.add(\n\t\t\t\tnode$.subscribe(\n\t\t\t\t\tn => {\n\t\t\t\t\t\tradixLog.debug(`Using node ${n.url.toString()}`)\n\t\t\t\t\t\tnodeSubject.next(n)\n\t\t\t\t\t},\n\t\t\t\t\t(error: Error) => {\n\t\t\t\t\t\terrorNotificationSubject.next(nodeError(error) as any)\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t)\n\t\t\treturn methods\n\t\t},\n\n\t\t__withAPI: (radixCoreAPI$: Observable<RadixCoreAPI>) => {\n\t\t\tsubs.add(radixCoreAPI$.subscribe(a => coreAPISubject.next(a)))\n\t\t\treturn methods\n\t\t},\n\n\t\t__withWallet: (wallet: WalletT) => {\n\t\t\twalletSubject.next(wallet)\n\t\t\treturn methods\n\t\t},\n\n\t\t__withKeychain: (signingKeychain: SigningKeychainT) => {\n\t\t\tfirstValueFrom(networkSubject).then(network => {\n\t\t\t\tconst wallet = Wallet.create({\n\t\t\t\t\tsigningKeychain,\n\t\t\t\t\tnetwork,\n\t\t\t\t})\n\t\t\t\tmethods.__withWallet(wallet)\n\t\t\t})\n\t\t\treturn methods\n\t\t},\n\n\t\tconnect: async (url: string) => {\n\t\t\tmethods.__withNodeConnection(of({ url: new URL(url) }))\n\t\t\tconst networkId = await firstValueFrom(api.networkId())\n\t\t\tconst nativeToken = await firstValueFrom(api.nativeToken(networkId))\n\t\t\tnetworkSubject.next(networkId)\n\t\t\tnativeTokenSubject.next(nativeToken)\n\t\t},\n\n\t\tlogin: (password: string, loadKeystore: () => Promise<KeystoreT>) => {\n\t\t\twalletSubscription?.unsubscribe()\n\n\t\t\tvoid SigningKeychain.byLoadingAndDecryptingKeystore({\n\t\t\t\tpassword,\n\t\t\t\tload: loadKeystore,\n\t\t\t}).then(signingKeychainResult => {\n\t\t\t\tsigningKeychainResult.match(\n\t\t\t\t\t(signingKeychain: SigningKeychainT) => {\n\t\t\t\t\t\twalletSubscription = networkSubject.subscribe(\n\t\t\t\t\t\t\tnetwork => {\n\t\t\t\t\t\t\t\tconst wallet = Wallet.create({\n\t\t\t\t\t\t\t\t\tsigningKeychain,\n\t\t\t\t\t\t\t\t\tnetwork,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\tmethods.__withWallet(wallet)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\terrorNotificationSubject.next(walletError(error) as any)\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t})\n\n\t\t\treturn methods\n\t\t},\n\n\t\terrors: errorNotificationSubject.asObservable(),\n\n\t\tderiveNextAccount: (input?: DeriveNextInput) => {\n\t\t\tconst derivation: DeriveNextInput = input ?? {}\n\t\t\tderiveNextLocalHDAccountSubject.next(derivation)\n\t\t\treturn methods\n\t\t},\n\n\t\tderiveHWAccount: (\n\t\t\tinput: DeriveHWSigningKeyInput,\n\t\t): Observable<AccountT> =>\n\t\t\twallet$.pipe(mergeMap(wallet => wallet.deriveHWAccount(input))),\n\n\t\tdisplayAddressForActiveHWAccountOnHWDeviceForVerification: (): Observable<void> =>\n\t\t\twallet$.pipe(\n\t\t\t\tmergeMap(wallet =>\n\t\t\t\t\twallet.displayAddressForActiveHWAccountOnHWDeviceForVerification(),\n\t\t\t\t),\n\t\t\t),\n\n\t\taddAccountFromPrivateKey: (input: AddAccountByPrivateKeyInput) => {\n\t\t\taddAccountByPrivateKeySubject.next(input)\n\t\t\treturn methods\n\t\t},\n\n\t\tswitchAccount: (input: SwitchAccountInput) => {\n\t\t\tswitchAccountSubject.next(input)\n\t\t\treturn methods\n\t\t},\n\n\t\trestoreLocalHDAccountsToIndex,\n\n\t\tdecryptTransaction: decryptTransaction,\n\n\t\tlogLevel: (level: LogLevel) => {\n\t\t\tlog.setLevel(level)\n\t\t\treturn methods\n\t\t},\n\n\t\ttransactionStatus: (\n\t\t\ttxID: TransactionIdentifierT,\n\t\t\ttrigger: Observable<number>,\n\t\t) =>\n\t\t\ttrigger.pipe(\n\t\t\t\twithLatestFrom(networkSubject),\n\t\t\t\tmergeMap(([_, network]) => api.getTransaction(txID, network)),\n\t\t\t\tdistinctUntilChanged((prev, cur) => prev.status === cur.status),\n\t\t\t\tfilter(({ txID }) => txID.equals(txID)),\n\t\t\t\ttap(({ status }) =>\n\t\t\t\t\tradixLog.info(\n\t\t\t\t\t\t`Got transaction status ${status.toString()} for txID: ${txID.toString()}`,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\n\t\twithTokenBalanceFetchTrigger: (trigger: Observable<number>) => {\n\t\t\tsubs.add(trigger.subscribe(tokenBalanceFetchSubject))\n\t\t\treturn methods\n\t\t},\n\n\t\twithStakingFetchTrigger: (trigger: Observable<number>) => {\n\t\t\tsubs.add(trigger.subscribe(stakingFetchSubject))\n\t\t\treturn methods\n\t\t},\n\n\t\t// Wallet APIs\n\t\trevealMnemonic,\n\t\tactiveAddress,\n\t\tactiveAccount,\n\t\taccounts,\n\n\t\t// Active AccountAddress/Account APIs\n\t\ttokenBalances,\n\t\tstakingPositions,\n\t\tunstakingPositions,\n\n\t\tlookupTransaction: (\n\t\t\ttxID: TransactionIdentifierT,\n\t\t): Observable<ExecutedTransaction> =>\n\t\t\tnetworkSubject.pipe(\n\t\t\t\tmergeMap(network =>\n\t\t\t\t\tapi.getTransaction(txID, network).pipe(\n\t\t\t\t\t\twithLatestFrom(activeAddress),\n\t\t\t\t\t\tmap(([simpleTx, aa]) =>\n\t\t\t\t\t\t\tdecorateSimpleExecutedTransactionWithType(\n\t\t\t\t\t\t\t\tsimpleTx,\n\t\t\t\t\t\t\t\taa,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\n\t\ttransactionHistory,\n\t\ttransferTokens,\n\t\tstakeTokens,\n\t\tunstakeTokens,\n\n\t\tgetTransaction: (txID: TransactionIdentifierT) =>\n\t\t\tnetworkSubject.pipe(\n\t\t\t\tmergeMap(network => api.getTransaction(txID, network)),\n\t\t\t),\n\n\t\tvalidators: () =>\n\t\t\tnetworkSubject.pipe(mergeMap(network => api.validators(network))),\n\n\t\tsetHeaders: (headers: Record<string, string>) => {\n\t\t\theaderSub.unsubscribe()\n\t\t\theaderSub = coreAPI$.subscribe(api => api.setHeaders(headers))\n\t\t},\n\n\t\ttargetApiVersion: apiVersion,\n\t}\n\n\treturn methods\n}\n\nexport const Radix = {\n\tcreate,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}