{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar Vector_1 = require(\"./Vector\");\nvar Option_1 = require(\"./Option\");\nvar Either_1 = require(\"./Either\");\nvar HashMap_1 = require(\"./HashMap\");\n/**\n * A Future is the equivalent, and ultimately wraps, a javascript Promise.\n * While Futures support the [[Future.then]] call (so that among others\n * you can use `await` on them), you should call [[Future.map]] and\n * [[Future.flatMap]].\n *\n * Futures represent an asynchronous computation. A Future will only ever\n * be computed once at most. Once it's computed, calling [[Future.map]] or\n * `await` will return instantly.\n */\nvar Future = /** @class */function () {\n  // careful cause i can't have my type be F<F<T>>\n  // while the code does F<T> as JS's then does!!!\n  // for that reason I wrap the value in an array\n  // to make sure JS will never turn a Promise<Promise<T>>\n  // in a Promise<T>\n  function Future(promise) {\n    this.promise = promise;\n  }\n  /**\n   * Build a Future in the same way as the 'new Promise'\n   * constructor.\n   * You get one callback to signal success (resolve),\n   * failure (reject), or you can throw to signal failure.\n   *\n   *     Future.ofPromiseCtor<string>((resolve,reject) => setTimeout(resolve, 10, \"hello!\"))\n   */\n  Future.ofPromiseCtor = function (executor) {\n    return new Future(new Promise(executor).then(function (v) {\n      return [v];\n    }));\n  };\n  /**\n   * Build a Future from an existing javascript Promise.\n   */\n  Future.of = function (promise) {\n    return new Future(promise.then(function (x) {\n      return [x];\n    }));\n  };\n  /**\n   * Build a Future from a node-style callback API, for instance:\n   *\n   *     Future.ofCallback<string>(cb => fs.readFile('/etc/passwd', 'utf-8', cb))\n   */\n  Future.ofCallback = function (fn) {\n    return Future.ofPromiseCtor(function (resolve, reject) {\n      return fn(function (err, data) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    });\n  };\n  /**\n   * Build a successful Future with the value you provide.\n   */\n  Future.ok = function (val) {\n    return new Future(Promise.resolve([val]));\n  };\n  /**\n   * Build a failed Future with the error data you provide.\n   */\n  Future.failed = function (reason) {\n    return new Future(Promise.reject(reason));\n  };\n  /**\n   * Creates a Future from a function returning a Promise,\n   * which can be inline in the call, for instance:\n   *\n   *     const f1 = Future.ok(1);\n   *     const f2 = Future.ok(2);\n   *     return Future.do(async () => {\n   *         const v1 = await f1;\n   *         const v2 = await f2;\n   *         return v1 + v2;\n   *     });\n   */\n  Future[\"do\"] = function (fn) {\n    return Future.of(fn());\n  };\n  /**\n   * The `then` call is not meant to be a part of the `Future` API,\n   * we need then so that `await` works directly.\n   *\n   * Please rather use [[Future.map]] or [[Future.flatMap]].\n   */\n  Future.prototype.then = function (onfulfilled, onrejected) {\n    return this.promise.then(function (_a) {\n      var x = _a[0];\n      return onfulfilled(x);\n    }, function (rejected) {\n      return onrejected ? onrejected(rejected) : Promise.reject(rejected);\n    });\n  };\n  /**\n   * Get a `Promise` from this `Future`.\n   */\n  Future.prototype.toPromise = function () {\n    return this.promise.then(function (_a) {\n      var x = _a[0];\n      return x;\n    });\n  };\n  /**\n   * Returns a `Future` that'll complete when the first `Future` of\n   * the iterable you give will complete, with the value of that first\n   * future. Be careful, completing doesn't necessarily mean completing\n   * successfully!\n   *\n   * Also see [[Future.firstSuccessfulOf]]\n   */\n  Future.firstCompletedOf = function (elts) {\n    return Future.of(Promise.race(Vector_1.Vector.ofIterable(elts).map(function (f) {\n      return f.toPromise();\n    })));\n  };\n  /**\n   * Returns a `Future` that'll complete when the first `Future` of\n   * the iterable you give will complete successfully, with the value of that first\n   * future.\n   *\n   * Also see [[Future.firstCompletedOf]]\n   */\n  Future.firstSuccessfulOf = function (elts) {\n    // https://stackoverflow.com/a/37235274/516188\n    return Future.of(Promise.all(Vector_1.Vector.ofIterable(elts).map(function (p) {\n      // If a request fails, count that as a resolution so it will keep\n      // waiting for other possible successes. If a request succeeds,\n      // treat it as a rejection so Promise.all immediately bails out.\n      return p.then(function (val) {\n        return Promise.reject(val);\n      }, function (err) {\n        return Promise.resolve(err);\n      });\n    })).then(\n    // If '.all' resolved, we've just got an array of errors.\n    function (errors) {\n      return Promise.reject(errors);\n    },\n    // If '.all' rejected, we've got the result we wanted.\n    function (val) {\n      return Promise.resolve(val);\n    }));\n  };\n  /**\n   * Turns a list of futures in a future containing a list of items.\n   * Useful in many contexts.\n   *\n   * But if a single future is failed, you get back a failed Future.\n   *\n   * Also see [[Future.traverse]]\n   */\n  Future.sequence = function (elts) {\n    return Future.traverse(elts, function (x) {\n      return x;\n    });\n  };\n  /**\n   * Takes a list, a function that can transform list elements\n   * to futures, then return a Future containing a list of\n   * the transformed elements.\n   *\n   * But if a single element results in failure, the result also\n   * resolves to a failure.\n   *\n   * There is an optional third parameter to specify options.\n   * You can specify `{maxConcurrent: number}` to request that\n   * the futures are not all triggered at the same time, but\n   * rather only 'number' at a time.\n   *\n   * Also see [[Future.sequence]]\n   */\n  Future.traverse = function (elts, fn, opts) {\n    if (!opts) {\n      return Future.of(Promise.all(Vector_1.Vector.ofIterable(elts).map(function (x) {\n        return fn(x).toPromise();\n      })).then(Vector_1.Vector.ofIterable));\n    }\n    // maxConcurrent algorithm inspired by https://stackoverflow.com/a/38778887/516188\n    var index = 0;\n    var active = [];\n    var results = {};\n    var it = elts[Symbol.iterator]();\n    var failed;\n    var addAsNeeded = function (_) {\n      if (failed) {\n        return failed;\n      }\n      var cur;\n      var _loop_1 = function () {\n        var p = fn(cur.value);\n        active.push(p);\n        var curIdx = index++;\n        p.onComplete(function (eitherRes) {\n          active.splice(active.indexOf(p), 1);\n          if (eitherRes.isLeft()) {\n            failed = p;\n          } else {\n            results[curIdx] = eitherRes.get();\n          }\n        });\n      };\n      while (active.length < opts.maxConcurrent && !(cur = it.next()).done) {\n        _loop_1();\n      }\n      if (!failed && active.length === 0 && cur && cur.done) {\n        return Future.ok(HashMap_1.HashMap.ofObjectDictionary(results).toVector().sortOn(function (kv) {\n          return parseInt(kv[0]);\n        }).map(function (kv) {\n          return kv[1];\n        }));\n      }\n      return Future.firstCompletedOf(active).flatMap(addAsNeeded);\n    };\n    return addAsNeeded();\n  };\n  /**\n   * From the list of Futures you give, will attempt to find a successful\n   * Future which value matches the predicate you give.\n   * We return a Future of an [[Option]], which will [[None]] in case\n   * no matching Future is found.\n   */\n  Future.find = function (elts, p) {\n    var origElts = Vector_1.Vector.ofIterable(elts);\n    if (origElts.isEmpty()) {\n      return Future.ok(Option_1.Option.none());\n    }\n    // map the failures to successes with option.none\n    // backup the original future object matching the new future\n    var velts = origElts.map(function (f) {\n      return f.map(function (item) {\n        return [f, Option_1.Option.of(item)];\n      }).recoverWith(function (_) {\n        return Future.ok([f, Option_1.Option.none()]);\n      });\n    });\n    // go for the first completed of the iterable\n    // remember after our map they're all successful now\n    var success = Future.firstCompletedOf(velts);\n    return success.flatMap(function (_a) {\n      var originalFuture = _a[0],\n        option = _a[1];\n      if (option.isSome() && p(option.get())) {\n        // this successful future matches our predicate, that's it.\n        return success.map(function (x) {\n          return x[1];\n        });\n      } else {\n        // this future failed or doesn't match our predicate.\n        // remove the future from the input list (we can do that\n        // because we \"backed up\" the original future in the future\n        // result), and try again only with the remaining candidates\n        return Future.find(origElts.removeFirst(function (future) {\n          return future === originalFuture;\n        }), p);\n      }\n    });\n  };\n  /**\n   * Applicative lifting for Future. 'p' stands for 'properties'.\n   *\n   * Takes a function which operates on a simple JS object, and turns it\n   * in a function that operates on the same JS object type except which each field\n   * wrapped in a Future ('lifts' the function).\n   * It's an alternative to [[Future.liftA2]] when the number of parameters\n   * is not two.\n   *\n   * @param A the object property type specifying the parameters for your function\n   * @param B the type returned by your function, returned wrapped in a future by liftAp.\n   */\n  Future.liftAp = function (fn) {\n    return function (x) {\n      var fieldNames = Object.keys(x);\n      var promisesAr = fieldNames.map(function (n) {\n        return x[n];\n      });\n      var i = 0;\n      return Future.of(Promise.all(promisesAr).then(function (resultAr) {\n        return resultAr.reduce(function (sofar, cur) {\n          sofar[fieldNames[i++]] = cur;\n          return sofar;\n        }, {});\n      })).map(fn);\n    };\n  };\n  /**\n   * Applicative lifting for Future.\n   * Takes a function which operates on basic values, and turns it\n   * in a function that operates on futures of these values ('lifts'\n   * the function). The 2 is because it works on functions taking two\n   * parameters.\n   *\n   * @param R1 the first future type\n   * @param R2 the second future type\n   * @param V the new future type as returned by the combining function.\n   */\n  Future.liftA2 = function (fn) {\n    return function (p1, p2) {\n      return p1.flatMap(function (a1) {\n        return p2.map(function (a2) {\n          return fn(a1, a2);\n        });\n      });\n    };\n  };\n  /**\n   * Take a function returning a Promise\n   * and lift it to return a [[Future]] instead.\n   */\n  Future.lift = function (fn) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return Future.of(fn.apply(void 0, args));\n    };\n  };\n  /**\n   * Transform the value contained in a successful Future. Has no effect\n   * if the Future was failed. Will turn a successful Future in a failed\n   * one if you throw an exception in the map callback (but please don't\n   * do it.. Rather use [[Future.filter]] or another mechanism).\n   */\n  Future.prototype.map = function (fn) {\n    return new Future(this.promise.then(function (_a) {\n      var x = _a[0];\n      return [fn(x)];\n    }));\n  };\n  /**\n   * Transform the value contained in a successful Future. You return a\n   * Future, but it is then \"flattened\" so we still return a Future<T>\n   * (and not a Future<Future<T>>).\n   * Has no effect if the Future was failed. Will turn a successful Future in a failed\n   * one if you throw an exception in the map callback (but please don't\n   * do it.. Rather use [[Future.filter]] or another mechanism).\n   * This is the monadic bind.\n   */\n  Future.prototype.flatMap = function (fn) {\n    return new Future(this.promise.then(function (_a) {\n      var x = _a[0];\n      return fn(x).promise;\n    }));\n  };\n  /**\n   * Transform the value contained in a failed Future. Has no effect\n   * if the Future was successful.\n   */\n  Future.prototype.mapFailure = function (fn) {\n    return new Future(this.promise[\"catch\"](function (x) {\n      throw fn(x);\n    }));\n  };\n  /**\n   * Execute the side-effecting function you give if the Future is a failure.\n   *\n   * The Future is unchanged by this call.\n   */\n  Future.prototype.onFailure = function (fn) {\n    this.promise[\"catch\"](function (x) {\n      return fn(x);\n    });\n    return this;\n  };\n  /**\n   * Execute the side-effecting function you give if the Future is a success.\n   *\n   * The Future is unchanged by this call.\n   */\n  Future.prototype.onSuccess = function (fn) {\n    // we create a new promise here, need to catch errors on it,\n    // to avoid node UnhandledPromiseRejectionWarning warnings\n    this.promise.then(function (x) {\n      fn(x[0]);\n      return x;\n    })[\"catch\"](function (_) {});\n    return this;\n  };\n  /**\n   * Execute the side-effecting function you give when the Future is\n   * completed. You get an [[Either]], a `Right` if the Future is a\n   * success, a `Left` if it's a failure.\n   *\n   * The Future is unchanged by this call.\n   */\n  Future.prototype.onComplete = function (fn) {\n    this.promise.then(function (x) {\n      fn(Either_1.Either.right(x[0]));\n      return x;\n    }, function (x) {\n      return fn(Either_1.Either.left(x));\n    });\n    return this;\n  };\n  /**\n   * Has no effect on a failed Future. If the Future was successful,\n   * will check whether its value matches the predicate you give as\n   * first parameter. If the value matches the predicate, an equivalent\n   * Future to the input one is returned.\n   *\n   * If the value doesn't match predicate however, the second parameter\n   * function is used to compute the contents of a failed Future that'll\n   * be returned.\n   */\n  Future.prototype.filter = function (p, ifFail) {\n    return this.flatMap(function (x) {\n      return p(x) ? Future.ok(x) : Future.failed(ifFail(x));\n    });\n  };\n  /**\n   * Has no effect if this Future is successful. If it's failed however,\n   * the function you give will be called, receiving as parameter\n   * the error contents, and a Future equivalent to the one your\n   * function returns will be returned.\n   */\n  Future.prototype.recoverWith = function (f) {\n    return new Future(this.promise[\"catch\"](function (err) {\n      return f(err).promise;\n    }));\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  Future.prototype.transform = function (fn) {\n    return fn(this);\n  };\n  return Future;\n}();\nexports.Future = Future;","map":{"version":3,"names":["Vector_1","require","Option_1","Either_1","HashMap_1","Future","promise","ofPromiseCtor","executor","Promise","then","v","of","x","ofCallback","fn","resolve","reject","err","data","ok","val","failed","reason","prototype","onfulfilled","onrejected","_a","rejected","toPromise","firstCompletedOf","elts","race","Vector","ofIterable","map","f","firstSuccessfulOf","all","p","errors","sequence","traverse","opts","index","active","results","it","Symbol","iterator","addAsNeeded","_","cur","value","push","curIdx","onComplete","eitherRes","splice","indexOf","isLeft","get","length","maxConcurrent","next","done","HashMap","ofObjectDictionary","toVector","sortOn","kv","parseInt","flatMap","find","origElts","isEmpty","Option","none","velts","item","recoverWith","success","originalFuture","option","isSome","removeFirst","future","liftAp","fieldNames","Object","keys","promisesAr","n","i","resultAr","reduce","sofar","liftA2","p1","p2","a1","a2","lift","args","_i","arguments","apply","mapFailure","onFailure","onSuccess","Either","right","left","filter","ifFail","transform","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/Future.ts"],"sourcesContent":["import { Vector } from \"./Vector\";\nimport { Option } from \"./Option\";\nimport { Either } from \"./Either\";\nimport { HashMap } from \"./HashMap\";\n\n/**\n * A Future is the equivalent, and ultimately wraps, a javascript Promise.\n * While Futures support the [[Future.then]] call (so that among others\n * you can use `await` on them), you should call [[Future.map]] and\n * [[Future.flatMap]].\n *\n * Futures represent an asynchronous computation. A Future will only ever\n * be computed once at most. Once it's computed, calling [[Future.map]] or\n * `await` will return instantly.\n */\nexport class Future<T> {\n\n    // careful cause i can't have my type be F<F<T>>\n    // while the code does F<T> as JS's then does!!!\n    // for that reason I wrap the value in an array\n    // to make sure JS will never turn a Promise<Promise<T>>\n    // in a Promise<T>\n    private constructor(private promise: Promise<T[]>) { }\n\n    /**\n     * Build a Future in the same way as the 'new Promise'\n     * constructor.\n     * You get one callback to signal success (resolve),\n     * failure (reject), or you can throw to signal failure.\n     *\n     *     Future.ofPromiseCtor<string>((resolve,reject) => setTimeout(resolve, 10, \"hello!\"))\n     */\n    static ofPromiseCtor<T>(executor: (resolve:(x:T)=>void, reject: (x:any)=>void)=>void): Future<T> {\n        return new Future(new Promise(executor).then(v=>[v]));\n    }\n\n    /**\n     * Build a Future from an existing javascript Promise.\n     */\n    static of<T>(promise: Promise<T>): Future<T> {\n        return new Future(promise.then(x => [x]));\n    }\n\n    /**\n     * Build a Future from a node-style callback API, for instance:\n     *\n     *     Future.ofCallback<string>(cb => fs.readFile('/etc/passwd', 'utf-8', cb))\n     */\n    static ofCallback<T>(fn: (cb:(err:any, val:T)=>void)=>void): Future<T> {\n        return Future.ofPromiseCtor((resolve,reject)=>fn((err, data)=>{\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        }));\n    }\n\n    /**\n     * Build a successful Future with the value you provide.\n     */\n    static ok<T>(val:T): Future<T> {\n        return new Future(Promise.resolve([val]));\n    }\n\n    /**\n     * Build a failed Future with the error data you provide.\n     */\n    static failed<T>(reason: any): Future<T> {\n        return new Future(Promise.reject(reason));\n    }\n\n    /**\n     * Creates a Future from a function returning a Promise,\n     * which can be inline in the call, for instance:\n     *\n     *     const f1 = Future.ok(1);\n     *     const f2 = Future.ok(2);\n     *     return Future.do(async () => {\n     *         const v1 = await f1;\n     *         const v2 = await f2;\n     *         return v1 + v2;\n     *     });\n     */\n    static do<T>(fn: ()=>Promise<T>): Future<T> {\n        return Future.of(fn())\n    }\n\n    /**\n     * The `then` call is not meant to be a part of the `Future` API,\n     * we need then so that `await` works directly.\n     *\n     * Please rather use [[Future.map]] or [[Future.flatMap]].\n     */\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled: ((value: T) => TResult1 | PromiseLike<TResult1>),\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2> {\n        return this.promise.then(([x]) => onfulfilled(x), rejected => onrejected?onrejected(rejected):Promise.reject<TResult2>(rejected)); \n    }\n\n    /**\n     * Get a `Promise` from this `Future`.\n     */\n    toPromise(): Promise<T> {\n        return this.promise.then(([x]) => x);\n    }\n\n    /**\n     * Returns a `Future` that'll complete when the first `Future` of\n     * the iterable you give will complete, with the value of that first\n     * future. Be careful, completing doesn't necessarily mean completing\n     * successfully!\n     *\n     * Also see [[Future.firstSuccessfulOf]]\n     */\n    static firstCompletedOf<T>(elts: Iterable<Future<T>>): Future<T> {\n        return Future.of(\n            Promise.race(Vector.ofIterable(elts).map(f => f.toPromise())));\n    }\n\n    /**\n     * Returns a `Future` that'll complete when the first `Future` of\n     * the iterable you give will complete successfully, with the value of that first\n     * future.\n     *\n     * Also see [[Future.firstCompletedOf]]\n     */\n    static firstSuccessfulOf<T>(elts: Iterable<Future<T>>): Future<T> {\n        // https://stackoverflow.com/a/37235274/516188\n        return Future.of(\n            Promise.all(Vector.ofIterable(elts).map(p => {\n                // If a request fails, count that as a resolution so it will keep\n                // waiting for other possible successes. If a request succeeds,\n                // treat it as a rejection so Promise.all immediately bails out.\n                return p.then(\n                    val => Promise.reject(val),\n                    err => Promise.resolve(err)\n                );\n            })).then(\n                // If '.all' resolved, we've just got an array of errors.\n                errors => Promise.reject(errors),\n                // If '.all' rejected, we've got the result we wanted.\n                val => Promise.resolve(val)\n                )\n        );\n    }\n\n    /**\n     * Turns a list of futures in a future containing a list of items.\n     * Useful in many contexts.\n     *\n     * But if a single future is failed, you get back a failed Future.\n     *\n     * Also see [[Future.traverse]]\n     */\n    static sequence<T>(elts: Iterable<Future<T>>): Future<Vector<T>> {\n        return Future.traverse(elts, x=>x);\n    }\n\n    /**\n     * Takes a list, a function that can transform list elements\n     * to futures, then return a Future containing a list of\n     * the transformed elements. \n     *\n     * But if a single element results in failure, the result also\n     * resolves to a failure.\n     *\n     * There is an optional third parameter to specify options.\n     * You can specify `{maxConcurrent: number}` to request that\n     * the futures are not all triggered at the same time, but\n     * rather only 'number' at a time.\n     *\n     * Also see [[Future.sequence]]\n     */\n    static traverse<T,U>(elts: Iterable<T>, fn: (x:T)=>Future<U>,\n                         opts?: {maxConcurrent:number}): Future<Vector<U>> {\n        if (!opts) {\n            return Future.of(\n                Promise.all(Vector.ofIterable(elts).map(x => fn(x).toPromise()))\n                    .then(Vector.ofIterable));\n        }\n        // maxConcurrent algorithm inspired by https://stackoverflow.com/a/38778887/516188\n        let index = 0;\n        let active: Future<U>[] = [];\n        const results: {[idx:number]:U} = {};\n        const it = elts[Symbol.iterator]();\n        let failed: Future<U>|undefined;\n        const addAsNeeded = (_?:U): Future<Vector<U>> => {\n            if (failed) {\n                return <any>failed;\n            }\n            let cur;\n            while (active.length < opts.maxConcurrent &&\n                   !(cur = it.next()).done) {\n                const p = fn(cur.value);\n                active.push(p);\n                const curIdx = index++;\n                p.onComplete(eitherRes => {\n                    active.splice(active.indexOf(p), 1)\n                    if (eitherRes.isLeft()) {\n                        failed = p;\n                    } else {\n                        results[curIdx] = eitherRes.get();\n                    }\n                });\n            }\n            if (!failed && active.length === 0 && cur && cur.done) {\n                return Future.ok(\n                    HashMap.ofObjectDictionary<U>(results)\n                        .toVector()\n                        .sortOn(kv => parseInt(kv[0]))\n                        .map(kv => kv[1]));\n            }\n            return Future.firstCompletedOf(active).flatMap(addAsNeeded);\n        };\n        return addAsNeeded();\n    }\n\n    /**\n     * From the list of Futures you give, will attempt to find a successful\n     * Future which value matches the predicate you give.\n     * We return a Future of an [[Option]], which will [[None]] in case\n     * no matching Future is found.\n     */\n    static find<T>(elts: Iterable<Future<T>>, p: (x: T) => boolean): Future<Option<T>> {\n        const origElts = Vector.ofIterable(elts)\n        if (origElts.isEmpty()) {\n            return Future.ok(Option.none<T>());\n        }\n        type FutOptPair = [Future<T>,Option<T>];\n        // map the failures to successes with option.none\n        // backup the original future object matching the new future\n        const velts = origElts\n            .map(\n                f => f\n                    .map<FutOptPair>(item => [f, Option.of(item)])\n                    .recoverWith(_=>Future.ok<FutOptPair>([f, Option.none<T>()])));\n        // go for the first completed of the iterable\n        // remember after our map they're all successful now\n        const success = Future.firstCompletedOf(velts);\n        return success\n            .flatMap(([originalFuture, option]) => {\n                if (option.isSome() && p(option.get())) {\n                    // this successful future matches our predicate, that's it.\n                    return success.map(x => x[1]);\n                } else {\n                    // this future failed or doesn't match our predicate.\n                    // remove the future from the input list (we can do that\n                    // because we \"backed up\" the original future in the future\n                    // result), and try again only with the remaining candidates\n                    return Future.find(origElts.removeFirst(future => future === originalFuture), p);\n                }\n            });\n    }\n\n    /**\n     * Applicative lifting for Future. 'p' stands for 'properties'.\n     *\n     * Takes a function which operates on a simple JS object, and turns it\n     * in a function that operates on the same JS object type except which each field\n     * wrapped in a Future ('lifts' the function).\n     * It's an alternative to [[Future.liftA2]] when the number of parameters\n     * is not two.\n     *\n     * @param A the object property type specifying the parameters for your function\n     * @param B the type returned by your function, returned wrapped in a future by liftAp.\n     */\n    static liftAp<A,B>(fn:(x:A)=>B): (x: {[K in keyof A]: Future<A[K]>;}) => Future<B> {\n        return x => {\n            const fieldNames: Array<keyof A> = <any>Object.keys(x);\n            const promisesAr = fieldNames.map(n => x[n]);\n            let i=0;\n            return Future.of(\n                Promise.all(promisesAr)\n                    .then(resultAr => resultAr.reduce<{[K in keyof A]: A[K]}>((sofar,cur) => {\n                        sofar[fieldNames[i++]] = cur;\n                        return sofar;\n                    }, <any>{}))).map(fn);\n        };\n    }\n\n    /**\n     * Applicative lifting for Future.\n     * Takes a function which operates on basic values, and turns it\n     * in a function that operates on futures of these values ('lifts'\n     * the function). The 2 is because it works on functions taking two\n     * parameters.\n     *\n     * @param R1 the first future type\n     * @param R2 the second future type\n     * @param V the new future type as returned by the combining function.\n     */\n    static liftA2<R1,R2,V>(fn:(v1:R1,v2:R2)=>V) : (p1:Future<R1>, p2:Future<R2>) => Future<V> {\n        return (p1,p2) => p1.flatMap(a1 => p2.map(a2 => fn(a1,a2)));\n    }\n\n    /**\n     * Take a function returning a Promise\n     * and lift it to return a [[Future]] instead.\n     */\n    static lift<T extends any[],U>(fn: (...args: T)=>Promise<U>): (...args:T)=>Future<U> {\n        return (...args:T) => Future.of(fn(...args));\n    }\n\n    /**\n     * Transform the value contained in a successful Future. Has no effect\n     * if the Future was failed. Will turn a successful Future in a failed\n     * one if you throw an exception in the map callback (but please don't\n     * do it.. Rather use [[Future.filter]] or another mechanism).\n     */\n    map<U>(fn: (x:T)=>U): Future<U> {\n        return new Future<U>(this.promise.then(([x]) => [fn(x)]));\n    }\n\n    /**\n     * Transform the value contained in a successful Future. You return a\n     * Future, but it is then \"flattened\" so we still return a Future<T>\n     * (and not a Future<Future<T>>).\n     * Has no effect if the Future was failed. Will turn a successful Future in a failed\n     * one if you throw an exception in the map callback (but please don't\n     * do it.. Rather use [[Future.filter]] or another mechanism).\n     * This is the monadic bind.\n     */\n    flatMap<U>(fn: (x:T)=>Future<U>): Future<U> {\n        return new Future<U>(this.promise.then(([x]) => fn(x).promise));\n    }\n\n    /**\n     * Transform the value contained in a failed Future. Has no effect\n     * if the Future was successful.\n     */\n    mapFailure(fn: (x:any)=>any): Future<T> {\n        return new Future<T>(this.promise.catch(x => {throw fn(x)}));\n    }\n\n    /**\n     * Execute the side-effecting function you give if the Future is a failure.\n     *\n     * The Future is unchanged by this call.\n     */\n    onFailure(fn: (x:any)=>void): Future<T> {\n        this.promise.catch(x => fn(x));\n        return this;\n    }\n\n    /**\n     * Execute the side-effecting function you give if the Future is a success.\n     *\n     * The Future is unchanged by this call.\n     */\n    onSuccess(fn: (x:T)=>void): Future<T> {\n        // we create a new promise here, need to catch errors on it,\n        // to avoid node UnhandledPromiseRejectionWarning warnings\n        this.promise.then(x => {fn(x[0]); return x;}).catch(_ => {});\n        return this;\n    }\n\n    /**\n     * Execute the side-effecting function you give when the Future is\n     * completed. You get an [[Either]], a `Right` if the Future is a\n     * success, a `Left` if it's a failure.\n     *\n     * The Future is unchanged by this call.\n     */\n    onComplete(fn: (x:Either<any,T>)=>void): Future<T> {\n        this.promise.then(\n            x => {fn(Either.right(x[0])); return x;},\n            x => fn(Either.left(x)));\n        return this;\n    }\n\n    /**\n     * Has no effect on a failed Future. If the Future was successful,\n     * will check whether its value matches the predicate you give as\n     * first parameter. If the value matches the predicate, an equivalent\n     * Future to the input one is returned.\n     *\n     * If the value doesn't match predicate however, the second parameter\n     * function is used to compute the contents of a failed Future that'll\n     * be returned.\n     */\n    filter(p: (x:T)=>boolean, ifFail: (x:T)=>any): Future<T> {\n        return this.flatMap(\n            x => p(x) ? Future.ok(x) : Future.failed(ifFail(x)));\n    }\n    \n    /**\n     * Has no effect if this Future is successful. If it's failed however,\n     * the function you give will be called, receiving as parameter\n     * the error contents, and a Future equivalent to the one your\n     * function returns will be returned.\n     */\n    recoverWith(f: (err:any)=>Future<T>): Future<T> {\n        return new Future<T>(this.promise.catch(err => f(err).promise));\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(fn: (x:Future<T>)=>U): U {\n        return fn(this);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}