{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nexports.__esModule = true;\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\nvar Contract_1 = require(\"./Contract\");\nvar Option_1 = require(\"./Option\");\nvar HashSet_1 = require(\"./HashSet\");\nvar Vector_1 = require(\"./Vector\");\nvar LinkedList_1 = require(\"./LinkedList\");\nvar SeqHelpers = require(\"./SeqHelpers\");\nvar Value_1 = require(\"./Value\");\nvar hamt = require(\"hamt_plus\");\n// HashMap could extend Collection, conceptually. But I'm\n// not super happy of having the callbacks get a pair, for instance\n// 'HashMap.filter' takes two parameters in the current HashMap;\n// if HashMap did implement Collection, it would have to take a k,v\n// pair. There's also another trick with 'contains'. The Collection signature\n// says T&WithEquality, but here we get [K&WithEquality,V&WithEquality],\n// but arrays don't have equality so that doesn't type-check :-(\n/**\n * A dictionary, mapping keys to values.\n * @param K the key type\n * @param V the value type\n */\nvar HashMap = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function HashMap(hamt) {\n    this.hamt = hamt;\n  }\n  /**\n   * The empty map.\n   * @param K the key type\n   * @param V the value type\n   */\n  HashMap.empty = function () {\n    return emptyHashMap;\n  };\n  /**\n   * Build a HashMap from key-value pairs.\n   *\n   *     HashMap.of([1,\"a\"],[2,\"b\"])\n   *\n   */\n  HashMap.of = function () {\n    var entries = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      entries[_i] = arguments[_i];\n    }\n    return HashMap.ofIterable(entries);\n  };\n  /**\n   * Build a HashMap from an iterable containing key-value pairs.\n   *\n   *    HashMap.ofIterable(Vector.of<[number,string]>([1,\"a\"],[2,\"b\"]));\n   */\n  HashMap.ofIterable = function (entries) {\n    // remember we must set up the hamt with the custom equality\n    var iterator = entries[Symbol.iterator]();\n    var curItem = iterator.next();\n    if (curItem.done) {\n      return new EmptyHashMap();\n    }\n    // emptyhashmap.put sets up the custom equality+hashcode\n    var startH = new EmptyHashMap().put(curItem.value[0], curItem.value[1]).hamt;\n    curItem = iterator.next();\n    return new HashMap(startH.mutate(function (h) {\n      while (!curItem.done) {\n        h.set(curItem.value[0], curItem.value[1]);\n        curItem = iterator.next();\n      }\n    }));\n  };\n  /**\n   * Build a HashMap from a javascript object literal representing\n   * a dictionary. Note that the key type must always be string,\n   * as that's the way it works in javascript.\n   * Also note that entries with undefined values will be stripped\n   * from the map.\n   *\n   *     HashMap.ofObjectDictionary<number>({a:1,b:2})\n   *     => HashMap.of([\"a\",1],[\"b\",2])\n   */\n  HashMap.ofObjectDictionary = function (object) {\n    // no need to bother with the proper equals & hashcode\n    // as I know the key type supports ===\n    var h = hamt.make().beginMutation();\n    for (var property in object) {\n      // the reason we strip entries with undefined values on\n      // import from object dictionaries are: sanity, and also\n      // partial object definitions like {[TKey in MyEnum]?:number}\n      // where typescript sees the value type as 'number|undefined'\n      // (there is a test covering that)\n      if (object.hasOwnProperty(property) && typeof object[property] !== \"undefined\") {\n        h.set(property, object[property]);\n      }\n    }\n    return new HashMap(h.endMutation());\n  };\n  /**\n   * Curried predicate to find out whether the HashMap is empty.\n   *\n   *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())\n   *         .filter(HashMap.isEmpty)\n   *     => Vector.of(HashMap.empty<number,number>())\n   */\n  HashMap.isEmpty = function (v) {\n    return v.isEmpty();\n  };\n  /**\n   * Curried predicate to find out whether the HashMap is empty.\n   *\n   *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())\n   *         .filter(HashMap.isNotEmpty)\n   *     => Vector.of(HashMap.of([1,2]))\n   */\n  HashMap.isNotEmpty = function (v) {\n    return !v.isEmpty();\n  };\n  /**\n   * Get the value for the key you give, if the key is present.\n   */\n  HashMap.prototype.get = function (k) {\n    return Option_1.Option.of(this.hamt.get(k));\n  };\n  /**\n   * Implementation of the Iterator interface.\n   */\n  HashMap.prototype[Symbol.iterator] = function () {\n    return this.hamt.entries();\n  };\n  /**\n   * @hidden\n   */\n  HashMap.prototype.hasTrueEquality = function () {\n    // for true equality, need both key & value to have true\n    // equality. but i can't check when they're in an array,\n    // as array doesn't have true equality => extract them\n    // and check them separately.\n    return Option_1.Option.of(this.hamt.entries().next().value).map(function (x) {\n      return x[0];\n    }).hasTrueEquality() && Option_1.Option.of(this.hamt.entries().next().value).map(function (x) {\n      return x[1];\n    }).hasTrueEquality();\n  };\n  /**\n   * Add a new entry in the map. If there was entry with the same\n   * key, it will be overwritten.\n   * @param k the key\n   * @param v the value\n   */\n  HashMap.prototype.put = function (k, v) {\n    return new HashMap(this.hamt.set(k, v));\n  };\n  /**\n   * Return a new map with the key you give removed.\n   */\n  HashMap.prototype.remove = function (k) {\n    return new HashMap(this.hamt.remove(k));\n  };\n  /**\n   * Add a new entry in the map; in case there was already an\n   * entry with the same key, the merge function will be invoked\n   * with the old and the new value to produce the value to take\n   * into account.\n   *\n   * It is guaranteed that the merge function first parameter\n   * will be the entry from this map, and the second parameter\n   * from the map you give.\n   * @param k the key\n   * @param v the value\n   * @param merge a function to merge old and new values in case of conflict.\n   */\n  HashMap.prototype.putWithMerge = function (k, v, merge) {\n    return new HashMap(this.hamt.modify(k, function (curV) {\n      if (curV === undefined) {\n        return v;\n      }\n      return merge(curV, v);\n    }));\n  };\n  /**\n   * number of items in the map\n   */\n  HashMap.prototype.length = function () {\n    return this.hamt.size;\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  HashMap.prototype.single = function () {\n    return this.hamt.size === 1 ? Option_1.Option.of(this.hamt.entries().next().value) : Option_1.Option.none();\n  };\n  /**\n   * true if the map is empty, false otherwise.\n   */\n  HashMap.prototype.isEmpty = function () {\n    return this.hamt.size === 0;\n  };\n  /**\n   * Get a Set containing all the keys in the map\n   */\n  HashMap.prototype.keySet = function () {\n    return HashSet_1.HashSet.ofIterable(this.hamt.keys());\n  };\n  /**\n   * Get an iterable containing all the values in the map\n   * (can't return a set as we don't constrain map values\n   * to have equality in the generics type)\n   */\n  HashMap.prototype.valueIterable = function () {\n    var _a;\n    var hamt = this.hamt;\n    return _a = {}, _a[Symbol.iterator] = function () {\n      return hamt.values();\n    }, _a;\n  };\n  /**\n   * Create a new map combining the entries of this map, and\n   * the other map you give. In case an entry from this map\n   * and the other map have the same key, the merge function\n   * will be invoked to get a combined value.\n   *\n   * It is guaranteed that the merge function first parameter\n   * will be the entry from this map, and the second parameter\n   * from the map you give.\n   * @param other another map to merge with this one\n   * @param merge a merge function to combine two values\n   *        in case two entries share the same key.\n   */\n  HashMap.prototype.mergeWith = function (elts, merge) {\n    var iterator = elts[Symbol.iterator]();\n    var map = this;\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      map = map.putWithMerge(curItem.value[0], curItem.value[1], merge);\n      curItem = iterator.next();\n    }\n    return map;\n  };\n  /**\n   * Return a new map where each entry was transformed\n   * by the mapper function you give. You return key,value\n   * as pairs.\n   */\n  HashMap.prototype.map = function (fn) {\n    return this.hamt.fold(function (acc, value, key) {\n      var _a = fn(key, value),\n        newk = _a[0],\n        newv = _a[1];\n      return acc.put(newk, newv);\n    }, HashMap.empty());\n  };\n  /**\n   * Return a new map where keys are the same as in this one,\n   * but values are transformed\n   * by the mapper function you give. You return key,value\n   * as pairs.\n   */\n  HashMap.prototype.mapValues = function (fn) {\n    return this.hamt.fold(function (acc, value, key) {\n      return acc.put(key, fn(value));\n    }, HashMap.empty());\n  };\n  /**\n   * Call a function for element in the collection.\n   */\n  HashMap.prototype.forEach = function (fun) {\n    var iterator = this.hamt.entries();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      fun(curItem.value);\n      curItem = iterator.next();\n    }\n    return this;\n  };\n  /**\n   * Calls the function you give for each item in the map,\n   * your function returns a map, all the maps are\n   * merged.\n   */\n  HashMap.prototype.flatMap = function (fn) {\n    return this.foldLeft(HashMap.empty(), function (soFar, cur) {\n      return soFar.mergeWith(fn(cur[0], cur[1]), function (a, b) {\n        return b;\n      });\n    });\n  };\n  /**\n   * Returns true if the predicate returns true for all the\n   * elements in the collection.\n   */\n  HashMap.prototype.allMatch = function (predicate) {\n    var iterator = this.hamt.entries();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (!predicate(curItem.value[0], curItem.value[1])) {\n        return false;\n      }\n      curItem = iterator.next();\n    }\n    return true;\n  };\n  /**\n   * Returns true if there the predicate returns true for any\n   * element in the collection.\n   */\n  HashMap.prototype.anyMatch = function (predicate) {\n    var iterator = this.hamt.entries();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (predicate(curItem.value[0], curItem.value[1])) {\n        return true;\n      }\n      curItem = iterator.next();\n    }\n    return false;\n  };\n  /**\n   * Returns true if the item is in the collection,\n   * false otherwise.\n   */\n  HashMap.prototype.contains = function (val) {\n    return Comparison_1.areEqual(this.hamt.get(val[0]), val[1]);\n  };\n  /**\n   * Returns true if there is item with that key in the collection,\n   * false otherwise.\n   *\n   *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"]).containsKey(1);\n   *     => true\n   *\n   *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"]).containsKey(3);\n   *     => false\n   */\n  HashMap.prototype.containsKey = function (key) {\n    return this.hamt.has(key);\n  };\n  /**\n   * Call a predicate for each element in the collection,\n   * build a new collection holding only the elements\n   * for which the predicate returned true.\n   */\n  HashMap.prototype.filter = function (predicate) {\n    var _this = this;\n    return new HashMap(hamt.make({\n      hash: this.hamt._config.hash,\n      keyEq: this.hamt._config.keyEq\n    }).mutate(function (h) {\n      var iterator = _this.hamt.entries();\n      var curItem = iterator.next();\n      while (!curItem.done) {\n        if (predicate(curItem.value[0], curItem.value[1])) {\n          h.set(curItem.value[0], curItem.value[1]);\n        }\n        curItem = iterator.next();\n      }\n    }));\n  };\n  /**\n   * Search for an item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   * We name the method findAny instead of find to emphasize\n   * that there is not ordering in a hashset.\n   *\n   *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])\n   *         .findAny((k,v) => k>=2 && v === \"c\")\n   *     => Option.of([3,'c'])\n   *\n   *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])\n   *         .findAny((k,v) => k>=3 && v === \"b\")\n   *     => Option.none<[number,string]>()\n   */\n  HashMap.prototype.findAny = function (predicate) {\n    var iterator = this.hamt.entries();\n    var curItem = iterator.next();\n    while (!curItem.done) {\n      if (predicate(curItem.value[0], curItem.value[1])) {\n        return Option_1.Option.of(curItem.value);\n      }\n      curItem = iterator.next();\n    }\n    return Option_1.Option.none();\n  };\n  HashMap.prototype.filterKeys = function (predicate) {\n    return this.filter(function (k, v) {\n      return predicate(k);\n    });\n  };\n  HashMap.prototype.filterValues = function (predicate) {\n    return this.filter(function (k, v) {\n      return predicate(v);\n    });\n  };\n  /**\n   * Reduces the collection to a single value using the\n   * associative binary function you give. Since the function\n   * is associative, order of application doesn't matter.\n   *\n   * Example:\n   *\n   *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"],[3,\"c\"])\n   *      .fold([0,\"\"], ([a,b],[c,d])=>[a+c, b>d?b:d])\n   *     => [6,\"c\"]\n   */\n  HashMap.prototype.fold = function (zero, fn) {\n    return this.foldLeft(zero, fn);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Left-associative.\n   * No guarantees for the order of items in a hashset!\n   *\n   * Example:\n   *\n   *     HashMap.of([1,\"a\"], [2,\"bb\"], [3,\"ccc\"])\n   *     .foldLeft(0, (soFar,[item,val])=>soFar+val.length);\n   *     => 6\n   *\n   * @param zero The initial value\n   * @param fn A function taking the previous value and\n   *           the current collection item, and returning\n   *           an updated value.\n   */\n  HashMap.prototype.foldLeft = function (zero, fn) {\n    return this.hamt.fold(function (acc, v, k) {\n      return fn(acc, [k, v]);\n    }, zero);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Right-associative.\n   * No guarantees for the order of items in a hashset!\n   *\n   * Example:\n   *\n   *     HashMap.of([1,\"a\"], [2,\"bb\"], [3,\"ccc\"])\n   *     .foldRight(0, ([item,value],soFar)=>soFar+value.length);\n   *     => 6\n   *\n   * @param zero The initial value\n   * @param fn A function taking the current collection item and\n   *           the previous value , and returning\n   *           an updated value.\n   */\n  HashMap.prototype.foldRight = function (zero, fn) {\n    return this.foldLeft(zero, function (cur, soFar) {\n      return fn(soFar, cur);\n    });\n  };\n  /**\n   * Reduces the collection to a single value by repeatedly\n   * calling the combine function.\n   * No starting value. The order in which the elements are\n   * passed to the combining function is undetermined.\n   */\n  HashMap.prototype.reduce = function (combine) {\n    // not really glorious with any...\n    return SeqHelpers.reduce(this, combine);\n  };\n  /**\n   * Convert to array.\n   */\n  HashMap.prototype.toArray = function () {\n    return this.hamt.fold(function (acc, value, key) {\n      acc.push([key, value]);\n      return acc;\n    }, []);\n  };\n  /**\n   * Convert this map to a vector of key,value pairs.\n   * Note that Map is already an iterable of key,value pairs!\n   */\n  HashMap.prototype.toVector = function () {\n    return this.hamt.fold(function (acc, value, key) {\n      return acc.append([key, value]);\n    }, Vector_1.Vector.empty());\n  };\n  /**\n   * Convert this map to a list of key,value pairs.\n   * Note that Map is already an iterable of key,value pairs!\n   */\n  HashMap.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.ofIterable(this);\n  };\n  /**\n   * Convert to a javascript object dictionary\n   * You must provide a function to convert the\n   * key to a string.\n   *\n   *     HashMap.of<string,number>([\"a\",1],[\"b\",2])\n   *         .toObjectDictionary(x=>x);\n   *     => {a:1,b:2}\n   */\n  HashMap.prototype.toObjectDictionary = function (keyConvert) {\n    return this.foldLeft({}, function (soFar, cur) {\n      soFar[keyConvert(cur[0])] = cur[1];\n      return soFar;\n    });\n  };\n  HashMap.prototype.toJsMap = function (keyConvert) {\n    return this.foldLeft(new Map(), function (soFar, cur) {\n      return soFar.set(keyConvert(cur[0]), cur[1]);\n    });\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  HashMap.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  HashMap.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || !other.valueIterable) {\n      return false;\n    }\n    Contract_1.contractTrueEquality(\"HashMap.equals\", this, other);\n    var sz = this.hamt.size;\n    if (other.length() === 0 && sz === 0) {\n      // we could get that i'm not the empty map\n      // but my size is zero, after some filtering and such.\n      return true;\n    }\n    if (sz !== other.length()) {\n      return false;\n    }\n    var keys = Array.from(this.hamt.keys());\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var k = keys_1[_i];\n      var myVal = this.hamt.get(k);\n      var hisVal = other.get(k).getOrUndefined();\n      if (myVal === undefined || hisVal === undefined) {\n        return false;\n      }\n      if (!Comparison_1.areEqual(myVal, hisVal)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  HashMap.prototype.hashCode = function () {\n    // references:\n    // https://github.com/clojure/clojure/blob/5ffe3833508495ca7c635d47ad7a1c8b820eab76/src/jvm/clojure/lang/APersistentMap.java#L98\n    // https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/19fb8f93c59dfd791f62d41f332db9e306bc1422/src/java.base/share/classes/java/util/HashMap.java#L296\n    // Both the Clojure and AdoptOpenJDK references calculate the bitwise XOR\n    // of the key/value pairs. The significance of the bitwise XOR is that,\n    // unlike just adding the hashcode of the key and value pair, they become\n    // intertwined, which prevents collisions when identical values are swapped\n    // between keys.\n    // This algorithm only intertwines the keys and the values. The calculations\n    // for the pairs are summed up, to make sure that we get the same result\n    // if the pairs are in a different order.\n    // The Clojure implementation also caches the result of the calculation, but\n    // we've decided not to do that yet, see the discussion on the PR for context:\n    // https://github.com/emmanueltouzery/prelude-ts/pull/67\n    return this.hamt.fold(function (acc, value, key) {\n      return acc + (Comparison_1.getHashCode(key) ^ Comparison_1.getHashCode(value));\n    }, 0);\n  };\n  /*\n   * Get a human-friendly string representation of that value.\n   */\n  HashMap.prototype.toString = function () {\n    return \"HashMap(\" + this.hamt.fold(function (acc, value, key) {\n      acc.push(SeqHelpers_1.toStringHelper(key, {\n        quoteStrings: false\n      }) + \": \" + SeqHelpers_1.toStringHelper(value));\n      return acc;\n    }, []).join(\", \") + \")\";\n  };\n  HashMap.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return HashMap;\n}();\nexports.HashMap = HashMap;\n// we need to override the empty hashmap\n// because i don't know how to get the hash & keyset\n// functions for the keys without a key value to get\n// the functions from\nvar EmptyHashMap = /** @class */function (_super) {\n  __extends(EmptyHashMap, _super);\n  function EmptyHashMap() {\n    return _super.call(this, {}) || this;\n  }\n  EmptyHashMap.prototype.get = function (k) {\n    return Option_1.none;\n  };\n  EmptyHashMap.prototype[Symbol.iterator] = function () {\n    return {\n      next: function () {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  };\n  EmptyHashMap.prototype.put = function (k, v) {\n    Contract_1.contractTrueEquality(\"Error building a HashMap\", k);\n    if (Comparison_1.hasEquals(k)) {\n      return new HashMap(hamt.make({\n        hash: function (v) {\n          return v.hashCode();\n        },\n        keyEq: function (a, b) {\n          return a.equals(b);\n        }\n      }).set(k, v));\n    }\n    return new HashMap(hamt.make().set(k, v));\n  };\n  EmptyHashMap.prototype.remove = function (k) {\n    return this;\n  };\n  EmptyHashMap.prototype.hasTrueEquality = function () {\n    return true;\n  };\n  EmptyHashMap.prototype.putWithMerge = function (k, v, merge) {\n    return this.put(k, v);\n  };\n  EmptyHashMap.prototype.length = function () {\n    return 0;\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  EmptyHashMap.prototype.single = function () {\n    return Option_1.Option.none();\n  };\n  EmptyHashMap.prototype.isEmpty = function () {\n    return true;\n  };\n  EmptyHashMap.prototype.keySet = function () {\n    return HashSet_1.HashSet.empty();\n  };\n  EmptyHashMap.prototype.valueIterable = function () {\n    var _a;\n    return _a = {}, _a[Symbol.iterator] = function () {\n      return {\n        next: function () {\n          return {\n            done: true,\n            value: undefined\n          };\n        }\n      };\n    }, _a;\n  };\n  EmptyHashMap.prototype.mergeWith = function (other, merge) {\n    return HashMap.ofIterable(other);\n  };\n  EmptyHashMap.prototype.map = function (fn) {\n    return HashMap.empty();\n  };\n  EmptyHashMap.prototype.mapValues = function (fn) {\n    return HashMap.empty();\n  };\n  EmptyHashMap.prototype.forEach = function (fun) {\n    return this;\n  };\n  EmptyHashMap.prototype.allMatch = function (predicate) {\n    return true;\n  };\n  EmptyHashMap.prototype.anyMatch = function (predicate) {\n    return false;\n  };\n  EmptyHashMap.prototype.contains = function (val) {\n    return false;\n  };\n  EmptyHashMap.prototype.containsKey = function (key) {\n    return false;\n  };\n  EmptyHashMap.prototype.filter = function (predicate) {\n    return this;\n  };\n  EmptyHashMap.prototype.findAny = function (predicate) {\n    return Option_1.Option.none();\n  };\n  EmptyHashMap.prototype.foldLeft = function (zero, fn) {\n    return zero;\n  };\n  EmptyHashMap.prototype.toArray = function () {\n    return [];\n  };\n  EmptyHashMap.prototype.toVector = function () {\n    return Vector_1.Vector.empty();\n  };\n  EmptyHashMap.prototype.toLinkedList = function () {\n    return LinkedList_1.LinkedList.empty();\n  };\n  EmptyHashMap.prototype.equals = function (other) {\n    if (!other || !other.valueIterable) {\n      return false;\n    }\n    return other === emptyHashMap || other.length() === 0;\n  };\n  EmptyHashMap.prototype.hashCode = function () {\n    return 0;\n  };\n  EmptyHashMap.prototype.toString = function () {\n    return \"HashMap()\";\n  };\n  return EmptyHashMap;\n}(HashMap);\nvar emptyHashMap = new EmptyHashMap();","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","exports","__esModule","Comparison_1","require","SeqHelpers_1","Contract_1","Option_1","HashSet_1","Vector_1","LinkedList_1","SeqHelpers","Value_1","hamt","HashMap","empty","emptyHashMap","of","entries","_i","arguments","length","ofIterable","iterator","Symbol","curItem","next","done","EmptyHashMap","startH","put","value","mutate","h","set","ofObjectDictionary","object","make","beginMutation","property","endMutation","isEmpty","v","isNotEmpty","get","k","Option","hasTrueEquality","map","x","remove","putWithMerge","merge","modify","curV","undefined","size","single","none","keySet","HashSet","keys","valueIterable","_a","values","mergeWith","elts","fn","fold","acc","key","newk","newv","mapValues","forEach","fun","flatMap","foldLeft","soFar","cur","a","allMatch","predicate","anyMatch","contains","val","areEqual","containsKey","has","filter","_this","hash","_config","keyEq","findAny","filterKeys","filterValues","zero","foldRight","reduce","combine","toArray","push","toVector","append","Vector","toLinkedList","LinkedList","toObjectDictionary","keyConvert","toJsMap","Map","transform","converter","equals","other","contractTrueEquality","sz","from","keys_1","myVal","hisVal","getOrUndefined","hashCode","getHashCode","toString","toStringHelper","quoteStrings","join","inspect","_super","call","hasEquals"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/dist/src/HashMap.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nexports.__esModule = true;\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\nvar Contract_1 = require(\"./Contract\");\nvar Option_1 = require(\"./Option\");\nvar HashSet_1 = require(\"./HashSet\");\nvar Vector_1 = require(\"./Vector\");\nvar LinkedList_1 = require(\"./LinkedList\");\nvar SeqHelpers = require(\"./SeqHelpers\");\nvar Value_1 = require(\"./Value\");\nvar hamt = require(\"hamt_plus\");\n// HashMap could extend Collection, conceptually. But I'm\n// not super happy of having the callbacks get a pair, for instance\n// 'HashMap.filter' takes two parameters in the current HashMap;\n// if HashMap did implement Collection, it would have to take a k,v\n// pair. There's also another trick with 'contains'. The Collection signature\n// says T&WithEquality, but here we get [K&WithEquality,V&WithEquality],\n// but arrays don't have equality so that doesn't type-check :-(\n/**\n * A dictionary, mapping keys to values.\n * @param K the key type\n * @param V the value type\n */\nvar HashMap = /** @class */ (function () {\n    /**\n     * @hidden\n     */\n    function HashMap(hamt) {\n        this.hamt = hamt;\n    }\n    /**\n     * The empty map.\n     * @param K the key type\n     * @param V the value type\n     */\n    HashMap.empty = function () {\n        return emptyHashMap;\n    };\n    /**\n     * Build a HashMap from key-value pairs.\n     *\n     *     HashMap.of([1,\"a\"],[2,\"b\"])\n     *\n     */\n    HashMap.of = function () {\n        var entries = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            entries[_i] = arguments[_i];\n        }\n        return HashMap.ofIterable(entries);\n    };\n    /**\n     * Build a HashMap from an iterable containing key-value pairs.\n     *\n     *    HashMap.ofIterable(Vector.of<[number,string]>([1,\"a\"],[2,\"b\"]));\n     */\n    HashMap.ofIterable = function (entries) {\n        // remember we must set up the hamt with the custom equality\n        var iterator = entries[Symbol.iterator]();\n        var curItem = iterator.next();\n        if (curItem.done) {\n            return new EmptyHashMap();\n        }\n        // emptyhashmap.put sets up the custom equality+hashcode\n        var startH = (new EmptyHashMap()).put(curItem.value[0], curItem.value[1]).hamt;\n        curItem = iterator.next();\n        return new HashMap(startH.mutate(function (h) {\n            while (!curItem.done) {\n                h.set(curItem.value[0], curItem.value[1]);\n                curItem = iterator.next();\n            }\n        }));\n    };\n    /**\n     * Build a HashMap from a javascript object literal representing\n     * a dictionary. Note that the key type must always be string,\n     * as that's the way it works in javascript.\n     * Also note that entries with undefined values will be stripped\n     * from the map.\n     *\n     *     HashMap.ofObjectDictionary<number>({a:1,b:2})\n     *     => HashMap.of([\"a\",1],[\"b\",2])\n     */\n    HashMap.ofObjectDictionary = function (object) {\n        // no need to bother with the proper equals & hashcode\n        // as I know the key type supports ===\n        var h = hamt.make().beginMutation();\n        for (var property in object) {\n            // the reason we strip entries with undefined values on\n            // import from object dictionaries are: sanity, and also\n            // partial object definitions like {[TKey in MyEnum]?:number}\n            // where typescript sees the value type as 'number|undefined'\n            // (there is a test covering that)\n            if (object.hasOwnProperty(property) &&\n                (typeof object[property] !== \"undefined\")) {\n                h.set(property, object[property]);\n            }\n        }\n        return new HashMap(h.endMutation());\n    };\n    /**\n     * Curried predicate to find out whether the HashMap is empty.\n     *\n     *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())\n     *         .filter(HashMap.isEmpty)\n     *     => Vector.of(HashMap.empty<number,number>())\n     */\n    HashMap.isEmpty = function (v) {\n        return v.isEmpty();\n    };\n    /**\n     * Curried predicate to find out whether the HashMap is empty.\n     *\n     *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())\n     *         .filter(HashMap.isNotEmpty)\n     *     => Vector.of(HashMap.of([1,2]))\n     */\n    HashMap.isNotEmpty = function (v) {\n        return !v.isEmpty();\n    };\n    /**\n     * Get the value for the key you give, if the key is present.\n     */\n    HashMap.prototype.get = function (k) {\n        return Option_1.Option.of(this.hamt.get(k));\n    };\n    /**\n     * Implementation of the Iterator interface.\n     */\n    HashMap.prototype[Symbol.iterator] = function () {\n        return this.hamt.entries();\n    };\n    /**\n     * @hidden\n     */\n    HashMap.prototype.hasTrueEquality = function () {\n        // for true equality, need both key & value to have true\n        // equality. but i can't check when they're in an array,\n        // as array doesn't have true equality => extract them\n        // and check them separately.\n        return Option_1.Option.of(this.hamt.entries().next().value)\n            .map(function (x) { return x[0]; }).hasTrueEquality() &&\n            Option_1.Option.of(this.hamt.entries().next().value)\n                .map(function (x) { return x[1]; }).hasTrueEquality();\n    };\n    /**\n     * Add a new entry in the map. If there was entry with the same\n     * key, it will be overwritten.\n     * @param k the key\n     * @param v the value\n     */\n    HashMap.prototype.put = function (k, v) {\n        return new HashMap(this.hamt.set(k, v));\n    };\n    /**\n     * Return a new map with the key you give removed.\n     */\n    HashMap.prototype.remove = function (k) {\n        return new HashMap(this.hamt.remove(k));\n    };\n    /**\n     * Add a new entry in the map; in case there was already an\n     * entry with the same key, the merge function will be invoked\n     * with the old and the new value to produce the value to take\n     * into account.\n     *\n     * It is guaranteed that the merge function first parameter\n     * will be the entry from this map, and the second parameter\n     * from the map you give.\n     * @param k the key\n     * @param v the value\n     * @param merge a function to merge old and new values in case of conflict.\n     */\n    HashMap.prototype.putWithMerge = function (k, v, merge) {\n        return new HashMap(this.hamt.modify(k, function (curV) {\n            if (curV === undefined) {\n                return v;\n            }\n            return merge(curV, v);\n        }));\n    };\n    /**\n     * number of items in the map\n     */\n    HashMap.prototype.length = function () {\n        return this.hamt.size;\n    };\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    HashMap.prototype.single = function () {\n        return this.hamt.size === 1\n            ? Option_1.Option.of(this.hamt.entries().next().value)\n            : Option_1.Option.none();\n    };\n    /**\n     * true if the map is empty, false otherwise.\n     */\n    HashMap.prototype.isEmpty = function () {\n        return this.hamt.size === 0;\n    };\n    /**\n     * Get a Set containing all the keys in the map\n     */\n    HashMap.prototype.keySet = function () {\n        return HashSet_1.HashSet.ofIterable(this.hamt.keys());\n    };\n    /**\n     * Get an iterable containing all the values in the map\n     * (can't return a set as we don't constrain map values\n     * to have equality in the generics type)\n     */\n    HashMap.prototype.valueIterable = function () {\n        var _a;\n        var hamt = this.hamt;\n        return _a = {},\n            _a[Symbol.iterator] = function () { return hamt.values(); },\n            _a;\n    };\n    /**\n     * Create a new map combining the entries of this map, and\n     * the other map you give. In case an entry from this map\n     * and the other map have the same key, the merge function\n     * will be invoked to get a combined value.\n     *\n     * It is guaranteed that the merge function first parameter\n     * will be the entry from this map, and the second parameter\n     * from the map you give.\n     * @param other another map to merge with this one\n     * @param merge a merge function to combine two values\n     *        in case two entries share the same key.\n     */\n    HashMap.prototype.mergeWith = function (elts, merge) {\n        var iterator = elts[Symbol.iterator]();\n        var map = this;\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            map = map.putWithMerge(curItem.value[0], curItem.value[1], merge);\n            curItem = iterator.next();\n        }\n        return map;\n    };\n    /**\n     * Return a new map where each entry was transformed\n     * by the mapper function you give. You return key,value\n     * as pairs.\n     */\n    HashMap.prototype.map = function (fn) {\n        return this.hamt.fold(function (acc, value, key) {\n            var _a = fn(key, value), newk = _a[0], newv = _a[1];\n            return acc.put(newk, newv);\n        }, HashMap.empty());\n    };\n    /**\n     * Return a new map where keys are the same as in this one,\n     * but values are transformed\n     * by the mapper function you give. You return key,value\n     * as pairs.\n     */\n    HashMap.prototype.mapValues = function (fn) {\n        return this.hamt.fold(function (acc, value, key) {\n            return acc.put(key, fn(value));\n        }, HashMap.empty());\n    };\n    /**\n     * Call a function for element in the collection.\n     */\n    HashMap.prototype.forEach = function (fun) {\n        var iterator = this.hamt.entries();\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            fun(curItem.value);\n            curItem = iterator.next();\n        }\n        return this;\n    };\n    /**\n     * Calls the function you give for each item in the map,\n     * your function returns a map, all the maps are\n     * merged.\n     */\n    HashMap.prototype.flatMap = function (fn) {\n        return this.foldLeft(HashMap.empty(), function (soFar, cur) { return soFar.mergeWith(fn(cur[0], cur[1]), function (a, b) { return b; }); });\n    };\n    /**\n     * Returns true if the predicate returns true for all the\n     * elements in the collection.\n     */\n    HashMap.prototype.allMatch = function (predicate) {\n        var iterator = this.hamt.entries();\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            if (!predicate(curItem.value[0], curItem.value[1])) {\n                return false;\n            }\n            curItem = iterator.next();\n        }\n        return true;\n    };\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    HashMap.prototype.anyMatch = function (predicate) {\n        var iterator = this.hamt.entries();\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            if (predicate(curItem.value[0], curItem.value[1])) {\n                return true;\n            }\n            curItem = iterator.next();\n        }\n        return false;\n    };\n    /**\n     * Returns true if the item is in the collection,\n     * false otherwise.\n     */\n    HashMap.prototype.contains = function (val) {\n        return Comparison_1.areEqual(this.hamt.get(val[0]), val[1]);\n    };\n    /**\n     * Returns true if there is item with that key in the collection,\n     * false otherwise.\n     *\n     *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"]).containsKey(1);\n     *     => true\n     *\n     *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"]).containsKey(3);\n     *     => false\n     */\n    HashMap.prototype.containsKey = function (key) {\n        return this.hamt.has(key);\n    };\n    /**\n     * Call a predicate for each element in the collection,\n     * build a new collection holding only the elements\n     * for which the predicate returned true.\n     */\n    HashMap.prototype.filter = function (predicate) {\n        var _this = this;\n        return new HashMap(hamt.make({ hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq }).mutate(function (h) {\n            var iterator = _this.hamt.entries();\n            var curItem = iterator.next();\n            while (!curItem.done) {\n                if (predicate(curItem.value[0], curItem.value[1])) {\n                    h.set(curItem.value[0], curItem.value[1]);\n                }\n                curItem = iterator.next();\n            }\n        }));\n    };\n    /**\n     * Search for an item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     * We name the method findAny instead of find to emphasize\n     * that there is not ordering in a hashset.\n     *\n     *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])\n     *         .findAny((k,v) => k>=2 && v === \"c\")\n     *     => Option.of([3,'c'])\n     *\n     *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])\n     *         .findAny((k,v) => k>=3 && v === \"b\")\n     *     => Option.none<[number,string]>()\n     */\n    HashMap.prototype.findAny = function (predicate) {\n        var iterator = this.hamt.entries();\n        var curItem = iterator.next();\n        while (!curItem.done) {\n            if (predicate(curItem.value[0], curItem.value[1])) {\n                return Option_1.Option.of(curItem.value);\n            }\n            curItem = iterator.next();\n        }\n        return Option_1.Option.none();\n    };\n    HashMap.prototype.filterKeys = function (predicate) {\n        return this.filter(function (k, v) { return predicate(k); });\n    };\n    HashMap.prototype.filterValues = function (predicate) {\n        return this.filter(function (k, v) { return predicate(v); });\n    };\n    /**\n     * Reduces the collection to a single value using the\n     * associative binary function you give. Since the function\n     * is associative, order of application doesn't matter.\n     *\n     * Example:\n     *\n     *     HashMap.of<number,string>([1,\"a\"],[2,\"b\"],[3,\"c\"])\n     *      .fold([0,\"\"], ([a,b],[c,d])=>[a+c, b>d?b:d])\n     *     => [6,\"c\"]\n     */\n    HashMap.prototype.fold = function (zero, fn) {\n        return this.foldLeft(zero, fn);\n    };\n    /**\n     * Reduces the collection to a single value.\n     * Left-associative.\n     * No guarantees for the order of items in a hashset!\n     *\n     * Example:\n     *\n     *     HashMap.of([1,\"a\"], [2,\"bb\"], [3,\"ccc\"])\n     *     .foldLeft(0, (soFar,[item,val])=>soFar+val.length);\n     *     => 6\n     *\n     * @param zero The initial value\n     * @param fn A function taking the previous value and\n     *           the current collection item, and returning\n     *           an updated value.\n     */\n    HashMap.prototype.foldLeft = function (zero, fn) {\n        return this.hamt.fold(function (acc, v, k) {\n            return fn(acc, [k, v]);\n        }, zero);\n    };\n    /**\n     * Reduces the collection to a single value.\n     * Right-associative.\n     * No guarantees for the order of items in a hashset!\n     *\n     * Example:\n     *\n     *     HashMap.of([1,\"a\"], [2,\"bb\"], [3,\"ccc\"])\n     *     .foldRight(0, ([item,value],soFar)=>soFar+value.length);\n     *     => 6\n     *\n     * @param zero The initial value\n     * @param fn A function taking the current collection item and\n     *           the previous value , and returning\n     *           an updated value.\n     */\n    HashMap.prototype.foldRight = function (zero, fn) {\n        return this.foldLeft(zero, function (cur, soFar) { return fn(soFar, cur); });\n    };\n    /**\n     * Reduces the collection to a single value by repeatedly\n     * calling the combine function.\n     * No starting value. The order in which the elements are\n     * passed to the combining function is undetermined.\n     */\n    HashMap.prototype.reduce = function (combine) {\n        // not really glorious with any...\n        return SeqHelpers.reduce(this, combine);\n    };\n    /**\n     * Convert to array.\n     */\n    HashMap.prototype.toArray = function () {\n        return this.hamt.fold(function (acc, value, key) { acc.push([key, value]); return acc; }, []);\n    };\n    /**\n     * Convert this map to a vector of key,value pairs.\n     * Note that Map is already an iterable of key,value pairs!\n     */\n    HashMap.prototype.toVector = function () {\n        return this.hamt.fold(function (acc, value, key) {\n            return acc.append([key, value]);\n        }, Vector_1.Vector.empty());\n    };\n    /**\n     * Convert this map to a list of key,value pairs.\n     * Note that Map is already an iterable of key,value pairs!\n     */\n    HashMap.prototype.toLinkedList = function () {\n        return LinkedList_1.LinkedList.ofIterable(this);\n    };\n    /**\n     * Convert to a javascript object dictionary\n     * You must provide a function to convert the\n     * key to a string.\n     *\n     *     HashMap.of<string,number>([\"a\",1],[\"b\",2])\n     *         .toObjectDictionary(x=>x);\n     *     => {a:1,b:2}\n     */\n    HashMap.prototype.toObjectDictionary = function (keyConvert) {\n        return this.foldLeft({}, function (soFar, cur) {\n            soFar[keyConvert(cur[0])] = cur[1];\n            return soFar;\n        });\n    };\n    HashMap.prototype.toJsMap = function (keyConvert) {\n        return this.foldLeft(new Map(), function (soFar, cur) { return soFar.set(keyConvert(cur[0]), cur[1]); });\n    };\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    HashMap.prototype.transform = function (converter) {\n        return converter(this);\n    };\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    HashMap.prototype.equals = function (other) {\n        if (other === this) {\n            return true;\n        }\n        if (!other || !other.valueIterable) {\n            return false;\n        }\n        Contract_1.contractTrueEquality(\"HashMap.equals\", this, other);\n        var sz = this.hamt.size;\n        if (other.length() === 0 && sz === 0) {\n            // we could get that i'm not the empty map\n            // but my size is zero, after some filtering and such.\n            return true;\n        }\n        if (sz !== other.length()) {\n            return false;\n        }\n        var keys = Array.from(this.hamt.keys());\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var k = keys_1[_i];\n            var myVal = this.hamt.get(k);\n            var hisVal = other.get(k).getOrUndefined();\n            if (myVal === undefined || hisVal === undefined) {\n                return false;\n            }\n            if (!Comparison_1.areEqual(myVal, hisVal)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    HashMap.prototype.hashCode = function () {\n        // references:\n        // https://github.com/clojure/clojure/blob/5ffe3833508495ca7c635d47ad7a1c8b820eab76/src/jvm/clojure/lang/APersistentMap.java#L98\n        // https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/19fb8f93c59dfd791f62d41f332db9e306bc1422/src/java.base/share/classes/java/util/HashMap.java#L296\n        // Both the Clojure and AdoptOpenJDK references calculate the bitwise XOR\n        // of the key/value pairs. The significance of the bitwise XOR is that,\n        // unlike just adding the hashcode of the key and value pair, they become\n        // intertwined, which prevents collisions when identical values are swapped\n        // between keys.\n        // This algorithm only intertwines the keys and the values. The calculations\n        // for the pairs are summed up, to make sure that we get the same result\n        // if the pairs are in a different order.\n        // The Clojure implementation also caches the result of the calculation, but\n        // we've decided not to do that yet, see the discussion on the PR for context:\n        // https://github.com/emmanueltouzery/prelude-ts/pull/67\n        return this.hamt.fold(function (acc, value, key) {\n            return acc + (Comparison_1.getHashCode(key) ^ Comparison_1.getHashCode(value));\n        }, 0);\n    };\n    /*\n     * Get a human-friendly string representation of that value.\n     */\n    HashMap.prototype.toString = function () {\n        return \"HashMap(\" +\n            this.hamt.fold(function (acc, value, key) {\n                acc.push(SeqHelpers_1.toStringHelper(key, { quoteStrings: false }) +\n                    \": \" + SeqHelpers_1.toStringHelper(value));\n                return acc;\n            }, [])\n                .join(\", \") + \")\";\n    };\n    HashMap.prototype[Value_1.inspect] = function () {\n        return this.toString();\n    };\n    return HashMap;\n}());\nexports.HashMap = HashMap;\n// we need to override the empty hashmap\n// because i don't know how to get the hash & keyset\n// functions for the keys without a key value to get\n// the functions from\nvar EmptyHashMap = /** @class */ (function (_super) {\n    __extends(EmptyHashMap, _super);\n    function EmptyHashMap() {\n        return _super.call(this, {}) || this;\n    }\n    EmptyHashMap.prototype.get = function (k) {\n        return Option_1.none;\n    };\n    EmptyHashMap.prototype[Symbol.iterator] = function () {\n        return { next: function () { return ({ done: true, value: undefined }); } };\n    };\n    EmptyHashMap.prototype.put = function (k, v) {\n        Contract_1.contractTrueEquality(\"Error building a HashMap\", k);\n        if (Comparison_1.hasEquals(k)) {\n            return new HashMap(hamt.make({\n                hash: function (v) { return v.hashCode(); },\n                keyEq: function (a, b) { return a.equals(b); }\n            }).set(k, v));\n        }\n        return new HashMap(hamt.make().set(k, v));\n    };\n    EmptyHashMap.prototype.remove = function (k) {\n        return this;\n    };\n    EmptyHashMap.prototype.hasTrueEquality = function () {\n        return true;\n    };\n    EmptyHashMap.prototype.putWithMerge = function (k, v, merge) {\n        return this.put(k, v);\n    };\n    EmptyHashMap.prototype.length = function () {\n        return 0;\n    };\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    EmptyHashMap.prototype.single = function () {\n        return Option_1.Option.none();\n    };\n    EmptyHashMap.prototype.isEmpty = function () {\n        return true;\n    };\n    EmptyHashMap.prototype.keySet = function () {\n        return HashSet_1.HashSet.empty();\n    };\n    EmptyHashMap.prototype.valueIterable = function () {\n        var _a;\n        return _a = {},\n            _a[Symbol.iterator] = function () {\n                return {\n                    next: function () {\n                        return {\n                            done: true,\n                            value: undefined\n                        };\n                    }\n                };\n            },\n            _a;\n    };\n    EmptyHashMap.prototype.mergeWith = function (other, merge) {\n        return HashMap.ofIterable(other);\n    };\n    EmptyHashMap.prototype.map = function (fn) {\n        return HashMap.empty();\n    };\n    EmptyHashMap.prototype.mapValues = function (fn) {\n        return HashMap.empty();\n    };\n    EmptyHashMap.prototype.forEach = function (fun) {\n        return this;\n    };\n    EmptyHashMap.prototype.allMatch = function (predicate) {\n        return true;\n    };\n    EmptyHashMap.prototype.anyMatch = function (predicate) {\n        return false;\n    };\n    EmptyHashMap.prototype.contains = function (val) {\n        return false;\n    };\n    EmptyHashMap.prototype.containsKey = function (key) {\n        return false;\n    };\n    EmptyHashMap.prototype.filter = function (predicate) {\n        return this;\n    };\n    EmptyHashMap.prototype.findAny = function (predicate) {\n        return Option_1.Option.none();\n    };\n    EmptyHashMap.prototype.foldLeft = function (zero, fn) {\n        return zero;\n    };\n    EmptyHashMap.prototype.toArray = function () {\n        return [];\n    };\n    EmptyHashMap.prototype.toVector = function () {\n        return Vector_1.Vector.empty();\n    };\n    EmptyHashMap.prototype.toLinkedList = function () {\n        return LinkedList_1.LinkedList.empty();\n    };\n    EmptyHashMap.prototype.equals = function (other) {\n        if (!other || !other.valueIterable) {\n            return false;\n        }\n        return other === emptyHashMap || other.length() === 0;\n    };\n    EmptyHashMap.prototype.hashCode = function () {\n        return 0;\n    };\n    EmptyHashMap.prototype.toString = function () {\n        return \"HashMap()\";\n    };\n    return EmptyHashMap;\n}(HashMap));\nvar emptyHashMap = new EmptyHashMap();\n//# sourceMappingURL=HashMap.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}