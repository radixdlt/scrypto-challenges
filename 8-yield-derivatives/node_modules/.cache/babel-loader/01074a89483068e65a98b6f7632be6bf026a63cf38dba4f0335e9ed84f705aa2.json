{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n/**\n * A sequence of values, organized in-memory as a strict linked list.\n * Each element has an head (value) and a tail (the rest of the list).\n *\n * The code is organized through the class [[EmptyLinkedList]] (empty list\n * or tail), the class [[ConsLinkedList]] (list value and pointer to next),\n * and the type alias [[LinkedList]] (empty or cons).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[LinkedListStatic]] and are accessed through the global constant LinkedList.\n *\n * Random access is expensive, appending is expensive, prepend or getting\n * the tail of the list is very cheap.\n * If you often need random access you should rather use [[Vector]].\n * Avoid appending at the end of the list in a loop, prefer prepending and\n * then reversing the list.\n *\n * Examples:\n *\n *     LinkedList.of(1,2,3);\n *     LinkedList.of(1,2,3).map(x => x*2).last();\n */\nvar Option_1 = require(\"./Option\");\nvar Vector_1 = require(\"./Vector\");\nvar Comparison_1 = require(\"./Comparison\");\nvar Contract_1 = require(\"./Contract\");\nvar Value_1 = require(\"./Value\");\nvar HashMap_1 = require(\"./HashMap\");\nvar HashSet_1 = require(\"./HashSet\");\nvar SeqHelpers = require(\"./SeqHelpers\");\n/**\n * Holds the \"static methods\" for [[LinkedList]]\n */\nvar LinkedListStatic = /** @class */function () {\n  function LinkedListStatic() {}\n  /**\n   * The empty stream\n   */\n  LinkedListStatic.prototype.empty = function () {\n    return emptyLinkedList;\n  };\n  LinkedListStatic.prototype.of = function () {\n    var elts = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      elts[_i] = arguments[_i];\n    }\n    return exports.LinkedList.ofIterable(elts);\n  };\n  /**\n   * Build a stream from any iterable, which means also\n   * an array for instance.\n   * @param T the item type\n   */\n  LinkedListStatic.prototype.ofIterable = function (elts) {\n    var iterator = elts[Symbol.iterator]();\n    var curItem = iterator.next();\n    var result = emptyLinkedList;\n    while (!curItem.done) {\n      result = new ConsLinkedList(curItem.value, result);\n      curItem = iterator.next();\n    }\n    return result.reverse();\n  };\n  /**\n   * Curried type guard for LinkedList.\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(LinkedList.of(1), LinkedList.empty<number>())\n   *         .filter(LinkedList.isEmpty)\n   *     => Vector.of(LinkedList.empty<number>())\n   */\n  LinkedListStatic.prototype.isEmpty = function (l) {\n    return l.isEmpty();\n  };\n  /**\n   * Curried type guard for LinkedList.\n   * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n   *\n   *     Vector.of(Stream.of(1), Stream.empty<number>())\n   *         .filter(Stream.isNotEmpty)\n   *         .map(s => s.head().get()+1)\n   *     => Vector.of(2)\n   */\n  LinkedListStatic.prototype.isNotEmpty = function (l) {\n    return !l.isEmpty();\n  };\n  /**\n   * Dual to the foldRight function. Build a collection from a seed.\n   * Takes a starting element and a function.\n   * It applies the function on the starting element; if the\n   * function returns None, it stops building the list, if it\n   * returns Some of a pair, it adds the first element to the result\n   * and takes the second element as a seed to keep going.\n   *\n   *     LinkedList.unfoldRight(\n   *          10, x=>Option.of(x)\n   *              .filter(x => x!==0)\n   *              .map<[number,number]>(x => [x,x-1]))\n   *     => LinkedList.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n   */\n  LinkedListStatic.prototype.unfoldRight = function (seed, fn) {\n    var nextVal = fn(seed);\n    var result = emptyLinkedList;\n    while (!nextVal.isNone()) {\n      result = new ConsLinkedList(nextVal.get()[0], result);\n      nextVal = fn(nextVal.get()[1]);\n    }\n    return result.reverse();\n  };\n  /**\n   * Combine any number of iterables you give in as\n   * parameters to produce a new collection which combines all,\n   * in tuples. For instance:\n   *\n   *     LinkedList.zip(LinkedList.of(1,2,3), [\"a\",\"b\",\"c\"], Vector.of(8,9,10))\n   *     => LinkedList.of([1,\"a\",8], [2,\"b\",9], [3,\"c\",10])\n   *\n   * The result collection will have the length of the shorter\n   * of the input iterables. Extra elements will be discarded.\n   *\n   * Also see the non-static version [[ConsLinkedList.zip]], which only combines two\n   * collections.\n   * @param A A is the type of the tuple that'll be generated\n   *          (`[number,string,number]` for the code sample)\n   */\n  LinkedListStatic.prototype.zip = function () {\n    var iterables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      iterables[_i] = arguments[_i];\n    }\n    var r = exports.LinkedList.empty();\n    var iterators = iterables.map(function (i) {\n      return i[Symbol.iterator]();\n    });\n    var items = iterators.map(function (i) {\n      return i.next();\n    });\n    while (!items.some(function (item) {\n      return item.done;\n    })) {\n      r = r.prepend(items.map(function (item) {\n        return item.value;\n      }));\n      items = iterators.map(function (i) {\n        return i.next();\n      });\n    }\n    return r.reverse();\n  };\n  return LinkedListStatic;\n}();\nexports.LinkedListStatic = LinkedListStatic;\n/**\n * The LinkedList constant allows to call the LinkedList \"static\" methods\n */\nexports.LinkedList = new LinkedListStatic();\n/**\n * EmptyLinkedList is the empty linked list; every non-empty\n * linked list also has a pointer to an empty linked list\n * after its last element.\n * \"static methods\" available through [[LinkedListStatic]]\n * @param T the item type\n */\nvar EmptyLinkedList = /** @class */function () {\n  function EmptyLinkedList() {\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * @hidden\n   */\n  EmptyLinkedList.prototype.hasTrueEquality = function () {\n    return SeqHelpers.seqHasTrueEquality(this);\n  };\n  /**\n   * Implementation of the Iterator interface.\n   */\n  EmptyLinkedList.prototype[Symbol.iterator] = function () {\n    return {\n      next: function () {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  };\n  /**\n   * View this Some a as LinkedList. Useful to help typescript type\n   * inference sometimes.\n   */\n  EmptyLinkedList.prototype.asLinkedList = function () {\n    return this;\n  };\n  /**\n   * Get the length of the collection.\n   */\n  EmptyLinkedList.prototype.length = function () {\n    return 0;\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  EmptyLinkedList.prototype.single = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * true if the collection is empty, false otherwise.\n   */\n  EmptyLinkedList.prototype.isEmpty = function () {\n    return true;\n  };\n  /**\n   * Get the first value of the collection, if any.\n   * In this case the list is empty, so returns Option.none\n   */\n  EmptyLinkedList.prototype.head = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * Get all the elements in the collection but the first one.\n   * If the collection is empty, return None.\n   */\n  EmptyLinkedList.prototype.tail = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * Get the last value of the collection, if any.\n   * returns Option.Some if the collection is not empty,\n   * Option.None if it's empty.\n   */\n  EmptyLinkedList.prototype.last = function () {\n    return Option_1.Option.none();\n  };\n  /**\n   * Retrieve the element at index idx.\n   * Returns an option because the collection may\n   * contain less elements than the index.\n   *\n   * Careful this is going to have poor performance\n   * on LinkedList, which is not a good data structure\n   * for random access!\n   */\n  EmptyLinkedList.prototype.get = function (idx) {\n    return Option_1.Option.none();\n  };\n  /**\n   * Search for an item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   */\n  EmptyLinkedList.prototype.find = function (predicate) {\n    return Option_1.Option.none();\n  };\n  /**\n   * Returns true if the item is in the collection,\n   * false otherwise.\n   */\n  EmptyLinkedList.prototype.contains = function (v) {\n    return false;\n  };\n  /**\n   * Return a new stream keeping only the first n elements\n   * from this stream.\n   */\n  EmptyLinkedList.prototype.take = function (n) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate.\n   */\n  EmptyLinkedList.prototype.takeWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate,\n   * but starting from the end of the collection.\n   *\n   *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)\n   *     => LinkedList.of(3,4)\n   */\n  EmptyLinkedList.prototype.takeRightWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection with the first\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  EmptyLinkedList.prototype.drop = function (n) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the first elements\n   * until one element fails the predicate. All elements\n   * after that point are retained.\n   */\n  EmptyLinkedList.prototype.dropWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection with the last\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  EmptyLinkedList.prototype.dropRight = function (n) {\n    return this;\n  };\n  /**\n   * Returns a new collection, discarding the last elements\n   * until one element fails the predicate. All elements\n   * before that point are retained.\n   */\n  EmptyLinkedList.prototype.dropRightWhile = function (predicate) {\n    return this;\n  };\n  /**\n   * Reduces the collection to a single value using the\n   * associative binary function you give. Since the function\n   * is associative, order of application doesn't matter.\n   *\n   * Example:\n   *\n   *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);\n   *     => 6\n   */\n  EmptyLinkedList.prototype.fold = function (zero, fn) {\n    return zero;\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Left-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n   *     => \"cba!\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the previous value and\n   *           the current collection item, and returning\n   *           an updated value.\n   */\n  EmptyLinkedList.prototype.foldLeft = function (zero, fn) {\n    return zero;\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Right-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n   *     => \"!cba\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the current collection item and\n   *           the previous value , and returning\n   *           an updated value.\n   */\n  EmptyLinkedList.prototype.foldRight = function (zero, fn) {\n    return zero;\n  };\n  /**\n   * Combine this collection with the collection you give in\n   * parameter to produce a new collection which combines both,\n   * in pairs. For instance:\n   *\n   *     Vector.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n   *     => Vector.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n   *\n   * The result collection will have the length of the shorter\n   * of both collections. Extra elements will be discarded.\n   *\n   * Also see [[LinkedListStatic.zip]] (static version which can more than two\n   * iterables)\n   */\n  EmptyLinkedList.prototype.zip = function (other) {\n    return emptyLinkedList;\n  };\n  /**\n   * Combine this collection with the index of the elements\n   * in it. Handy if you need the index when you map on\n   * the collection for instance:\n   *\n   *     LinkedList.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n   *     => LinkedList.of(\"a0\", \"b1\")\n   */\n  EmptyLinkedList.prototype.zipWithIndex = function () {\n    return this;\n  };\n  /**\n   * Reverse the collection. For instance:\n   *\n   *     LinkedList.of(1,2,3).reverse();\n   *     => LinkedList.of(3,2,1)\n   */\n  EmptyLinkedList.prototype.reverse = function () {\n    return this;\n  };\n  /**\n   * Takes a predicate; returns a pair of collections.\n   * The first one is the longest prefix of this collection\n   * which satisfies the predicate, and the second collection\n   * is the remainder of the collection.\n   *\n   *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)\n   *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]\n   */\n  EmptyLinkedList.prototype.span = function (predicate) {\n    return [this, this];\n  };\n  /**\n   * Split the collection at a specific index.\n   *\n   *     LinkedList.of(1,2,3,4,5).splitAt(3)\n   *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]\n   */\n  EmptyLinkedList.prototype.splitAt = function (index) {\n    return [this, this];\n  };\n  EmptyLinkedList.prototype.partition = function (predicate) {\n    return [exports.LinkedList.empty(), exports.LinkedList.empty()];\n  };\n  /**\n   * Group elements in the collection using a classifier function.\n   * Elements are then organized in a map. The key is the value of\n   * the classifier, and in value we get the list of elements\n   * matching that value.\n   *\n   * also see [[ConsLinkedList.arrangeBy]]\n   */\n  EmptyLinkedList.prototype.groupBy = function (classifier) {\n    return HashMap_1.HashMap.empty();\n  };\n  /**\n   * Matches each element with a unique key that you extract from it.\n   * If the same key is present twice, the function will return None.\n   *\n   * also see [[ConsLinkedList.groupBy]]\n   */\n  EmptyLinkedList.prototype.arrangeBy = function (getKey) {\n    return SeqHelpers.arrangeBy(this, getKey);\n  };\n  /**\n   * Randomly reorder the elements of the collection.\n   */\n  EmptyLinkedList.prototype.shuffle = function () {\n    return this;\n  };\n  /**\n   * Append an element at the end of this LinkedList.\n   * Warning: appending in a loop on a linked list is going\n   * to be very slow!\n   */\n  EmptyLinkedList.prototype.append = function (v) {\n    return exports.LinkedList.of(v);\n  };\n  /*\n   * Append multiple elements at the end of this LinkedList.\n   */\n  EmptyLinkedList.prototype.appendAll = function (elts) {\n    return exports.LinkedList.ofIterable(elts);\n  };\n  /**\n   * Remove multiple elements from a LinkedList\n   *\n   *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])\n   *     => LinkedList.of(1,3,3,1)\n   */\n  EmptyLinkedList.prototype.removeAll = function (elts) {\n    return this;\n  };\n  /**\n   * Removes the first element matching the predicate\n   * (use [[Seq.filter]] to remove all elements matching a predicate)\n   */\n  EmptyLinkedList.prototype.removeFirst = function (predicate) {\n    return this;\n  };\n  /**\n   * Prepend an element at the beginning of the collection.\n   */\n  EmptyLinkedList.prototype.prepend = function (elt) {\n    return new ConsLinkedList(elt, this);\n  };\n  /**\n   * Prepend multiple elements at the beginning of the collection.\n   */\n  EmptyLinkedList.prototype.prependAll = function (elt) {\n    return exports.LinkedList.ofIterable(elt);\n  };\n  /**\n   * Return a new collection where each element was transformed\n   * by the mapper function you give.\n   */\n  EmptyLinkedList.prototype.map = function (mapper) {\n    return emptyLinkedList;\n  };\n  /**\n   * Apply the mapper function on every element of this collection.\n   * The mapper function returns an Option; if the Option is a Some,\n   * the value it contains is added to the result Collection, if it's\n   * a None, the value is discarded.\n   *\n   *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?\n   *         Option.of(x+1) : Option.none<number>())\n   *     => LinkedList.of(3, 7)\n   */\n  EmptyLinkedList.prototype.mapOption = function (mapper) {\n    return emptyLinkedList;\n  };\n  /**\n   * Calls the function you give for each item in the collection,\n   * your function returns a collection, all the collections are\n   * concatenated.\n   * This is the monadic bind.\n   */\n  EmptyLinkedList.prototype.flatMap = function (mapper) {\n    return emptyLinkedList;\n  };\n  EmptyLinkedList.prototype.allMatch = function (predicate) {\n    return true;\n  };\n  /**\n   * Returns true if there the predicate returns true for any\n   * element in the collection.\n   */\n  EmptyLinkedList.prototype.anyMatch = function (predicate) {\n    return false;\n  };\n  EmptyLinkedList.prototype.filter = function (predicate) {\n    return this;\n  };\n  /**\n   * Returns a new collection with elements\n   * sorted according to the comparator you give.\n   *\n   *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n   *     LinkedList.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n   *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n   *     => LinkedList.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n   *\n   * also see [[ConsLinkedList.sortOn]]\n   */\n  EmptyLinkedList.prototype.sortBy = function (compare) {\n    return this;\n  };\n  /**\n   * Give a function associating a number or a string with\n   * elements from the collection, and the elements\n   * are sorted according to that value.\n   *\n   *     LinkedList.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n   *     => LinkedList.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n   *\n   * You can also sort by multiple criteria, and request 'descending'\n   * sorting:\n   *\n   *     LinkedList.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n   *     => LinkedList.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n   *\n   * also see [[ConsLinkedList.sortBy]]\n   */\n  EmptyLinkedList.prototype.sortOn = function () {\n    var getKeys = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      getKeys[_i] = arguments[_i];\n    }\n    return this;\n  };\n  /**\n   * Remove duplicate items; elements are mapped to keys, those\n   * get compared.\n   *\n   *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)\n   *     => LinkedList.of(1,2,3)\n   */\n  EmptyLinkedList.prototype.distinctBy = function (keyExtractor) {\n    return this;\n  };\n  /**\n   * Call a function for element in the collection.\n   */\n  EmptyLinkedList.prototype.forEach = function (fn) {\n    return this;\n  };\n  /**\n   * Reduces the collection to a single value by repeatedly\n   * calling the combine function.\n   * No starting value. The order in which the elements are\n   * passed to the combining function is undetermined.\n   */\n  EmptyLinkedList.prototype.reduce = function (combine) {\n    return SeqHelpers.reduce(this, combine);\n  };\n  /**\n   * Compare values in the collection and return the smallest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsLinkedList.minOn]]\n   */\n  EmptyLinkedList.prototype.minBy = function (compare) {\n    return SeqHelpers.minBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the smallest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n   *     => Option.of({name:\"Paula\", age:6})\n   *\n   * also see [[ConsLinkedList.minBy]]\n   */\n  EmptyLinkedList.prototype.minOn = function (getOrderable) {\n    return SeqHelpers.minOn(this, getOrderable);\n  };\n  /**\n   * Compare values in the collection and return the largest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsLinkedList.maxOn]]\n   */\n  EmptyLinkedList.prototype.maxBy = function (compare) {\n    return SeqHelpers.maxBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the largest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n   *     => Option.of({name:\"Joe\", age:12})\n   *\n   * also see [[ConsLinkedList.maxBy]]\n   */\n  EmptyLinkedList.prototype.maxOn = function (getOrderable) {\n    return SeqHelpers.maxOn(this, getOrderable);\n  };\n  /**\n   * Call the function you give for each element in the collection\n   * and sum all the numbers, return that sum.\n   * Will return 0 if the collection is empty.\n   *\n   *     LinkedList.of(1,2,3).sumOn(x=>x)\n   *     => 6\n   */\n  EmptyLinkedList.prototype.sumOn = function (getNumber) {\n    return SeqHelpers.sumOn(this, getNumber);\n  };\n  /**\n   * Slides a window of a specific size over the sequence.\n   * Returns a lazy stream so memory use is not prohibitive.\n   *\n   *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)\n   *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))\n   */\n  EmptyLinkedList.prototype.sliding = function (count) {\n    return SeqHelpers.sliding(this, count);\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   * The last element of the result is the final cumulative result.\n   *\n   *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n   *     => LinkedList.of(0,1,3,6)\n   */\n  EmptyLinkedList.prototype.scanLeft = function (init, fn) {\n    return exports.LinkedList.of(init);\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   * The first element of the result is the final cumulative result.\n   *\n   *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n   *     => LinkedList.of(6,5,3,0)\n   */\n  EmptyLinkedList.prototype.scanRight = function (init, fn) {\n    return exports.LinkedList.of(init);\n  };\n  /**\n   * Joins elements of the collection by a separator.\n   * Example:\n   *\n   *     LinkedList.of(1,2,3).mkString(\", \")\n   *     => \"1, 2, 3\"\n   */\n  EmptyLinkedList.prototype.mkString = function (separator) {\n    return \"\";\n  };\n  /**\n   * Convert to array.\n   * Don't do it on an infinite stream!\n   */\n  EmptyLinkedList.prototype.toArray = function () {\n    return [];\n  };\n  /**\n   * Convert to vector.\n   * Don't do it on an infinite stream!\n   */\n  EmptyLinkedList.prototype.toVector = function () {\n    return Vector_1.Vector.empty();\n  };\n  /**\n   * Convert this collection to a map. You give a function which\n   * for each element in the collection returns a pair. The\n   * key of the pair will be used as a key in the map, the value,\n   * as a value in the map. If several values get the same key,\n   * entries will be lost.\n   *\n   *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])\n   *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n   */\n  EmptyLinkedList.prototype.toMap = function (converter) {\n    return HashMap_1.HashMap.empty();\n  };\n  /**\n   * Convert this collection to a set. Since the elements of the\n   * Seq may not support equality, you must pass a function returning\n   * a value supporting equality.\n   *\n   *     LinkedList.of(1,2,3,3,4).toSet(x=>x)\n   *     => HashSet.of(1,2,3,4)\n   */\n  EmptyLinkedList.prototype.toSet = function (converter) {\n    return HashSet_1.HashSet.empty();\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  EmptyLinkedList.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  EmptyLinkedList.prototype.equals = function (other) {\n    if (!other) {\n      return false;\n    }\n    return other.isEmpty();\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  EmptyLinkedList.prototype.hashCode = function () {\n    return 1;\n  };\n  EmptyLinkedList.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   *\n   * Also see [[ConsLinkedList.mkString]]\n   */\n  EmptyLinkedList.prototype.toString = function () {\n    return \"LinkedList()\";\n  };\n  return EmptyLinkedList;\n}();\nexports.EmptyLinkedList = EmptyLinkedList;\n/**\n * ConsLinkedList holds a value and a pointer to a next element,\n * which could be [[ConsLinkedList]] or [[EmptyLinkedList]].\n * A ConsLinkedList is basically a non-empty linked list. It will\n * contain at least one element.\n * \"static methods\" available through [[LinkedListStatic]]\n * @param T the item type\n */\nvar ConsLinkedList = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function ConsLinkedList(value, _tail) {\n    this.value = value;\n    this._tail = _tail;\n    /**\n     * @hidden\n     */\n    this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n  }\n  /**\n   * @hidden\n   */\n  ConsLinkedList.prototype.hasTrueEquality = function () {\n    return SeqHelpers.seqHasTrueEquality(this);\n  };\n  /**\n   * View this Some a as LinkedList. Useful to help typescript type\n   * inference sometimes.\n   */\n  ConsLinkedList.prototype.asLinkedList = function () {\n    return this;\n  };\n  /**\n   * Implementation of the Iterator interface.\n   */\n  ConsLinkedList.prototype[Symbol.iterator] = function () {\n    var item = this;\n    return {\n      next: function () {\n        if (item.isEmpty()) {\n          return {\n            done: true,\n            value: undefined\n          };\n        }\n        var value = item.head().get();\n        item = item.tail().get();\n        return {\n          done: false,\n          value: value\n        };\n      }\n    };\n  };\n  /**\n   * Get the length of the collection.\n   */\n  ConsLinkedList.prototype.length = function () {\n    return this.foldLeft(0, function (n, ignored) {\n      return n + 1;\n    });\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  ConsLinkedList.prototype.single = function () {\n    return this._tail.isEmpty() ? Option_1.Option.of(this.value) : Option_1.Option.none();\n  };\n  /**\n   * true if the collection is empty, false otherwise.\n   */\n  ConsLinkedList.prototype.isEmpty = function () {\n    return false;\n  };\n  /**\n   * Get the first value of the collection, if any.\n   * In this case the list is not empty, so returns Option.some\n   */\n  ConsLinkedList.prototype.head = function () {\n    return Option_1.Option.some(this.value);\n  };\n  /**\n   * Get all the elements in the collection but the first one.\n   * If the collection is empty, return None.\n   */\n  ConsLinkedList.prototype.tail = function () {\n    return Option_1.Option.some(this._tail);\n  };\n  /**\n   * Get the last value of the collection, if any.\n   * returns Option.Some if the collection is not empty,\n   * Option.None if it's empty.\n   */\n  ConsLinkedList.prototype.last = function () {\n    var curItem = this;\n    while (true) {\n      var item = curItem.value;\n      curItem = curItem._tail;\n      if (curItem.isEmpty()) {\n        return Option_1.Option.some(item);\n      }\n    }\n  };\n  /**\n   * Retrieve the element at index idx.\n   * Returns an option because the collection may\n   * contain less elements than the index.\n   *\n   * Careful this is going to have poor performance\n   * on LinkedList, which is not a good data structure\n   * for random access!\n   */\n  ConsLinkedList.prototype.get = function (idx) {\n    var curItem = this;\n    var i = 0;\n    while (!curItem.isEmpty()) {\n      if (i === idx) {\n        var item = curItem.value;\n        return Option_1.Option.of(item);\n      }\n      curItem = curItem._tail;\n      ++i;\n    }\n    return Option_1.Option.none();\n  };\n  /**\n   * Search for an item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   */\n  ConsLinkedList.prototype.find = function (predicate) {\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      var item = curItem.value;\n      if (predicate(item)) {\n        return Option_1.Option.of(item);\n      }\n      curItem = curItem._tail;\n    }\n    return Option_1.Option.none();\n  };\n  /**\n   * Returns true if the item is in the collection,\n   * false otherwise.\n   */\n  ConsLinkedList.prototype.contains = function (v) {\n    return this.find(function (x) {\n      return Comparison_1.areEqual(x, v);\n    }).isSome();\n  };\n  /**\n   * Return a new stream keeping only the first n elements\n   * from this stream.\n   */\n  ConsLinkedList.prototype.take = function (n) {\n    var result = emptyLinkedList;\n    var curItem = this;\n    var i = 0;\n    while (i++ < n && !curItem.isEmpty()) {\n      result = new ConsLinkedList(curItem.value, result);\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate.\n   */\n  ConsLinkedList.prototype.takeWhile = function (predicate) {\n    var result = emptyLinkedList;\n    var curItem = this;\n    while (!curItem.isEmpty() && predicate(curItem.value)) {\n      result = new ConsLinkedList(curItem.value, result);\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate,\n   * but starting from the end of the collection.\n   *\n   *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)\n   *     => LinkedList.of(3,4)\n   */\n  ConsLinkedList.prototype.takeRightWhile = function (predicate) {\n    return this.reverse().takeWhile(predicate).reverse();\n  };\n  /**\n   * Returns a new collection with the first\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  ConsLinkedList.prototype.drop = function (n) {\n    var i = n;\n    var curItem = this;\n    while (i-- > 0 && !curItem.isEmpty()) {\n      curItem = curItem._tail;\n    }\n    return curItem;\n  };\n  /**\n   * Returns a new collection, discarding the first elements\n   * until one element fails the predicate. All elements\n   * after that point are retained.\n   */\n  ConsLinkedList.prototype.dropWhile = function (predicate) {\n    var curItem = this;\n    while (!curItem.isEmpty() && predicate(curItem.value)) {\n      curItem = curItem._tail;\n    }\n    return curItem;\n  };\n  /**\n   * Returns a new collection with the last\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  ConsLinkedList.prototype.dropRight = function (n) {\n    // going twice through the list...\n    var length = this.length();\n    return this.take(length - n);\n  };\n  /**\n   * Returns a new collection, discarding the last elements\n   * until one element fails the predicate. All elements\n   * before that point are retained.\n   */\n  ConsLinkedList.prototype.dropRightWhile = function (predicate) {\n    return this.reverse().dropWhile(predicate).reverse();\n  };\n  /**\n   * Reduces the collection to a single value using the\n   * associative binary function you give. Since the function\n   * is associative, order of application doesn't matter.\n   *\n   * Example:\n   *\n   *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);\n   *     => 6\n   */\n  ConsLinkedList.prototype.fold = function (zero, fn) {\n    return this.foldLeft(zero, fn);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Left-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n   *     => \"cba!\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the previous value and\n   *           the current collection item, and returning\n   *           an updated value.\n   */\n  ConsLinkedList.prototype.foldLeft = function (zero, fn) {\n    var r = zero;\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      r = fn(r, curItem.value);\n      curItem = curItem._tail;\n    }\n    return r;\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Right-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n   *     => \"!cba\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the current collection item and\n   *           the previous value , and returning\n   *           an updated value.\n   */\n  ConsLinkedList.prototype.foldRight = function (zero, fn) {\n    return this.reverse().foldLeft(zero, function (xs, x) {\n      return fn(x, xs);\n    });\n  };\n  /**\n   * Combine this collection with the collection you give in\n   * parameter to produce a new collection which combines both,\n   * in pairs. For instance:\n   *\n   *     Vector.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n   *     => Vector.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n   *\n   * The result collection will have the length of the shorter\n   * of both collections. Extra elements will be discarded.\n   *\n   * Also see [[LinkedListStatic.zip]] (static version which can more than two\n   * iterables)\n   */\n  ConsLinkedList.prototype.zip = function (other) {\n    var otherIterator = other[Symbol.iterator]();\n    var otherCurItem = otherIterator.next();\n    var curItem = this;\n    var result = emptyLinkedList;\n    while (!curItem.isEmpty() && !otherCurItem.done) {\n      result = new ConsLinkedList([curItem.value, otherCurItem.value], result);\n      curItem = curItem._tail;\n      otherCurItem = otherIterator.next();\n    }\n    return result.reverse();\n  };\n  /**\n   * Combine this collection with the index of the elements\n   * in it. Handy if you need the index when you map on\n   * the collection for instance:\n   *\n   *     LinkedList.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n   *     => LinkedList.of(\"a0\", \"b1\")\n   */\n  ConsLinkedList.prototype.zipWithIndex = function () {\n    return SeqHelpers.zipWithIndex(this);\n  };\n  /**\n   * Reverse the collection. For instance:\n   *\n   *     LinkedList.of(1,2,3).reverse();\n   *     => LinkedList.of(3,2,1)\n   */\n  ConsLinkedList.prototype.reverse = function () {\n    return this.foldLeft(emptyLinkedList, function (xs, x) {\n      return xs.prepend(x);\n    });\n  };\n  /**\n   * Takes a predicate; returns a pair of collections.\n   * The first one is the longest prefix of this collection\n   * which satisfies the predicate, and the second collection\n   * is the remainder of the collection.\n   *\n   *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)\n   *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]\n   */\n  ConsLinkedList.prototype.span = function (predicate) {\n    var first = emptyLinkedList;\n    var curItem = this;\n    while (!curItem.isEmpty() && predicate(curItem.value)) {\n      first = new ConsLinkedList(curItem.value, first);\n      curItem = curItem._tail;\n    }\n    return [first.reverse(), curItem];\n  };\n  /**\n   * Split the collection at a specific index.\n   *\n   *     LinkedList.of(1,2,3,4,5).splitAt(3)\n   *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]\n   */\n  ConsLinkedList.prototype.splitAt = function (index) {\n    var first = emptyLinkedList;\n    var curItem = this;\n    var i = 0;\n    while (i++ < index && !curItem.isEmpty()) {\n      first = new ConsLinkedList(curItem.value, first);\n      curItem = curItem._tail;\n    }\n    return [first.reverse(), curItem];\n  };\n  ConsLinkedList.prototype.partition = function (predicate) {\n    var fst = exports.LinkedList.empty();\n    var snd = exports.LinkedList.empty();\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      if (predicate(curItem.value)) {\n        fst = new ConsLinkedList(curItem.value, fst);\n      } else {\n        snd = new ConsLinkedList(curItem.value, snd);\n      }\n      curItem = curItem._tail;\n    }\n    return [fst.reverse(), snd.reverse()];\n  };\n  /**\n   * Group elements in the collection using a classifier function.\n   * Elements are then organized in a map. The key is the value of\n   * the classifier, and in value we get the list of elements\n   * matching that value.\n   *\n   * also see [[ConsLinkedList.arrangeBy]]\n   */\n  ConsLinkedList.prototype.groupBy = function (classifier) {\n    return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, v) {\n      return acc.putWithMerge(classifier(v), exports.LinkedList.of(v), function (v1, v2) {\n        return v1.prepend(v2.single().getOrThrow());\n      });\n    }).mapValues(function (l) {\n      return l.reverse();\n    });\n  };\n  /**\n   * Matches each element with a unique key that you extract from it.\n   * If the same key is present twice, the function will return None.\n   *\n   * also see [[ConsLinkedList.groupBy]]\n   */\n  ConsLinkedList.prototype.arrangeBy = function (getKey) {\n    return SeqHelpers.arrangeBy(this, getKey);\n  };\n  /**\n   * Randomly reorder the elements of the collection.\n   */\n  ConsLinkedList.prototype.shuffle = function () {\n    return exports.LinkedList.ofIterable(SeqHelpers.shuffle(this.toArray()));\n  };\n  /**\n   * Append an element at the end of this LinkedList.\n   * Warning: appending in a loop on a linked list is going\n   * to be very slow!\n   */\n  ConsLinkedList.prototype.append = function (v) {\n    return new ConsLinkedList(this.value, this._tail.append(v));\n  };\n  /*\n   * Append multiple elements at the end of this LinkedList.\n   */\n  ConsLinkedList.prototype.appendAll = function (elts) {\n    return exports.LinkedList.ofIterable(elts).prependAll(this);\n  };\n  /**\n   * Remove multiple elements from a LinkedList\n   *\n   *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])\n   *     => LinkedList.of(1,3,3,1)\n   */\n  ConsLinkedList.prototype.removeAll = function (elts) {\n    return SeqHelpers.removeAll(this, elts);\n  };\n  /**\n   * Removes the first element matching the predicate\n   * (use [[Seq.filter]] to remove all elements matching a predicate)\n   */\n  ConsLinkedList.prototype.removeFirst = function (predicate) {\n    var curItem = this;\n    var result = emptyLinkedList;\n    var removed = false;\n    while (!curItem.isEmpty()) {\n      if (predicate(curItem.value) && !removed) {\n        removed = true;\n      } else {\n        result = new ConsLinkedList(curItem.value, result);\n      }\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Prepend an element at the beginning of the collection.\n   */\n  ConsLinkedList.prototype.prepend = function (elt) {\n    return new ConsLinkedList(elt, this);\n  };\n  /**\n   * Prepend multiple elements at the beginning of the collection.\n   */\n  ConsLinkedList.prototype.prependAll = function (elts) {\n    var leftToAdd = exports.LinkedList.ofIterable(elts).reverse();\n    var result = this;\n    while (!leftToAdd.isEmpty()) {\n      result = new ConsLinkedList(leftToAdd.value, result);\n      leftToAdd = leftToAdd._tail;\n    }\n    return result;\n  };\n  /**\n   * Return a new collection where each element was transformed\n   * by the mapper function you give.\n   */\n  ConsLinkedList.prototype.map = function (mapper) {\n    var curItem = this;\n    var result = emptyLinkedList;\n    while (!curItem.isEmpty()) {\n      result = new ConsLinkedList(mapper(curItem.value), result);\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Apply the mapper function on every element of this collection.\n   * The mapper function returns an Option; if the Option is a Some,\n   * the value it contains is added to the result Collection, if it's\n   * a None, the value is discarded.\n   *\n   *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?\n   *         Option.of(x+1) : Option.none<number>())\n   *     => LinkedList.of(3, 7)\n   */\n  ConsLinkedList.prototype.mapOption = function (mapper) {\n    var curItem = this;\n    var result = emptyLinkedList;\n    while (!curItem.isEmpty()) {\n      var mapped = mapper(curItem.value);\n      if (mapped.isSome()) {\n        result = new ConsLinkedList(mapped.get(), result);\n      }\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Calls the function you give for each item in the collection,\n   * your function returns a collection, all the collections are\n   * concatenated.\n   * This is the monadic bind.\n   */\n  ConsLinkedList.prototype.flatMap = function (mapper) {\n    var curItem = this;\n    var result = emptyLinkedList;\n    while (!curItem.isEmpty()) {\n      result = result.prependAll(mapper(curItem.value).reverse());\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  ConsLinkedList.prototype.allMatch = function (predicate) {\n    return this.find(function (x) {\n      return !predicate(x);\n    }).isNone();\n  };\n  /**\n   * Returns true if there the predicate returns true for any\n   * element in the collection.\n   */\n  ConsLinkedList.prototype.anyMatch = function (predicate) {\n    return this.find(predicate).isSome();\n  };\n  ConsLinkedList.prototype.filter = function (predicate) {\n    var curItem = this;\n    var result = emptyLinkedList;\n    while (!curItem.isEmpty()) {\n      if (predicate(curItem.value)) {\n        result = new ConsLinkedList(curItem.value, result);\n      }\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Returns a new collection with elements\n   * sorted according to the comparator you give.\n   *\n   *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n   *     LinkedList.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n   *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n   *     => LinkedList.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n   *\n   * also see [[ConsLinkedList.sortOn]]\n   */\n  ConsLinkedList.prototype.sortBy = function (compare) {\n    return exports.LinkedList.ofIterable(this.toArray().sort(compare));\n  };\n  /**\n   * Give a function associating a number or a string with\n   * elements from the collection, and the elements\n   * are sorted according to that value.\n   *\n   *     LinkedList.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n   *     => LinkedList.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n   *\n   * You can also sort by multiple criteria, and request 'descending'\n   * sorting:\n   *\n   *     LinkedList.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n   *     => LinkedList.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n   *\n   * also see [[ConsLinkedList.sortBy]]\n   */\n  ConsLinkedList.prototype.sortOn = function () {\n    var getKeys = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      getKeys[_i] = arguments[_i];\n    }\n    return SeqHelpers.sortOn(this, getKeys);\n  };\n  /**\n   * Remove duplicate items; elements are mapped to keys, those\n   * get compared.\n   *\n   *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)\n   *     => LinkedList.of(1,2,3)\n   */\n  ConsLinkedList.prototype.distinctBy = function (keyExtractor) {\n    return SeqHelpers.distinctBy(this, keyExtractor);\n  };\n  /**\n   * Call a function for element in the collection.\n   */\n  ConsLinkedList.prototype.forEach = function (fn) {\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      fn(curItem.value);\n      curItem = curItem._tail;\n    }\n    return this;\n  };\n  /**\n   * Reduces the collection to a single value by repeatedly\n   * calling the combine function.\n   * No starting value. The order in which the elements are\n   * passed to the combining function is undetermined.\n   */\n  ConsLinkedList.prototype.reduce = function (combine) {\n    return SeqHelpers.reduce(this, combine);\n  };\n  /**\n   * Compare values in the collection and return the smallest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsLinkedList.minOn]]\n   */\n  ConsLinkedList.prototype.minBy = function (compare) {\n    return SeqHelpers.minBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the smallest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n   *     => Option.of({name:\"Paula\", age:6})\n   *\n   * also see [[ConsLinkedList.minBy]]\n   */\n  ConsLinkedList.prototype.minOn = function (getOrderable) {\n    return SeqHelpers.minOn(this, getOrderable);\n  };\n  /**\n   * Compare values in the collection and return the largest element.\n   * Returns Option.none if the collection is empty.\n   *\n   *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n   *     => Option.of({name:\"Joe\", age:12})\n   *\n   * also see [[ConsLinkedList.maxOn]]\n   */\n  ConsLinkedList.prototype.maxBy = function (compare) {\n    return SeqHelpers.maxBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the largest.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[ConsLinkedList.maxBy]]\n   */\n  ConsLinkedList.prototype.maxOn = function (getOrderable) {\n    return SeqHelpers.maxOn(this, getOrderable);\n  };\n  /**\n   * Call the function you give for each element in the collection\n   * and sum all the numbers, return that sum.\n   * Will return 0 if the collection is empty.\n   *\n   *     LinkedList.of(1,2,3).sumOn(x=>x)\n   *     => 6\n   */\n  ConsLinkedList.prototype.sumOn = function (getNumber) {\n    return SeqHelpers.sumOn(this, getNumber);\n  };\n  /**\n   * Slides a window of a specific size over the sequence.\n   * Returns a lazy stream so memory use is not prohibitive.\n   *\n   *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)\n   *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))\n   */\n  ConsLinkedList.prototype.sliding = function (count) {\n    return SeqHelpers.sliding(this, count);\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   *\n   *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n   *     => LinkedList.of(0,1,3,6)\n   */\n  ConsLinkedList.prototype.scanLeft = function (init, fn) {\n    var result = exports.LinkedList.of(init);\n    var curItem = this;\n    var soFar = init;\n    while (!curItem.isEmpty()) {\n      soFar = fn(soFar, curItem.value);\n      result = new ConsLinkedList(soFar, result);\n      curItem = curItem._tail;\n    }\n    return result.reverse();\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   * The first element of the result is the final cumulative result.\n   *\n   *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n   *     => LinkedList.of(6,5,3,0)\n   */\n  ConsLinkedList.prototype.scanRight = function (init, fn) {\n    var result = exports.LinkedList.of(init);\n    var curItem = this.reverse();\n    var soFar = init;\n    while (!curItem.isEmpty()) {\n      soFar = fn(curItem.value, soFar);\n      result = new ConsLinkedList(soFar, result);\n      curItem = curItem._tail;\n    }\n    return result;\n  };\n  /**\n   * Joins elements of the collection by a separator.\n   * Example:\n   *\n   *     LinkedList.of(1,2,3).mkString(\", \")\n   *     => \"1, 2, 3\"\n   */\n  ConsLinkedList.prototype.mkString = function (separator) {\n    var r = \"\";\n    var curItem = this;\n    var isNotFirst = false;\n    while (!curItem.isEmpty()) {\n      if (isNotFirst) {\n        r += separator;\n      }\n      r += SeqHelpers.toStringHelper(curItem.value, {\n        quoteStrings: false\n      });\n      curItem = curItem._tail;\n      isNotFirst = true;\n    }\n    return r;\n  };\n  /**\n   * Convert to array.\n   * Don't do it on an infinite stream!\n   */\n  ConsLinkedList.prototype.toArray = function () {\n    var r = [];\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      r.push(curItem.value);\n      curItem = curItem._tail;\n    }\n    return r;\n  };\n  /**\n   * Convert to vector.\n   * Don't do it on an infinite stream!\n   */\n  ConsLinkedList.prototype.toVector = function () {\n    return Vector_1.Vector.ofIterable(this.toArray());\n  };\n  /**\n   * Convert this collection to a map. You give a function which\n   * for each element in the collection returns a pair. The\n   * key of the pair will be used as a key in the map, the value,\n   * as a value in the map. If several values get the same key,\n   * entries will be lost.\n   *\n   *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])\n   *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n   */\n  ConsLinkedList.prototype.toMap = function (converter) {\n    return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, cur) {\n      var converted = converter(cur);\n      return acc.put(converted[0], converted[1]);\n    });\n  };\n  /**\n   * Convert this collection to a set. Since the elements of the\n   * Seq may not support equality, you must pass a function returning\n   * a value supporting equality.\n   *\n   *     LinkedList.of(1,2,3,3,4).toSet(x=>x)\n   *     => HashSet.of(1,2,3,4)\n   */\n  ConsLinkedList.prototype.toSet = function (converter) {\n    return this.foldLeft(HashSet_1.HashSet.empty(), function (acc, cur) {\n      return acc.add(converter(cur));\n    });\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  ConsLinkedList.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  ConsLinkedList.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || !other.tail) {\n      return false;\n    }\n    Contract_1.contractTrueEquality(\"LinkedList.equals\", this, other);\n    var myVal = this;\n    var hisVal = other;\n    while (true) {\n      if (myVal.isEmpty() !== hisVal.isEmpty()) {\n        return false;\n      }\n      if (myVal.isEmpty()) {\n        // they are both empty, end of the stream\n        return true;\n      }\n      var myHead = myVal.value;\n      var hisHead = hisVal.value;\n      if (myHead === undefined !== (hisHead === undefined)) {\n        return false;\n      }\n      if (myHead === undefined || hisHead === undefined) {\n        // they are both undefined, the || is for TS's flow analysis\n        // so he realizes none of them is undefined after this.\n        continue;\n      }\n      if (!Comparison_1.areEqual(myHead, hisHead)) {\n        return false;\n      }\n      myVal = myVal._tail;\n      hisVal = hisVal._tail;\n    }\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  ConsLinkedList.prototype.hashCode = function () {\n    var hash = 1;\n    var curItem = this;\n    while (!curItem.isEmpty()) {\n      hash = 31 * hash + Comparison_1.getHashCode(curItem.value);\n      curItem = curItem._tail;\n    }\n    return hash;\n  };\n  ConsLinkedList.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   *\n   * Also see [[ConsLinkedList.mkString]]\n   */\n  ConsLinkedList.prototype.toString = function () {\n    var curItem = this;\n    var result = \"LinkedList(\";\n    while (!curItem.isEmpty()) {\n      result += SeqHelpers.toStringHelper(curItem.value);\n      var tail = curItem._tail;\n      curItem = tail;\n      if (!curItem.isEmpty()) {\n        result += \", \";\n      }\n    }\n    return result + \")\";\n  };\n  return ConsLinkedList;\n}();\nexports.ConsLinkedList = ConsLinkedList;\nvar emptyLinkedList = new EmptyLinkedList();","map":{"version":3,"names":["exports","__esModule","Option_1","require","Vector_1","Comparison_1","Contract_1","Value_1","HashMap_1","HashSet_1","SeqHelpers","LinkedListStatic","prototype","empty","emptyLinkedList","of","elts","_i","arguments","length","LinkedList","ofIterable","iterator","Symbol","curItem","next","result","done","ConsLinkedList","value","reverse","isEmpty","l","isNotEmpty","unfoldRight","seed","fn","nextVal","isNone","get","zip","iterables","r","iterators","map","i","items","some","item","prepend","EmptyLinkedList","className","undefined","hasTrueEquality","seqHasTrueEquality","asLinkedList","single","Option","none","head","tail","last","idx","find","predicate","contains","v","take","n","takeWhile","takeRightWhile","drop","dropWhile","dropRight","dropRightWhile","fold","zero","foldLeft","foldRight","other","zipWithIndex","span","splitAt","index","partition","groupBy","classifier","HashMap","arrangeBy","getKey","shuffle","append","appendAll","removeAll","removeFirst","elt","prependAll","mapper","mapOption","flatMap","allMatch","anyMatch","filter","sortBy","compare","sortOn","getKeys","distinctBy","keyExtractor","forEach","reduce","combine","minBy","minOn","getOrderable","maxBy","maxOn","sumOn","getNumber","sliding","count","scanLeft","init","scanRight","mkString","separator","toArray","toVector","Vector","toMap","converter","toSet","HashSet","transform","equals","hashCode","inspect","toString","_tail","ignored","x","areEqual","isSome","xs","otherIterator","otherCurItem","first","fst","snd","acc","putWithMerge","v1","v2","getOrThrow","mapValues","removed","leftToAdd","mapped","sort","soFar","isNotFirst","toStringHelper","quoteStrings","push","cur","converted","put","add","contractTrueEquality","myVal","hisVal","myHead","hisHead","hash","getHashCode"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/dist/src/LinkedList.js"],"sourcesContent":["\"use strict\";\nexports.__esModule = true;\n/**\n * A sequence of values, organized in-memory as a strict linked list.\n * Each element has an head (value) and a tail (the rest of the list).\n *\n * The code is organized through the class [[EmptyLinkedList]] (empty list\n * or tail), the class [[ConsLinkedList]] (list value and pointer to next),\n * and the type alias [[LinkedList]] (empty or cons).\n *\n * Finally, \"static\" functions on Option are arranged in the class\n * [[LinkedListStatic]] and are accessed through the global constant LinkedList.\n *\n * Random access is expensive, appending is expensive, prepend or getting\n * the tail of the list is very cheap.\n * If you often need random access you should rather use [[Vector]].\n * Avoid appending at the end of the list in a loop, prefer prepending and\n * then reversing the list.\n *\n * Examples:\n *\n *     LinkedList.of(1,2,3);\n *     LinkedList.of(1,2,3).map(x => x*2).last();\n */\nvar Option_1 = require(\"./Option\");\nvar Vector_1 = require(\"./Vector\");\nvar Comparison_1 = require(\"./Comparison\");\nvar Contract_1 = require(\"./Contract\");\nvar Value_1 = require(\"./Value\");\nvar HashMap_1 = require(\"./HashMap\");\nvar HashSet_1 = require(\"./HashSet\");\nvar SeqHelpers = require(\"./SeqHelpers\");\n/**\n * Holds the \"static methods\" for [[LinkedList]]\n */\nvar LinkedListStatic = /** @class */ (function () {\n    function LinkedListStatic() {\n    }\n    /**\n     * The empty stream\n     */\n    LinkedListStatic.prototype.empty = function () {\n        return emptyLinkedList;\n    };\n    LinkedListStatic.prototype.of = function () {\n        var elts = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            elts[_i] = arguments[_i];\n        }\n        return exports.LinkedList.ofIterable(elts);\n    };\n    /**\n     * Build a stream from any iterable, which means also\n     * an array for instance.\n     * @param T the item type\n     */\n    LinkedListStatic.prototype.ofIterable = function (elts) {\n        var iterator = elts[Symbol.iterator]();\n        var curItem = iterator.next();\n        var result = emptyLinkedList;\n        while (!curItem.done) {\n            result = new ConsLinkedList(curItem.value, result);\n            curItem = iterator.next();\n        }\n        return result.reverse();\n    };\n    /**\n     * Curried type guard for LinkedList.\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(LinkedList.of(1), LinkedList.empty<number>())\n     *         .filter(LinkedList.isEmpty)\n     *     => Vector.of(LinkedList.empty<number>())\n     */\n    LinkedListStatic.prototype.isEmpty = function (l) {\n        return l.isEmpty();\n    };\n    /**\n     * Curried type guard for LinkedList.\n     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218\n     *\n     *     Vector.of(Stream.of(1), Stream.empty<number>())\n     *         .filter(Stream.isNotEmpty)\n     *         .map(s => s.head().get()+1)\n     *     => Vector.of(2)\n     */\n    LinkedListStatic.prototype.isNotEmpty = function (l) {\n        return !l.isEmpty();\n    };\n    /**\n     * Dual to the foldRight function. Build a collection from a seed.\n     * Takes a starting element and a function.\n     * It applies the function on the starting element; if the\n     * function returns None, it stops building the list, if it\n     * returns Some of a pair, it adds the first element to the result\n     * and takes the second element as a seed to keep going.\n     *\n     *     LinkedList.unfoldRight(\n     *          10, x=>Option.of(x)\n     *              .filter(x => x!==0)\n     *              .map<[number,number]>(x => [x,x-1]))\n     *     => LinkedList.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n     */\n    LinkedListStatic.prototype.unfoldRight = function (seed, fn) {\n        var nextVal = fn(seed);\n        var result = emptyLinkedList;\n        while (!nextVal.isNone()) {\n            result = new ConsLinkedList(nextVal.get()[0], result);\n            nextVal = fn(nextVal.get()[1]);\n        }\n        return result.reverse();\n    };\n    /**\n     * Combine any number of iterables you give in as\n     * parameters to produce a new collection which combines all,\n     * in tuples. For instance:\n     *\n     *     LinkedList.zip(LinkedList.of(1,2,3), [\"a\",\"b\",\"c\"], Vector.of(8,9,10))\n     *     => LinkedList.of([1,\"a\",8], [2,\"b\",9], [3,\"c\",10])\n     *\n     * The result collection will have the length of the shorter\n     * of the input iterables. Extra elements will be discarded.\n     *\n     * Also see the non-static version [[ConsLinkedList.zip]], which only combines two\n     * collections.\n     * @param A A is the type of the tuple that'll be generated\n     *          (`[number,string,number]` for the code sample)\n     */\n    LinkedListStatic.prototype.zip = function () {\n        var iterables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            iterables[_i] = arguments[_i];\n        }\n        var r = exports.LinkedList.empty();\n        var iterators = iterables.map(function (i) { return i[Symbol.iterator](); });\n        var items = iterators.map(function (i) { return i.next(); });\n        while (!items.some(function (item) { return item.done; })) {\n            r = r.prepend(items.map(function (item) { return item.value; }));\n            items = iterators.map(function (i) { return i.next(); });\n        }\n        return r.reverse();\n    };\n    return LinkedListStatic;\n}());\nexports.LinkedListStatic = LinkedListStatic;\n/**\n * The LinkedList constant allows to call the LinkedList \"static\" methods\n */\nexports.LinkedList = new LinkedListStatic();\n/**\n * EmptyLinkedList is the empty linked list; every non-empty\n * linked list also has a pointer to an empty linked list\n * after its last element.\n * \"static methods\" available through [[LinkedListStatic]]\n * @param T the item type\n */\nvar EmptyLinkedList = /** @class */ (function () {\n    function EmptyLinkedList() {\n        /**\n         * @hidden\n         */\n        this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n    }\n    /**\n     * @hidden\n     */\n    EmptyLinkedList.prototype.hasTrueEquality = function () {\n        return SeqHelpers.seqHasTrueEquality(this);\n    };\n    /**\n     * Implementation of the Iterator interface.\n     */\n    EmptyLinkedList.prototype[Symbol.iterator] = function () {\n        return {\n            next: function () {\n                return {\n                    done: true,\n                    value: undefined\n                };\n            }\n        };\n    };\n    /**\n     * View this Some a as LinkedList. Useful to help typescript type\n     * inference sometimes.\n     */\n    EmptyLinkedList.prototype.asLinkedList = function () {\n        return this;\n    };\n    /**\n     * Get the length of the collection.\n     */\n    EmptyLinkedList.prototype.length = function () {\n        return 0;\n    };\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    EmptyLinkedList.prototype.single = function () {\n        return Option_1.Option.none();\n    };\n    /**\n     * true if the collection is empty, false otherwise.\n     */\n    EmptyLinkedList.prototype.isEmpty = function () {\n        return true;\n    };\n    /**\n     * Get the first value of the collection, if any.\n     * In this case the list is empty, so returns Option.none\n     */\n    EmptyLinkedList.prototype.head = function () {\n        return Option_1.Option.none();\n    };\n    /**\n     * Get all the elements in the collection but the first one.\n     * If the collection is empty, return None.\n     */\n    EmptyLinkedList.prototype.tail = function () {\n        return Option_1.Option.none();\n    };\n    /**\n     * Get the last value of the collection, if any.\n     * returns Option.Some if the collection is not empty,\n     * Option.None if it's empty.\n     */\n    EmptyLinkedList.prototype.last = function () {\n        return Option_1.Option.none();\n    };\n    /**\n     * Retrieve the element at index idx.\n     * Returns an option because the collection may\n     * contain less elements than the index.\n     *\n     * Careful this is going to have poor performance\n     * on LinkedList, which is not a good data structure\n     * for random access!\n     */\n    EmptyLinkedList.prototype.get = function (idx) {\n        return Option_1.Option.none();\n    };\n    /**\n     * Search for an item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     */\n    EmptyLinkedList.prototype.find = function (predicate) {\n        return Option_1.Option.none();\n    };\n    /**\n     * Returns true if the item is in the collection,\n     * false otherwise.\n     */\n    EmptyLinkedList.prototype.contains = function (v) {\n        return false;\n    };\n    /**\n     * Return a new stream keeping only the first n elements\n     * from this stream.\n     */\n    EmptyLinkedList.prototype.take = function (n) {\n        return this;\n    };\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate.\n     */\n    EmptyLinkedList.prototype.takeWhile = function (predicate) {\n        return this;\n    };\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate,\n     * but starting from the end of the collection.\n     *\n     *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)\n     *     => LinkedList.of(3,4)\n     */\n    EmptyLinkedList.prototype.takeRightWhile = function (predicate) {\n        return this;\n    };\n    /**\n     * Returns a new collection with the first\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    EmptyLinkedList.prototype.drop = function (n) {\n        return this;\n    };\n    /**\n     * Returns a new collection, discarding the first elements\n     * until one element fails the predicate. All elements\n     * after that point are retained.\n     */\n    EmptyLinkedList.prototype.dropWhile = function (predicate) {\n        return this;\n    };\n    /**\n     * Returns a new collection with the last\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    EmptyLinkedList.prototype.dropRight = function (n) {\n        return this;\n    };\n    /**\n     * Returns a new collection, discarding the last elements\n     * until one element fails the predicate. All elements\n     * before that point are retained.\n     */\n    EmptyLinkedList.prototype.dropRightWhile = function (predicate) {\n        return this;\n    };\n    /**\n     * Reduces the collection to a single value using the\n     * associative binary function you give. Since the function\n     * is associative, order of application doesn't matter.\n     *\n     * Example:\n     *\n     *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);\n     *     => 6\n     */\n    EmptyLinkedList.prototype.fold = function (zero, fn) {\n        return zero;\n    };\n    /**\n     * Reduces the collection to a single value.\n     * Left-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n     *     => \"cba!\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the previous value and\n     *           the current collection item, and returning\n     *           an updated value.\n     */\n    EmptyLinkedList.prototype.foldLeft = function (zero, fn) {\n        return zero;\n    };\n    /**\n     * Reduces the collection to a single value.\n     * Right-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n     *     => \"!cba\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the current collection item and\n     *           the previous value , and returning\n     *           an updated value.\n     */\n    EmptyLinkedList.prototype.foldRight = function (zero, fn) {\n        return zero;\n    };\n    /**\n     * Combine this collection with the collection you give in\n     * parameter to produce a new collection which combines both,\n     * in pairs. For instance:\n     *\n     *     Vector.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n     *     => Vector.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n     *\n     * The result collection will have the length of the shorter\n     * of both collections. Extra elements will be discarded.\n     *\n     * Also see [[LinkedListStatic.zip]] (static version which can more than two\n     * iterables)\n     */\n    EmptyLinkedList.prototype.zip = function (other) {\n        return emptyLinkedList;\n    };\n    /**\n     * Combine this collection with the index of the elements\n     * in it. Handy if you need the index when you map on\n     * the collection for instance:\n     *\n     *     LinkedList.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n     *     => LinkedList.of(\"a0\", \"b1\")\n     */\n    EmptyLinkedList.prototype.zipWithIndex = function () {\n        return this;\n    };\n    /**\n     * Reverse the collection. For instance:\n     *\n     *     LinkedList.of(1,2,3).reverse();\n     *     => LinkedList.of(3,2,1)\n     */\n    EmptyLinkedList.prototype.reverse = function () {\n        return this;\n    };\n    /**\n     * Takes a predicate; returns a pair of collections.\n     * The first one is the longest prefix of this collection\n     * which satisfies the predicate, and the second collection\n     * is the remainder of the collection.\n     *\n     *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)\n     *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]\n     */\n    EmptyLinkedList.prototype.span = function (predicate) {\n        return [this, this];\n    };\n    /**\n     * Split the collection at a specific index.\n     *\n     *     LinkedList.of(1,2,3,4,5).splitAt(3)\n     *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]\n     */\n    EmptyLinkedList.prototype.splitAt = function (index) {\n        return [this, this];\n    };\n    EmptyLinkedList.prototype.partition = function (predicate) {\n        return [exports.LinkedList.empty(), exports.LinkedList.empty()];\n    };\n    /**\n     * Group elements in the collection using a classifier function.\n     * Elements are then organized in a map. The key is the value of\n     * the classifier, and in value we get the list of elements\n     * matching that value.\n     *\n     * also see [[ConsLinkedList.arrangeBy]]\n     */\n    EmptyLinkedList.prototype.groupBy = function (classifier) {\n        return HashMap_1.HashMap.empty();\n    };\n    /**\n     * Matches each element with a unique key that you extract from it.\n     * If the same key is present twice, the function will return None.\n     *\n     * also see [[ConsLinkedList.groupBy]]\n     */\n    EmptyLinkedList.prototype.arrangeBy = function (getKey) {\n        return SeqHelpers.arrangeBy(this, getKey);\n    };\n    /**\n     * Randomly reorder the elements of the collection.\n     */\n    EmptyLinkedList.prototype.shuffle = function () {\n        return this;\n    };\n    /**\n     * Append an element at the end of this LinkedList.\n     * Warning: appending in a loop on a linked list is going\n     * to be very slow!\n     */\n    EmptyLinkedList.prototype.append = function (v) {\n        return exports.LinkedList.of(v);\n    };\n    /*\n     * Append multiple elements at the end of this LinkedList.\n     */\n    EmptyLinkedList.prototype.appendAll = function (elts) {\n        return exports.LinkedList.ofIterable(elts);\n    };\n    /**\n     * Remove multiple elements from a LinkedList\n     *\n     *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])\n     *     => LinkedList.of(1,3,3,1)\n     */\n    EmptyLinkedList.prototype.removeAll = function (elts) {\n        return this;\n    };\n    /**\n     * Removes the first element matching the predicate\n     * (use [[Seq.filter]] to remove all elements matching a predicate)\n     */\n    EmptyLinkedList.prototype.removeFirst = function (predicate) {\n        return this;\n    };\n    /**\n     * Prepend an element at the beginning of the collection.\n     */\n    EmptyLinkedList.prototype.prepend = function (elt) {\n        return new ConsLinkedList(elt, this);\n    };\n    /**\n     * Prepend multiple elements at the beginning of the collection.\n     */\n    EmptyLinkedList.prototype.prependAll = function (elt) {\n        return exports.LinkedList.ofIterable(elt);\n    };\n    /**\n     * Return a new collection where each element was transformed\n     * by the mapper function you give.\n     */\n    EmptyLinkedList.prototype.map = function (mapper) {\n        return emptyLinkedList;\n    };\n    /**\n     * Apply the mapper function on every element of this collection.\n     * The mapper function returns an Option; if the Option is a Some,\n     * the value it contains is added to the result Collection, if it's\n     * a None, the value is discarded.\n     *\n     *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?\n     *         Option.of(x+1) : Option.none<number>())\n     *     => LinkedList.of(3, 7)\n     */\n    EmptyLinkedList.prototype.mapOption = function (mapper) {\n        return emptyLinkedList;\n    };\n    /**\n     * Calls the function you give for each item in the collection,\n     * your function returns a collection, all the collections are\n     * concatenated.\n     * This is the monadic bind.\n     */\n    EmptyLinkedList.prototype.flatMap = function (mapper) {\n        return emptyLinkedList;\n    };\n    EmptyLinkedList.prototype.allMatch = function (predicate) {\n        return true;\n    };\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    EmptyLinkedList.prototype.anyMatch = function (predicate) {\n        return false;\n    };\n    EmptyLinkedList.prototype.filter = function (predicate) {\n        return this;\n    };\n    /**\n     * Returns a new collection with elements\n     * sorted according to the comparator you give.\n     *\n     *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n     *     LinkedList.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n     *     => LinkedList.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n     *\n     * also see [[ConsLinkedList.sortOn]]\n     */\n    EmptyLinkedList.prototype.sortBy = function (compare) {\n        return this;\n    };\n    /**\n     * Give a function associating a number or a string with\n     * elements from the collection, and the elements\n     * are sorted according to that value.\n     *\n     *     LinkedList.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n     *     => LinkedList.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n     *\n     * You can also sort by multiple criteria, and request 'descending'\n     * sorting:\n     *\n     *     LinkedList.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n     *     => LinkedList.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n     *\n     * also see [[ConsLinkedList.sortBy]]\n     */\n    EmptyLinkedList.prototype.sortOn = function () {\n        var getKeys = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            getKeys[_i] = arguments[_i];\n        }\n        return this;\n    };\n    /**\n     * Remove duplicate items; elements are mapped to keys, those\n     * get compared.\n     *\n     *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)\n     *     => LinkedList.of(1,2,3)\n     */\n    EmptyLinkedList.prototype.distinctBy = function (keyExtractor) {\n        return this;\n    };\n    /**\n     * Call a function for element in the collection.\n     */\n    EmptyLinkedList.prototype.forEach = function (fn) {\n        return this;\n    };\n    /**\n     * Reduces the collection to a single value by repeatedly\n     * calling the combine function.\n     * No starting value. The order in which the elements are\n     * passed to the combining function is undetermined.\n     */\n    EmptyLinkedList.prototype.reduce = function (combine) {\n        return SeqHelpers.reduce(this, combine);\n    };\n    /**\n     * Compare values in the collection and return the smallest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsLinkedList.minOn]]\n     */\n    EmptyLinkedList.prototype.minBy = function (compare) {\n        return SeqHelpers.minBy(this, compare);\n    };\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the smallest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n     *     => Option.of({name:\"Paula\", age:6})\n     *\n     * also see [[ConsLinkedList.minBy]]\n     */\n    EmptyLinkedList.prototype.minOn = function (getOrderable) {\n        return SeqHelpers.minOn(this, getOrderable);\n    };\n    /**\n     * Compare values in the collection and return the largest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsLinkedList.maxOn]]\n     */\n    EmptyLinkedList.prototype.maxBy = function (compare) {\n        return SeqHelpers.maxBy(this, compare);\n    };\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the largest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n     *     => Option.of({name:\"Joe\", age:12})\n     *\n     * also see [[ConsLinkedList.maxBy]]\n     */\n    EmptyLinkedList.prototype.maxOn = function (getOrderable) {\n        return SeqHelpers.maxOn(this, getOrderable);\n    };\n    /**\n     * Call the function you give for each element in the collection\n     * and sum all the numbers, return that sum.\n     * Will return 0 if the collection is empty.\n     *\n     *     LinkedList.of(1,2,3).sumOn(x=>x)\n     *     => 6\n     */\n    EmptyLinkedList.prototype.sumOn = function (getNumber) {\n        return SeqHelpers.sumOn(this, getNumber);\n    };\n    /**\n     * Slides a window of a specific size over the sequence.\n     * Returns a lazy stream so memory use is not prohibitive.\n     *\n     *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)\n     *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))\n     */\n    EmptyLinkedList.prototype.sliding = function (count) {\n        return SeqHelpers.sliding(this, count);\n    };\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     * The last element of the result is the final cumulative result.\n     *\n     *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n     *     => LinkedList.of(0,1,3,6)\n     */\n    EmptyLinkedList.prototype.scanLeft = function (init, fn) {\n        return exports.LinkedList.of(init);\n    };\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     * The first element of the result is the final cumulative result.\n     *\n     *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n     *     => LinkedList.of(6,5,3,0)\n     */\n    EmptyLinkedList.prototype.scanRight = function (init, fn) {\n        return exports.LinkedList.of(init);\n    };\n    /**\n     * Joins elements of the collection by a separator.\n     * Example:\n     *\n     *     LinkedList.of(1,2,3).mkString(\", \")\n     *     => \"1, 2, 3\"\n     */\n    EmptyLinkedList.prototype.mkString = function (separator) {\n        return \"\";\n    };\n    /**\n     * Convert to array.\n     * Don't do it on an infinite stream!\n     */\n    EmptyLinkedList.prototype.toArray = function () {\n        return [];\n    };\n    /**\n     * Convert to vector.\n     * Don't do it on an infinite stream!\n     */\n    EmptyLinkedList.prototype.toVector = function () {\n        return Vector_1.Vector.empty();\n    };\n    /**\n     * Convert this collection to a map. You give a function which\n     * for each element in the collection returns a pair. The\n     * key of the pair will be used as a key in the map, the value,\n     * as a value in the map. If several values get the same key,\n     * entries will be lost.\n     *\n     *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])\n     *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n     */\n    EmptyLinkedList.prototype.toMap = function (converter) {\n        return HashMap_1.HashMap.empty();\n    };\n    /**\n     * Convert this collection to a set. Since the elements of the\n     * Seq may not support equality, you must pass a function returning\n     * a value supporting equality.\n     *\n     *     LinkedList.of(1,2,3,3,4).toSet(x=>x)\n     *     => HashSet.of(1,2,3,4)\n     */\n    EmptyLinkedList.prototype.toSet = function (converter) {\n        return HashSet_1.HashSet.empty();\n    };\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    EmptyLinkedList.prototype.transform = function (converter) {\n        return converter(this);\n    };\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    EmptyLinkedList.prototype.equals = function (other) {\n        if (!other) {\n            return false;\n        }\n        return other.isEmpty();\n    };\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    EmptyLinkedList.prototype.hashCode = function () {\n        return 1;\n    };\n    EmptyLinkedList.prototype[Value_1.inspect] = function () {\n        return this.toString();\n    };\n    /**\n     * Get a human-friendly string representation of that value.\n     *\n     * Also see [[ConsLinkedList.mkString]]\n     */\n    EmptyLinkedList.prototype.toString = function () {\n        return \"LinkedList()\";\n    };\n    return EmptyLinkedList;\n}());\nexports.EmptyLinkedList = EmptyLinkedList;\n/**\n * ConsLinkedList holds a value and a pointer to a next element,\n * which could be [[ConsLinkedList]] or [[EmptyLinkedList]].\n * A ConsLinkedList is basically a non-empty linked list. It will\n * contain at least one element.\n * \"static methods\" available through [[LinkedListStatic]]\n * @param T the item type\n */\nvar ConsLinkedList = /** @class */ (function () {\n    /**\n     * @hidden\n     */\n    function ConsLinkedList(value, _tail) {\n        this.value = value;\n        this._tail = _tail;\n        /**\n         * @hidden\n         */\n        this.className = undefined; // https://stackoverflow.com/a/47841595/516188\n    }\n    /**\n     * @hidden\n     */\n    ConsLinkedList.prototype.hasTrueEquality = function () {\n        return SeqHelpers.seqHasTrueEquality(this);\n    };\n    /**\n     * View this Some a as LinkedList. Useful to help typescript type\n     * inference sometimes.\n     */\n    ConsLinkedList.prototype.asLinkedList = function () {\n        return this;\n    };\n    /**\n     * Implementation of the Iterator interface.\n     */\n    ConsLinkedList.prototype[Symbol.iterator] = function () {\n        var item = this;\n        return {\n            next: function () {\n                if (item.isEmpty()) {\n                    return { done: true, value: undefined };\n                }\n                var value = item.head().get();\n                item = item.tail().get();\n                return { done: false, value: value };\n            }\n        };\n    };\n    /**\n     * Get the length of the collection.\n     */\n    ConsLinkedList.prototype.length = function () {\n        return this.foldLeft(0, function (n, ignored) { return n + 1; });\n    };\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    ConsLinkedList.prototype.single = function () {\n        return this._tail.isEmpty() ?\n            Option_1.Option.of(this.value) :\n            Option_1.Option.none();\n    };\n    /**\n     * true if the collection is empty, false otherwise.\n     */\n    ConsLinkedList.prototype.isEmpty = function () {\n        return false;\n    };\n    /**\n     * Get the first value of the collection, if any.\n     * In this case the list is not empty, so returns Option.some\n     */\n    ConsLinkedList.prototype.head = function () {\n        return Option_1.Option.some(this.value);\n    };\n    /**\n     * Get all the elements in the collection but the first one.\n     * If the collection is empty, return None.\n     */\n    ConsLinkedList.prototype.tail = function () {\n        return Option_1.Option.some(this._tail);\n    };\n    /**\n     * Get the last value of the collection, if any.\n     * returns Option.Some if the collection is not empty,\n     * Option.None if it's empty.\n     */\n    ConsLinkedList.prototype.last = function () {\n        var curItem = this;\n        while (true) {\n            var item = curItem.value;\n            curItem = curItem._tail;\n            if (curItem.isEmpty()) {\n                return Option_1.Option.some(item);\n            }\n        }\n    };\n    /**\n     * Retrieve the element at index idx.\n     * Returns an option because the collection may\n     * contain less elements than the index.\n     *\n     * Careful this is going to have poor performance\n     * on LinkedList, which is not a good data structure\n     * for random access!\n     */\n    ConsLinkedList.prototype.get = function (idx) {\n        var curItem = this;\n        var i = 0;\n        while (!curItem.isEmpty()) {\n            if (i === idx) {\n                var item = curItem.value;\n                return Option_1.Option.of(item);\n            }\n            curItem = curItem._tail;\n            ++i;\n        }\n        return Option_1.Option.none();\n    };\n    /**\n     * Search for an item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     */\n    ConsLinkedList.prototype.find = function (predicate) {\n        var curItem = this;\n        while (!curItem.isEmpty()) {\n            var item = curItem.value;\n            if (predicate(item)) {\n                return Option_1.Option.of(item);\n            }\n            curItem = curItem._tail;\n        }\n        return Option_1.Option.none();\n    };\n    /**\n     * Returns true if the item is in the collection,\n     * false otherwise.\n     */\n    ConsLinkedList.prototype.contains = function (v) {\n        return this.find(function (x) { return Comparison_1.areEqual(x, v); }).isSome();\n    };\n    /**\n     * Return a new stream keeping only the first n elements\n     * from this stream.\n     */\n    ConsLinkedList.prototype.take = function (n) {\n        var result = emptyLinkedList;\n        var curItem = this;\n        var i = 0;\n        while (i++ < n && (!curItem.isEmpty())) {\n            result = new ConsLinkedList(curItem.value, result);\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    };\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate.\n     */\n    ConsLinkedList.prototype.takeWhile = function (predicate) {\n        var result = emptyLinkedList;\n        var curItem = this;\n        while ((!curItem.isEmpty()) && predicate(curItem.value)) {\n            result = new ConsLinkedList(curItem.value, result);\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    };\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate,\n     * but starting from the end of the collection.\n     *\n     *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)\n     *     => LinkedList.of(3,4)\n     */\n    ConsLinkedList.prototype.takeRightWhile = function (predicate) {\n        return this.reverse().takeWhile(predicate).reverse();\n    };\n    /**\n     * Returns a new collection with the first\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    ConsLinkedList.prototype.drop = function (n) {\n        var i = n;\n        var curItem = this;\n        while (i-- > 0 && !curItem.isEmpty()) {\n            curItem = curItem._tail;\n        }\n        return curItem;\n    };\n    /**\n     * Returns a new collection, discarding the first elements\n     * until one element fails the predicate. All elements\n     * after that point are retained.\n     */\n    ConsLinkedList.prototype.dropWhile = function (predicate) {\n        var curItem = this;\n        while (!curItem.isEmpty() && predicate(curItem.value)) {\n            curItem = curItem._tail;\n        }\n        return curItem;\n    };\n    /**\n     * Returns a new collection with the last\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    ConsLinkedList.prototype.dropRight = function (n) {\n        // going twice through the list...\n        var length = this.length();\n        return this.take(length - n);\n    };\n    /**\n     * Returns a new collection, discarding the last elements\n     * until one element fails the predicate. All elements\n     * before that point are retained.\n     */\n    ConsLinkedList.prototype.dropRightWhile = function (predicate) {\n        return this.reverse().dropWhile(predicate).reverse();\n    };\n    /**\n     * Reduces the collection to a single value using the\n     * associative binary function you give. Since the function\n     * is associative, order of application doesn't matter.\n     *\n     * Example:\n     *\n     *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);\n     *     => 6\n     */\n    ConsLinkedList.prototype.fold = function (zero, fn) {\n        return this.foldLeft(zero, fn);\n    };\n    /**\n     * Reduces the collection to a single value.\n     * Left-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n     *     => \"cba!\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the previous value and\n     *           the current collection item, and returning\n     *           an updated value.\n     */\n    ConsLinkedList.prototype.foldLeft = function (zero, fn) {\n        var r = zero;\n        var curItem = this;\n        while (!curItem.isEmpty()) {\n            r = fn(r, curItem.value);\n            curItem = curItem._tail;\n        }\n        return r;\n    };\n    /**\n     * Reduces the collection to a single value.\n     * Right-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n     *     => \"!cba\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the current collection item and\n     *           the previous value , and returning\n     *           an updated value.\n     */\n    ConsLinkedList.prototype.foldRight = function (zero, fn) {\n        return this.reverse().foldLeft(zero, function (xs, x) { return fn(x, xs); });\n    };\n    /**\n     * Combine this collection with the collection you give in\n     * parameter to produce a new collection which combines both,\n     * in pairs. For instance:\n     *\n     *     Vector.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n     *     => Vector.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n     *\n     * The result collection will have the length of the shorter\n     * of both collections. Extra elements will be discarded.\n     *\n     * Also see [[LinkedListStatic.zip]] (static version which can more than two\n     * iterables)\n     */\n    ConsLinkedList.prototype.zip = function (other) {\n        var otherIterator = other[Symbol.iterator]();\n        var otherCurItem = otherIterator.next();\n        var curItem = this;\n        var result = emptyLinkedList;\n        while ((!curItem.isEmpty()) && (!otherCurItem.done)) {\n            result = new ConsLinkedList([curItem.value, otherCurItem.value], result);\n            curItem = curItem._tail;\n            otherCurItem = otherIterator.next();\n        }\n        return result.reverse();\n    };\n    /**\n     * Combine this collection with the index of the elements\n     * in it. Handy if you need the index when you map on\n     * the collection for instance:\n     *\n     *     LinkedList.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx);\n     *     => LinkedList.of(\"a0\", \"b1\")\n     */\n    ConsLinkedList.prototype.zipWithIndex = function () {\n        return SeqHelpers.zipWithIndex(this);\n    };\n    /**\n     * Reverse the collection. For instance:\n     *\n     *     LinkedList.of(1,2,3).reverse();\n     *     => LinkedList.of(3,2,1)\n     */\n    ConsLinkedList.prototype.reverse = function () {\n        return this.foldLeft(emptyLinkedList, function (xs, x) { return xs.prepend(x); });\n    };\n    /**\n     * Takes a predicate; returns a pair of collections.\n     * The first one is the longest prefix of this collection\n     * which satisfies the predicate, and the second collection\n     * is the remainder of the collection.\n     *\n     *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)\n     *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]\n     */\n    ConsLinkedList.prototype.span = function (predicate) {\n        var first = emptyLinkedList;\n        var curItem = this;\n        while ((!curItem.isEmpty()) && predicate(curItem.value)) {\n            first = new ConsLinkedList(curItem.value, first);\n            curItem = curItem._tail;\n        }\n        return [first.reverse(), curItem];\n    };\n    /**\n     * Split the collection at a specific index.\n     *\n     *     LinkedList.of(1,2,3,4,5).splitAt(3)\n     *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]\n     */\n    ConsLinkedList.prototype.splitAt = function (index) {\n        var first = emptyLinkedList;\n        var curItem = this;\n        var i = 0;\n        while (i++ < index && (!curItem.isEmpty())) {\n            first = new ConsLinkedList(curItem.value, first);\n            curItem = curItem._tail;\n        }\n        return [first.reverse(), curItem];\n    };\n    ConsLinkedList.prototype.partition = function (predicate) {\n        var fst = exports.LinkedList.empty();\n        var snd = exports.LinkedList.empty();\n        var curItem = this;\n        while (!curItem.isEmpty()) {\n            if (predicate(curItem.value)) {\n                fst = new ConsLinkedList(curItem.value, fst);\n            }\n            else {\n                snd = new ConsLinkedList(curItem.value, snd);\n            }\n            curItem = curItem._tail;\n        }\n        return [fst.reverse(), snd.reverse()];\n    };\n    /**\n     * Group elements in the collection using a classifier function.\n     * Elements are then organized in a map. The key is the value of\n     * the classifier, and in value we get the list of elements\n     * matching that value.\n     *\n     * also see [[ConsLinkedList.arrangeBy]]\n     */\n    ConsLinkedList.prototype.groupBy = function (classifier) {\n        return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, v) {\n            return acc.putWithMerge(classifier(v), exports.LinkedList.of(v), function (v1, v2) {\n                return v1.prepend(v2.single().getOrThrow());\n            });\n        })\n            .mapValues(function (l) { return l.reverse(); });\n    };\n    /**\n     * Matches each element with a unique key that you extract from it.\n     * If the same key is present twice, the function will return None.\n     *\n     * also see [[ConsLinkedList.groupBy]]\n     */\n    ConsLinkedList.prototype.arrangeBy = function (getKey) {\n        return SeqHelpers.arrangeBy(this, getKey);\n    };\n    /**\n     * Randomly reorder the elements of the collection.\n     */\n    ConsLinkedList.prototype.shuffle = function () {\n        return exports.LinkedList.ofIterable(SeqHelpers.shuffle(this.toArray()));\n    };\n    /**\n     * Append an element at the end of this LinkedList.\n     * Warning: appending in a loop on a linked list is going\n     * to be very slow!\n     */\n    ConsLinkedList.prototype.append = function (v) {\n        return new ConsLinkedList(this.value, this._tail.append(v));\n    };\n    /*\n     * Append multiple elements at the end of this LinkedList.\n     */\n    ConsLinkedList.prototype.appendAll = function (elts) {\n        return exports.LinkedList.ofIterable(elts).prependAll(this);\n    };\n    /**\n     * Remove multiple elements from a LinkedList\n     *\n     *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])\n     *     => LinkedList.of(1,3,3,1)\n     */\n    ConsLinkedList.prototype.removeAll = function (elts) {\n        return SeqHelpers.removeAll(this, elts);\n    };\n    /**\n     * Removes the first element matching the predicate\n     * (use [[Seq.filter]] to remove all elements matching a predicate)\n     */\n    ConsLinkedList.prototype.removeFirst = function (predicate) {\n        var curItem = this;\n        var result = emptyLinkedList;\n        var removed = false;\n        while (!curItem.isEmpty()) {\n            if (predicate(curItem.value) && !removed) {\n                removed = true;\n            }\n            else {\n                result = new ConsLinkedList(curItem.value, result);\n            }\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    };\n    /**\n     * Prepend an element at the beginning of the collection.\n     */\n    ConsLinkedList.prototype.prepend = function (elt) {\n        return new ConsLinkedList(elt, this);\n    };\n    /**\n     * Prepend multiple elements at the beginning of the collection.\n     */\n    ConsLinkedList.prototype.prependAll = function (elts) {\n        var leftToAdd = exports.LinkedList.ofIterable(elts).reverse();\n        var result = this;\n        while (!leftToAdd.isEmpty()) {\n            result = new ConsLinkedList(leftToAdd.value, result);\n            leftToAdd = leftToAdd._tail;\n        }\n        return result;\n    };\n    /**\n     * Return a new collection where each element was transformed\n     * by the mapper function you give.\n     */\n    ConsLinkedList.prototype.map = function (mapper) {\n        var curItem = this;\n        var result = emptyLinkedList;\n        while (!curItem.isEmpty()) {\n            result = new ConsLinkedList(mapper(curItem.value), result);\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    };\n    /**\n     * Apply the mapper function on every element of this collection.\n     * The mapper function returns an Option; if the Option is a Some,\n     * the value it contains is added to the result Collection, if it's\n     * a None, the value is discarded.\n     *\n     *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?\n     *         Option.of(x+1) : Option.none<number>())\n     *     => LinkedList.of(3, 7)\n     */\n    ConsLinkedList.prototype.mapOption = function (mapper) {\n        var curItem = this;\n        var result = emptyLinkedList;\n        while (!curItem.isEmpty()) {\n            var mapped = mapper(curItem.value);\n            if (mapped.isSome()) {\n                result = new ConsLinkedList(mapped.get(), result);\n            }\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    };\n    /**\n     * Calls the function you give for each item in the collection,\n     * your function returns a collection, all the collections are\n     * concatenated.\n     * This is the monadic bind.\n     */\n    ConsLinkedList.prototype.flatMap = function (mapper) {\n        var curItem = this;\n        var result = emptyLinkedList;\n        while (!curItem.isEmpty()) {\n            result = result.prependAll(mapper(curItem.value).reverse());\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    };\n    ConsLinkedList.prototype.allMatch = function (predicate) {\n        return this.find(function (x) { return !predicate(x); }).isNone();\n    };\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    ConsLinkedList.prototype.anyMatch = function (predicate) {\n        return this.find(predicate).isSome();\n    };\n    ConsLinkedList.prototype.filter = function (predicate) {\n        var curItem = this;\n        var result = emptyLinkedList;\n        while (!curItem.isEmpty()) {\n            if (predicate(curItem.value)) {\n                result = new ConsLinkedList(curItem.value, result);\n            }\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    };\n    /**\n     * Returns a new collection with elements\n     * sorted according to the comparator you give.\n     *\n     *     const activityOrder = [\"Writer\", \"Actor\", \"Director\"];\n     *     LinkedList.of({name:\"George\", activity: \"Director\"}, {name:\"Robert\", activity: \"Actor\"})\n     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));\n     *     => LinkedList.of({\"name\":\"Robert\",\"activity\":\"Actor\"}, {\"name\":\"George\",\"activity\":\"Director\"})\n     *\n     * also see [[ConsLinkedList.sortOn]]\n     */\n    ConsLinkedList.prototype.sortBy = function (compare) {\n        return exports.LinkedList.ofIterable(this.toArray().sort(compare));\n    };\n    /**\n     * Give a function associating a number or a string with\n     * elements from the collection, and the elements\n     * are sorted according to that value.\n     *\n     *     LinkedList.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n     *     => LinkedList.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n     *\n     * You can also sort by multiple criteria, and request 'descending'\n     * sorting:\n     *\n     *     LinkedList.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n     *     => LinkedList.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n     *\n     * also see [[ConsLinkedList.sortBy]]\n     */\n    ConsLinkedList.prototype.sortOn = function () {\n        var getKeys = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            getKeys[_i] = arguments[_i];\n        }\n        return SeqHelpers.sortOn(this, getKeys);\n    };\n    /**\n     * Remove duplicate items; elements are mapped to keys, those\n     * get compared.\n     *\n     *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)\n     *     => LinkedList.of(1,2,3)\n     */\n    ConsLinkedList.prototype.distinctBy = function (keyExtractor) {\n        return SeqHelpers.distinctBy(this, keyExtractor);\n    };\n    /**\n     * Call a function for element in the collection.\n     */\n    ConsLinkedList.prototype.forEach = function (fn) {\n        var curItem = this;\n        while (!curItem.isEmpty()) {\n            fn(curItem.value);\n            curItem = curItem._tail;\n        }\n        return this;\n    };\n    /**\n     * Reduces the collection to a single value by repeatedly\n     * calling the combine function.\n     * No starting value. The order in which the elements are\n     * passed to the combining function is undetermined.\n     */\n    ConsLinkedList.prototype.reduce = function (combine) {\n        return SeqHelpers.reduce(this, combine);\n    };\n    /**\n     * Compare values in the collection and return the smallest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsLinkedList.minOn]]\n     */\n    ConsLinkedList.prototype.minBy = function (compare) {\n        return SeqHelpers.minBy(this, compare);\n    };\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the smallest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n     *     => Option.of({name:\"Paula\", age:6})\n     *\n     * also see [[ConsLinkedList.minBy]]\n     */\n    ConsLinkedList.prototype.minOn = function (getOrderable) {\n        return SeqHelpers.minOn(this, getOrderable);\n    };\n    /**\n     * Compare values in the collection and return the largest element.\n     * Returns Option.none if the collection is empty.\n     *\n     *     LinkedList.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n     *     => Option.of({name:\"Joe\", age:12})\n     *\n     * also see [[ConsLinkedList.maxOn]]\n     */\n    ConsLinkedList.prototype.maxBy = function (compare) {\n        return SeqHelpers.maxBy(this, compare);\n    };\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the largest.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[ConsLinkedList.maxBy]]\n     */\n    ConsLinkedList.prototype.maxOn = function (getOrderable) {\n        return SeqHelpers.maxOn(this, getOrderable);\n    };\n    /**\n     * Call the function you give for each element in the collection\n     * and sum all the numbers, return that sum.\n     * Will return 0 if the collection is empty.\n     *\n     *     LinkedList.of(1,2,3).sumOn(x=>x)\n     *     => 6\n     */\n    ConsLinkedList.prototype.sumOn = function (getNumber) {\n        return SeqHelpers.sumOn(this, getNumber);\n    };\n    /**\n     * Slides a window of a specific size over the sequence.\n     * Returns a lazy stream so memory use is not prohibitive.\n     *\n     *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)\n     *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))\n     */\n    ConsLinkedList.prototype.sliding = function (count) {\n        return SeqHelpers.sliding(this, count);\n    };\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     *\n     *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n     *     => LinkedList.of(0,1,3,6)\n     */\n    ConsLinkedList.prototype.scanLeft = function (init, fn) {\n        var result = exports.LinkedList.of(init);\n        var curItem = this;\n        var soFar = init;\n        while (!curItem.isEmpty()) {\n            soFar = fn(soFar, curItem.value);\n            result = new ConsLinkedList(soFar, result);\n            curItem = curItem._tail;\n        }\n        return result.reverse();\n    };\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     * The first element of the result is the final cumulative result.\n     *\n     *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n     *     => LinkedList.of(6,5,3,0)\n     */\n    ConsLinkedList.prototype.scanRight = function (init, fn) {\n        var result = exports.LinkedList.of(init);\n        var curItem = this.reverse();\n        var soFar = init;\n        while (!curItem.isEmpty()) {\n            soFar = fn(curItem.value, soFar);\n            result = new ConsLinkedList(soFar, result);\n            curItem = curItem._tail;\n        }\n        return result;\n    };\n    /**\n     * Joins elements of the collection by a separator.\n     * Example:\n     *\n     *     LinkedList.of(1,2,3).mkString(\", \")\n     *     => \"1, 2, 3\"\n     */\n    ConsLinkedList.prototype.mkString = function (separator) {\n        var r = \"\";\n        var curItem = this;\n        var isNotFirst = false;\n        while (!curItem.isEmpty()) {\n            if (isNotFirst) {\n                r += separator;\n            }\n            r += SeqHelpers.toStringHelper(curItem.value, { quoteStrings: false });\n            curItem = curItem._tail;\n            isNotFirst = true;\n        }\n        return r;\n    };\n    /**\n     * Convert to array.\n     * Don't do it on an infinite stream!\n     */\n    ConsLinkedList.prototype.toArray = function () {\n        var r = [];\n        var curItem = this;\n        while (!curItem.isEmpty()) {\n            r.push(curItem.value);\n            curItem = curItem._tail;\n        }\n        return r;\n    };\n    /**\n     * Convert to vector.\n     * Don't do it on an infinite stream!\n     */\n    ConsLinkedList.prototype.toVector = function () {\n        return Vector_1.Vector.ofIterable(this.toArray());\n    };\n    /**\n     * Convert this collection to a map. You give a function which\n     * for each element in the collection returns a pair. The\n     * key of the pair will be used as a key in the map, the value,\n     * as a value in the map. If several values get the same key,\n     * entries will be lost.\n     *\n     *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])\n     *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n     */\n    ConsLinkedList.prototype.toMap = function (converter) {\n        return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, cur) {\n            var converted = converter(cur);\n            return acc.put(converted[0], converted[1]);\n        });\n    };\n    /**\n     * Convert this collection to a set. Since the elements of the\n     * Seq may not support equality, you must pass a function returning\n     * a value supporting equality.\n     *\n     *     LinkedList.of(1,2,3,3,4).toSet(x=>x)\n     *     => HashSet.of(1,2,3,4)\n     */\n    ConsLinkedList.prototype.toSet = function (converter) {\n        return this.foldLeft(HashSet_1.HashSet.empty(), function (acc, cur) {\n            return acc.add(converter(cur));\n        });\n    };\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    ConsLinkedList.prototype.transform = function (converter) {\n        return converter(this);\n    };\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    ConsLinkedList.prototype.equals = function (other) {\n        if (other === this) {\n            return true;\n        }\n        if (!other || !other.tail) {\n            return false;\n        }\n        Contract_1.contractTrueEquality(\"LinkedList.equals\", this, other);\n        var myVal = this;\n        var hisVal = other;\n        while (true) {\n            if (myVal.isEmpty() !== hisVal.isEmpty()) {\n                return false;\n            }\n            if (myVal.isEmpty()) {\n                // they are both empty, end of the stream\n                return true;\n            }\n            var myHead = myVal.value;\n            var hisHead = hisVal.value;\n            if ((myHead === undefined) !== (hisHead === undefined)) {\n                return false;\n            }\n            if (myHead === undefined || hisHead === undefined) {\n                // they are both undefined, the || is for TS's flow analysis\n                // so he realizes none of them is undefined after this.\n                continue;\n            }\n            if (!Comparison_1.areEqual(myHead, hisHead)) {\n                return false;\n            }\n            myVal = myVal._tail;\n            hisVal = hisVal._tail;\n        }\n    };\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    ConsLinkedList.prototype.hashCode = function () {\n        var hash = 1;\n        var curItem = this;\n        while (!curItem.isEmpty()) {\n            hash = 31 * hash + Comparison_1.getHashCode(curItem.value);\n            curItem = curItem._tail;\n        }\n        return hash;\n    };\n    ConsLinkedList.prototype[Value_1.inspect] = function () {\n        return this.toString();\n    };\n    /**\n     * Get a human-friendly string representation of that value.\n     *\n     * Also see [[ConsLinkedList.mkString]]\n     */\n    ConsLinkedList.prototype.toString = function () {\n        var curItem = this;\n        var result = \"LinkedList(\";\n        while (!curItem.isEmpty()) {\n            result += SeqHelpers.toStringHelper(curItem.value);\n            var tail = curItem._tail;\n            curItem = tail;\n            if (!curItem.isEmpty()) {\n                result += \", \";\n            }\n        }\n        return result + \")\";\n    };\n    return ConsLinkedList;\n}());\nexports.ConsLinkedList = ConsLinkedList;\nvar emptyLinkedList = new EmptyLinkedList();\n//# sourceMappingURL=LinkedList.js.map"],"mappings":"AAAA,YAAY;;AACZA,OAAO,CAACC,UAAU,GAAG,IAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,UAAU,CAAC;AAClC,IAAIC,QAAQ,GAAGD,OAAO,CAAC,UAAU,CAAC;AAClC,IAAIE,YAAY,GAAGF,OAAO,CAAC,cAAc,CAAC;AAC1C,IAAIG,UAAU,GAAGH,OAAO,CAAC,YAAY,CAAC;AACtC,IAAII,OAAO,GAAGJ,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIK,SAAS,GAAGL,OAAO,CAAC,WAAW,CAAC;AACpC,IAAIM,SAAS,GAAGN,OAAO,CAAC,WAAW,CAAC;AACpC,IAAIO,UAAU,GAAGP,OAAO,CAAC,cAAc,CAAC;AACxC;AACA;AACA;AACA,IAAIQ,gBAAgB,GAAG,aAAe,YAAY;EAC9C,SAASA,gBAAgBA,CAAA,EAAG,CAC5B;EACA;AACJ;AACA;EACIA,gBAAgB,CAACC,SAAS,CAACC,KAAK,GAAG,YAAY;IAC3C,OAAOC,eAAe;EAC1B,CAAC;EACDH,gBAAgB,CAACC,SAAS,CAACG,EAAE,GAAG,YAAY;IACxC,IAAIC,IAAI,GAAG,EAAE;IACb,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;MAC1CD,IAAI,CAACC,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IAC5B;IACA,OAAOjB,OAAO,CAACoB,UAAU,CAACC,UAAU,CAACL,IAAI,CAAC;EAC9C,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIL,gBAAgB,CAACC,SAAS,CAACS,UAAU,GAAG,UAAUL,IAAI,EAAE;IACpD,IAAIM,QAAQ,GAAGN,IAAI,CAACO,MAAM,CAACD,QAAQ,CAAC,CAAC,CAAC;IACtC,IAAIE,OAAO,GAAGF,QAAQ,CAACG,IAAI,CAAC,CAAC;IAC7B,IAAIC,MAAM,GAAGZ,eAAe;IAC5B,OAAO,CAACU,OAAO,CAACG,IAAI,EAAE;MAClBD,MAAM,GAAG,IAAIE,cAAc,CAACJ,OAAO,CAACK,KAAK,EAAEH,MAAM,CAAC;MAClDF,OAAO,GAAGF,QAAQ,CAACG,IAAI,CAAC,CAAC;IAC7B;IACA,OAAOC,MAAM,CAACI,OAAO,CAAC,CAAC;EAC3B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACInB,gBAAgB,CAACC,SAAS,CAACmB,OAAO,GAAG,UAAUC,CAAC,EAAE;IAC9C,OAAOA,CAAC,CAACD,OAAO,CAAC,CAAC;EACtB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIpB,gBAAgB,CAACC,SAAS,CAACqB,UAAU,GAAG,UAAUD,CAAC,EAAE;IACjD,OAAO,CAACA,CAAC,CAACD,OAAO,CAAC,CAAC;EACvB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIpB,gBAAgB,CAACC,SAAS,CAACsB,WAAW,GAAG,UAAUC,IAAI,EAAEC,EAAE,EAAE;IACzD,IAAIC,OAAO,GAAGD,EAAE,CAACD,IAAI,CAAC;IACtB,IAAIT,MAAM,GAAGZ,eAAe;IAC5B,OAAO,CAACuB,OAAO,CAACC,MAAM,CAAC,CAAC,EAAE;MACtBZ,MAAM,GAAG,IAAIE,cAAc,CAACS,OAAO,CAACE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEb,MAAM,CAAC;MACrDW,OAAO,GAAGD,EAAE,CAACC,OAAO,CAACE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAClC;IACA,OAAOb,MAAM,CAACI,OAAO,CAAC,CAAC;EAC3B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACInB,gBAAgB,CAACC,SAAS,CAAC4B,GAAG,GAAG,YAAY;IACzC,IAAIC,SAAS,GAAG,EAAE;IAClB,KAAK,IAAIxB,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;MAC1CwB,SAAS,CAACxB,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IACjC;IACA,IAAIyB,CAAC,GAAG1C,OAAO,CAACoB,UAAU,CAACP,KAAK,CAAC,CAAC;IAClC,IAAI8B,SAAS,GAAGF,SAAS,CAACG,GAAG,CAAC,UAAUC,CAAC,EAAE;MAAE,OAAOA,CAAC,CAACtB,MAAM,CAACD,QAAQ,CAAC,CAAC,CAAC;IAAE,CAAC,CAAC;IAC5E,IAAIwB,KAAK,GAAGH,SAAS,CAACC,GAAG,CAAC,UAAUC,CAAC,EAAE;MAAE,OAAOA,CAAC,CAACpB,IAAI,CAAC,CAAC;IAAE,CAAC,CAAC;IAC5D,OAAO,CAACqB,KAAK,CAACC,IAAI,CAAC,UAAUC,IAAI,EAAE;MAAE,OAAOA,IAAI,CAACrB,IAAI;IAAE,CAAC,CAAC,EAAE;MACvDe,CAAC,GAAGA,CAAC,CAACO,OAAO,CAACH,KAAK,CAACF,GAAG,CAAC,UAAUI,IAAI,EAAE;QAAE,OAAOA,IAAI,CAACnB,KAAK;MAAE,CAAC,CAAC,CAAC;MAChEiB,KAAK,GAAGH,SAAS,CAACC,GAAG,CAAC,UAAUC,CAAC,EAAE;QAAE,OAAOA,CAAC,CAACpB,IAAI,CAAC,CAAC;MAAE,CAAC,CAAC;IAC5D;IACA,OAAOiB,CAAC,CAACZ,OAAO,CAAC,CAAC;EACtB,CAAC;EACD,OAAOnB,gBAAgB;AAC3B,CAAC,CAAC,CAAE;AACJX,OAAO,CAACW,gBAAgB,GAAGA,gBAAgB;AAC3C;AACA;AACA;AACAX,OAAO,CAACoB,UAAU,GAAG,IAAIT,gBAAgB,CAAC,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIuC,eAAe,GAAG,aAAe,YAAY;EAC7C,SAASA,eAAeA,CAAA,EAAG;IACvB;AACR;AACA;IACQ,IAAI,CAACC,SAAS,GAAGC,SAAS,CAAC,CAAC;EAChC;EACA;AACJ;AACA;EACIF,eAAe,CAACtC,SAAS,CAACyC,eAAe,GAAG,YAAY;IACpD,OAAO3C,UAAU,CAAC4C,kBAAkB,CAAC,IAAI,CAAC;EAC9C,CAAC;EACD;AACJ;AACA;EACIJ,eAAe,CAACtC,SAAS,CAACW,MAAM,CAACD,QAAQ,CAAC,GAAG,YAAY;IACrD,OAAO;MACHG,IAAI,EAAE,SAAAA,CAAA,EAAY;QACd,OAAO;UACHE,IAAI,EAAE,IAAI;UACVE,KAAK,EAAEuB;QACX,CAAC;MACL;IACJ,CAAC;EACL,CAAC;EACD;AACJ;AACA;AACA;EACIF,eAAe,CAACtC,SAAS,CAAC2C,YAAY,GAAG,YAAY;IACjD,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;EACIL,eAAe,CAACtC,SAAS,CAACO,MAAM,GAAG,YAAY;IAC3C,OAAO,CAAC;EACZ,CAAC;EACD;AACJ;AACA;AACA;EACI+B,eAAe,CAACtC,SAAS,CAAC4C,MAAM,GAAG,YAAY;IAC3C,OAAOtD,QAAQ,CAACuD,MAAM,CAACC,IAAI,CAAC,CAAC;EACjC,CAAC;EACD;AACJ;AACA;EACIR,eAAe,CAACtC,SAAS,CAACmB,OAAO,GAAG,YAAY;IAC5C,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;EACImB,eAAe,CAACtC,SAAS,CAAC+C,IAAI,GAAG,YAAY;IACzC,OAAOzD,QAAQ,CAACuD,MAAM,CAACC,IAAI,CAAC,CAAC;EACjC,CAAC;EACD;AACJ;AACA;AACA;EACIR,eAAe,CAACtC,SAAS,CAACgD,IAAI,GAAG,YAAY;IACzC,OAAO1D,QAAQ,CAACuD,MAAM,CAACC,IAAI,CAAC,CAAC;EACjC,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIR,eAAe,CAACtC,SAAS,CAACiD,IAAI,GAAG,YAAY;IACzC,OAAO3D,QAAQ,CAACuD,MAAM,CAACC,IAAI,CAAC,CAAC;EACjC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIR,eAAe,CAACtC,SAAS,CAAC2B,GAAG,GAAG,UAAUuB,GAAG,EAAE;IAC3C,OAAO5D,QAAQ,CAACuD,MAAM,CAACC,IAAI,CAAC,CAAC;EACjC,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIR,eAAe,CAACtC,SAAS,CAACmD,IAAI,GAAG,UAAUC,SAAS,EAAE;IAClD,OAAO9D,QAAQ,CAACuD,MAAM,CAACC,IAAI,CAAC,CAAC;EACjC,CAAC;EACD;AACJ;AACA;AACA;EACIR,eAAe,CAACtC,SAAS,CAACqD,QAAQ,GAAG,UAAUC,CAAC,EAAE;IAC9C,OAAO,KAAK;EAChB,CAAC;EACD;AACJ;AACA;AACA;EACIhB,eAAe,CAACtC,SAAS,CAACuD,IAAI,GAAG,UAAUC,CAAC,EAAE;IAC1C,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;EACIlB,eAAe,CAACtC,SAAS,CAACyD,SAAS,GAAG,UAAUL,SAAS,EAAE;IACvD,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACId,eAAe,CAACtC,SAAS,CAAC0D,cAAc,GAAG,UAAUN,SAAS,EAAE;IAC5D,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACId,eAAe,CAACtC,SAAS,CAAC2D,IAAI,GAAG,UAAUH,CAAC,EAAE;IAC1C,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIlB,eAAe,CAACtC,SAAS,CAAC4D,SAAS,GAAG,UAAUR,SAAS,EAAE;IACvD,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACId,eAAe,CAACtC,SAAS,CAAC6D,SAAS,GAAG,UAAUL,CAAC,EAAE;IAC/C,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIlB,eAAe,CAACtC,SAAS,CAAC8D,cAAc,GAAG,UAAUV,SAAS,EAAE;IAC5D,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACId,eAAe,CAACtC,SAAS,CAAC+D,IAAI,GAAG,UAAUC,IAAI,EAAExC,EAAE,EAAE;IACjD,OAAOwC,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI1B,eAAe,CAACtC,SAAS,CAACiE,QAAQ,GAAG,UAAUD,IAAI,EAAExC,EAAE,EAAE;IACrD,OAAOwC,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI1B,eAAe,CAACtC,SAAS,CAACkE,SAAS,GAAG,UAAUF,IAAI,EAAExC,EAAE,EAAE;IACtD,OAAOwC,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI1B,eAAe,CAACtC,SAAS,CAAC4B,GAAG,GAAG,UAAUuC,KAAK,EAAE;IAC7C,OAAOjE,eAAe;EAC1B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIoC,eAAe,CAACtC,SAAS,CAACoE,YAAY,GAAG,YAAY;IACjD,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI9B,eAAe,CAACtC,SAAS,CAACkB,OAAO,GAAG,YAAY;IAC5C,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIoB,eAAe,CAACtC,SAAS,CAACqE,IAAI,GAAG,UAAUjB,SAAS,EAAE;IAClD,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC;EACvB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACId,eAAe,CAACtC,SAAS,CAACsE,OAAO,GAAG,UAAUC,KAAK,EAAE;IACjD,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC;EACvB,CAAC;EACDjC,eAAe,CAACtC,SAAS,CAACwE,SAAS,GAAG,UAAUpB,SAAS,EAAE;IACvD,OAAO,CAAChE,OAAO,CAACoB,UAAU,CAACP,KAAK,CAAC,CAAC,EAAEb,OAAO,CAACoB,UAAU,CAACP,KAAK,CAAC,CAAC,CAAC;EACnE,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIqC,eAAe,CAACtC,SAAS,CAACyE,OAAO,GAAG,UAAUC,UAAU,EAAE;IACtD,OAAO9E,SAAS,CAAC+E,OAAO,CAAC1E,KAAK,CAAC,CAAC;EACpC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIqC,eAAe,CAACtC,SAAS,CAAC4E,SAAS,GAAG,UAAUC,MAAM,EAAE;IACpD,OAAO/E,UAAU,CAAC8E,SAAS,CAAC,IAAI,EAAEC,MAAM,CAAC;EAC7C,CAAC;EACD;AACJ;AACA;EACIvC,eAAe,CAACtC,SAAS,CAAC8E,OAAO,GAAG,YAAY;IAC5C,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIxC,eAAe,CAACtC,SAAS,CAAC+E,MAAM,GAAG,UAAUzB,CAAC,EAAE;IAC5C,OAAOlE,OAAO,CAACoB,UAAU,CAACL,EAAE,CAACmD,CAAC,CAAC;EACnC,CAAC;EACD;AACJ;AACA;EACIhB,eAAe,CAACtC,SAAS,CAACgF,SAAS,GAAG,UAAU5E,IAAI,EAAE;IAClD,OAAOhB,OAAO,CAACoB,UAAU,CAACC,UAAU,CAACL,IAAI,CAAC;EAC9C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIkC,eAAe,CAACtC,SAAS,CAACiF,SAAS,GAAG,UAAU7E,IAAI,EAAE;IAClD,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;EACIkC,eAAe,CAACtC,SAAS,CAACkF,WAAW,GAAG,UAAU9B,SAAS,EAAE;IACzD,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;EACId,eAAe,CAACtC,SAAS,CAACqC,OAAO,GAAG,UAAU8C,GAAG,EAAE;IAC/C,OAAO,IAAInE,cAAc,CAACmE,GAAG,EAAE,IAAI,CAAC;EACxC,CAAC;EACD;AACJ;AACA;EACI7C,eAAe,CAACtC,SAAS,CAACoF,UAAU,GAAG,UAAUD,GAAG,EAAE;IAClD,OAAO/F,OAAO,CAACoB,UAAU,CAACC,UAAU,CAAC0E,GAAG,CAAC;EAC7C,CAAC;EACD;AACJ;AACA;AACA;EACI7C,eAAe,CAACtC,SAAS,CAACgC,GAAG,GAAG,UAAUqD,MAAM,EAAE;IAC9C,OAAOnF,eAAe;EAC1B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIoC,eAAe,CAACtC,SAAS,CAACsF,SAAS,GAAG,UAAUD,MAAM,EAAE;IACpD,OAAOnF,eAAe;EAC1B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIoC,eAAe,CAACtC,SAAS,CAACuF,OAAO,GAAG,UAAUF,MAAM,EAAE;IAClD,OAAOnF,eAAe;EAC1B,CAAC;EACDoC,eAAe,CAACtC,SAAS,CAACwF,QAAQ,GAAG,UAAUpC,SAAS,EAAE;IACtD,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;EACId,eAAe,CAACtC,SAAS,CAACyF,QAAQ,GAAG,UAAUrC,SAAS,EAAE;IACtD,OAAO,KAAK;EAChB,CAAC;EACDd,eAAe,CAACtC,SAAS,CAAC0F,MAAM,GAAG,UAAUtC,SAAS,EAAE;IACpD,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACId,eAAe,CAACtC,SAAS,CAAC2F,MAAM,GAAG,UAAUC,OAAO,EAAE;IAClD,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACItD,eAAe,CAACtC,SAAS,CAAC6F,MAAM,GAAG,YAAY;IAC3C,IAAIC,OAAO,GAAG,EAAE;IAChB,KAAK,IAAIzF,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;MAC1CyF,OAAO,CAACzF,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IAC/B;IACA,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIiC,eAAe,CAACtC,SAAS,CAAC+F,UAAU,GAAG,UAAUC,YAAY,EAAE;IAC3D,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;EACI1D,eAAe,CAACtC,SAAS,CAACiG,OAAO,GAAG,UAAUzE,EAAE,EAAE;IAC9C,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIc,eAAe,CAACtC,SAAS,CAACkG,MAAM,GAAG,UAAUC,OAAO,EAAE;IAClD,OAAOrG,UAAU,CAACoG,MAAM,CAAC,IAAI,EAAEC,OAAO,CAAC;EAC3C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI7D,eAAe,CAACtC,SAAS,CAACoG,KAAK,GAAG,UAAUR,OAAO,EAAE;IACjD,OAAO9F,UAAU,CAACsG,KAAK,CAAC,IAAI,EAAER,OAAO,CAAC;EAC1C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACItD,eAAe,CAACtC,SAAS,CAACqG,KAAK,GAAG,UAAUC,YAAY,EAAE;IACtD,OAAOxG,UAAU,CAACuG,KAAK,CAAC,IAAI,EAAEC,YAAY,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIhE,eAAe,CAACtC,SAAS,CAACuG,KAAK,GAAG,UAAUX,OAAO,EAAE;IACjD,OAAO9F,UAAU,CAACyG,KAAK,CAAC,IAAI,EAAEX,OAAO,CAAC;EAC1C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACItD,eAAe,CAACtC,SAAS,CAACwG,KAAK,GAAG,UAAUF,YAAY,EAAE;IACtD,OAAOxG,UAAU,CAAC0G,KAAK,CAAC,IAAI,EAAEF,YAAY,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIhE,eAAe,CAACtC,SAAS,CAACyG,KAAK,GAAG,UAAUC,SAAS,EAAE;IACnD,OAAO5G,UAAU,CAAC2G,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;EAC5C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIpE,eAAe,CAACtC,SAAS,CAAC2G,OAAO,GAAG,UAAUC,KAAK,EAAE;IACjD,OAAO9G,UAAU,CAAC6G,OAAO,CAAC,IAAI,EAAEC,KAAK,CAAC;EAC1C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACItE,eAAe,CAACtC,SAAS,CAAC6G,QAAQ,GAAG,UAAUC,IAAI,EAAEtF,EAAE,EAAE;IACrD,OAAOpC,OAAO,CAACoB,UAAU,CAACL,EAAE,CAAC2G,IAAI,CAAC;EACtC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIxE,eAAe,CAACtC,SAAS,CAAC+G,SAAS,GAAG,UAAUD,IAAI,EAAEtF,EAAE,EAAE;IACtD,OAAOpC,OAAO,CAACoB,UAAU,CAACL,EAAE,CAAC2G,IAAI,CAAC;EACtC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIxE,eAAe,CAACtC,SAAS,CAACgH,QAAQ,GAAG,UAAUC,SAAS,EAAE;IACtD,OAAO,EAAE;EACb,CAAC;EACD;AACJ;AACA;AACA;EACI3E,eAAe,CAACtC,SAAS,CAACkH,OAAO,GAAG,YAAY;IAC5C,OAAO,EAAE;EACb,CAAC;EACD;AACJ;AACA;AACA;EACI5E,eAAe,CAACtC,SAAS,CAACmH,QAAQ,GAAG,YAAY;IAC7C,OAAO3H,QAAQ,CAAC4H,MAAM,CAACnH,KAAK,CAAC,CAAC;EAClC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIqC,eAAe,CAACtC,SAAS,CAACqH,KAAK,GAAG,UAAUC,SAAS,EAAE;IACnD,OAAO1H,SAAS,CAAC+E,OAAO,CAAC1E,KAAK,CAAC,CAAC;EACpC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIqC,eAAe,CAACtC,SAAS,CAACuH,KAAK,GAAG,UAAUD,SAAS,EAAE;IACnD,OAAOzH,SAAS,CAAC2H,OAAO,CAACvH,KAAK,CAAC,CAAC;EACpC,CAAC;EACD;AACJ;AACA;AACA;EACIqC,eAAe,CAACtC,SAAS,CAACyH,SAAS,GAAG,UAAUH,SAAS,EAAE;IACvD,OAAOA,SAAS,CAAC,IAAI,CAAC;EAC1B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIhF,eAAe,CAACtC,SAAS,CAAC0H,MAAM,GAAG,UAAUvD,KAAK,EAAE;IAChD,IAAI,CAACA,KAAK,EAAE;MACR,OAAO,KAAK;IAChB;IACA,OAAOA,KAAK,CAAChD,OAAO,CAAC,CAAC;EAC1B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACImB,eAAe,CAACtC,SAAS,CAAC2H,QAAQ,GAAG,YAAY;IAC7C,OAAO,CAAC;EACZ,CAAC;EACDrF,eAAe,CAACtC,SAAS,CAACL,OAAO,CAACiI,OAAO,CAAC,GAAG,YAAY;IACrD,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC;EAC1B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIvF,eAAe,CAACtC,SAAS,CAAC6H,QAAQ,GAAG,YAAY;IAC7C,OAAO,cAAc;EACzB,CAAC;EACD,OAAOvF,eAAe;AAC1B,CAAC,CAAC,CAAE;AACJlD,OAAO,CAACkD,eAAe,GAAGA,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAItB,cAAc,GAAG,aAAe,YAAY;EAC5C;AACJ;AACA;EACI,SAASA,cAAcA,CAACC,KAAK,EAAE6G,KAAK,EAAE;IAClC,IAAI,CAAC7G,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC6G,KAAK,GAAGA,KAAK;IAClB;AACR;AACA;IACQ,IAAI,CAACvF,SAAS,GAAGC,SAAS,CAAC,CAAC;EAChC;EACA;AACJ;AACA;EACIxB,cAAc,CAAChB,SAAS,CAACyC,eAAe,GAAG,YAAY;IACnD,OAAO3C,UAAU,CAAC4C,kBAAkB,CAAC,IAAI,CAAC;EAC9C,CAAC;EACD;AACJ;AACA;AACA;EACI1B,cAAc,CAAChB,SAAS,CAAC2C,YAAY,GAAG,YAAY;IAChD,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;EACI3B,cAAc,CAAChB,SAAS,CAACW,MAAM,CAACD,QAAQ,CAAC,GAAG,YAAY;IACpD,IAAI0B,IAAI,GAAG,IAAI;IACf,OAAO;MACHvB,IAAI,EAAE,SAAAA,CAAA,EAAY;QACd,IAAIuB,IAAI,CAACjB,OAAO,CAAC,CAAC,EAAE;UAChB,OAAO;YAAEJ,IAAI,EAAE,IAAI;YAAEE,KAAK,EAAEuB;UAAU,CAAC;QAC3C;QACA,IAAIvB,KAAK,GAAGmB,IAAI,CAACW,IAAI,CAAC,CAAC,CAACpB,GAAG,CAAC,CAAC;QAC7BS,IAAI,GAAGA,IAAI,CAACY,IAAI,CAAC,CAAC,CAACrB,GAAG,CAAC,CAAC;QACxB,OAAO;UAAEZ,IAAI,EAAE,KAAK;UAAEE,KAAK,EAAEA;QAAM,CAAC;MACxC;IACJ,CAAC;EACL,CAAC;EACD;AACJ;AACA;EACID,cAAc,CAAChB,SAAS,CAACO,MAAM,GAAG,YAAY;IAC1C,OAAO,IAAI,CAAC0D,QAAQ,CAAC,CAAC,EAAE,UAAUT,CAAC,EAAEuE,OAAO,EAAE;MAAE,OAAOvE,CAAC,GAAG,CAAC;IAAE,CAAC,CAAC;EACpE,CAAC;EACD;AACJ;AACA;AACA;EACIxC,cAAc,CAAChB,SAAS,CAAC4C,MAAM,GAAG,YAAY;IAC1C,OAAO,IAAI,CAACkF,KAAK,CAAC3G,OAAO,CAAC,CAAC,GACvB7B,QAAQ,CAACuD,MAAM,CAAC1C,EAAE,CAAC,IAAI,CAACc,KAAK,CAAC,GAC9B3B,QAAQ,CAACuD,MAAM,CAACC,IAAI,CAAC,CAAC;EAC9B,CAAC;EACD;AACJ;AACA;EACI9B,cAAc,CAAChB,SAAS,CAACmB,OAAO,GAAG,YAAY;IAC3C,OAAO,KAAK;EAChB,CAAC;EACD;AACJ;AACA;AACA;EACIH,cAAc,CAAChB,SAAS,CAAC+C,IAAI,GAAG,YAAY;IACxC,OAAOzD,QAAQ,CAACuD,MAAM,CAACV,IAAI,CAAC,IAAI,CAAClB,KAAK,CAAC;EAC3C,CAAC;EACD;AACJ;AACA;AACA;EACID,cAAc,CAAChB,SAAS,CAACgD,IAAI,GAAG,YAAY;IACxC,OAAO1D,QAAQ,CAACuD,MAAM,CAACV,IAAI,CAAC,IAAI,CAAC2F,KAAK,CAAC;EAC3C,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI9G,cAAc,CAAChB,SAAS,CAACiD,IAAI,GAAG,YAAY;IACxC,IAAIrC,OAAO,GAAG,IAAI;IAClB,OAAO,IAAI,EAAE;MACT,IAAIwB,IAAI,GAAGxB,OAAO,CAACK,KAAK;MACxBL,OAAO,GAAGA,OAAO,CAACkH,KAAK;MACvB,IAAIlH,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;QACnB,OAAO7B,QAAQ,CAACuD,MAAM,CAACV,IAAI,CAACC,IAAI,CAAC;MACrC;IACJ;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIpB,cAAc,CAAChB,SAAS,CAAC2B,GAAG,GAAG,UAAUuB,GAAG,EAAE;IAC1C,IAAItC,OAAO,GAAG,IAAI;IAClB,IAAIqB,CAAC,GAAG,CAAC;IACT,OAAO,CAACrB,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvB,IAAIc,CAAC,KAAKiB,GAAG,EAAE;QACX,IAAId,IAAI,GAAGxB,OAAO,CAACK,KAAK;QACxB,OAAO3B,QAAQ,CAACuD,MAAM,CAAC1C,EAAE,CAACiC,IAAI,CAAC;MACnC;MACAxB,OAAO,GAAGA,OAAO,CAACkH,KAAK;MACvB,EAAE7F,CAAC;IACP;IACA,OAAO3C,QAAQ,CAACuD,MAAM,CAACC,IAAI,CAAC,CAAC;EACjC,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI9B,cAAc,CAAChB,SAAS,CAACmD,IAAI,GAAG,UAAUC,SAAS,EAAE;IACjD,IAAIxC,OAAO,GAAG,IAAI;IAClB,OAAO,CAACA,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvB,IAAIiB,IAAI,GAAGxB,OAAO,CAACK,KAAK;MACxB,IAAImC,SAAS,CAAChB,IAAI,CAAC,EAAE;QACjB,OAAO9C,QAAQ,CAACuD,MAAM,CAAC1C,EAAE,CAACiC,IAAI,CAAC;MACnC;MACAxB,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOxI,QAAQ,CAACuD,MAAM,CAACC,IAAI,CAAC,CAAC;EACjC,CAAC;EACD;AACJ;AACA;AACA;EACI9B,cAAc,CAAChB,SAAS,CAACqD,QAAQ,GAAG,UAAUC,CAAC,EAAE;IAC7C,OAAO,IAAI,CAACH,IAAI,CAAC,UAAU6E,CAAC,EAAE;MAAE,OAAOvI,YAAY,CAACwI,QAAQ,CAACD,CAAC,EAAE1E,CAAC,CAAC;IAAE,CAAC,CAAC,CAAC4E,MAAM,CAAC,CAAC;EACnF,CAAC;EACD;AACJ;AACA;AACA;EACIlH,cAAc,CAAChB,SAAS,CAACuD,IAAI,GAAG,UAAUC,CAAC,EAAE;IACzC,IAAI1C,MAAM,GAAGZ,eAAe;IAC5B,IAAIU,OAAO,GAAG,IAAI;IAClB,IAAIqB,CAAC,GAAG,CAAC;IACT,OAAOA,CAAC,EAAE,GAAGuB,CAAC,IAAK,CAAC5C,OAAO,CAACO,OAAO,CAAC,CAAE,EAAE;MACpCL,MAAM,GAAG,IAAIE,cAAc,CAACJ,OAAO,CAACK,KAAK,EAAEH,MAAM,CAAC;MAClDF,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOhH,MAAM,CAACI,OAAO,CAAC,CAAC;EAC3B,CAAC;EACD;AACJ;AACA;AACA;EACIF,cAAc,CAAChB,SAAS,CAACyD,SAAS,GAAG,UAAUL,SAAS,EAAE;IACtD,IAAItC,MAAM,GAAGZ,eAAe;IAC5B,IAAIU,OAAO,GAAG,IAAI;IAClB,OAAQ,CAACA,OAAO,CAACO,OAAO,CAAC,CAAC,IAAKiC,SAAS,CAACxC,OAAO,CAACK,KAAK,CAAC,EAAE;MACrDH,MAAM,GAAG,IAAIE,cAAc,CAACJ,OAAO,CAACK,KAAK,EAAEH,MAAM,CAAC;MAClDF,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOhH,MAAM,CAACI,OAAO,CAAC,CAAC;EAC3B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIF,cAAc,CAAChB,SAAS,CAAC0D,cAAc,GAAG,UAAUN,SAAS,EAAE;IAC3D,OAAO,IAAI,CAAClC,OAAO,CAAC,CAAC,CAACuC,SAAS,CAACL,SAAS,CAAC,CAAClC,OAAO,CAAC,CAAC;EACxD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIF,cAAc,CAAChB,SAAS,CAAC2D,IAAI,GAAG,UAAUH,CAAC,EAAE;IACzC,IAAIvB,CAAC,GAAGuB,CAAC;IACT,IAAI5C,OAAO,GAAG,IAAI;IAClB,OAAOqB,CAAC,EAAE,GAAG,CAAC,IAAI,CAACrB,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MAClCP,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOlH,OAAO;EAClB,CAAC;EACD;AACJ;AACA;AACA;AACA;EACII,cAAc,CAAChB,SAAS,CAAC4D,SAAS,GAAG,UAAUR,SAAS,EAAE;IACtD,IAAIxC,OAAO,GAAG,IAAI;IAClB,OAAO,CAACA,OAAO,CAACO,OAAO,CAAC,CAAC,IAAIiC,SAAS,CAACxC,OAAO,CAACK,KAAK,CAAC,EAAE;MACnDL,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOlH,OAAO;EAClB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACII,cAAc,CAAChB,SAAS,CAAC6D,SAAS,GAAG,UAAUL,CAAC,EAAE;IAC9C;IACA,IAAIjD,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC,CAAC;IAC1B,OAAO,IAAI,CAACgD,IAAI,CAAChD,MAAM,GAAGiD,CAAC,CAAC;EAChC,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIxC,cAAc,CAAChB,SAAS,CAAC8D,cAAc,GAAG,UAAUV,SAAS,EAAE;IAC3D,OAAO,IAAI,CAAClC,OAAO,CAAC,CAAC,CAAC0C,SAAS,CAACR,SAAS,CAAC,CAAClC,OAAO,CAAC,CAAC;EACxD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIF,cAAc,CAAChB,SAAS,CAAC+D,IAAI,GAAG,UAAUC,IAAI,EAAExC,EAAE,EAAE;IAChD,OAAO,IAAI,CAACyC,QAAQ,CAACD,IAAI,EAAExC,EAAE,CAAC;EAClC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIR,cAAc,CAAChB,SAAS,CAACiE,QAAQ,GAAG,UAAUD,IAAI,EAAExC,EAAE,EAAE;IACpD,IAAIM,CAAC,GAAGkC,IAAI;IACZ,IAAIpD,OAAO,GAAG,IAAI;IAClB,OAAO,CAACA,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvBW,CAAC,GAAGN,EAAE,CAACM,CAAC,EAAElB,OAAO,CAACK,KAAK,CAAC;MACxBL,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOhG,CAAC;EACZ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACId,cAAc,CAAChB,SAAS,CAACkE,SAAS,GAAG,UAAUF,IAAI,EAAExC,EAAE,EAAE;IACrD,OAAO,IAAI,CAACN,OAAO,CAAC,CAAC,CAAC+C,QAAQ,CAACD,IAAI,EAAE,UAAUmE,EAAE,EAAEH,CAAC,EAAE;MAAE,OAAOxG,EAAE,CAACwG,CAAC,EAAEG,EAAE,CAAC;IAAE,CAAC,CAAC;EAChF,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACInH,cAAc,CAAChB,SAAS,CAAC4B,GAAG,GAAG,UAAUuC,KAAK,EAAE;IAC5C,IAAIiE,aAAa,GAAGjE,KAAK,CAACxD,MAAM,CAACD,QAAQ,CAAC,CAAC,CAAC;IAC5C,IAAI2H,YAAY,GAAGD,aAAa,CAACvH,IAAI,CAAC,CAAC;IACvC,IAAID,OAAO,GAAG,IAAI;IAClB,IAAIE,MAAM,GAAGZ,eAAe;IAC5B,OAAQ,CAACU,OAAO,CAACO,OAAO,CAAC,CAAC,IAAM,CAACkH,YAAY,CAACtH,IAAK,EAAE;MACjDD,MAAM,GAAG,IAAIE,cAAc,CAAC,CAACJ,OAAO,CAACK,KAAK,EAAEoH,YAAY,CAACpH,KAAK,CAAC,EAAEH,MAAM,CAAC;MACxEF,OAAO,GAAGA,OAAO,CAACkH,KAAK;MACvBO,YAAY,GAAGD,aAAa,CAACvH,IAAI,CAAC,CAAC;IACvC;IACA,OAAOC,MAAM,CAACI,OAAO,CAAC,CAAC;EAC3B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIF,cAAc,CAAChB,SAAS,CAACoE,YAAY,GAAG,YAAY;IAChD,OAAOtE,UAAU,CAACsE,YAAY,CAAC,IAAI,CAAC;EACxC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIpD,cAAc,CAAChB,SAAS,CAACkB,OAAO,GAAG,YAAY;IAC3C,OAAO,IAAI,CAAC+C,QAAQ,CAAC/D,eAAe,EAAE,UAAUiI,EAAE,EAAEH,CAAC,EAAE;MAAE,OAAOG,EAAE,CAAC9F,OAAO,CAAC2F,CAAC,CAAC;IAAE,CAAC,CAAC;EACrF,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIhH,cAAc,CAAChB,SAAS,CAACqE,IAAI,GAAG,UAAUjB,SAAS,EAAE;IACjD,IAAIkF,KAAK,GAAGpI,eAAe;IAC3B,IAAIU,OAAO,GAAG,IAAI;IAClB,OAAQ,CAACA,OAAO,CAACO,OAAO,CAAC,CAAC,IAAKiC,SAAS,CAACxC,OAAO,CAACK,KAAK,CAAC,EAAE;MACrDqH,KAAK,GAAG,IAAItH,cAAc,CAACJ,OAAO,CAACK,KAAK,EAAEqH,KAAK,CAAC;MAChD1H,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAO,CAACQ,KAAK,CAACpH,OAAO,CAAC,CAAC,EAAEN,OAAO,CAAC;EACrC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACII,cAAc,CAAChB,SAAS,CAACsE,OAAO,GAAG,UAAUC,KAAK,EAAE;IAChD,IAAI+D,KAAK,GAAGpI,eAAe;IAC3B,IAAIU,OAAO,GAAG,IAAI;IAClB,IAAIqB,CAAC,GAAG,CAAC;IACT,OAAOA,CAAC,EAAE,GAAGsC,KAAK,IAAK,CAAC3D,OAAO,CAACO,OAAO,CAAC,CAAE,EAAE;MACxCmH,KAAK,GAAG,IAAItH,cAAc,CAACJ,OAAO,CAACK,KAAK,EAAEqH,KAAK,CAAC;MAChD1H,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAO,CAACQ,KAAK,CAACpH,OAAO,CAAC,CAAC,EAAEN,OAAO,CAAC;EACrC,CAAC;EACDI,cAAc,CAAChB,SAAS,CAACwE,SAAS,GAAG,UAAUpB,SAAS,EAAE;IACtD,IAAImF,GAAG,GAAGnJ,OAAO,CAACoB,UAAU,CAACP,KAAK,CAAC,CAAC;IACpC,IAAIuI,GAAG,GAAGpJ,OAAO,CAACoB,UAAU,CAACP,KAAK,CAAC,CAAC;IACpC,IAAIW,OAAO,GAAG,IAAI;IAClB,OAAO,CAACA,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvB,IAAIiC,SAAS,CAACxC,OAAO,CAACK,KAAK,CAAC,EAAE;QAC1BsH,GAAG,GAAG,IAAIvH,cAAc,CAACJ,OAAO,CAACK,KAAK,EAAEsH,GAAG,CAAC;MAChD,CAAC,MACI;QACDC,GAAG,GAAG,IAAIxH,cAAc,CAACJ,OAAO,CAACK,KAAK,EAAEuH,GAAG,CAAC;MAChD;MACA5H,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAO,CAACS,GAAG,CAACrH,OAAO,CAAC,CAAC,EAAEsH,GAAG,CAACtH,OAAO,CAAC,CAAC,CAAC;EACzC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIF,cAAc,CAAChB,SAAS,CAACyE,OAAO,GAAG,UAAUC,UAAU,EAAE;IACrD,OAAO,IAAI,CAACT,QAAQ,CAACrE,SAAS,CAAC+E,OAAO,CAAC1E,KAAK,CAAC,CAAC,EAAE,UAAUwI,GAAG,EAAEnF,CAAC,EAAE;MAC9D,OAAOmF,GAAG,CAACC,YAAY,CAAChE,UAAU,CAACpB,CAAC,CAAC,EAAElE,OAAO,CAACoB,UAAU,CAACL,EAAE,CAACmD,CAAC,CAAC,EAAE,UAAUqF,EAAE,EAAEC,EAAE,EAAE;QAC/E,OAAOD,EAAE,CAACtG,OAAO,CAACuG,EAAE,CAAChG,MAAM,CAAC,CAAC,CAACiG,UAAU,CAAC,CAAC,CAAC;MAC/C,CAAC,CAAC;IACN,CAAC,CAAC,CACGC,SAAS,CAAC,UAAU1H,CAAC,EAAE;MAAE,OAAOA,CAAC,CAACF,OAAO,CAAC,CAAC;IAAE,CAAC,CAAC;EACxD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIF,cAAc,CAAChB,SAAS,CAAC4E,SAAS,GAAG,UAAUC,MAAM,EAAE;IACnD,OAAO/E,UAAU,CAAC8E,SAAS,CAAC,IAAI,EAAEC,MAAM,CAAC;EAC7C,CAAC;EACD;AACJ;AACA;EACI7D,cAAc,CAAChB,SAAS,CAAC8E,OAAO,GAAG,YAAY;IAC3C,OAAO1F,OAAO,CAACoB,UAAU,CAACC,UAAU,CAACX,UAAU,CAACgF,OAAO,CAAC,IAAI,CAACoC,OAAO,CAAC,CAAC,CAAC,CAAC;EAC5E,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIlG,cAAc,CAAChB,SAAS,CAAC+E,MAAM,GAAG,UAAUzB,CAAC,EAAE;IAC3C,OAAO,IAAItC,cAAc,CAAC,IAAI,CAACC,KAAK,EAAE,IAAI,CAAC6G,KAAK,CAAC/C,MAAM,CAACzB,CAAC,CAAC,CAAC;EAC/D,CAAC;EACD;AACJ;AACA;EACItC,cAAc,CAAChB,SAAS,CAACgF,SAAS,GAAG,UAAU5E,IAAI,EAAE;IACjD,OAAOhB,OAAO,CAACoB,UAAU,CAACC,UAAU,CAACL,IAAI,CAAC,CAACgF,UAAU,CAAC,IAAI,CAAC;EAC/D,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIpE,cAAc,CAAChB,SAAS,CAACiF,SAAS,GAAG,UAAU7E,IAAI,EAAE;IACjD,OAAON,UAAU,CAACmF,SAAS,CAAC,IAAI,EAAE7E,IAAI,CAAC;EAC3C,CAAC;EACD;AACJ;AACA;AACA;EACIY,cAAc,CAAChB,SAAS,CAACkF,WAAW,GAAG,UAAU9B,SAAS,EAAE;IACxD,IAAIxC,OAAO,GAAG,IAAI;IAClB,IAAIE,MAAM,GAAGZ,eAAe;IAC5B,IAAI6I,OAAO,GAAG,KAAK;IACnB,OAAO,CAACnI,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvB,IAAIiC,SAAS,CAACxC,OAAO,CAACK,KAAK,CAAC,IAAI,CAAC8H,OAAO,EAAE;QACtCA,OAAO,GAAG,IAAI;MAClB,CAAC,MACI;QACDjI,MAAM,GAAG,IAAIE,cAAc,CAACJ,OAAO,CAACK,KAAK,EAAEH,MAAM,CAAC;MACtD;MACAF,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOhH,MAAM,CAACI,OAAO,CAAC,CAAC;EAC3B,CAAC;EACD;AACJ;AACA;EACIF,cAAc,CAAChB,SAAS,CAACqC,OAAO,GAAG,UAAU8C,GAAG,EAAE;IAC9C,OAAO,IAAInE,cAAc,CAACmE,GAAG,EAAE,IAAI,CAAC;EACxC,CAAC;EACD;AACJ;AACA;EACInE,cAAc,CAAChB,SAAS,CAACoF,UAAU,GAAG,UAAUhF,IAAI,EAAE;IAClD,IAAI4I,SAAS,GAAG5J,OAAO,CAACoB,UAAU,CAACC,UAAU,CAACL,IAAI,CAAC,CAACc,OAAO,CAAC,CAAC;IAC7D,IAAIJ,MAAM,GAAG,IAAI;IACjB,OAAO,CAACkI,SAAS,CAAC7H,OAAO,CAAC,CAAC,EAAE;MACzBL,MAAM,GAAG,IAAIE,cAAc,CAACgI,SAAS,CAAC/H,KAAK,EAAEH,MAAM,CAAC;MACpDkI,SAAS,GAAGA,SAAS,CAAClB,KAAK;IAC/B;IACA,OAAOhH,MAAM;EACjB,CAAC;EACD;AACJ;AACA;AACA;EACIE,cAAc,CAAChB,SAAS,CAACgC,GAAG,GAAG,UAAUqD,MAAM,EAAE;IAC7C,IAAIzE,OAAO,GAAG,IAAI;IAClB,IAAIE,MAAM,GAAGZ,eAAe;IAC5B,OAAO,CAACU,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvBL,MAAM,GAAG,IAAIE,cAAc,CAACqE,MAAM,CAACzE,OAAO,CAACK,KAAK,CAAC,EAAEH,MAAM,CAAC;MAC1DF,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOhH,MAAM,CAACI,OAAO,CAAC,CAAC;EAC3B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIF,cAAc,CAAChB,SAAS,CAACsF,SAAS,GAAG,UAAUD,MAAM,EAAE;IACnD,IAAIzE,OAAO,GAAG,IAAI;IAClB,IAAIE,MAAM,GAAGZ,eAAe;IAC5B,OAAO,CAACU,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvB,IAAI8H,MAAM,GAAG5D,MAAM,CAACzE,OAAO,CAACK,KAAK,CAAC;MAClC,IAAIgI,MAAM,CAACf,MAAM,CAAC,CAAC,EAAE;QACjBpH,MAAM,GAAG,IAAIE,cAAc,CAACiI,MAAM,CAACtH,GAAG,CAAC,CAAC,EAAEb,MAAM,CAAC;MACrD;MACAF,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOhH,MAAM,CAACI,OAAO,CAAC,CAAC;EAC3B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIF,cAAc,CAAChB,SAAS,CAACuF,OAAO,GAAG,UAAUF,MAAM,EAAE;IACjD,IAAIzE,OAAO,GAAG,IAAI;IAClB,IAAIE,MAAM,GAAGZ,eAAe;IAC5B,OAAO,CAACU,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvBL,MAAM,GAAGA,MAAM,CAACsE,UAAU,CAACC,MAAM,CAACzE,OAAO,CAACK,KAAK,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC;MAC3DN,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOhH,MAAM,CAACI,OAAO,CAAC,CAAC;EAC3B,CAAC;EACDF,cAAc,CAAChB,SAAS,CAACwF,QAAQ,GAAG,UAAUpC,SAAS,EAAE;IACrD,OAAO,IAAI,CAACD,IAAI,CAAC,UAAU6E,CAAC,EAAE;MAAE,OAAO,CAAC5E,SAAS,CAAC4E,CAAC,CAAC;IAAE,CAAC,CAAC,CAACtG,MAAM,CAAC,CAAC;EACrE,CAAC;EACD;AACJ;AACA;AACA;EACIV,cAAc,CAAChB,SAAS,CAACyF,QAAQ,GAAG,UAAUrC,SAAS,EAAE;IACrD,OAAO,IAAI,CAACD,IAAI,CAACC,SAAS,CAAC,CAAC8E,MAAM,CAAC,CAAC;EACxC,CAAC;EACDlH,cAAc,CAAChB,SAAS,CAAC0F,MAAM,GAAG,UAAUtC,SAAS,EAAE;IACnD,IAAIxC,OAAO,GAAG,IAAI;IAClB,IAAIE,MAAM,GAAGZ,eAAe;IAC5B,OAAO,CAACU,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvB,IAAIiC,SAAS,CAACxC,OAAO,CAACK,KAAK,CAAC,EAAE;QAC1BH,MAAM,GAAG,IAAIE,cAAc,CAACJ,OAAO,CAACK,KAAK,EAAEH,MAAM,CAAC;MACtD;MACAF,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOhH,MAAM,CAACI,OAAO,CAAC,CAAC;EAC3B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIF,cAAc,CAAChB,SAAS,CAAC2F,MAAM,GAAG,UAAUC,OAAO,EAAE;IACjD,OAAOxG,OAAO,CAACoB,UAAU,CAACC,UAAU,CAAC,IAAI,CAACyG,OAAO,CAAC,CAAC,CAACgC,IAAI,CAACtD,OAAO,CAAC,CAAC;EACtE,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI5E,cAAc,CAAChB,SAAS,CAAC6F,MAAM,GAAG,YAAY;IAC1C,IAAIC,OAAO,GAAG,EAAE;IAChB,KAAK,IAAIzF,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;MAC1CyF,OAAO,CAACzF,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IAC/B;IACA,OAAOP,UAAU,CAAC+F,MAAM,CAAC,IAAI,EAAEC,OAAO,CAAC;EAC3C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACI9E,cAAc,CAAChB,SAAS,CAAC+F,UAAU,GAAG,UAAUC,YAAY,EAAE;IAC1D,OAAOlG,UAAU,CAACiG,UAAU,CAAC,IAAI,EAAEC,YAAY,CAAC;EACpD,CAAC;EACD;AACJ;AACA;EACIhF,cAAc,CAAChB,SAAS,CAACiG,OAAO,GAAG,UAAUzE,EAAE,EAAE;IAC7C,IAAIZ,OAAO,GAAG,IAAI;IAClB,OAAO,CAACA,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvBK,EAAE,CAACZ,OAAO,CAACK,KAAK,CAAC;MACjBL,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI9G,cAAc,CAAChB,SAAS,CAACkG,MAAM,GAAG,UAAUC,OAAO,EAAE;IACjD,OAAOrG,UAAU,CAACoG,MAAM,CAAC,IAAI,EAAEC,OAAO,CAAC;EAC3C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACInF,cAAc,CAAChB,SAAS,CAACoG,KAAK,GAAG,UAAUR,OAAO,EAAE;IAChD,OAAO9F,UAAU,CAACsG,KAAK,CAAC,IAAI,EAAER,OAAO,CAAC;EAC1C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI5E,cAAc,CAAChB,SAAS,CAACqG,KAAK,GAAG,UAAUC,YAAY,EAAE;IACrD,OAAOxG,UAAU,CAACuG,KAAK,CAAC,IAAI,EAAEC,YAAY,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACItF,cAAc,CAAChB,SAAS,CAACuG,KAAK,GAAG,UAAUX,OAAO,EAAE;IAChD,OAAO9F,UAAU,CAACyG,KAAK,CAAC,IAAI,EAAEX,OAAO,CAAC;EAC1C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACI5E,cAAc,CAAChB,SAAS,CAACwG,KAAK,GAAG,UAAUF,YAAY,EAAE;IACrD,OAAOxG,UAAU,CAAC0G,KAAK,CAAC,IAAI,EAAEF,YAAY,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACItF,cAAc,CAAChB,SAAS,CAACyG,KAAK,GAAG,UAAUC,SAAS,EAAE;IAClD,OAAO5G,UAAU,CAAC2G,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;EAC5C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACI1F,cAAc,CAAChB,SAAS,CAAC2G,OAAO,GAAG,UAAUC,KAAK,EAAE;IAChD,OAAO9G,UAAU,CAAC6G,OAAO,CAAC,IAAI,EAAEC,KAAK,CAAC;EAC1C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI5F,cAAc,CAAChB,SAAS,CAAC6G,QAAQ,GAAG,UAAUC,IAAI,EAAEtF,EAAE,EAAE;IACpD,IAAIV,MAAM,GAAG1B,OAAO,CAACoB,UAAU,CAACL,EAAE,CAAC2G,IAAI,CAAC;IACxC,IAAIlG,OAAO,GAAG,IAAI;IAClB,IAAIuI,KAAK,GAAGrC,IAAI;IAChB,OAAO,CAAClG,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvBgI,KAAK,GAAG3H,EAAE,CAAC2H,KAAK,EAAEvI,OAAO,CAACK,KAAK,CAAC;MAChCH,MAAM,GAAG,IAAIE,cAAc,CAACmI,KAAK,EAAErI,MAAM,CAAC;MAC1CF,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOhH,MAAM,CAACI,OAAO,CAAC,CAAC;EAC3B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIF,cAAc,CAAChB,SAAS,CAAC+G,SAAS,GAAG,UAAUD,IAAI,EAAEtF,EAAE,EAAE;IACrD,IAAIV,MAAM,GAAG1B,OAAO,CAACoB,UAAU,CAACL,EAAE,CAAC2G,IAAI,CAAC;IACxC,IAAIlG,OAAO,GAAG,IAAI,CAACM,OAAO,CAAC,CAAC;IAC5B,IAAIiI,KAAK,GAAGrC,IAAI;IAChB,OAAO,CAAClG,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvBgI,KAAK,GAAG3H,EAAE,CAACZ,OAAO,CAACK,KAAK,EAAEkI,KAAK,CAAC;MAChCrI,MAAM,GAAG,IAAIE,cAAc,CAACmI,KAAK,EAAErI,MAAM,CAAC;MAC1CF,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOhH,MAAM;EACjB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,cAAc,CAAChB,SAAS,CAACgH,QAAQ,GAAG,UAAUC,SAAS,EAAE;IACrD,IAAInF,CAAC,GAAG,EAAE;IACV,IAAIlB,OAAO,GAAG,IAAI;IAClB,IAAIwI,UAAU,GAAG,KAAK;IACtB,OAAO,CAACxI,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvB,IAAIiI,UAAU,EAAE;QACZtH,CAAC,IAAImF,SAAS;MAClB;MACAnF,CAAC,IAAIhC,UAAU,CAACuJ,cAAc,CAACzI,OAAO,CAACK,KAAK,EAAE;QAAEqI,YAAY,EAAE;MAAM,CAAC,CAAC;MACtE1I,OAAO,GAAGA,OAAO,CAACkH,KAAK;MACvBsB,UAAU,GAAG,IAAI;IACrB;IACA,OAAOtH,CAAC;EACZ,CAAC;EACD;AACJ;AACA;AACA;EACId,cAAc,CAAChB,SAAS,CAACkH,OAAO,GAAG,YAAY;IAC3C,IAAIpF,CAAC,GAAG,EAAE;IACV,IAAIlB,OAAO,GAAG,IAAI;IAClB,OAAO,CAACA,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvBW,CAAC,CAACyH,IAAI,CAAC3I,OAAO,CAACK,KAAK,CAAC;MACrBL,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOhG,CAAC;EACZ,CAAC;EACD;AACJ;AACA;AACA;EACId,cAAc,CAAChB,SAAS,CAACmH,QAAQ,GAAG,YAAY;IAC5C,OAAO3H,QAAQ,CAAC4H,MAAM,CAAC3G,UAAU,CAAC,IAAI,CAACyG,OAAO,CAAC,CAAC,CAAC;EACrD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIlG,cAAc,CAAChB,SAAS,CAACqH,KAAK,GAAG,UAAUC,SAAS,EAAE;IAClD,OAAO,IAAI,CAACrD,QAAQ,CAACrE,SAAS,CAAC+E,OAAO,CAAC1E,KAAK,CAAC,CAAC,EAAE,UAAUwI,GAAG,EAAEe,GAAG,EAAE;MAChE,IAAIC,SAAS,GAAGnC,SAAS,CAACkC,GAAG,CAAC;MAC9B,OAAOf,GAAG,CAACiB,GAAG,CAACD,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC;IAC9C,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIzI,cAAc,CAAChB,SAAS,CAACuH,KAAK,GAAG,UAAUD,SAAS,EAAE;IAClD,OAAO,IAAI,CAACrD,QAAQ,CAACpE,SAAS,CAAC2H,OAAO,CAACvH,KAAK,CAAC,CAAC,EAAE,UAAUwI,GAAG,EAAEe,GAAG,EAAE;MAChE,OAAOf,GAAG,CAACkB,GAAG,CAACrC,SAAS,CAACkC,GAAG,CAAC,CAAC;IAClC,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;AACA;EACIxI,cAAc,CAAChB,SAAS,CAACyH,SAAS,GAAG,UAAUH,SAAS,EAAE;IACtD,OAAOA,SAAS,CAAC,IAAI,CAAC;EAC1B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACItG,cAAc,CAAChB,SAAS,CAAC0H,MAAM,GAAG,UAAUvD,KAAK,EAAE;IAC/C,IAAIA,KAAK,KAAK,IAAI,EAAE;MAChB,OAAO,IAAI;IACf;IACA,IAAI,CAACA,KAAK,IAAI,CAACA,KAAK,CAACnB,IAAI,EAAE;MACvB,OAAO,KAAK;IAChB;IACAtD,UAAU,CAACkK,oBAAoB,CAAC,mBAAmB,EAAE,IAAI,EAAEzF,KAAK,CAAC;IACjE,IAAI0F,KAAK,GAAG,IAAI;IAChB,IAAIC,MAAM,GAAG3F,KAAK;IAClB,OAAO,IAAI,EAAE;MACT,IAAI0F,KAAK,CAAC1I,OAAO,CAAC,CAAC,KAAK2I,MAAM,CAAC3I,OAAO,CAAC,CAAC,EAAE;QACtC,OAAO,KAAK;MAChB;MACA,IAAI0I,KAAK,CAAC1I,OAAO,CAAC,CAAC,EAAE;QACjB;QACA,OAAO,IAAI;MACf;MACA,IAAI4I,MAAM,GAAGF,KAAK,CAAC5I,KAAK;MACxB,IAAI+I,OAAO,GAAGF,MAAM,CAAC7I,KAAK;MAC1B,IAAK8I,MAAM,KAAKvH,SAAS,MAAOwH,OAAO,KAAKxH,SAAS,CAAC,EAAE;QACpD,OAAO,KAAK;MAChB;MACA,IAAIuH,MAAM,KAAKvH,SAAS,IAAIwH,OAAO,KAAKxH,SAAS,EAAE;QAC/C;QACA;QACA;MACJ;MACA,IAAI,CAAC/C,YAAY,CAACwI,QAAQ,CAAC8B,MAAM,EAAEC,OAAO,CAAC,EAAE;QACzC,OAAO,KAAK;MAChB;MACAH,KAAK,GAAGA,KAAK,CAAC/B,KAAK;MACnBgC,MAAM,GAAGA,MAAM,CAAChC,KAAK;IACzB;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI9G,cAAc,CAAChB,SAAS,CAAC2H,QAAQ,GAAG,YAAY;IAC5C,IAAIsC,IAAI,GAAG,CAAC;IACZ,IAAIrJ,OAAO,GAAG,IAAI;IAClB,OAAO,CAACA,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvB8I,IAAI,GAAG,EAAE,GAAGA,IAAI,GAAGxK,YAAY,CAACyK,WAAW,CAACtJ,OAAO,CAACK,KAAK,CAAC;MAC1DL,OAAO,GAAGA,OAAO,CAACkH,KAAK;IAC3B;IACA,OAAOmC,IAAI;EACf,CAAC;EACDjJ,cAAc,CAAChB,SAAS,CAACL,OAAO,CAACiI,OAAO,CAAC,GAAG,YAAY;IACpD,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC;EAC1B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI7G,cAAc,CAAChB,SAAS,CAAC6H,QAAQ,GAAG,YAAY;IAC5C,IAAIjH,OAAO,GAAG,IAAI;IAClB,IAAIE,MAAM,GAAG,aAAa;IAC1B,OAAO,CAACF,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;MACvBL,MAAM,IAAIhB,UAAU,CAACuJ,cAAc,CAACzI,OAAO,CAACK,KAAK,CAAC;MAClD,IAAI+B,IAAI,GAAGpC,OAAO,CAACkH,KAAK;MACxBlH,OAAO,GAAGoC,IAAI;MACd,IAAI,CAACpC,OAAO,CAACO,OAAO,CAAC,CAAC,EAAE;QACpBL,MAAM,IAAI,IAAI;MAClB;IACJ;IACA,OAAOA,MAAM,GAAG,GAAG;EACvB,CAAC;EACD,OAAOE,cAAc;AACzB,CAAC,CAAC,CAAE;AACJ5B,OAAO,CAAC4B,cAAc,GAAGA,cAAc;AACvC,IAAId,eAAe,GAAG,IAAIoC,eAAe,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}