{"ast":null,"code":"/**\n * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.\n *\n * See: RFC 1421.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\n *\n * A Forge PEM object has the following fields:\n *\n * type: identifies the type of message (eg: \"RSA PRIVATE KEY\").\n *\n * procType: identifies the type of processing performed on the message,\n *   it has two subfields: version and type, eg: 4,ENCRYPTED.\n *\n * contentDomain: identifies the type of content in the message, typically\n *   only uses the value: \"RFC822\".\n *\n * dekInfo: identifies the message encryption algorithm and mode and includes\n *   any parameters for the algorithm, it has two subfields: algorithm and\n *   parameters, eg: DES-CBC,F8143EDE5960C597.\n *\n * headers: contains all other PEM encapsulated headers -- where order is\n *   significant (for pairing data like recipient ID + key info).\n *\n * body: the binary-encoded body.\n */\nvar forge = require('./forge');\nrequire('./util');\n\n// shortcut for pem API\nvar pem = module.exports = forge.pem = forge.pem || {};\n\n/**\n * Encodes (serializes) the given PEM object.\n *\n * @param msg the PEM message object to encode.\n * @param options the options to use:\n *          maxline the maximum characters per line for the body, (default: 64).\n *\n * @return the PEM-formatted string.\n */\npem.encode = function (msg, options) {\n  options = options || {};\n  var rval = '-----BEGIN ' + msg.type + '-----\\r\\n';\n\n  // encode special headers\n  var header;\n  if (msg.procType) {\n    header = {\n      name: 'Proc-Type',\n      values: [String(msg.procType.version), msg.procType.type]\n    };\n    rval += foldHeader(header);\n  }\n  if (msg.contentDomain) {\n    header = {\n      name: 'Content-Domain',\n      values: [msg.contentDomain]\n    };\n    rval += foldHeader(header);\n  }\n  if (msg.dekInfo) {\n    header = {\n      name: 'DEK-Info',\n      values: [msg.dekInfo.algorithm]\n    };\n    if (msg.dekInfo.parameters) {\n      header.values.push(msg.dekInfo.parameters);\n    }\n    rval += foldHeader(header);\n  }\n  if (msg.headers) {\n    // encode all other headers\n    for (var i = 0; i < msg.headers.length; ++i) {\n      rval += foldHeader(msg.headers[i]);\n    }\n  }\n\n  // terminate header\n  if (msg.procType) {\n    rval += '\\r\\n';\n  }\n\n  // add body\n  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\\r\\n';\n  rval += '-----END ' + msg.type + '-----\\r\\n';\n  return rval;\n};\n\n/**\n * Decodes (deserializes) all PEM messages found in the given string.\n *\n * @param str the PEM-formatted string to decode.\n *\n * @return the PEM message objects in an array.\n */\npem.decode = function (str) {\n  var rval = [];\n\n  // split string into PEM messages (be lenient w/EOF on BEGIN line)\n  var rMessage = /\\s*-----BEGIN ([A-Z0-9- ]+)-----\\r?\\n?([\\x21-\\x7e\\s]+?(?:\\r?\\n\\r?\\n))?([:A-Za-z0-9+\\/=\\s]+?)-----END \\1-----/g;\n  var rHeader = /([\\x21-\\x7e]+):\\s*([\\x21-\\x7e\\s^:]+)/;\n  var rCRLF = /\\r?\\n/;\n  var match;\n  while (true) {\n    match = rMessage.exec(str);\n    if (!match) {\n      break;\n    }\n    var msg = {\n      type: match[1],\n      procType: null,\n      contentDomain: null,\n      dekInfo: null,\n      headers: [],\n      body: forge.util.decode64(match[3])\n    };\n    rval.push(msg);\n\n    // no headers\n    if (!match[2]) {\n      continue;\n    }\n\n    // parse headers\n    var lines = match[2].split(rCRLF);\n    var li = 0;\n    while (match && li < lines.length) {\n      // get line, trim any rhs whitespace\n      var line = lines[li].replace(/\\s+$/, '');\n\n      // RFC2822 unfold any following folded lines\n      for (var nl = li + 1; nl < lines.length; ++nl) {\n        var next = lines[nl];\n        if (!/\\s/.test(next[0])) {\n          break;\n        }\n        line += next;\n        li = nl;\n      }\n\n      // parse header\n      match = line.match(rHeader);\n      if (match) {\n        var header = {\n          name: match[1],\n          values: []\n        };\n        var values = match[2].split(',');\n        for (var vi = 0; vi < values.length; ++vi) {\n          header.values.push(ltrim(values[vi]));\n        }\n\n        // Proc-Type must be the first header\n        if (!msg.procType) {\n          if (header.name !== 'Proc-Type') {\n            throw new Error('Invalid PEM formatted message. The first ' + 'encapsulated header must be \"Proc-Type\".');\n          } else if (header.values.length !== 2) {\n            throw new Error('Invalid PEM formatted message. The \"Proc-Type\" ' + 'header must have two subfields.');\n          }\n          msg.procType = {\n            version: values[0],\n            type: values[1]\n          };\n        } else if (!msg.contentDomain && header.name === 'Content-Domain') {\n          // special-case Content-Domain\n          msg.contentDomain = values[0] || '';\n        } else if (!msg.dekInfo && header.name === 'DEK-Info') {\n          // special-case DEK-Info\n          if (header.values.length === 0) {\n            throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' + 'header must have at least one subfield.');\n          }\n          msg.dekInfo = {\n            algorithm: values[0],\n            parameters: values[1] || null\n          };\n        } else {\n          msg.headers.push(header);\n        }\n      }\n      ++li;\n    }\n    if (msg.procType === 'ENCRYPTED' && !msg.dekInfo) {\n      throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' + 'header must be present if \"Proc-Type\" is \"ENCRYPTED\".');\n    }\n  }\n  if (rval.length === 0) {\n    throw new Error('Invalid PEM formatted message.');\n  }\n  return rval;\n};\nfunction foldHeader(header) {\n  var rval = header.name + ': ';\n\n  // ensure values with CRLF are folded\n  var values = [];\n  var insertSpace = function (match, $1) {\n    return ' ' + $1;\n  };\n  for (var i = 0; i < header.values.length; ++i) {\n    values.push(header.values[i].replace(/^(\\S+\\r\\n)/, insertSpace));\n  }\n  rval += values.join(',') + '\\r\\n';\n\n  // do folding\n  var length = 0;\n  var candidate = -1;\n  for (var i = 0; i < rval.length; ++i, ++length) {\n    if (length > 65 && candidate !== -1) {\n      var insert = rval[candidate];\n      if (insert === ',') {\n        ++candidate;\n        rval = rval.substr(0, candidate) + '\\r\\n ' + rval.substr(candidate);\n      } else {\n        rval = rval.substr(0, candidate) + '\\r\\n' + insert + rval.substr(candidate + 1);\n      }\n      length = i - candidate - 1;\n      candidate = -1;\n      ++i;\n    } else if (rval[i] === ' ' || rval[i] === '\\t' || rval[i] === ',') {\n      candidate = i;\n    }\n  }\n  return rval;\n}\nfunction ltrim(str) {\n  return str.replace(/^\\s+/, '');\n}","map":{"version":3,"names":["forge","require","pem","module","exports","encode","msg","options","rval","type","header","procType","name","values","String","version","foldHeader","contentDomain","dekInfo","algorithm","parameters","push","headers","i","length","util","encode64","body","maxline","decode","str","rMessage","rHeader","rCRLF","match","exec","decode64","lines","split","li","line","replace","nl","next","test","vi","ltrim","Error","insertSpace","$1","join","candidate","insert","substr"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/node-forge/lib/pem.js"],"sourcesContent":["/**\n * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.\n *\n * See: RFC 1421.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\n *\n * A Forge PEM object has the following fields:\n *\n * type: identifies the type of message (eg: \"RSA PRIVATE KEY\").\n *\n * procType: identifies the type of processing performed on the message,\n *   it has two subfields: version and type, eg: 4,ENCRYPTED.\n *\n * contentDomain: identifies the type of content in the message, typically\n *   only uses the value: \"RFC822\".\n *\n * dekInfo: identifies the message encryption algorithm and mode and includes\n *   any parameters for the algorithm, it has two subfields: algorithm and\n *   parameters, eg: DES-CBC,F8143EDE5960C597.\n *\n * headers: contains all other PEM encapsulated headers -- where order is\n *   significant (for pairing data like recipient ID + key info).\n *\n * body: the binary-encoded body.\n */\nvar forge = require('./forge');\nrequire('./util');\n\n// shortcut for pem API\nvar pem = module.exports = forge.pem = forge.pem || {};\n\n/**\n * Encodes (serializes) the given PEM object.\n *\n * @param msg the PEM message object to encode.\n * @param options the options to use:\n *          maxline the maximum characters per line for the body, (default: 64).\n *\n * @return the PEM-formatted string.\n */\npem.encode = function(msg, options) {\n  options = options || {};\n  var rval = '-----BEGIN ' + msg.type + '-----\\r\\n';\n\n  // encode special headers\n  var header;\n  if(msg.procType) {\n    header = {\n      name: 'Proc-Type',\n      values: [String(msg.procType.version), msg.procType.type]\n    };\n    rval += foldHeader(header);\n  }\n  if(msg.contentDomain) {\n    header = {name: 'Content-Domain', values: [msg.contentDomain]};\n    rval += foldHeader(header);\n  }\n  if(msg.dekInfo) {\n    header = {name: 'DEK-Info', values: [msg.dekInfo.algorithm]};\n    if(msg.dekInfo.parameters) {\n      header.values.push(msg.dekInfo.parameters);\n    }\n    rval += foldHeader(header);\n  }\n\n  if(msg.headers) {\n    // encode all other headers\n    for(var i = 0; i < msg.headers.length; ++i) {\n      rval += foldHeader(msg.headers[i]);\n    }\n  }\n\n  // terminate header\n  if(msg.procType) {\n    rval += '\\r\\n';\n  }\n\n  // add body\n  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\\r\\n';\n\n  rval += '-----END ' + msg.type + '-----\\r\\n';\n  return rval;\n};\n\n/**\n * Decodes (deserializes) all PEM messages found in the given string.\n *\n * @param str the PEM-formatted string to decode.\n *\n * @return the PEM message objects in an array.\n */\npem.decode = function(str) {\n  var rval = [];\n\n  // split string into PEM messages (be lenient w/EOF on BEGIN line)\n  var rMessage = /\\s*-----BEGIN ([A-Z0-9- ]+)-----\\r?\\n?([\\x21-\\x7e\\s]+?(?:\\r?\\n\\r?\\n))?([:A-Za-z0-9+\\/=\\s]+?)-----END \\1-----/g;\n  var rHeader = /([\\x21-\\x7e]+):\\s*([\\x21-\\x7e\\s^:]+)/;\n  var rCRLF = /\\r?\\n/;\n  var match;\n  while(true) {\n    match = rMessage.exec(str);\n    if(!match) {\n      break;\n    }\n\n    var msg = {\n      type: match[1],\n      procType: null,\n      contentDomain: null,\n      dekInfo: null,\n      headers: [],\n      body: forge.util.decode64(match[3])\n    };\n    rval.push(msg);\n\n    // no headers\n    if(!match[2]) {\n      continue;\n    }\n\n    // parse headers\n    var lines = match[2].split(rCRLF);\n    var li = 0;\n    while(match && li < lines.length) {\n      // get line, trim any rhs whitespace\n      var line = lines[li].replace(/\\s+$/, '');\n\n      // RFC2822 unfold any following folded lines\n      for(var nl = li + 1; nl < lines.length; ++nl) {\n        var next = lines[nl];\n        if(!/\\s/.test(next[0])) {\n          break;\n        }\n        line += next;\n        li = nl;\n      }\n\n      // parse header\n      match = line.match(rHeader);\n      if(match) {\n        var header = {name: match[1], values: []};\n        var values = match[2].split(',');\n        for(var vi = 0; vi < values.length; ++vi) {\n          header.values.push(ltrim(values[vi]));\n        }\n\n        // Proc-Type must be the first header\n        if(!msg.procType) {\n          if(header.name !== 'Proc-Type') {\n            throw new Error('Invalid PEM formatted message. The first ' +\n              'encapsulated header must be \"Proc-Type\".');\n          } else if(header.values.length !== 2) {\n            throw new Error('Invalid PEM formatted message. The \"Proc-Type\" ' +\n              'header must have two subfields.');\n          }\n          msg.procType = {version: values[0], type: values[1]};\n        } else if(!msg.contentDomain && header.name === 'Content-Domain') {\n          // special-case Content-Domain\n          msg.contentDomain = values[0] || '';\n        } else if(!msg.dekInfo && header.name === 'DEK-Info') {\n          // special-case DEK-Info\n          if(header.values.length === 0) {\n            throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' +\n              'header must have at least one subfield.');\n          }\n          msg.dekInfo = {algorithm: values[0], parameters: values[1] || null};\n        } else {\n          msg.headers.push(header);\n        }\n      }\n\n      ++li;\n    }\n\n    if(msg.procType === 'ENCRYPTED' && !msg.dekInfo) {\n      throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' +\n        'header must be present if \"Proc-Type\" is \"ENCRYPTED\".');\n    }\n  }\n\n  if(rval.length === 0) {\n    throw new Error('Invalid PEM formatted message.');\n  }\n\n  return rval;\n};\n\nfunction foldHeader(header) {\n  var rval = header.name + ': ';\n\n  // ensure values with CRLF are folded\n  var values = [];\n  var insertSpace = function(match, $1) {\n    return ' ' + $1;\n  };\n  for(var i = 0; i < header.values.length; ++i) {\n    values.push(header.values[i].replace(/^(\\S+\\r\\n)/, insertSpace));\n  }\n  rval += values.join(',') + '\\r\\n';\n\n  // do folding\n  var length = 0;\n  var candidate = -1;\n  for(var i = 0; i < rval.length; ++i, ++length) {\n    if(length > 65 && candidate !== -1) {\n      var insert = rval[candidate];\n      if(insert === ',') {\n        ++candidate;\n        rval = rval.substr(0, candidate) + '\\r\\n ' + rval.substr(candidate);\n      } else {\n        rval = rval.substr(0, candidate) +\n          '\\r\\n' + insert + rval.substr(candidate + 1);\n      }\n      length = (i - candidate - 1);\n      candidate = -1;\n      ++i;\n    } else if(rval[i] === ' ' || rval[i] === '\\t' || rval[i] === ',') {\n      candidate = i;\n    }\n  }\n\n  return rval;\n}\n\nfunction ltrim(str) {\n  return str.replace(/^\\s+/, '');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}