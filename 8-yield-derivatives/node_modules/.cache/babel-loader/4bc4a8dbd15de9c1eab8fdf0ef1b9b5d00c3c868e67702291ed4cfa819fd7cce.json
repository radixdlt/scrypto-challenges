{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nvar VirtualTimeScheduler = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(VirtualTimeScheduler, _super);\n  function VirtualTimeScheduler(SchedulerAction, maxFrames) {\n    if (SchedulerAction === void 0) {\n      SchedulerAction = VirtualAction;\n    }\n    if (maxFrames === void 0) {\n      maxFrames = Number.POSITIVE_INFINITY;\n    }\n    var _this = _super.call(this, SchedulerAction, function () {\n      return _this.frame;\n    }) || this;\n    _this.maxFrames = maxFrames;\n    _this.frame = 0;\n    _this.index = -1;\n    return _this;\n  }\n  VirtualTimeScheduler.prototype.flush = function () {\n    var _a = this,\n      actions = _a.actions,\n      maxFrames = _a.maxFrames;\n    var error, action;\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    }\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  };\n  VirtualTimeScheduler.frameTimeFactor = 10;\n  return VirtualTimeScheduler;\n}(AsyncScheduler);\nexport { VirtualTimeScheduler };\nvar VirtualAction = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(VirtualAction, _super);\n  function VirtualAction(scheduler, work, index) {\n    if (index === void 0) {\n      index = scheduler.index += 1;\n    }\n    var _this = _super.call(this, scheduler, work) || this;\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.index = index;\n    _this.active = true;\n    _this.index = scheduler.index = index;\n    return _this;\n  }\n  VirtualAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    if (!this.id) {\n      return _super.prototype.schedule.call(this, state, delay);\n    }\n    this.active = false;\n    var action = new VirtualAction(this.scheduler, this.work);\n    this.add(action);\n    return action.schedule(state, delay);\n  };\n  VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    this.delay = scheduler.frame + delay;\n    var actions = scheduler.actions;\n    actions.push(this);\n    actions.sort(VirtualAction.sortActions);\n    return true;\n  };\n  VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    return undefined;\n  };\n  VirtualAction.prototype._execute = function (state, delay) {\n    if (this.active === true) {\n      return _super.prototype._execute.call(this, state, delay);\n    }\n  };\n  VirtualAction.sortActions = function (a, b) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  };\n  return VirtualAction;\n}(AsyncAction);\nexport { VirtualAction };","map":{"version":3,"names":["tslib_1","AsyncAction","AsyncScheduler","VirtualTimeScheduler","_super","__extends","SchedulerAction","maxFrames","VirtualAction","Number","POSITIVE_INFINITY","_this","call","frame","index","prototype","flush","_a","actions","action","delay","shift","error","execute","state","unsubscribe","frameTimeFactor","scheduler","work","active","schedule","id","add","requestAsyncId","push","sort","sortActions","recycleAsyncId","_execute","a","b"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/radixdlt/node_modules/rxjs/src/internal/scheduler/VirtualTimeScheduler.ts"],"sourcesContent":["import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n\n  protected static frameTimeFactor: number = 10;\n\n  public frame: number = 0;\n  public index: number = -1;\n\n  constructor(SchedulerAction: typeof AsyncAction = VirtualAction as any,\n              public maxFrames: number = Number.POSITIVE_INFINITY) {\n    super(SchedulerAction, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   * @return {void}\n   */\n  public flush(): void {\n\n    const {actions, maxFrames} = this;\n    let error: any, action: AsyncAction<any>;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    }\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @nodoc\n */\nexport class VirtualAction<T> extends AsyncAction<T> {\n\n  protected active: boolean = true;\n\n  constructor(protected scheduler: VirtualTimeScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void,\n              protected index: number = scheduler.index += 1) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (!this.id) {\n      return super.schedule(state, delay);\n    }\n    this.active = false;\n    // If an action is rescheduled, we save allocations by mutating its state,\n    // pushing it to the end of the scheduler queue, and recycling the action.\n    // But since the VirtualTimeScheduler is used for testing, VirtualActions\n    // must be immutable so they can be inspected later.\n    const action = new VirtualAction(this.scheduler, this.work);\n    this.add(action);\n    return action.schedule(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\n    this.delay = scheduler.frame + delay;\n    const {actions} = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return true;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  public static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}