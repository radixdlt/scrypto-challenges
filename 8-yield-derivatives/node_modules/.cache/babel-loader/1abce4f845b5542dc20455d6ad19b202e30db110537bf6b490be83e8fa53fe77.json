{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JSONDecoding = exports.decoder = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\nconst ramda_1 = require(\"ramda\");\nconst util_1 = require(\"@radixdlt/util\");\n/**\n * Creates a new decoder. A decoder defines a way to transform a key-value pair through a\n * supplied algorithm.\n */\nconst decoder = algorithm => (value, key) => algorithm(value, key);\nexports.decoder = decoder;\nconst applyDecoders = (decoders, value, key) => {\n  let unwrappedValue;\n  if (util_1.isResult(value)) {\n    if (value.isOk()) {\n      unwrappedValue = value.value;\n    } else {\n      return value;\n    }\n  } else {\n    unwrappedValue = value;\n  }\n  const results = decoders.map(decoder => decoder(unwrappedValue, key)).filter(result => result !== undefined);\n  return results.length > 1 ? neverthrow_1.err(Error(`JSON decoding failed. Several decoders were valid for key/value pair. \n                    This can lead to unexpected behavior.`)) : results[0] ? results[0] : neverthrow_1.ok(unwrappedValue);\n};\nconst JSONDecode = (...decoders) => json => {\n  const decode = JSONDecodeUnflattened(...decoders);\n  return ramda_1.pipe(\n  //applyDecoders.bind(null, decoders),\n  util_1.flattenResultsObject)(decode(json));\n};\n/**\n * Main decoding logic. Uses the registered decoders and applies matching decoders to\n * all key-value pairs in the supplied JSON.\n */\nconst JSONDecodeUnflattened = (...decoders) => json => util_1.isObject(json) ? util_1.flattenResultsObject(neverthrow_1.ok(ramda_1.mapObjIndexed((value, key) => applyDecoders(decoders, JSONDecodeUnflattened(...decoders)(value), key), json))) : util_1.isString(json) || util_1.isBoolean(json) || util_1.isNumber(json) ? applyDecoders(decoders, json).mapErr(err => [err]) : util_1.isArray(json) ? neverthrow_1.combine(json.map(item => JSONDecodeUnflattened(...decoders)(item))).mapErr(err => err) : neverthrow_1.err([Error('JSON decoding failed. Unknown data type.')]);\nconst withDecoders = (...decoders) => ({\n  create: () => JSONDecode(...decoders)\n});\nexports.JSONDecoding = {\n  withDecoders,\n  create: () => JSONDecode(...[])\n};","map":{"version":3,"names":["neverthrow_1","require","ramda_1","util_1","decoder","algorithm","value","key","exports","applyDecoders","decoders","unwrappedValue","isResult","isOk","results","map","filter","result","undefined","length","err","Error","ok","JSONDecode","json","decode","JSONDecodeUnflattened","pipe","flattenResultsObject","isObject","mapObjIndexed","isString","isBoolean","isNumber","mapErr","isArray","combine","item","withDecoders","create","JSONDecoding"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/data-formats/src/json/decoding.ts"],"sourcesContent":["import { combine, err, ok, Result } from 'neverthrow'\nimport { mapObjIndexed, pipe } from 'ramda'\nimport {\n\tisObject,\n\tisString,\n\tflattenResultsObject,\n\tisArray,\n\tisBoolean,\n\tisNumber,\n\tisResult,\n} from '@radixdlt/util'\nimport { Decoder } from './_types'\n\n/**\n * Creates a new decoder. A decoder defines a way to transform a key-value pair through a\n * supplied algorithm.\n */\nexport const decoder = <T>(\n\talgorithm: (value: unknown, key?: string) => Result<T, Error> | undefined,\n): Decoder => (value: unknown, key?: string) => algorithm(value, key)\n\nconst applyDecoders = (\n\tdecoders: Decoder[],\n\tvalue: unknown,\n\tkey?: string,\n): Result<unknown, Error> => {\n\tlet unwrappedValue: unknown\n\n\tif (isResult(value)) {\n\t\tif (value.isOk()) {\n\t\t\tunwrappedValue = value.value\n\t\t} else {\n\t\t\treturn value\n\t\t}\n\t} else {\n\t\tunwrappedValue = value\n\t}\n\n\tconst results = decoders\n\t\t.map(decoder => decoder(unwrappedValue, key))\n\t\t.filter(result => result !== undefined)\n\n\treturn results.length > 1\n\t\t? err(\n\t\t\t\tError(\n\t\t\t\t\t`JSON decoding failed. Several decoders were valid for key/value pair. \n                    This can lead to unexpected behavior.`,\n\t\t\t\t),\n\t\t  )\n\t\t: results[0]\n\t\t? results[0]\n\t\t: ok(unwrappedValue)\n}\n\nconst JSONDecode = <Input, Decoded>(...decoders: Decoder[]) => (\n\tjson: Input,\n): Result<Decoded, Error[]> => {\n\tconst decode = JSONDecodeUnflattened(...decoders)\n\n\treturn pipe(\n\t\t//applyDecoders.bind(null, decoders),\n\t\tflattenResultsObject,\n\t)(decode(json)) as Result<Decoded, Error[]>\n}\n\n/**\n * Main decoding logic. Uses the registered decoders and applies matching decoders to\n * all key-value pairs in the supplied JSON.\n */\nconst JSONDecodeUnflattened = (...decoders: Decoder[]) => (\n\tjson: unknown,\n): Result<unknown, Error[]> =>\n\tisObject(json)\n\t\t? flattenResultsObject(\n\t\t\t\tok(\n\t\t\t\t\tmapObjIndexed(\n\t\t\t\t\t\t(value, key) =>\n\t\t\t\t\t\t\tapplyDecoders(\n\t\t\t\t\t\t\t\tdecoders,\n\t\t\t\t\t\t\t\tJSONDecodeUnflattened(...decoders)(value),\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\tjson,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t  )\n\t\t: isString(json) || isBoolean(json) || isNumber(json)\n\t\t? applyDecoders(decoders, json).mapErr(err => [err])\n\t\t: isArray(json)\n\t\t? combine(\n\t\t\t\tjson.map(item => JSONDecodeUnflattened(...decoders)(item)),\n\t\t  ).mapErr(err => err)\n\t\t: err([Error('JSON decoding failed. Unknown data type.')])\n\nconst withDecoders = (...decoders: Decoder[]) => ({\n\tcreate: <Input, Decoded>() => JSONDecode<Input, Decoded>(...decoders),\n})\n\nexport const JSONDecoding = {\n\twithDecoders,\n\tcreate: <Input, Decoded>() => JSONDecode<Input, Decoded>(...[]),\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}