{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Wallet = void 0;\nconst account_1 = require(\"@radixdlt/account\");\nconst rxjs_1 = require(\"rxjs\");\nconst account_2 = require(\"./account\");\nconst operators_1 = require(\"rxjs/operators\");\nconst create = input => {\n  const {\n    network,\n    signingKeychain\n  } = input;\n  const skToAccountAddress = signingKey => account_1.AccountAddress.fromPublicKeyAndNetwork({\n    network,\n    publicKey: signingKey.publicKey\n  });\n  const skToAccount = signingKey => account_2.Account.create({\n    signingKey,\n    address: skToAccountAddress(signingKey)\n  });\n  const sksToAccounts = signingKeys => {\n    const getAccountWithHDSigningKeyByHDPath = hdPath => signingKeys.getHDSigningKeyByHDPath(hdPath).map(skToAccount);\n    const getAnyAccountByPublicKey = publicKey => signingKeys.getAnySigningKeyByPublicKey(publicKey).map(skToAccount);\n    const all = signingKeys.all.map(skToAccount);\n    return {\n      all,\n      getAccountWithHDSigningKeyByHDPath,\n      getAnyAccountByPublicKey,\n      accountsWithHDSigningKeys: () => signingKeys.hdSigningKeys().map(skToAccount),\n      accountsWithHardwareHDSigningKeys: () => signingKeys.hardwareHDSigningKeys().map(skToAccount),\n      accountsWithLocalHDSigningKeys: () => signingKeys.localHDSigningKeys().map(skToAccount),\n      accountsWithNonHDSigningKeys: () => signingKeys.nonHDSigningKeys().map(skToAccount),\n      size: () => all.length\n    };\n  };\n  const observeActiveAccount = () => signingKeychain.observeActiveSigningKey().pipe((0, operators_1.map)(skToAccount));\n  return {\n    __unsafeGetAccount: () => skToAccount(signingKeychain.__unsafeGetSigningKey()),\n    revealMnemonic: signingKeychain.revealMnemonic,\n    deriveNextLocalHDAccount: input => signingKeychain.deriveNextLocalHDSigningKey(input).pipe((0, operators_1.map)(skToAccount)),\n    deriveHWAccount: input => signingKeychain.deriveHWSigningKey(input).pipe((0, operators_1.map)(skToAccount)),\n    displayAddressForActiveHWAccountOnHWDeviceForVerification: () => signingKeychain.__unsafeGetSigningKey().getPublicKeyDisplayOnlyAddress().pipe((0, operators_1.mergeMap)(() => {\n      return (0, rxjs_1.of)(undefined);\n    })),\n    observeActiveAccount,\n    observeAccounts: () => signingKeychain.observeSigningKeys().pipe((0, operators_1.map)(sksToAccounts)),\n    addAccountFromPrivateKey: input => (0, rxjs_1.of)(skToAccount(signingKeychain.addSigningKeyFromPrivateKey(input))),\n    restoreLocalHDAccountsToIndex: index => signingKeychain.restoreLocalHDSigningKeysUpToIndex(index).pipe((0, operators_1.map)(sksToAccounts)),\n    switchAccount: input => {\n      const isSwitchToAccount = something => {\n        const inspection = input;\n        return inspection.toAccount !== undefined && (0, account_2.isAccount)(inspection.toAccount);\n      };\n      if (isSwitchToAccount(input)) {\n        return skToAccount(signingKeychain.switchSigningKey({\n          toSigningKey: input.toAccount.signingKey\n        }));\n      } else {\n        return skToAccount(signingKeychain.switchSigningKey(input));\n      }\n    }\n  };\n};\nexports.Wallet = {\n  create\n};","map":{"version":3,"names":["account_1","require","rxjs_1","account_2","operators_1","create","input","network","signingKeychain","skToAccountAddress","signingKey","AccountAddress","fromPublicKeyAndNetwork","publicKey","skToAccount","Account","address","sksToAccounts","signingKeys","getAccountWithHDSigningKeyByHDPath","hdPath","getHDSigningKeyByHDPath","map","getAnyAccountByPublicKey","getAnySigningKeyByPublicKey","all","accountsWithHDSigningKeys","hdSigningKeys","accountsWithHardwareHDSigningKeys","hardwareHDSigningKeys","accountsWithLocalHDSigningKeys","localHDSigningKeys","accountsWithNonHDSigningKeys","nonHDSigningKeys","size","length","observeActiveAccount","observeActiveSigningKey","pipe","__unsafeGetAccount","__unsafeGetSigningKey","revealMnemonic","deriveNextLocalHDAccount","deriveNextLocalHDSigningKey","deriveHWAccount","deriveHWSigningKey","displayAddressForActiveHWAccountOnHWDeviceForVerification","getPublicKeyDisplayOnlyAddress","mergeMap","of","undefined","observeAccounts","observeSigningKeys","addAccountFromPrivateKey","addSigningKeyFromPrivateKey","restoreLocalHDAccountsToIndex","index","restoreLocalHDSigningKeysUpToIndex","switchAccount","isSwitchToAccount","something","inspection","toAccount","isAccount","switchSigningKey","toSigningKey","exports","Wallet"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/application/src/wallet.ts"],"sourcesContent":["import {\n\tSigningKeychainT,\n\tSigningKeyT,\n\tSigningKeysT,\n\tAccountAddressT,\n\tDeriveNextInput,\n\tAccountAddress,\n\tDeriveHWSigningKeyInput,\n} from '@radixdlt/account'\nimport {\n\tWalletT,\n\tAccountT,\n\tAccountsT,\n\tSwitchAccountInput,\n\tSwitchToAccount,\n\tAddAccountByPrivateKeyInput,\n} from './_types'\nimport { Observable, of, throwError } from 'rxjs'\nimport { Account, isAccount } from './account'\nimport { map, mergeMap } from 'rxjs/operators'\nimport { Option } from 'prelude-ts'\nimport { PublicKeyT, HDPathRadixT } from '@radixdlt/crypto'\nimport { Network } from '@radixdlt/primitives'\nimport { log } from '@radixdlt/util/dist/logging'\n\nconst create = (\n\tinput: Readonly<{\n\t\tsigningKeychain: SigningKeychainT\n\t\tnetwork: Network\n\t}>,\n): WalletT => {\n\tconst { network, signingKeychain } = input\n\tconst skToAccountAddress = (signingKey: SigningKeyT): AccountAddressT =>\n\t\tAccountAddress.fromPublicKeyAndNetwork({\n\t\t\tnetwork,\n\t\t\tpublicKey: signingKey.publicKey,\n\t\t})\n\n\tconst skToAccount = (signingKey: SigningKeyT): AccountT =>\n\t\tAccount.create({ signingKey, address: skToAccountAddress(signingKey) })\n\n\tconst sksToAccounts = (signingKeys: SigningKeysT): AccountsT => {\n\t\tconst getAccountWithHDSigningKeyByHDPath = (\n\t\t\thdPath: HDPathRadixT,\n\t\t): Option<AccountT> =>\n\t\t\tsigningKeys.getHDSigningKeyByHDPath(hdPath).map(skToAccount)\n\n\t\tconst getAnyAccountByPublicKey = (\n\t\t\tpublicKey: PublicKeyT,\n\t\t): Option<AccountT> =>\n\t\t\tsigningKeys.getAnySigningKeyByPublicKey(publicKey).map(skToAccount)\n\n\t\tconst all = signingKeys.all.map(skToAccount)\n\n\t\treturn {\n\t\t\tall,\n\t\t\tgetAccountWithHDSigningKeyByHDPath,\n\t\t\tgetAnyAccountByPublicKey,\n\t\t\taccountsWithHDSigningKeys: () =>\n\t\t\t\tsigningKeys.hdSigningKeys().map(skToAccount),\n\t\t\taccountsWithHardwareHDSigningKeys: () =>\n\t\t\t\tsigningKeys.hardwareHDSigningKeys().map(skToAccount),\n\t\t\taccountsWithLocalHDSigningKeys: () =>\n\t\t\t\tsigningKeys.localHDSigningKeys().map(skToAccount),\n\t\t\taccountsWithNonHDSigningKeys: () =>\n\t\t\t\tsigningKeys.nonHDSigningKeys().map(skToAccount),\n\t\t\tsize: () => all.length,\n\t\t}\n\t}\n\n\tconst observeActiveAccount = (): Observable<AccountT> =>\n\t\tsigningKeychain.observeActiveSigningKey().pipe(map(skToAccount))\n\n\treturn {\n\t\t__unsafeGetAccount: (): AccountT =>\n\t\t\tskToAccount(signingKeychain.__unsafeGetSigningKey()),\n\n\t\trevealMnemonic: signingKeychain.revealMnemonic,\n\n\t\tderiveNextLocalHDAccount: (\n\t\t\tinput?: DeriveNextInput,\n\t\t): Observable<AccountT> =>\n\t\t\tsigningKeychain\n\t\t\t\t.deriveNextLocalHDSigningKey(input)\n\t\t\t\t.pipe(map(skToAccount)),\n\n\t\tderiveHWAccount: (\n\t\t\tinput: DeriveHWSigningKeyInput,\n\t\t): Observable<AccountT> =>\n\t\t\tsigningKeychain.deriveHWSigningKey(input).pipe(map(skToAccount)),\n\n\t\tdisplayAddressForActiveHWAccountOnHWDeviceForVerification: (): Observable<void> =>\n\t\t\tsigningKeychain\n\t\t\t\t.__unsafeGetSigningKey()\n\t\t\t\t.getPublicKeyDisplayOnlyAddress()\n\t\t\t\t.pipe(\n\t\t\t\t\tmergeMap(\n\t\t\t\t\t\t(): Observable<void> => {\n\t\t\t\t\t\t\treturn of(undefined)\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t),\n\n\t\tobserveActiveAccount,\n\t\tobserveAccounts: (): Observable<AccountsT> =>\n\t\t\tsigningKeychain.observeSigningKeys().pipe(map(sksToAccounts)),\n\n\t\taddAccountFromPrivateKey: (\n\t\t\tinput: AddAccountByPrivateKeyInput,\n\t\t): Observable<AccountT> =>\n\t\t\tof(skToAccount(signingKeychain.addSigningKeyFromPrivateKey(input))),\n\n\t\trestoreLocalHDAccountsToIndex: (index: number): Observable<AccountsT> =>\n\t\t\tsigningKeychain\n\t\t\t\t.restoreLocalHDSigningKeysUpToIndex(index)\n\t\t\t\t.pipe(map(sksToAccounts)),\n\n\t\tswitchAccount: (input: SwitchAccountInput): AccountT => {\n\t\t\tconst isSwitchToAccount = (\n\t\t\t\tsomething: unknown,\n\t\t\t): something is SwitchToAccount => {\n\t\t\t\tconst inspection = input as SwitchToAccount\n\t\t\t\treturn (\n\t\t\t\t\tinspection.toAccount !== undefined &&\n\t\t\t\t\tisAccount(inspection.toAccount)\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tif (isSwitchToAccount(input)) {\n\t\t\t\treturn skToAccount(\n\t\t\t\t\tsigningKeychain.switchSigningKey({\n\t\t\t\t\t\ttoSigningKey: input.toAccount.signingKey,\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\treturn skToAccount(signingKeychain.switchSigningKey(input))\n\t\t\t}\n\t\t},\n\t}\n}\n\nexport const Wallet = {\n\tcreate,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}