{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isUInt256 = exports.secureRandomUInt256 = exports.uint256Max = exports.bnFromUInt256 = exports.uint256FromUnsafe = exports.isUnsafeInputForUInt256 = exports.uint256FromBN = exports.fitsInUInt256 = void 0;\nconst tslib_1 = require(\"tslib\");\nconst bn_js_1 = (0, tslib_1.__importDefault)(require(\"bn.js\"));\nconst neverthrow_1 = require(\"neverthrow\");\nconst uint256_1 = require(\"@radixdlt/uint256\");\nconst util_1 = require(\"@radixdlt/util\");\nconst bnUInt256Max = new bn_js_1.default(2).pow(new bn_js_1.default(256)).sub(new bn_js_1.default(1));\nconst fitsInUInt256 = number => {\n  const bn = new bn_js_1.default(number);\n  const isNotTooBig = bn.lte(bnUInt256Max);\n  const isNonNegative = bn.gte(new bn_js_1.default(0));\n  return isNotTooBig && isNonNegative;\n};\nexports.fitsInUInt256 = fitsInUInt256;\n/**\n * Converts a big number (BN) into a UInt256\n *\n * @param {BN} bn - A big number to be converted into a UInt256.\n * @returns {UInt256} A 256 bit wide unsigned integer.\n */\nconst uint256FromBN = bn => {\n  if (!(0, exports.fitsInUInt256)(bn)) {\n    return (0, neverthrow_1.err)(new Error(`BN is either less than 0 or larger than 2^256 - 1, which does not fit in a UInt256.`));\n  }\n  return (0, neverthrow_1.ok)(new uint256_1.UInt256(bn.toString('hex'), 16));\n};\nexports.uint256FromBN = uint256FromBN;\n// eslint-disable-next-line complexity\nconst isUnsafeInputForUInt256 = something => {\n  if (typeof something === 'number') {\n    return true;\n  } else if (typeof something === 'string') {\n    return true;\n  } else if ((0, util_1.isNumberArray)(something)) {\n    return true;\n  } else if (something instanceof Uint8Array) {\n    return true;\n  } else return something instanceof Buffer;\n};\nexports.isUnsafeInputForUInt256 = isUnsafeInputForUInt256;\nconst uint256FromUnsafe = unsafe => {\n  // eslint-disable-next-line functional/no-try-statement\n  try {\n    const bn = new bn_js_1.default(unsafe);\n    return (0, exports.uint256FromBN)(bn);\n  } catch (e) {\n    return (0, neverthrow_1.err)(e);\n  }\n};\nexports.uint256FromUnsafe = uint256FromUnsafe;\nconst bnFromUInt256 = uint256 => new bn_js_1.default(uint256.toString(16), 'hex');\nexports.bnFromUInt256 = bnFromUInt256;\nexports.uint256Max = (0, exports.uint256FromBN)(bnUInt256Max)._unsafeUnwrap();\nconst secureRandomUInt256 = (secureRandom = util_1.secureRandomGenerator) => {\n  const randomBytes = secureRandom.randomSecureBytes(32);\n  return new uint256_1.UInt256(randomBytes, 16);\n};\nexports.secureRandomUInt256 = secureRandomUInt256;\nconst isUInt256 = something => something instanceof uint256_1.UInt256;\nexports.isUInt256 = isUInt256;","map":{"version":3,"names":["bn_js_1","tslib_1","__importDefault","require","neverthrow_1","uint256_1","util_1","bnUInt256Max","default","pow","sub","fitsInUInt256","number","bn","isNotTooBig","lte","isNonNegative","gte","exports","uint256FromBN","err","Error","ok","UInt256","toString","isUnsafeInputForUInt256","something","isNumberArray","Uint8Array","Buffer","uint256FromUnsafe","unsafe","e","bnFromUInt256","uint256","uint256Max","_unsafeUnwrap","secureRandomUInt256","secureRandom","secureRandomGenerator","randomBytes","randomSecureBytes","isUInt256"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/primitives/src/uint256-extensions.ts"],"sourcesContent":["import BN from 'bn.js'\nimport { err, Result, ok } from 'neverthrow'\nimport { UInt256 } from '@radixdlt/uint256'\nimport {\n\tisNumberArray,\n\tSecureRandom,\n\tsecureRandomGenerator,\n} from '@radixdlt/util'\n\nconst bnUInt256Max: BN = new BN(2).pow(new BN(256)).sub(new BN(1))\n\nexport const fitsInUInt256 = (number: BN | number): boolean => {\n\tconst bn = new BN(number)\n\tconst isNotTooBig = bn.lte(bnUInt256Max)\n\tconst isNonNegative = bn.gte(new BN(0))\n\treturn isNotTooBig && isNonNegative\n}\n\n/**\n * Converts a big number (BN) into a UInt256\n *\n * @param {BN} bn - A big number to be converted into a UInt256.\n * @returns {UInt256} A 256 bit wide unsigned integer.\n */\nexport const uint256FromBN = (bn: BN): Result<UInt256, Error> => {\n\tif (!fitsInUInt256(bn)) {\n\t\treturn err(\n\t\t\tnew Error(\n\t\t\t\t`BN is either less than 0 or larger than 2^256 - 1, which does not fit in a UInt256.`,\n\t\t\t),\n\t\t)\n\t}\n\treturn ok(new UInt256(bn.toString('hex'), 16))\n}\n\nexport type UInt256InputUnsafe =\n\t| number\n\t| string\n\t| number[]\n\t| Uint8Array\n\t| Buffer\n\n// eslint-disable-next-line complexity\nexport const isUnsafeInputForUInt256 = (\n\tsomething: unknown,\n): something is UInt256InputUnsafe => {\n\tif (typeof something === 'number') {\n\t\treturn true\n\t} else if (typeof something === 'string') {\n\t\treturn true\n\t} else if (isNumberArray(something)) {\n\t\treturn true\n\t} else if (something instanceof Uint8Array) {\n\t\treturn true\n\t} else return something instanceof Buffer\n}\n\nexport const uint256FromUnsafe = (\n\tunsafe: UInt256InputUnsafe,\n): Result<UInt256, Error> => {\n\t// eslint-disable-next-line functional/no-try-statement\n\ttry {\n\t\tconst bn = new BN(unsafe)\n\t\treturn uint256FromBN(bn)\n\t} catch (e) {\n\t\treturn err(e as Error)\n\t}\n}\n\nexport const bnFromUInt256 = (uint256: UInt256): BN =>\n\tnew BN(uint256.toString(16), 'hex')\n\nexport const uint256Max = uint256FromBN(bnUInt256Max)._unsafeUnwrap()\n\nexport const secureRandomUInt256 = (\n\tsecureRandom: SecureRandom = secureRandomGenerator,\n): UInt256 => {\n\tconst randomBytes = secureRandom.randomSecureBytes(32)\n\treturn new UInt256(randomBytes, 16)\n}\n\nexport const isUInt256 = (something: unknown): something is UInt256 =>\n\tsomething instanceof UInt256\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}