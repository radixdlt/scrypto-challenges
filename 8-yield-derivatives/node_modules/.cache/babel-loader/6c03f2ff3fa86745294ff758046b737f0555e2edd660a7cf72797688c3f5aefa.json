{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","map":{"version":3,"names":[],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/application/src/_types.ts"],"sourcesContent":["import {\n\tSigningKeyT,\n\tAccountAddressT,\n\tDeriveNextInput,\n\tSigning,\n\tEncrypting,\n\tDecrypting,\n\tSwitchToIndex,\n\tAddSigningKeyByPrivateKeyInput,\n\tDeriveHWSigningKeyInput,\n} from '@radixdlt/account'\nimport {\n\tPublicKeyT,\n\tHDPathRadixT,\n\tMnemomicT,\n\tKeystoreT,\n} from '@radixdlt/crypto'\nimport { Network } from '@radixdlt/primitives'\nimport { ErrorNotification, Observable, ReplaySubject } from 'rxjs'\nimport {\n\tBuiltTransaction,\n\tExecutedTransaction,\n\tSimpleExecutedTransaction,\n\tStakePositions,\n\tStatusOfTransaction,\n\tTokenBalances,\n\tTransactionHistory,\n\tTransactionHistoryActiveAccountRequestInput,\n\tTransactionIdentifierT,\n\tTransactionTracking,\n\tUnstakePositions,\n} from './dto'\nimport {\n\tStakeTokensInput,\n\tTransferTokensInput,\n\tUnstakeTokensInput,\n} from './actions'\nimport { Option } from 'prelude-ts'\nimport { SigningKeychainT, SigningKeyTypeT } from '@radixdlt/account/src/_types'\nimport { Radix } from './radix'\nimport { NodeT, RadixAPI, RadixCoreAPI } from './api'\nimport { LogLevel } from 'packages/account/node_modules/@radixdlt/util/dist'\nimport { ErrorT } from './errors'\n\nexport type ManualUserConfirmTX = {\n\ttxToConfirm: BuiltTransaction\n\tconfirm: () => void\n}\n\nexport type TransactionConfirmationBeforeFinalization =\n\t| 'skip'\n\t| ReplaySubject<ManualUserConfirmTX>\n\nexport type MessageInTransaction = Readonly<{\n\tplaintext: string\n\tencrypt: boolean\n}>\n\nexport type MakeTransactionOptions = Readonly<{\n\tuserConfirmation: TransactionConfirmationBeforeFinalization\n\tpollTXStatusTrigger?: Observable<unknown>\n}>\n\nexport type TransferTokensOptions = MakeTransactionOptions &\n\tReadonly<{\n\t\tmessage?: MessageInTransaction\n\t\ttransferInput: TransferTokensInput\n\t}>\n\nexport type StakeOptions = MakeTransactionOptions &\n\tReadonly<{\n\t\tstakeInput: StakeTokensInput\n\t}>\n\nexport type UnstakeOptions = MakeTransactionOptions &\n\tReadonly<{\n\t\tunstakeInput: UnstakeTokensInput\n\t}>\n\nexport type AccountT = Signing &\n\tEncrypting &\n\tDecrypting &\n\tReadonly<{\n\t\tequals: (other: AccountT) => boolean\n\t\tsigningKey: SigningKeyT\n\n\t\taddress: AccountAddressT\n\n\t\t// sugar for signingKey.publicKey/address.publicKey\n\t\tpublicKey: PublicKeyT\n\t\t// sugar for address.network\n\t\tnetwork: Network\n\n\t\t// sugar for `signingKey.type`\n\t\ttype: SigningKeyTypeT\n\n\t\t// sugar for `signingKey.hdPath`, if signingKey type is HD signingKey\n\t\thdPath?: HDPathRadixT\n\t}>\n\nexport type AccountsT = Readonly<{\n\t// Get only accounts which signingKey is a HD signingKey, by its path\n\tgetAccountWithHDSigningKeyByHDPath: (\n\t\thdPath: HDPathRadixT,\n\t) => Option<AccountT>\n\t// Get any account by its public key\n\tgetAnyAccountByPublicKey: (publicKey: PublicKeyT) => Option<AccountT>\n\n\t// ALL accounts, basically a concatenation of `accountsWithHDSigningKeys || accountsWithNonHDSigningKeys`\n\tall: AccountT[]\n\n\taccountsWithNonHDSigningKeys: () => AccountT[]\n\n\taccountsWithLocalHDSigningKeys: () => AccountT[]\n\taccountsWithHardwareHDSigningKeys: () => AccountT[]\n\n\t// Concatenation of `accountsWithLocalHDSigningKeys || accountsWithHardwareHDSigningKeys`\n\taccountsWithHDSigningKeys: () => AccountT[]\n\n\t// size of `all`.\n\tsize: () => number\n}>\n\nexport type SwitchToAccount = Readonly<{ toAccount: AccountT }>\n\nexport type SwitchAccountInput =\n\t| 'first'\n\t| 'last'\n\t| SwitchToAccount\n\t| SwitchToIndex\n\nexport type WalletT = Readonly<{\n\t// should only be used for testing\n\t__unsafeGetAccount: () => AccountT\n\n\trevealMnemonic: () => MnemomicT\n\n\trestoreLocalHDAccountsToIndex: (index: number) => Observable<AccountsT>\n\n\tderiveNextLocalHDAccount: (input?: DeriveNextInput) => Observable<AccountT>\n\n\tderiveHWAccount: (input: DeriveHWSigningKeyInput) => Observable<AccountT>\n\tdisplayAddressForActiveHWAccountOnHWDeviceForVerification: () => Observable<void>\n\n\taddAccountFromPrivateKey: (\n\t\tinput: AddAccountByPrivateKeyInput,\n\t) => Observable<AccountT>\n\n\tswitchAccount: (input: SwitchAccountInput) => AccountT\n\n\tobserveActiveAccount: () => Observable<AccountT>\n\tobserveAccounts: () => Observable<AccountsT>\n}>\n\nexport type AddAccountByPrivateKeyInput = AddSigningKeyByPrivateKeyInput\n\nexport type RadixT = Readonly<{\n\tledger: RadixAPI\n\t// Input\n\tconnect: (url: string) => Promise<void>\n\n\t// Primiarily useful for testing.\n\t__withAPI: (radixCoreAPI$: Observable<RadixCoreAPI>) => RadixT\n\n\t__withNodeConnection: (node$: Observable<NodeT>) => RadixT\n\t__withWallet: (wallet: WalletT) => RadixT\n\tlogin: (password: string, loadKeystore: () => Promise<KeystoreT>) => RadixT\n\n\t// Wallet APIs\n\n\t/**\n\t * Restores accounts in wallet up to and excluding `targetIndex`.\n\t *\n\t * @param {number} targetIndex - The index to restore account up to, this method will restore accounts from index 0 up to but excluding this index.\n\t */\n\trestoreLocalHDAccountsToIndex: (index: number) => Observable<AccountsT>\n\tderiveNextAccount: (input?: DeriveNextInput) => RadixT\n\n\t// Wait for Ledger Nano S/X to connect and app be opened and derive\n\t// account according to `input`.\n\tderiveHWAccount: (input: DeriveHWSigningKeyInput) => Observable<AccountT>\n\tdisplayAddressForActiveHWAccountOnHWDeviceForVerification: () => Observable<void>\n\n\taddAccountFromPrivateKey: (input: AddAccountByPrivateKeyInput) => RadixT\n\n\tswitchAccount: (input: SwitchAccountInput) => RadixT\n\trevealMnemonic: () => Observable<MnemomicT>\n\n\tactiveAddress: Observable<AccountAddressT>\n\tactiveAccount: Observable<AccountT>\n\taccounts: Observable<AccountsT>\n\n\t// Active AccountAddress/Account APIs\n\ttokenBalances: Observable<TokenBalances>\n\tstakingPositions: Observable<StakePositions>\n\tunstakingPositions: Observable<UnstakePositions>\n\n\tlogLevel: (level: LogLevel) => RadixT\n\n\t/**\n\t * Specify a trigger for when to fetch the token balances for the active address.\n\t *\n\t * @param {Observable<number>} trigger - An observable that signals when to fetch.\n\t */\n\twithTokenBalanceFetchTrigger: (trigger: Observable<number>) => RadixT\n\n\t/**\n\t * Specify a trigger for when to fetch the stakes and unstakes for the active address.\n\t *\n\t * @param {Observable<number>} trigger - An observable that signals when to fetch.\n\t */\n\twithStakingFetchTrigger: (trigger: Observable<number>) => RadixT\n\n\t/**\n\t * Transaction history of active signingKey.\n\t *\n\t * @param {TransactionHistoryActiveAccountRequestInput} input - Pagination input, size and cursor.\n\t * @returns {TransactionHistory} A page from the transaction history.\n\t */\n\ttransactionHistory: (\n\t\tinput: TransactionHistoryActiveAccountRequestInput,\n\t) => Observable<TransactionHistory>\n\n\t/**\n\t * A decorated variant of RadixApi's lookupTransaction, this decorated variant returns\n\t * `ExecutedTransaction` instead of `SimpleExecutedTransaction` which includes `transctionType`.\n\t */\n\tlookupTransaction: (\n\t\ttxID: TransactionIdentifierT,\n\t) => Observable<ExecutedTransaction>\n\n\t// Make TX flow\n\ttransferTokens: (input: TransferTokensOptions) => TransactionTracking\n\n\ttransactionStatus: (\n\t\ttxID: TransactionIdentifierT,\n\t\ttrigger: Observable<number>,\n\t) => Observable<StatusOfTransaction>\n\n\tstakeTokens: (input: StakeOptions) => TransactionTracking\n\n\tunstakeTokens: (input: UnstakeOptions) => TransactionTracking\n\n\tdecryptTransaction: (input: SimpleExecutedTransaction) => Observable<string>\n\n\terrors: Observable<ErrorT<any>>\n\n\t__wallet: Observable<WalletT>\n\t__node: Observable<NodeT>\n\t__reset: () => void\n\n\t__withKeychain: (signingKeychain: SigningKeychainT) => RadixT\n}>\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}