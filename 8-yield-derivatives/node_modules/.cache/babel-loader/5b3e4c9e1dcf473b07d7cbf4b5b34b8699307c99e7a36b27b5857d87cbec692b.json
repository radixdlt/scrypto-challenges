{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/from';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { OperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nexport function onErrorResumeNext() {\n  var sources = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    sources[_i] = arguments[_i];\n  }\n  var nextSources = argsOrArgArray(sources);\n  return operate(function (source, subscriber) {\n    var remaining = __spreadArray([source], __read(nextSources));\n    var subscribeNext = function () {\n      if (!subscriber.closed) {\n        if (remaining.length > 0) {\n          var nextSource = void 0;\n          try {\n            nextSource = innerFrom(remaining.shift());\n          } catch (err) {\n            subscribeNext();\n            return;\n          }\n          var innerSub = new OperatorSubscriber(subscriber, undefined, noop, noop);\n          subscriber.add(nextSource.subscribe(innerSub));\n          innerSub.add(subscribeNext);\n        } else {\n          subscriber.complete();\n        }\n      }\n    };\n    subscribeNext();\n  });\n}","map":{"version":3,"names":["operate","innerFrom","argsOrArgArray","OperatorSubscriber","noop","onErrorResumeNext","sources","_i","arguments","length","nextSources","source","subscriber","remaining","__spreadArray","__read","subscribeNext","closed","nextSource","shift","err","innerSub","undefined","add","subscribe","complete"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/rxjs/src/internal/operators/onErrorResumeNext.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { ObservableInputTuple, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/from';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { OperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\n\nexport function onErrorResumeNext<T, A extends readonly unknown[]>(\n  sources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]>;\nexport function onErrorResumeNext<T, A extends readonly unknown[]>(\n  ...sources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]>;\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables, subscribes to next one on error or complete.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link Observable#subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catchError} instead.\n *\n *\n * ## Example\n * Subscribe to the next Observable after map fails\n * ```ts\n * import { of } from 'rxjs';\n * import { onErrorResumeNext, map } from 'rxjs/operators';\n *\n * of(1, 2, 3, 0).pipe(\n *   map(x => {\n *       if (x === 0) { throw Error(); }\n *        return 10 / x;\n *   }),\n *   onErrorResumeNext(of(1, 2, 3)),\n * )\n * .subscribe(\n *   val => console.log(val),\n *   err => console.log(err),          // Will never be called.\n *   () => console.log('that\\'s it!')\n * );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param {...ObservableInput} nextSources Observables passed either directly or as an array.\n * @return A function that returns an Observable that emits values from source\n * Observable, but - if it errors - subscribes to the next passed Observable\n * and so on, until it completes or runs out of Observables.\n */\nexport function onErrorResumeNext<T, A extends readonly unknown[]>(\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  // For some reason, TS 4.1 RC gets the inference wrong here and infers the\n  // result to be `A[number][]` - completely dropping the ObservableInput part\n  // of the type. This makes no sense whatsoever. As a workaround, the type is\n  // asserted explicitly.\n  const nextSources = (argsOrArgArray(sources) as unknown) as ObservableInputTuple<A>;\n\n  return operate((source, subscriber) => {\n    const remaining = [source, ...nextSources];\n    const subscribeNext = () => {\n      if (!subscriber.closed) {\n        if (remaining.length > 0) {\n          let nextSource: Observable<A[number]>;\n          try {\n            nextSource = innerFrom<T | A[number]>(remaining.shift()!);\n          } catch (err) {\n            subscribeNext();\n            return;\n          }\n\n          // Here we have to use one of our Subscribers, or it does not wire up\n          // The `closed` property of upstream Subscribers synchronously, that\n          // would result in situation were we could not stop a synchronous firehose\n          // with something like `take(3)`.\n          const innerSub = new OperatorSubscriber(subscriber, undefined, noop, noop);\n          subscriber.add(nextSource.subscribe(innerSub));\n          innerSub.add(subscribeNext);\n        } else {\n          subscriber.complete();\n        }\n      }\n    };\n\n    subscribeNext();\n  });\n}\n"],"mappings":";AAEA,SAASA,OAAO,QAAQ,cAAc;AACtC,SAASC,SAAS,QAAQ,oBAAoB;AAC9C,SAASC,cAAc,QAAQ,wBAAwB;AACvD,SAASC,kBAAkB,QAAQ,sBAAsB;AACzD,SAASC,IAAI,QAAQ,cAAc;AA4EnC,OAAM,SAAUC,iBAAiBA,CAAA;EAC/B,IAAAC,OAAA;OAAA,IAAAC,EAAA,IAAyE,EAAzEA,EAAA,GAAAC,SAAA,CAAAC,MAAyE,EAAzEF,EAAA,EAAyE;IAAzED,OAAA,CAAAC,EAAA,IAAAC,SAAA,CAAAD,EAAA;;EAMA,IAAMG,WAAW,GAAIR,cAAc,CAACI,OAAO,CAAwC;EAEnF,OAAON,OAAO,CAAC,UAACW,MAAM,EAAEC,UAAU;IAChC,IAAMC,SAAS,GAAAC,aAAA,EAAIH,MAAM,GAAAI,MAAA,CAAKL,WAAW,EAAC;IAC1C,IAAMM,aAAa,GAAG,SAAAA,CAAA;MACpB,IAAI,CAACJ,UAAU,CAACK,MAAM,EAAE;QACtB,IAAIJ,SAAS,CAACJ,MAAM,GAAG,CAAC,EAAE;UACxB,IAAIS,UAAU,SAAuB;UACrC,IAAI;YACFA,UAAU,GAAGjB,SAAS,CAAgBY,SAAS,CAACM,KAAK,EAAG,CAAC;WAC1D,CAAC,OAAOC,GAAG,EAAE;YACZJ,aAAa,EAAE;YACf;;UAOF,IAAMK,QAAQ,GAAG,IAAIlB,kBAAkB,CAACS,UAAU,EAAEU,SAAS,EAAElB,IAAI,EAAEA,IAAI,CAAC;UAC1EQ,UAAU,CAACW,GAAG,CAACL,UAAU,CAACM,SAAS,CAACH,QAAQ,CAAC,CAAC;UAC9CA,QAAQ,CAACE,GAAG,CAACP,aAAa,CAAC;SAC5B,MAAM;UACLJ,UAAU,CAACa,QAAQ,EAAE;;;IAG3B,CAAC;IAEDT,aAAa,EAAE;EACjB,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}