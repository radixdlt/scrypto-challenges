{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractAddress = exports.isAbstractAddress = void 0;\nconst neverthrow_1 = require(\"neverthrow\");\nconst crypto_1 = require(\"@radixdlt/crypto\");\nconst util_1 = require(\"@radixdlt/util\");\nconst bech32_1 = require(\"../bech32\");\nconst isAbstractAddress = something => {\n  const inspection = something;\n  return inspection.publicKey !== undefined && (0, crypto_1.isPublicKey)(inspection.publicKey) && inspection.equals !== undefined && inspection.toString !== undefined && inspection.addressType !== undefined;\n};\nexports.isAbstractAddress = isAbstractAddress;\nconst __create = input => {\n  const {\n    hrp,\n    data,\n    encoding,\n    maxLength,\n    network,\n    publicKey,\n    addressType,\n    typeguard\n  } = input;\n  return bech32_1.Bech32.encode({\n    hrp,\n    data,\n    encoding,\n    maxLength\n  }).mapErr(error => {\n    const errMsg = `Incorrect implementation, failed to Bech32 encode data, underlying error: ${(0, util_1.msgFromError)(error)}, but expect to always be able to.`;\n    console.error(errMsg);\n    throw new Error(errMsg);\n  }).map(encoded => {\n    const toString = () => encoded.toString();\n    const equals = other => {\n      if (!(0, exports.isAbstractAddress)(other)) {\n        return false;\n      }\n      return other.publicKey.equals(publicKey) && other.network === network && addressType === other.addressType;\n    };\n    const abstract = {\n      addressType,\n      network,\n      publicKey,\n      toString,\n      equals\n    };\n    if (!typeguard(abstract)) {\n      const errMsg = `Incorrect implementation, expected to have created an address of type ${addressType.toString()}`;\n      util_1.log.error(errMsg);\n      throw new Error(errMsg);\n    }\n    return abstract;\n  });\n};\nconst byFormattingPublicKeyDataAndBech32ConvertingIt = input => {\n  var _a;\n  const {\n    publicKey,\n    hrpFromNetwork,\n    network\n  } = input;\n  const formatDataToBech32Convert = (_a = input.formatDataToBech32Convert) !== null && _a !== void 0 ? _a : b => b;\n  const publicKeyBytes = publicKey.asData({\n    compressed: true\n  });\n  const bytes = formatDataToBech32Convert(publicKeyBytes);\n  const hrp = hrpFromNetwork(network);\n  return bech32_1.Bech32.convertDataToBech32(bytes).andThen(data => __create(Object.assign(Object.assign({}, input), {\n    hrp,\n    data,\n    publicKey\n  })));\n};\nconst fromString = input => {\n  var _a;\n  const {\n    bechString,\n    networkFromHRP\n  } = input;\n  const validateDataAndExtractPubKeyBytes = (_a = input.validateDataAndExtractPubKeyBytes) !== null && _a !== void 0 ? _a : passthroughData => (0, neverthrow_1.ok)(passthroughData);\n  return bech32_1.Bech32.decode(input).andThen(({\n    hrp,\n    data: bech32Data\n  }) => bech32_1.Bech32.convertDataFromBech32(bech32Data).map(dataFromBech32 => ({\n    bech32Data,\n    dataFromBech32,\n    hrp\n  }))).andThen(({\n    bech32Data,\n    dataFromBech32,\n    hrp\n  }) => validateDataAndExtractPubKeyBytes(dataFromBech32).map(publicKeyBytes => ({\n    bech32Data,\n    publicKeyBytes,\n    hrp\n  }))).andThen(({\n    bech32Data,\n    publicKeyBytes,\n    hrp\n  }) => (0, neverthrow_1.combine)([networkFromHRP(hrp), crypto_1.PublicKey.fromBuffer(publicKeyBytes)]).map(resultList => {\n    const network = resultList[0];\n    const publicKey = resultList[1];\n    return {\n      bech32Data,\n      hrp,\n      network,\n      publicKey\n    };\n  })).andThen(({\n    bech32Data,\n    hrp,\n    network,\n    publicKey\n  }) => __create(Object.assign(Object.assign({}, input), {\n    network: network,\n    hrp,\n    data: bech32Data,\n    publicKey\n  }))).map(abstractAddress => {\n    // Soundness check\n    if (abstractAddress.toString().toLowerCase() !== bechString.toLowerCase()) {\n      const errMsg = `Incorrect implementation, AbstractAddress mismatch, passed in: ${bechString.toLowerCase()}, created: ${abstractAddress.toString().toLowerCase()}`;\n      util_1.log.error(errMsg);\n      throw new Error(errMsg);\n    }\n    return abstractAddress;\n  });\n};\nexports.AbstractAddress = {\n  byFormattingPublicKeyDataAndBech32ConvertingIt,\n  fromString\n};","map":{"version":3,"names":["neverthrow_1","require","crypto_1","util_1","bech32_1","isAbstractAddress","something","inspection","publicKey","undefined","isPublicKey","equals","toString","addressType","exports","__create","input","hrp","data","encoding","maxLength","network","typeguard","Bech32","encode","mapErr","error","errMsg","msgFromError","console","Error","map","encoded","other","abstract","log","byFormattingPublicKeyDataAndBech32ConvertingIt","hrpFromNetwork","formatDataToBech32Convert","_a","b","publicKeyBytes","asData","compressed","bytes","convertDataToBech32","andThen","Object","assign","fromString","bechString","networkFromHRP","validateDataAndExtractPubKeyBytes","passthroughData","ok","decode","bech32Data","convertDataFromBech32","dataFromBech32","combine","PublicKey","fromBuffer","resultList","abstractAddress","toLowerCase","AbstractAddress"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/account/src/addresses/abstractAddress.ts"],"sourcesContent":["import { combine, ok, Result } from 'neverthrow'\nimport { isPublicKey, PublicKey, PublicKeyT } from '@radixdlt/crypto'\nimport { log, msgFromError } from '@radixdlt/util'\nimport { Bech32, Encoding } from '../bech32'\nimport { AbstractAddressT, AddressTypeT } from './_types'\nimport { Network } from '@radixdlt/primitives'\n\nexport const isAbstractAddress = (\n\tsomething: unknown,\n): something is AbstractAddressT => {\n\tconst inspection = something as AbstractAddressT\n\treturn (\n\t\tinspection.publicKey !== undefined &&\n\t\tisPublicKey(inspection.publicKey) &&\n\t\tinspection.equals !== undefined &&\n\t\tinspection.toString !== undefined &&\n\t\tinspection.addressType !== undefined\n\t)\n}\n\nexport type TypeGuard<A extends AbstractAddressT> = (\n\tsomething: unknown,\n) => something is A\n\nexport type NetworkFromHRP = (hrp: string) => Result<Network, Error>\nexport type HRPFromNetwork = (network: Network) => string\nexport type FormatDataToBech32Convert = (publicKeyBytes: Buffer) => Buffer\n\nexport type ValidateDataAndExtractPubKeyBytes = (\n\tdata: Buffer,\n) => Result<Buffer, Error>\n\nconst __create = <A extends AbstractAddressT>(\n\tinput: Readonly<{\n\t\thrp: string\n\t\tdata: Buffer\n\t\taddressType: AddressTypeT\n\t\tpublicKey: PublicKeyT\n\t\tnetwork: Network\n\t\ttypeguard: TypeGuard<A>\n\t\tencoding?: Encoding\n\t\tmaxLength?: number\n\t}>,\n): Result<A, Error> => {\n\tconst {\n\t\thrp,\n\t\tdata,\n\t\tencoding,\n\t\tmaxLength,\n\t\tnetwork,\n\t\tpublicKey,\n\t\taddressType,\n\t\ttypeguard,\n\t} = input\n\treturn Bech32.encode({ hrp, data, encoding, maxLength })\n\t\t.mapErr(error => {\n\t\t\tconst errMsg = `Incorrect implementation, failed to Bech32 encode data, underlying error: ${msgFromError(\n\t\t\t\terror,\n\t\t\t)}, but expect to always be able to.`\n\t\t\tconsole.error(errMsg)\n\t\t\tthrow new Error(errMsg)\n\t\t})\n\t\t.map(encoded => {\n\t\t\tconst toString = (): string => encoded.toString()\n\n\t\t\tconst equals = (other: AbstractAddressT): boolean => {\n\t\t\t\tif (!isAbstractAddress(other)) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn (\n\t\t\t\t\tother.publicKey.equals(publicKey) &&\n\t\t\t\t\tother.network === network &&\n\t\t\t\t\taddressType === other.addressType\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst abstract: AbstractAddressT = {\n\t\t\t\taddressType,\n\t\t\t\tnetwork,\n\t\t\t\tpublicKey,\n\t\t\t\ttoString,\n\t\t\t\tequals,\n\t\t\t}\n\n\t\t\tif (!typeguard(abstract)) {\n\t\t\t\tconst errMsg = `Incorrect implementation, expected to have created an address of type ${addressType.toString()}`\n\t\t\t\tlog.error(errMsg)\n\t\t\t\tthrow new Error(errMsg)\n\t\t\t}\n\n\t\t\treturn abstract\n\t\t})\n}\n\nconst byFormattingPublicKeyDataAndBech32ConvertingIt = <\n\tA extends AbstractAddressT\n>(\n\tinput: Readonly<{\n\t\tpublicKey: PublicKeyT\n\t\thrpFromNetwork: HRPFromNetwork\n\t\taddressType: AddressTypeT\n\t\tnetwork: Network\n\t\ttypeguard: TypeGuard<A>\n\t\tformatDataToBech32Convert?: FormatDataToBech32Convert\n\t\tencoding?: Encoding\n\t\tmaxLength?: number\n\t}>,\n): Result<A, Error> => {\n\tconst { publicKey, hrpFromNetwork, network } = input\n\n\tconst formatDataToBech32Convert =\n\t\tinput.formatDataToBech32Convert ?? (b => b)\n\n\tconst publicKeyBytes = publicKey.asData({ compressed: true })\n\tconst bytes = formatDataToBech32Convert(publicKeyBytes)\n\tconst hrp = hrpFromNetwork(network)\n\treturn Bech32.convertDataToBech32(bytes).andThen(data =>\n\t\t__create({\n\t\t\t...input,\n\t\t\thrp,\n\t\t\tdata,\n\t\t\tpublicKey,\n\t\t}),\n\t)\n}\n\nconst fromString = <A extends AbstractAddressT>(\n\tinput: Readonly<{\n\t\tbechString: string\n\t\taddressType: AddressTypeT\n\t\tnetworkFromHRP: NetworkFromHRP\n\t\ttypeguard: TypeGuard<A>\n\t\tvalidateDataAndExtractPubKeyBytes?: ValidateDataAndExtractPubKeyBytes\n\t\tencoding?: Encoding\n\t\tmaxLength?: number\n\t}>,\n): Result<A, Error> => {\n\tconst { bechString, networkFromHRP } = input\n\n\tconst validateDataAndExtractPubKeyBytes =\n\t\tinput.validateDataAndExtractPubKeyBytes ??\n\t\t((passthroughData: Buffer) => ok(passthroughData))\n\n\treturn Bech32.decode(input)\n\t\t.andThen(({ hrp, data: bech32Data }) =>\n\t\t\tBech32.convertDataFromBech32(bech32Data).map(dataFromBech32 => ({\n\t\t\t\tbech32Data,\n\t\t\t\tdataFromBech32,\n\t\t\t\thrp,\n\t\t\t})),\n\t\t)\n\t\t.andThen(({ bech32Data, dataFromBech32, hrp }) =>\n\t\t\tvalidateDataAndExtractPubKeyBytes(dataFromBech32).map(\n\t\t\t\tpublicKeyBytes => ({\n\t\t\t\t\tbech32Data,\n\t\t\t\t\tpublicKeyBytes,\n\t\t\t\t\thrp,\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t\t.andThen(({ bech32Data, publicKeyBytes, hrp }) =>\n\t\t\tcombine([\n\t\t\t\tnetworkFromHRP(hrp),\n\t\t\t\tPublicKey.fromBuffer(publicKeyBytes),\n\t\t\t]).map(resultList => {\n\t\t\t\tconst network = resultList[0]\n\t\t\t\tconst publicKey = resultList[1] as PublicKeyT\n\t\t\t\treturn {\n\t\t\t\t\tbech32Data,\n\t\t\t\t\thrp,\n\t\t\t\t\tnetwork,\n\t\t\t\t\tpublicKey,\n\t\t\t\t}\n\t\t\t}),\n\t\t)\n\t\t.andThen(({ bech32Data, hrp, network, publicKey }) =>\n\t\t\t__create({\n\t\t\t\t...input,\n\t\t\t\tnetwork: network as Network,\n\t\t\t\thrp,\n\t\t\t\tdata: bech32Data,\n\t\t\t\tpublicKey,\n\t\t\t}),\n\t\t)\n\t\t.map(\n\t\t\t(abstractAddress: A): A => {\n\t\t\t\t// Soundness check\n\t\t\t\tif (\n\t\t\t\t\tabstractAddress.toString().toLowerCase() !==\n\t\t\t\t\tbechString.toLowerCase()\n\t\t\t\t) {\n\t\t\t\t\tconst errMsg = `Incorrect implementation, AbstractAddress mismatch, passed in: ${bechString.toLowerCase()}, created: ${abstractAddress\n\t\t\t\t\t\t.toString()\n\t\t\t\t\t\t.toLowerCase()}`\n\t\t\t\t\tlog.error(errMsg)\n\t\t\t\t\tthrow new Error(errMsg)\n\t\t\t\t}\n\t\t\t\treturn abstractAddress\n\t\t\t},\n\t\t)\n}\n\nexport const AbstractAddress = {\n\tbyFormattingPublicKeyDataAndBech32ConvertingIt,\n\tfromString,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}