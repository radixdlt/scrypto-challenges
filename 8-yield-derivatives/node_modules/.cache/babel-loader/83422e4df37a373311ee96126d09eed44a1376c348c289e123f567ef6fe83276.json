{"ast":null,"code":"var RetryOperation = require('./retry_operation');\nexports.operation = function (options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n    forever: options && options.forever,\n    unref: options && options.unref\n  });\n};\nexports.timeouts = function (options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function (a, b) {\n    return a - b;\n  });\n  return timeouts;\n};\nexports.createTimeout = function (attempt, opts) {\n  var random = opts.randomize ? Math.random() + 1 : 1;\n  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n  return timeout;\n};\nexports.wrap = function (obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    var original = obj[method];\n    obj[method] = function retryWrapper() {\n      var op = exports.operation(options);\n      var args = Array.prototype.slice.call(arguments);\n      var callback = args.pop();\n      args.push(function (err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n      op.attempt(function () {\n        original.apply(obj, args);\n      });\n    };\n    obj[method].options = options;\n  }\n};","map":{"version":3,"names":["RetryOperation","require","exports","operation","options","timeouts","forever","unref","Array","concat","opts","retries","factor","minTimeout","maxTimeout","Infinity","randomize","key","Error","i","push","createTimeout","length","sort","a","b","attempt","random","Math","timeout","round","pow","min","wrap","obj","methods","method","original","retryWrapper","op","args","prototype","slice","call","arguments","callback","pop","err","retry","mainError","apply"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/promise-retry/node_modules/retry/lib/retry.js"],"sourcesContent":["var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && options.forever,\n      unref: options && options.unref\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper() {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    };\n    obj[method].options = options;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}