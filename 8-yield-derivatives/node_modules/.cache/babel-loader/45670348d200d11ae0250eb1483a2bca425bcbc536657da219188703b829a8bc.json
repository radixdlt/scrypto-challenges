{"ast":null,"code":"\"use strict\";\n\n/**\n * Rich functions with helpers such as [[Function1.andThen]],\n * [[Function2.apply1]] and so on.\n *\n * We support functions of arities up to 5. For each arity, we have\n * the interface ([[Function1]], [[Function2]], ...), builders are on functions\n * on [[Function1Static]], [[Function2Static]]... accessible on constants\n * named Function1, Function2,...\n *\n * Examples:\n *\n *     const combined = Function1.of((x:number)=>x+2).andThen(x=>x*3);\n *     combined(6);\n *     => 24\n *\n *     const plus5 = Function2.of((x:number,y:number)=>x+y).apply1(5);\n *     plus5(1);\n *     => 6\n */\nexports.__esModule = true;\n/**\n * This is the type of the Function0 constant, which\n * offers some helper functions to deal\n * with [[Function0]] including\n * the ability to build [[Function0]]\n * from functions using [[Function0Static.of]].\n * It also offers some builtin functions like [[Function0Static.constant]].\n */\nvar Function0Static = /** @class */function () {\n  function Function0Static() {}\n  /**\n   * The constant function of one parameter:\n   * will always return the value you give, no\n   * matter the parameter it's given.\n   */\n  Function0Static.prototype.constant = function (val) {\n    return exports.Function0.of(function () {\n      return val;\n    });\n  };\n  /**\n   * Take a one-parameter function and lift it to become a [[Function1Static]],\n   * enabling you to call [[Function1.andThen]] and other such methods on it.\n   */\n  Function0Static.prototype.of = function (fn) {\n    var r = function () {\n      return fn();\n    };\n    r.andThen = function (fn2) {\n      return exports.Function0.of(function () {\n        return fn2(r());\n      });\n    };\n    return r;\n  };\n  return Function0Static;\n}();\nexports.Function0Static = Function0Static;\n/**\n * The Function1 constant allows to call the [[Function0]] \"static\" methods.\n */\nexports.Function0 = new Function0Static();\n/**\n * This is the type of the Function1 constant, which\n * offers some helper functions to deal\n * with [[Function1]] including\n * the ability to build [[Function1]]\n * from functions using [[Function1Static.of]].\n * It also offers some builtin functions like [[Function1Static.constant]].\n */\nvar Function1Static = /** @class */function () {\n  function Function1Static() {}\n  /**\n   * The identity function.\n   */\n  Function1Static.prototype.id = function () {\n    return exports.Function1.of(function (x) {\n      return x;\n    });\n  };\n  /**\n   * The constant function of one parameter:\n   * will always return the value you give, no\n   * matter the parameter it's given.\n   */\n  Function1Static.prototype.constant = function (val) {\n    return exports.Function1.of(function (x) {\n      return val;\n    });\n  };\n  /**\n   * Take a one-parameter function and lift it to become a [[Function1Static]],\n   * enabling you to call [[Function1.andThen]] and other such methods on it.\n   */\n  Function1Static.prototype.of = function (fn) {\n    var r = function (x) {\n      return fn(x);\n    };\n    r.andThen = function (fn2) {\n      return exports.Function1.of(function (x) {\n        return fn2(r(x));\n      });\n    };\n    r.compose = function (fn2) {\n      return exports.Function1.of(function (x) {\n        return r(fn2(x));\n      });\n    };\n    return r;\n  };\n  return Function1Static;\n}();\nexports.Function1Static = Function1Static;\n/**\n * The Function1 constant allows to call the [[Function1]] \"static\" methods.\n */\nexports.Function1 = new Function1Static();\n/**\n * This is the type of the Function2 constant, which\n * offers some helper functions to deal\n * with [[Function2]] including\n * the ability to build [[Function2]]\n * from functions using [[Function2Static.of]].\n * It also offers some builtin functions like [[Function2Static.constant]].\n */\nvar Function2Static = /** @class */function () {\n  function Function2Static() {}\n  /**\n   * The constant function of two parameters:\n   * will always return the value you give, no\n   * matter the parameters it's given.\n   */\n  Function2Static.prototype.constant = function (val) {\n    return exports.Function2.of(function (x, y) {\n      return val;\n    });\n  };\n  /**\n   * Take a two-parameter function and lift it to become a [[Function2]],\n   * enabling you to call [[Function2.andThen]] and other such methods on it.\n   */\n  Function2Static.prototype.of = function (fn) {\n    var r = function (x, y) {\n      return fn(x, y);\n    };\n    r.andThen = function (fn2) {\n      return exports.Function2.of(function (x, y) {\n        return fn2(r(x, y));\n      });\n    };\n    r.curried = function () {\n      return exports.Function1.of(function (x) {\n        return exports.Function1.of(function (y) {\n          return r(x, y);\n        });\n      });\n    };\n    r.tupled = function () {\n      return exports.Function1.of(function (pair) {\n        return r(pair[0], pair[1]);\n      });\n    };\n    r.flipped = function () {\n      return exports.Function2.of(function (x, y) {\n        return r(y, x);\n      });\n    };\n    r.apply1 = function (x) {\n      return exports.Function1.of(function (y) {\n        return r(x, y);\n      });\n    };\n    return r;\n  };\n  return Function2Static;\n}();\nexports.Function2Static = Function2Static;\n/**\n * The Function2 constant allows to call the [[Function2]] \"static\" methods.\n */\nexports.Function2 = new Function2Static();\n/**\n * This is the type of the Function3 constant, which\n * offers some helper functions to deal\n * with [[Function3]] including\n * the ability to build [[Function3]]\n * from functions using [[Function3Static.of]].\n * It also offers some builtin functions like [[Function3Static.constant]].\n */\nvar Function3Static = /** @class */function () {\n  function Function3Static() {}\n  /**\n   * The constant function of three parameters:\n   * will always return the value you give, no\n   * matter the parameters it's given.\n   */\n  Function3Static.prototype.constant = function (val) {\n    return exports.Function3.of(function (x, y, z) {\n      return val;\n    });\n  };\n  /**\n   * Take a three-parameter function and lift it to become a [[Function3]],\n   * enabling you to call [[Function3.andThen]] and other such methods on it.\n   */\n  Function3Static.prototype.of = function (fn) {\n    var r = function (x, y, z) {\n      return fn(x, y, z);\n    };\n    r.andThen = function (fn2) {\n      return exports.Function3.of(function (x, y, z) {\n        return fn2(r(x, y, z));\n      });\n    };\n    r.curried = function () {\n      return exports.Function1.of(function (x) {\n        return exports.Function1.of(function (y) {\n          return exports.Function1.of(function (z) {\n            return r(x, y, z);\n          });\n        });\n      });\n    };\n    r.tupled = function () {\n      return exports.Function1.of(function (tuple) {\n        return r(tuple[0], tuple[1], tuple[2]);\n      });\n    };\n    r.flipped = function () {\n      return exports.Function3.of(function (x, y, z) {\n        return r(z, y, x);\n      });\n    };\n    r.apply1 = function (x) {\n      return exports.Function2.of(function (y, z) {\n        return r(x, y, z);\n      });\n    };\n    r.apply2 = function (x, y) {\n      return exports.Function1.of(function (z) {\n        return r(x, y, z);\n      });\n    };\n    return r;\n  };\n  return Function3Static;\n}();\nexports.Function3Static = Function3Static;\n/**\n * The Function3 constant allows to call the [[Function3]] \"static\" methods.\n */\nexports.Function3 = new Function3Static();\n/**\n * This is the type of the Function4 constant, which\n * offers some helper functions to deal\n * with [[Function4]] including\n * the ability to build [[Function4]]\n * from functions using [[Function4Static.of]].\n * It also offers some builtin functions like [[Function4Static.constant]].\n */\nvar Function4Static = /** @class */function () {\n  function Function4Static() {}\n  /**\n   * The constant function of four parameters:\n   * will always return the value you give, no\n   * matter the parameters it's given.\n   */\n  Function4Static.prototype.constant = function (val) {\n    return exports.Function4.of(function (x, y, z, a) {\n      return val;\n    });\n  };\n  /**\n   * Take a four-parameter function and lift it to become a [[Function4]],\n   * enabling you to call [[Function4.andThen]] and other such methods on it.\n   */\n  Function4Static.prototype.of = function (fn) {\n    var r = function (x, y, z, a) {\n      return fn(x, y, z, a);\n    };\n    r.andThen = function (fn2) {\n      return exports.Function4.of(function (x, y, z, a) {\n        return fn2(r(x, y, z, a));\n      });\n    };\n    r.curried = function () {\n      return exports.Function1.of(function (x) {\n        return exports.Function1.of(function (y) {\n          return exports.Function1.of(function (z) {\n            return exports.Function1.of(function (a) {\n              return r(x, y, z, a);\n            });\n          });\n        });\n      });\n    };\n    r.tupled = function () {\n      return exports.Function1.of(function (tuple) {\n        return r(tuple[0], tuple[1], tuple[2], tuple[3]);\n      });\n    };\n    r.flipped = function () {\n      return exports.Function4.of(function (x, y, z, a) {\n        return r(a, z, y, x);\n      });\n    };\n    r.apply1 = function (x) {\n      return exports.Function3.of(function (y, z, a) {\n        return r(x, y, z, a);\n      });\n    };\n    r.apply2 = function (x, y) {\n      return exports.Function2.of(function (z, a) {\n        return r(x, y, z, a);\n      });\n    };\n    r.apply3 = function (x, y, z) {\n      return exports.Function1.of(function (a) {\n        return r(x, y, z, a);\n      });\n    };\n    return r;\n  };\n  return Function4Static;\n}();\nexports.Function4Static = Function4Static;\n;\n/**\n * The Function4 constant allows to call the [[Function4]] \"static\" methods.\n */\nexports.Function4 = new Function4Static();\n/**\n * This is the type of the Function5 constant, which\n * offers some helper functions to deal\n * with [[Function5]] including\n * the ability to build [[Function5]]\n * from functions using [[Function5Static.of]].\n * It also offers some builtin functions like [[Function5Static.constant]].\n */\nvar Function5Static = /** @class */function () {\n  function Function5Static() {}\n  /**\n   * The constant function of five parameters:\n   * will always return the value you give, no\n   * matter the parameters it's given.\n   */\n  Function5Static.prototype.constant = function (val) {\n    return exports.Function5.of(function (x, y, z, a, b) {\n      return val;\n    });\n  };\n  /**\n   * Take a five-parameter function and lift it to become a [[Function5]],\n   * enabling you to call [[Function5.andThen]] and other such methods on it.\n   */\n  Function5Static.prototype.of = function (fn) {\n    var r = function (x, y, z, a, b) {\n      return fn(x, y, z, a, b);\n    };\n    r.andThen = function (fn2) {\n      return exports.Function5.of(function (x, y, z, a, b) {\n        return fn2(r(x, y, z, a, b));\n      });\n    };\n    r.curried = function () {\n      return exports.Function1.of(function (x) {\n        return exports.Function1.of(function (y) {\n          return exports.Function1.of(function (z) {\n            return exports.Function1.of(function (a) {\n              return exports.Function1.of(function (b) {\n                return r(x, y, z, a, b);\n              });\n            });\n          });\n        });\n      });\n    };\n    r.tupled = function () {\n      return exports.Function1.of(function (tuple) {\n        return r(tuple[0], tuple[1], tuple[2], tuple[3], tuple[4]);\n      });\n    };\n    r.flipped = function () {\n      return exports.Function5.of(function (x, y, z, a, b) {\n        return r(b, a, z, y, x);\n      });\n    };\n    r.apply1 = function (x) {\n      return exports.Function4.of(function (y, z, a, b) {\n        return r(x, y, z, a, b);\n      });\n    };\n    r.apply2 = function (x, y) {\n      return exports.Function3.of(function (z, a, b) {\n        return r(x, y, z, a, b);\n      });\n    };\n    r.apply3 = function (x, y, z) {\n      return exports.Function2.of(function (a, b) {\n        return r(x, y, z, a, b);\n      });\n    };\n    r.apply4 = function (x, y, z, a) {\n      return exports.Function1.of(function (b) {\n        return r(x, y, z, a, b);\n      });\n    };\n    return r;\n  };\n  return Function5Static;\n}();\nexports.Function5Static = Function5Static;\n/**\n * The Function5 constant allows to call the [[Function5]] \"static\" methods.\n */\nexports.Function5 = new Function5Static();","map":{"version":3,"names":["Function0Static","prototype","constant","val","exports","Function0","of","fn","r","andThen","fn2","Function1Static","id","Function1","x","compose","Function2Static","Function2","y","curried","tupled","pair","flipped","apply1","Function3Static","Function3","z","tuple","apply2","Function4Static","Function4","a","apply3","Function5Static","Function5","b","apply4"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/Function.ts"],"sourcesContent":["/**\n * Rich functions with helpers such as [[Function1.andThen]],\n * [[Function2.apply1]] and so on.\n *\n * We support functions of arities up to 5. For each arity, we have\n * the interface ([[Function1]], [[Function2]], ...), builders are on functions\n * on [[Function1Static]], [[Function2Static]]... accessible on constants\n * named Function1, Function2,...\n *\n * Examples:\n *\n *     const combined = Function1.of((x:number)=>x+2).andThen(x=>x*3);\n *     combined(6);\n *     => 24\n *\n *     const plus5 = Function2.of((x:number,y:number)=>x+y).apply1(5);\n *     plus5(1);\n *     => 6\n */\n\n/**\n * Function0 encapsulates a parameterless function\n * which returns a value. It adds some useful functions\n * to combine or transform functions.\n *\n * @param T the parameter type\n * @param U the result type\n */\nexport interface Function0<R> {\n\n    /**\n     * Invoke the function\n     */\n    (): R;\n\n    /**\n     * Returns a new composed function which first calls the current\n     * function and then the one you pass as parameter.\n     */\n    andThen<V>(fn:(x:R)=>V): Function0<V>;\n}\n\n/**\n * Function1 encapsulates a function taking a single parameter\n * and returning a value. It adds some useful functions\n * to combine or transform functions.\n *\n * @param T the parameter type\n * @param U the result type\n */\nexport interface Function1<T,U> {\n\n    /**\n     * Invoke the function\n     */\n    (x:T): U;\n\n    /**\n     * Returns a new composed function which first applies the current\n     * function and then the one you pass as parameter.\n     */\n    andThen<V>(fn:(x:U)=>V): Function1<T,V>;\n\n    /**\n     *\n     */\n    compose<S>(fn:(x:S)=>T): Function1<S,U>;\n}\n\n/**\n * Function2 encapsulates a function taking two parameters\n * and returning a value. It adds some useful functions\n * to combine or transform functions.\n *\n * @param T1 the first parameter type\n * @param T2 the second parameter type\n * @param R the result type\n */\nexport interface Function2<T1,T2,R> {\n\n    /**\n     * Invoke the function\n     */\n    (x:T1,y:T2): R;\n\n    /**\n     * Returns a new composed function which first applies the current\n     * function and then the one you pass as parameter.\n     */\n    andThen<V>(fn:(x:R)=>V): Function2<T1,T2,V>;\n\n    /**\n     * Returns a curried version of this function, for example:\n     *\n     *     const plus5 = Function2.of(\n     *         (x:number,y:number)=>x+y)\n     *            .curried()(5);\n     *     assert.equal(6, plus5(1));\n     */\n    curried(): Function1<T1,Function1<T2,R>>;\n\n    /**\n     * Returns a version of this function which takes a tuple\n     * instead of individual parameters. Useful in combination\n     * with [[Vector.zip]] for instance.\n     */\n    tupled(): Function1<[T1,T2],R>;\n\n    /**\n     * Returns a version of this function taking its parameters\n     * in the reverse order.\n     */\n    flipped(): Function2<T2,T1,R>;\n\n    /**\n     * Applies this function partially to one argument.\n     *\n     *     const plus5 = Function2.of(\n     *         (x:number,y:number)=>x+y)\n     *            .apply1(5);\n     *     assert.equal(6, plus5(1));\n     */\n    apply1(param1:T1): Function1<T2,R>;\n}\n\n/**\n * Function3 encapsulates a function taking three parameters\n * and returning a value. It adds some useful functions\n * to combine or transform functions.\n *\n * @param T1 the first parameter type\n * @param T2 the second parameter type\n * @param T3 the third parameter type\n * @param R the result type\n */\nexport interface Function3<T1,T2,T3,R> {\n\n    /**\n     * Invoke the function\n     */\n    (x:T1,y:T2,z:T3): R;\n\n    /**\n     * Returns a new composed function which first applies the current\n     * function and then the one you pass as parameter.\n     */\n    andThen<V>(fn:(x:R)=>V): Function3<T1,T2,T3,V>;\n\n    /**\n     * Returns a curried version of this function, for example:\n     * See [[Function2.curried]]\n     */\n    curried(): Function1<T1,Function1<T2,Function1<T3,R>>>;\n\n    /**\n     * Returns a version of this function which takes a tuple\n     * instead of individual parameters.\n     */\n    tupled(): Function1<[T1,T2,T3],R>;\n\n    /**\n     * Returns a version of this function taking its parameters\n     * in the reverse order.\n     */\n    flipped(): Function3<T3,T2,T1,R>;\n\n    /**\n     * Applies this function partially to one argument.\n     *\n     *     const plus5 = Function3.of(\n     *         (x:number,y:number,z:number)=>x+y+z)\n     *            .apply1(5);\n     *     assert.equal(8, plus5(1,2));\n     */\n    apply1(param1:T1): Function2<T2,T3,R>;\n\n    /**\n     * Applies this function partially to two arguments.\n     *\n     *     const plus54 = Function3.of(\n     *         (x:number,y:number,z:number)=>x+y+z)\n     *            .apply2(5,4);\n     *     assert.equal(12, plus54(3));\n     */\n    apply2(param1:T1, param2: T2): Function1<T3,R>;\n}\n\n/**\n * Function4 encapsulates a function taking four parameters\n * and returning a value. It adds some useful functions\n * to combine or transform functions.\n *\n * @param T1 the first parameter type\n * @param T2 the second parameter type\n * @param T3 the third parameter type\n * @param T4 the fourth parameter type\n * @param R the result type\n */\nexport interface Function4<T1,T2,T3,T4,R> {\n\n    /**\n     * Invoke the function\n     */\n    (x:T1,y:T2,z:T3,a:T4): R;\n\n    /**\n     * Returns a new composed function which first applies the current\n     * function and then the one you pass as parameter.\n     */\n    andThen<V>(fn:(x:R)=>V): Function4<T1,T2,T3,T4,V>;\n\n    /**\n     * Returns a curried version of this function, for example:\n     * See [[Function2.curried]]\n     */\n    curried(): Function1<T1,Function1<T2,Function1<T3,Function1<T4,R>>>>;\n\n    /**\n     * Returns a version of this function which takes a tuple\n     * instead of individual parameters.\n     */\n    tupled(): Function1<[T1,T2,T3,T4],R>;\n\n    /**\n     * Returns a version of this function taking its parameters\n     * in the reverse order.\n     */\n    flipped(): Function4<T4,T3,T2,T1,R>;\n\n    /**\n     * Applies this function partially to one argument.\n     *\n     *     const plus5 = Function4.of(\n     *         (x:number,y:number,z:number,a:number)=>x+y+z+a)\n     *            .apply1(5);\n     *     assert.equal(11, plus5(1,2,3));\n     */\n    apply1(param1:T1): Function3<T2,T3,T4,R>;\n\n    /**\n     * Applies this function partially to two arguments.\n     *\n     *     const plus51 = Function4.of(\n     *         (x:number,y:number,z:number,a:number)=>x+y+z+a)\n     *            .apply2(5,1);\n     *     assert.equal(11, plus51(2,3));\n     */\n    apply2(param1:T1, param2: T2): Function2<T3,T4,R>;\n\n    /**\n     * Applies this function partially to three arguments.\n     *\n     *     const plus512 = Function4.of(\n     *         (x:number,y:number,z:number,a:number)=>x+y+z+a)\n     *            .apply3(5,1,2);\n     *     assert.equal(11, plus512(3));\n     */\n    apply3(param1:T1, param2: T2, param3: T3): Function1<T4,R>;\n}\n\n/**\n * Function5 encapsulates a function taking give parameters\n * and returning a value. It adds some useful functions\n * to combine or transform functions.\n *\n * @param T1 the first parameter type\n * @param T2 the second parameter type\n * @param T3 the third parameter type\n * @param T4 the fourth parameter type\n * @param T5 the fifth parameter type\n * @param R the result type\n */\nexport interface Function5<T1,T2,T3,T4,T5,R> {\n\n    /**\n     * Invoke the function\n     */\n    (x:T1,y:T2,z:T3,a:T4,b:T5): R;\n\n    /**\n     * Returns a new composed function which first applies the current\n     * function and then the one you pass as parameter.\n     */\n    andThen<V>(fn:(x:R)=>V): Function5<T1,T2,T3,T4,T5,V>;\n\n    /**\n     * Returns a curried version of this function, for example:\n     * See [[Function2.curried]]\n     */\n    curried(): Function1<T1,Function1<T2,Function1<T3,Function1<T4,Function1<T5,R>>>>>;\n\n    /**\n     * Returns a version of this function which takes a tuple\n     * instead of individual parameters.\n     */\n    tupled(): Function1<[T1,T2,T3,T4,T5],R>;\n\n    /**\n     * Returns a version of this function taking its parameters\n     * in the reverse order.\n     */\n    flipped(): Function5<T5,T4,T3,T2,T1,R>;\n\n    /**\n     * Applies this function partially to one argument.\n     *\n     *     const plus5 = Function5.of(\n     *         (x:number,y:number,z:number,a:number,b:number)=>x+y+z+a+b)\n     *            .apply1(5);\n     *     assert.equal(15, plus5(1,2,3,4));\n     */\n    apply1(param1:T1): Function4<T2,T3,T4,T5,R>;\n\n    /**\n     * Applies this function partially to two arguments.\n     *\n     *     const plus51 = Function5.of(\n     *         (x:number,y:number,z:number,a:number,b:number)=>x+y+z+a+b)\n     *            .apply2(5,1);\n     *     assert.equal(15, plus51(2,3,4));\n     */\n    apply2(param1:T1, param2: T2): Function3<T3,T4,T5,R>;\n\n    /**\n     * Applies this function partially to three arguments.\n     *\n     *     const plus512 = Function5.of(\n     *         (x:number,y:number,z:number,a:number,b:number)=>x+y+z+a+b)\n     *            .apply3(5,1,2);\n     *     assert.equal(15, plus512(3,4));\n     */\n    apply3(param1:T1, param2: T2, param3: T3): Function2<T4,T5,R>;\n\n    /**\n     * Applies this function partially to four arguments.\n     *\n     *     const plus5123 = Function5.of(\n     *         (x:number,y:number,z:number,a:number,b:number)=>x+y+z+a+b)\n     *            .apply4(5,1,2,3);\n     *     assert.equal(15, plus5123(4));\n     */\n    apply4(param1:T1, param2: T2, param3: T3, param4: T4): Function1<T5,R>;\n}\n\n/**\n * This is the type of the Function0 constant, which\n * offers some helper functions to deal\n * with [[Function0]] including\n * the ability to build [[Function0]]\n * from functions using [[Function0Static.of]].\n * It also offers some builtin functions like [[Function0Static.constant]].\n */\nexport class Function0Static {\n\n    /**\n     * The constant function of one parameter:\n     * will always return the value you give, no\n     * matter the parameter it's given.\n     */\n    constant<R>(val:R): Function0<R> {\n        return Function0.of(()=>val);\n    }\n\n    /**\n     * Take a one-parameter function and lift it to become a [[Function1Static]],\n     * enabling you to call [[Function1.andThen]] and other such methods on it.\n     */\n    of<R>(fn:()=>R): Function0<R> {\n        const r = <Function0<R>>(() => fn());\n        r.andThen = <V>(fn2:(x:R)=>V) => Function0.of(() => fn2(r()));\n        return r;\n    }\n}\n\n/**\n * The Function1 constant allows to call the [[Function0]] \"static\" methods.\n */\nexport const Function0 = new Function0Static();\n\n/**\n * This is the type of the Function1 constant, which\n * offers some helper functions to deal\n * with [[Function1]] including\n * the ability to build [[Function1]]\n * from functions using [[Function1Static.of]].\n * It also offers some builtin functions like [[Function1Static.constant]].\n */\nexport class Function1Static {\n\n    /**\n     * The identity function.\n     */\n    id<T>(): Function1<T,T> {\n        return Function1.of((x:T)=>x);\n    }\n\n    /**\n     * The constant function of one parameter:\n     * will always return the value you give, no\n     * matter the parameter it's given.\n     */\n    constant<U,T>(val:T): Function1<U,T> {\n        return Function1.of((x:U)=>val);\n    }\n\n    /**\n     * Take a one-parameter function and lift it to become a [[Function1Static]],\n     * enabling you to call [[Function1.andThen]] and other such methods on it.\n     */\n    of<T,U>(fn:(x:T)=>U): Function1<T,U> {\n        const r = <Function1<T,U>>(x => fn(x));\n        r.andThen = <V>(fn2:(x:U)=>V) => Function1.of((x:T) => fn2(r(x)));\n        r.compose = <S>(fn2:(x:S)=>T) => Function1.of((x:S) => r(fn2(x)));\n        return r;\n    }\n}\n\n/**\n * The Function1 constant allows to call the [[Function1]] \"static\" methods.\n */\nexport const Function1 = new Function1Static();\n\n/**\n * This is the type of the Function2 constant, which\n * offers some helper functions to deal\n * with [[Function2]] including\n * the ability to build [[Function2]]\n * from functions using [[Function2Static.of]].\n * It also offers some builtin functions like [[Function2Static.constant]].\n */\nexport class Function2Static {\n    /**\n     * The constant function of two parameters:\n     * will always return the value you give, no\n     * matter the parameters it's given.\n     */\n    constant<T1,T2,R>(val:R): Function2<T1,T2,R> {\n        return Function2.of((x:T1,y:T2)=>val);\n    }\n\n    /**\n     * Take a two-parameter function and lift it to become a [[Function2]],\n     * enabling you to call [[Function2.andThen]] and other such methods on it.\n     */\n    of<T1,T2,R>(fn:(x:T1,y:T2)=>R): Function2<T1,T2,R> {\n        const r = <Function2<T1,T2,R>>((x,y)=>fn(x,y));\n        r.andThen = <V>(fn2:(x:R)=>V) => Function2.of((x:T1,y:T2) => fn2(r(x,y)));\n        r.curried = () => Function1.of((x:T1) => Function1.of((y:T2) => r(x,y)));\n        r.tupled = () => Function1.of((pair:[T1,T2]) => r(pair[0],pair[1]));\n        r.flipped = () => Function2.of((x:T2,y:T1) => r(y,x));\n        r.apply1 = (x:T1) => Function1.of((y:T2) => r(x,y));\n        return r;\n    }\n}\n\n/**\n * The Function2 constant allows to call the [[Function2]] \"static\" methods.\n */\nexport const Function2 = new Function2Static();\n\n/**\n * This is the type of the Function3 constant, which\n * offers some helper functions to deal\n * with [[Function3]] including\n * the ability to build [[Function3]]\n * from functions using [[Function3Static.of]].\n * It also offers some builtin functions like [[Function3Static.constant]].\n */\nexport class Function3Static {\n    /**\n     * The constant function of three parameters:\n     * will always return the value you give, no\n     * matter the parameters it's given.\n     */\n    constant<T1,T2,T3,R>(val:R): Function3<T1,T2,T3,R> {\n        return Function3.of((x:T1,y:T2,z:T3)=>val);\n    }\n\n    /**\n     * Take a three-parameter function and lift it to become a [[Function3]],\n     * enabling you to call [[Function3.andThen]] and other such methods on it.\n     */\n    of<T1,T2,T3,R>(fn:(x:T1,y:T2,z:T3)=>R): Function3<T1,T2,T3,R> {\n        const r = <Function3<T1,T2,T3,R>>((x,y,z)=>fn(x,y,z));\n        r.andThen = <V>(fn2:(x:R)=>V) => Function3.of((x:T1,y:T2,z:T3) => fn2(r(x,y,z)));\n        r.curried = () => Function1.of((x:T1) => Function1.of((y:T2) => Function1.of((z:T3) => r(x,y,z))));\n        r.tupled = () => Function1.of((tuple:[T1,T2,T3]) => r(tuple[0],tuple[1],tuple[2]));\n        r.flipped = () => Function3.of((x:T3,y:T2,z:T1) => r(z,y,x));\n        r.apply1 = (x:T1) => Function2.of((y:T2,z:T3) => r(x,y,z));\n        r.apply2 = (x:T1,y:T2) => Function1.of((z:T3) => r(x,y,z));\n        return r;\n    }\n}\n\n/**\n * The Function3 constant allows to call the [[Function3]] \"static\" methods.\n */\nexport const Function3 = new Function3Static();\n\n/**\n * This is the type of the Function4 constant, which\n * offers some helper functions to deal\n * with [[Function4]] including\n * the ability to build [[Function4]]\n * from functions using [[Function4Static.of]].\n * It also offers some builtin functions like [[Function4Static.constant]].\n */\nexport class Function4Static {\n\n    /**\n     * The constant function of four parameters:\n     * will always return the value you give, no\n     * matter the parameters it's given.\n     */\n    constant<T1,T2,T3,T4,R>(val:R): Function4<T1,T2,T3,T4,R> {\n        return Function4.of((x:T1,y:T2,z:T3,a:T4)=>val);\n    }\n\n    /**\n     * Take a four-parameter function and lift it to become a [[Function4]],\n     * enabling you to call [[Function4.andThen]] and other such methods on it.\n     */\n    of<T1,T2,T3,T4,R>(fn:(x:T1,y:T2,z:T3,a:T4)=>R): Function4<T1,T2,T3,T4,R> {\n        const r = <Function4<T1,T2,T3,T4,R>>((x,y,z,a)=>fn(x,y,z,a));\n        r.andThen = <V>(fn2:(x:R)=>V) => Function4.of((x:T1,y:T2,z:T3,a:T4) => fn2(r(x,y,z,a)));\n        r.curried = () => Function1.of((x:T1) => Function1.of(\n            (y:T2) => Function1.of((z:T3) => Function1.of((a:T4)=>r(x,y,z,a)))));\n        r.tupled = () => Function1.of((tuple:[T1,T2,T3,T4]) => r(tuple[0],tuple[1],tuple[2],tuple[3]));\n        r.flipped = () => Function4.of((x:T4,y:T3,z:T2,a:T1) => r(a,z,y,x));\n        r.apply1 = (x:T1) => Function3.of((y:T2,z:T3,a:T4) => r(x,y,z,a));\n        r.apply2 = (x:T1,y:T2) => Function2.of((z:T3,a:T4) => r(x,y,z,a));\n        r.apply3 = (x:T1,y:T2,z:T3) => Function1.of((a:T4) => r(x,y,z,a));\n        return r;\n    }\n\n};\n\n/**\n * The Function4 constant allows to call the [[Function4]] \"static\" methods.\n */\nexport const Function4 = new Function4Static();\n\n/**\n * This is the type of the Function5 constant, which\n * offers some helper functions to deal\n * with [[Function5]] including\n * the ability to build [[Function5]]\n * from functions using [[Function5Static.of]].\n * It also offers some builtin functions like [[Function5Static.constant]].\n */\nexport class Function5Static {\n    /**\n     * The constant function of five parameters:\n     * will always return the value you give, no\n     * matter the parameters it's given.\n     */\n    constant<T1,T2,T3,T4,T5,R>(val:R): Function5<T1,T2,T3,T4,T5,R> {\n        return Function5.of((x:T1,y:T2,z:T3,a:T4,b:T5)=>val);\n    }\n\n    /**\n     * Take a five-parameter function and lift it to become a [[Function5]],\n     * enabling you to call [[Function5.andThen]] and other such methods on it.\n     */\n    of<T1,T2,T3,T4,T5,R>(fn:(x:T1,y:T2,z:T3,a:T4,b:T5)=>R): Function5<T1,T2,T3,T4,T5,R> {\n        const r = <Function5<T1,T2,T3,T4,T5,R>>((x,y,z,a,b)=>fn(x,y,z,a,b));\n        r.andThen = <V>(fn2:(x:R)=>V) => Function5.of((x:T1,y:T2,z:T3,a:T4,b:T5) => fn2(r(x,y,z,a,b)));\n        r.curried = () => Function1.of((x:T1) => Function1.of(\n            (y:T2) => Function1.of((z:T3) => Function1.of((a:T4)=>Function1.of((b:T5) => r(x,y,z,a,b))))));\n        r.tupled = () => Function1.of((tuple:[T1,T2,T3,T4,T5]) => r(tuple[0],tuple[1],tuple[2],tuple[3],tuple[4]));\n        r.flipped = () => Function5.of((x:T5,y:T4,z:T3,a:T2,b:T1) => r(b,a,z,y,x));\n        r.apply1 = (x:T1) => Function4.of((y:T2,z:T3,a:T4,b:T5) => r(x,y,z,a,b));\n        r.apply2 = (x:T1,y:T2) => Function3.of((z:T3,a:T4,b:T5) => r(x,y,z,a,b));\n        r.apply3 = (x:T1,y:T2,z:T3) => Function2.of((a:T4,b:T5) => r(x,y,z,a,b));\n        r.apply4 = (x:T1,y:T2,z:T3,a:T4) => Function1.of((b:T5) => r(x,y,z,a,b));\n        return r;\n    }\n}\n\n/**\n * The Function5 constant allows to call the [[Function5]] \"static\" methods.\n */\nexport const Function5 = new Function5Static();\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAwVA;;;;;;;;AAQA,IAAAA,eAAA;EAAA,SAAAA,gBAAA,GAoBA;EAlBI;;;;;EAKAA,eAAA,CAAAC,SAAA,CAAAC,QAAQ,GAAR,UAAYC,GAAK;IACb,OAAOC,OAAA,CAAAC,SAAS,CAACC,EAAE,CAAC;MAAI,OAAAH,GAAG;IAAH,CAAG,CAAC;EAChC,CAAC;EAED;;;;EAIAH,eAAA,CAAAC,SAAA,CAAAK,EAAE,GAAF,UAAMC,EAAQ;IACV,IAAMC,CAAC,GAAkB,SAAAA,CAAA;MAAM,OAAAD,EAAE,EAAE;IAAJ,CAAK;IACpCC,CAAC,CAACC,OAAO,GAAG,UAAIC,GAAY;MAAK,OAAAN,OAAA,CAAAC,SAAS,CAACC,EAAE,CAAC;QAAM,OAAAI,GAAG,CAACF,CAAC,EAAE,CAAC;MAAR,CAAQ,CAAC;IAA5B,CAA4B;IAC7D,OAAOA,CAAC;EACZ,CAAC;EACL,OAAAR,eAAC;AAAD,CAAC,CApBD;AAAaI,OAAA,CAAAJ,eAAA,GAAAA,eAAA;AAsBb;;;AAGaI,OAAA,CAAAC,SAAS,GAAG,IAAIL,eAAe,EAAE;AAE9C;;;;;;;;AAQA,IAAAW,eAAA;EAAA,SAAAA,gBAAA,GA4BA;EA1BI;;;EAGAA,eAAA,CAAAV,SAAA,CAAAW,EAAE,GAAF;IACI,OAAOR,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACQ,CAAG;MAAG,OAAAA,CAAC;IAAD,CAAC,CAAC;EACjC,CAAC;EAED;;;;;EAKAH,eAAA,CAAAV,SAAA,CAAAC,QAAQ,GAAR,UAAcC,GAAK;IACf,OAAOC,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACQ,CAAG;MAAG,OAAAX,GAAG;IAAH,CAAG,CAAC;EACnC,CAAC;EAED;;;;EAIAQ,eAAA,CAAAV,SAAA,CAAAK,EAAE,GAAF,UAAQC,EAAW;IACf,IAAMC,CAAC,GAAoB,SAAAA,CAAAM,CAAC;MAAI,OAAAP,EAAE,CAACO,CAAC,CAAC;IAAL,CAAM;IACtCN,CAAC,CAACC,OAAO,GAAG,UAAIC,GAAY;MAAK,OAAAN,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACQ,CAAG;QAAK,OAAAJ,GAAG,CAACF,CAAC,CAACM,CAAC,CAAC,CAAC;MAAT,CAAS,CAAC;IAAhC,CAAgC;IACjEN,CAAC,CAACO,OAAO,GAAG,UAAIL,GAAY;MAAK,OAAAN,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACQ,CAAG;QAAK,OAAAN,CAAC,CAACE,GAAG,CAACI,CAAC,CAAC,CAAC;MAAT,CAAS,CAAC;IAAhC,CAAgC;IACjE,OAAON,CAAC;EACZ,CAAC;EACL,OAAAG,eAAC;AAAD,CAAC,CA5BD;AAAaP,OAAA,CAAAO,eAAA,GAAAA,eAAA;AA8Bb;;;AAGaP,OAAA,CAAAS,SAAS,GAAG,IAAIF,eAAe,EAAE;AAE9C;;;;;;;;AAQA,IAAAK,eAAA;EAAA,SAAAA,gBAAA,GAuBA;EAtBI;;;;;EAKAA,eAAA,CAAAf,SAAA,CAAAC,QAAQ,GAAR,UAAkBC,GAAK;IACnB,OAAOC,OAAA,CAAAa,SAAS,CAACX,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI;MAAG,OAAAf,GAAG;IAAH,CAAG,CAAC;EACzC,CAAC;EAED;;;;EAIAa,eAAA,CAAAf,SAAA,CAAAK,EAAE,GAAF,UAAYC,EAAiB;IACzB,IAAMC,CAAC,GAAwB,SAAAA,CAACM,CAAC,EAACI,CAAC;MAAG,OAAAX,EAAE,CAACO,CAAC,EAACI,CAAC,CAAC;IAAP,CAAQ;IAC9CV,CAAC,CAACC,OAAO,GAAG,UAAIC,GAAY;MAAK,OAAAN,OAAA,CAAAa,SAAS,CAACX,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI;QAAK,OAAAR,GAAG,CAACF,CAAC,CAACM,CAAC,EAACI,CAAC,CAAC,CAAC;MAAX,CAAW,CAAC;IAAxC,CAAwC;IACzEV,CAAC,CAACW,OAAO,GAAG;MAAM,OAAAf,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACQ,CAAI;QAAK,OAAAV,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACY,CAAI;UAAK,OAAAV,CAAC,CAACM,CAAC,EAACI,CAAC,CAAC;QAAN,CAAM,CAAC;MAA9B,CAA8B,CAAC;IAAtD,CAAsD;IACxEV,CAAC,CAACY,MAAM,GAAG;MAAM,OAAAhB,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACe,IAAY;QAAK,OAAAb,CAAC,CAACa,IAAI,CAAC,CAAC,CAAC,EAACA,IAAI,CAAC,CAAC,CAAC,CAAC;MAAlB,CAAkB,CAAC;IAAlD,CAAkD;IACnEb,CAAC,CAACc,OAAO,GAAG;MAAM,OAAAlB,OAAA,CAAAa,SAAS,CAACX,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI;QAAK,OAAAV,CAAC,CAACU,CAAC,EAACJ,CAAC,CAAC;MAAN,CAAM,CAAC;IAAnC,CAAmC;IACrDN,CAAC,CAACe,MAAM,GAAG,UAACT,CAAI;MAAK,OAAAV,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACY,CAAI;QAAK,OAAAV,CAAC,CAACM,CAAC,EAACI,CAAC,CAAC;MAAN,CAAM,CAAC;IAA9B,CAA8B;IACnD,OAAOV,CAAC;EACZ,CAAC;EACL,OAAAQ,eAAC;AAAD,CAAC,CAvBD;AAAaZ,OAAA,CAAAY,eAAA,GAAAA,eAAA;AAyBb;;;AAGaZ,OAAA,CAAAa,SAAS,GAAG,IAAID,eAAe,EAAE;AAE9C;;;;;;;;AAQA,IAAAQ,eAAA;EAAA,SAAAA,gBAAA,GAwBA;EAvBI;;;;;EAKAA,eAAA,CAAAvB,SAAA,CAAAC,QAAQ,GAAR,UAAqBC,GAAK;IACtB,OAAOC,OAAA,CAAAqB,SAAS,CAACnB,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI,EAACQ,CAAI;MAAG,OAAAvB,GAAG;IAAH,CAAG,CAAC;EAC9C,CAAC;EAED;;;;EAIAqB,eAAA,CAAAvB,SAAA,CAAAK,EAAE,GAAF,UAAeC,EAAsB;IACjC,IAAMC,CAAC,GAA2B,SAAAA,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC;MAAG,OAAAnB,EAAE,CAACO,CAAC,EAACI,CAAC,EAACQ,CAAC,CAAC;IAAT,CAAU;IACrDlB,CAAC,CAACC,OAAO,GAAG,UAAIC,GAAY;MAAK,OAAAN,OAAA,CAAAqB,SAAS,CAACnB,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI,EAACQ,CAAI;QAAK,OAAAhB,GAAG,CAACF,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,CAAC,CAAC;MAAb,CAAa,CAAC;IAA/C,CAA+C;IAChFlB,CAAC,CAACW,OAAO,GAAG;MAAM,OAAAf,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACQ,CAAI;QAAK,OAAAV,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACY,CAAI;UAAK,OAAAd,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACoB,CAAI;YAAK,OAAAlB,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,CAAC;UAAR,CAAQ,CAAC;QAAhC,CAAgC,CAAC;MAAxD,CAAwD,CAAC;IAAhF,CAAgF;IAClGlB,CAAC,CAACY,MAAM,GAAG;MAAM,OAAAhB,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACqB,KAAgB;QAAK,OAAAnB,CAAC,CAACmB,KAAK,CAAC,CAAC,CAAC,EAACA,KAAK,CAAC,CAAC,CAAC,EAACA,KAAK,CAAC,CAAC,CAAC,CAAC;MAA7B,CAA6B,CAAC;IAAjE,CAAiE;IAClFnB,CAAC,CAACc,OAAO,GAAG;MAAM,OAAAlB,OAAA,CAAAqB,SAAS,CAACnB,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI,EAACQ,CAAI;QAAK,OAAAlB,CAAC,CAACkB,CAAC,EAACR,CAAC,EAACJ,CAAC,CAAC;MAAR,CAAQ,CAAC;IAA1C,CAA0C;IAC5DN,CAAC,CAACe,MAAM,GAAG,UAACT,CAAI;MAAK,OAAAV,OAAA,CAAAa,SAAS,CAACX,EAAE,CAAC,UAACY,CAAI,EAACQ,CAAI;QAAK,OAAAlB,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,CAAC;MAAR,CAAQ,CAAC;IAArC,CAAqC;IAC1DlB,CAAC,CAACoB,MAAM,GAAG,UAACd,CAAI,EAACI,CAAI;MAAK,OAAAd,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACoB,CAAI;QAAK,OAAAlB,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,CAAC;MAAR,CAAQ,CAAC;IAAhC,CAAgC;IAC1D,OAAOlB,CAAC;EACZ,CAAC;EACL,OAAAgB,eAAC;AAAD,CAAC,CAxBD;AAAapB,OAAA,CAAAoB,eAAA,GAAAA,eAAA;AA0Bb;;;AAGapB,OAAA,CAAAqB,SAAS,GAAG,IAAID,eAAe,EAAE;AAE9C;;;;;;;;AAQA,IAAAK,eAAA;EAAA,SAAAA,gBAAA,GA4BA;EA1BI;;;;;EAKAA,eAAA,CAAA5B,SAAA,CAAAC,QAAQ,GAAR,UAAwBC,GAAK;IACzB,OAAOC,OAAA,CAAA0B,SAAS,CAACxB,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI,EAACQ,CAAI,EAACK,CAAI;MAAG,OAAA5B,GAAG;IAAH,CAAG,CAAC;EACnD,CAAC;EAED;;;;EAIA0B,eAAA,CAAA5B,SAAA,CAAAK,EAAE,GAAF,UAAkBC,EAA2B;IACzC,IAAMC,CAAC,GAA8B,SAAAA,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC;MAAG,OAAAxB,EAAE,CAACO,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,CAAC;IAAX,CAAY;IAC5DvB,CAAC,CAACC,OAAO,GAAG,UAAIC,GAAY;MAAK,OAAAN,OAAA,CAAA0B,SAAS,CAACxB,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI,EAACQ,CAAI,EAACK,CAAI;QAAK,OAAArB,GAAG,CAACF,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,CAAC,CAAC;MAAf,CAAe,CAAC;IAAtD,CAAsD;IACvFvB,CAAC,CAACW,OAAO,GAAG;MAAM,OAAAf,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACQ,CAAI;QAAK,OAAAV,OAAA,CAAAS,SAAS,CAACP,EAAE,CACjD,UAACY,CAAI;UAAK,OAAAd,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACoB,CAAI;YAAK,OAAAtB,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACyB,CAAI;cAAG,OAAAvB,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,CAAC;YAAV,CAAU,CAAC;UAAhC,CAAgC,CAAC;QAAxD,CAAwD,CAAC;MAD9B,CAC8B,CAAC;IADtD,CACsD;IACxEvB,CAAC,CAACY,MAAM,GAAG;MAAM,OAAAhB,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACqB,KAAmB;QAAK,OAAAnB,CAAC,CAACmB,KAAK,CAAC,CAAC,CAAC,EAACA,KAAK,CAAC,CAAC,CAAC,EAACA,KAAK,CAAC,CAAC,CAAC,EAACA,KAAK,CAAC,CAAC,CAAC,CAAC;MAAtC,CAAsC,CAAC;IAA7E,CAA6E;IAC9FnB,CAAC,CAACc,OAAO,GAAG;MAAM,OAAAlB,OAAA,CAAA0B,SAAS,CAACxB,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI,EAACQ,CAAI,EAACK,CAAI;QAAK,OAAAvB,CAAC,CAACuB,CAAC,EAACL,CAAC,EAACR,CAAC,EAACJ,CAAC,CAAC;MAAV,CAAU,CAAC;IAAjD,CAAiD;IACnEN,CAAC,CAACe,MAAM,GAAG,UAACT,CAAI;MAAK,OAAAV,OAAA,CAAAqB,SAAS,CAACnB,EAAE,CAAC,UAACY,CAAI,EAACQ,CAAI,EAACK,CAAI;QAAK,OAAAvB,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,CAAC;MAAV,CAAU,CAAC;IAA5C,CAA4C;IACjEvB,CAAC,CAACoB,MAAM,GAAG,UAACd,CAAI,EAACI,CAAI;MAAK,OAAAd,OAAA,CAAAa,SAAS,CAACX,EAAE,CAAC,UAACoB,CAAI,EAACK,CAAI;QAAK,OAAAvB,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,CAAC;MAAV,CAAU,CAAC;IAAvC,CAAuC;IACjEvB,CAAC,CAACwB,MAAM,GAAG,UAAClB,CAAI,EAACI,CAAI,EAACQ,CAAI;MAAK,OAAAtB,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACyB,CAAI;QAAK,OAAAvB,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,CAAC;MAAV,CAAU,CAAC;IAAlC,CAAkC;IACjE,OAAOvB,CAAC;EACZ,CAAC;EAEL,OAAAqB,eAAC;AAAD,CAAC,CA5BD;AAAazB,OAAA,CAAAyB,eAAA,GAAAA,eAAA;AA4BZ;AAED;;;AAGazB,OAAA,CAAA0B,SAAS,GAAG,IAAID,eAAe,EAAE;AAE9C;;;;;;;;AAQA,IAAAI,eAAA;EAAA,SAAAA,gBAAA,GA2BA;EA1BI;;;;;EAKAA,eAAA,CAAAhC,SAAA,CAAAC,QAAQ,GAAR,UAA2BC,GAAK;IAC5B,OAAOC,OAAA,CAAA8B,SAAS,CAAC5B,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI,EAACQ,CAAI,EAACK,CAAI,EAACI,CAAI;MAAG,OAAAhC,GAAG;IAAH,CAAG,CAAC;EACxD,CAAC;EAED;;;;EAIA8B,eAAA,CAAAhC,SAAA,CAAAK,EAAE,GAAF,UAAqBC,EAAgC;IACjD,IAAMC,CAAC,GAAiC,SAAAA,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,EAACI,CAAC;MAAG,OAAA5B,EAAE,CAACO,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,EAACI,CAAC,CAAC;IAAb,CAAc;IACnE3B,CAAC,CAACC,OAAO,GAAG,UAAIC,GAAY;MAAK,OAAAN,OAAA,CAAA8B,SAAS,CAAC5B,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI,EAACQ,CAAI,EAACK,CAAI,EAACI,CAAI;QAAK,OAAAzB,GAAG,CAACF,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,EAACI,CAAC,CAAC,CAAC;MAAjB,CAAiB,CAAC;IAA7D,CAA6D;IAC9F3B,CAAC,CAACW,OAAO,GAAG;MAAM,OAAAf,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACQ,CAAI;QAAK,OAAAV,OAAA,CAAAS,SAAS,CAACP,EAAE,CACjD,UAACY,CAAI;UAAK,OAAAd,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACoB,CAAI;YAAK,OAAAtB,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACyB,CAAI;cAAG,OAAA3B,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAAC6B,CAAI;gBAAK,OAAA3B,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,EAACI,CAAC,CAAC;cAAZ,CAAY,CAAC;YAApC,CAAoC,CAAC;UAA1D,CAA0D,CAAC;QAAlF,CAAkF,CAAC;MADxD,CACwD,CAAC;IADhF,CACgF;IAClG3B,CAAC,CAACY,MAAM,GAAG;MAAM,OAAAhB,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAACqB,KAAsB;QAAK,OAAAnB,CAAC,CAACmB,KAAK,CAAC,CAAC,CAAC,EAACA,KAAK,CAAC,CAAC,CAAC,EAACA,KAAK,CAAC,CAAC,CAAC,EAACA,KAAK,CAAC,CAAC,CAAC,EAACA,KAAK,CAAC,CAAC,CAAC,CAAC;MAA/C,CAA+C,CAAC;IAAzF,CAAyF;IAC1GnB,CAAC,CAACc,OAAO,GAAG;MAAM,OAAAlB,OAAA,CAAA8B,SAAS,CAAC5B,EAAE,CAAC,UAACQ,CAAI,EAACI,CAAI,EAACQ,CAAI,EAACK,CAAI,EAACI,CAAI;QAAK,OAAA3B,CAAC,CAAC2B,CAAC,EAACJ,CAAC,EAACL,CAAC,EAACR,CAAC,EAACJ,CAAC,CAAC;MAAZ,CAAY,CAAC;IAAxD,CAAwD;IAC1EN,CAAC,CAACe,MAAM,GAAG,UAACT,CAAI;MAAK,OAAAV,OAAA,CAAA0B,SAAS,CAACxB,EAAE,CAAC,UAACY,CAAI,EAACQ,CAAI,EAACK,CAAI,EAACI,CAAI;QAAK,OAAA3B,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,EAACI,CAAC,CAAC;MAAZ,CAAY,CAAC;IAAnD,CAAmD;IACxE3B,CAAC,CAACoB,MAAM,GAAG,UAACd,CAAI,EAACI,CAAI;MAAK,OAAAd,OAAA,CAAAqB,SAAS,CAACnB,EAAE,CAAC,UAACoB,CAAI,EAACK,CAAI,EAACI,CAAI;QAAK,OAAA3B,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,EAACI,CAAC,CAAC;MAAZ,CAAY,CAAC;IAA9C,CAA8C;IACxE3B,CAAC,CAACwB,MAAM,GAAG,UAAClB,CAAI,EAACI,CAAI,EAACQ,CAAI;MAAK,OAAAtB,OAAA,CAAAa,SAAS,CAACX,EAAE,CAAC,UAACyB,CAAI,EAACI,CAAI;QAAK,OAAA3B,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,EAACI,CAAC,CAAC;MAAZ,CAAY,CAAC;IAAzC,CAAyC;IACxE3B,CAAC,CAAC4B,MAAM,GAAG,UAACtB,CAAI,EAACI,CAAI,EAACQ,CAAI,EAACK,CAAI;MAAK,OAAA3B,OAAA,CAAAS,SAAS,CAACP,EAAE,CAAC,UAAC6B,CAAI;QAAK,OAAA3B,CAAC,CAACM,CAAC,EAACI,CAAC,EAACQ,CAAC,EAACK,CAAC,EAACI,CAAC,CAAC;MAAZ,CAAY,CAAC;IAApC,CAAoC;IACxE,OAAO3B,CAAC;EACZ,CAAC;EACL,OAAAyB,eAAC;AAAD,CAAC,CA3BD;AAAa7B,OAAA,CAAA6B,eAAA,GAAAA,eAAA;AA6Bb;;;AAGa7B,OAAA,CAAA8B,SAAS,GAAG,IAAID,eAAe,EAAE","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}