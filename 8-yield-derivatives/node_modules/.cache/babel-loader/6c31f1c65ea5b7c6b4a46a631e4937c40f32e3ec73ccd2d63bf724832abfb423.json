{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar Value_1 = require(\"./Value\");\nvar Option_1 = require(\"./Option\");\nvar HashMap_1 = require(\"./HashMap\");\nvar HashSet_1 = require(\"./HashSet\");\nvar Comparison_1 = require(\"./Comparison\");\nvar SeqHelpers = require(\"./SeqHelpers\");\nvar L = require(\"list\");\n/**\n * A general-purpose list class with all-around good performance.\n * quasi-O(1) (actually O(log32(n))) access, append, replace.\n * It's backed by a bit-mapped vector trie.\n * @param T the item type\n */\nvar Vector = /** @class */function () {\n  /**\n   * @hidden\n   */\n  // _contents will be undefined only if length===0\n  function Vector(_list) {\n    this._list = _list;\n  }\n  /**\n   * The empty vector.\n   * @param T the item type\n   */\n  Vector.empty = function () {\n    return new Vector(L.empty());\n  };\n  /**\n   * Build a vector from a series of items (any number, as parameters)\n   * @param T the item type\n   */\n  Vector.of = function () {\n    var data = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      data[_i] = arguments[_i];\n    }\n    return Vector.ofIterable(data);\n  };\n  /**\n   * Build a vector from any iterable, which means also\n   * an array for instance.\n   * @param T the item type\n   */\n  Vector.ofIterable = function (elts) {\n    return new Vector(L.from(elts));\n  };\n  /**\n   * Curried predicate to find out whether the vector is empty.\n   *\n   *     LinkedList.of(Vector.of(1), Vector.empty<number>())\n   *         .filter(Vector.isEmpty)\n   *     => LinkedList.of(Vector.empty<number>())\n   */\n  Vector.isEmpty = function (v) {\n    return v.isEmpty();\n  };\n  /**\n   * Curried predicate to find out whether the vector is empty.\n   *\n   *     LinkedList.of(Vector.of(1), Vector.empty<number>())\n   *         .filter(Vector.isNotEmpty)\n   *     => LinkedList.of(Vector.of(1))\n   */\n  Vector.isNotEmpty = function (v) {\n    return !v.isEmpty();\n  };\n  /**\n   * Get the length of the collection.\n   */\n  Vector.prototype.length = function () {\n    return L.length(this._list);\n  };\n  /**\n   * true if the collection is empty, false otherwise.\n   */\n  Vector.prototype.isEmpty = function () {\n    return L.length(this._list) === 0;\n  };\n  /**\n   * Dual to the foldRight function. Build a collection from a seed.\n   * Takes a starting element and a function.\n   * It applies the function on the starting element; if the\n   * function returns None, it stops building the list, if it\n   * returns Some of a pair, it adds the first element to the result\n   * and takes the second element as a seed to keep going.\n   *\n   *     Vector.unfoldRight(\n   *          10, x=>Option.of(x)\n   *              .filter(x => x!==0)\n   *              .map<[number,number]>(x => [x,x-1]))\n   *     => Vector.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n   */\n  Vector.unfoldRight = function (seed, fn) {\n    var nextVal = fn(seed);\n    var r = L.empty();\n    while (nextVal.isSome()) {\n      r = L.append(nextVal.get()[0], r);\n      nextVal = fn(nextVal.get()[1]);\n    }\n    return new Vector(r);\n  };\n  /**\n   * Retrieve the element at index idx.\n   * Returns an option because the collection may\n   * contain less elements than the index.\n   */\n  Vector.prototype.get = function (index) {\n    return Option_1.Option.of(L.nth(index, this._list));\n  };\n  /**\n   * If the collection contains a single element,\n   * return Some of its value, otherwise return None.\n   */\n  Vector.prototype.single = function () {\n    return L.length(this._list) === 1 ? this.head() : Option_1.Option.none();\n  };\n  /**\n   * Replace the value of element at the index you give.\n   * Will throw if the index is out of bounds!\n   */\n  Vector.prototype.replace = function (index, val) {\n    if (index >= this.length() || index < 0) {\n      throw new Error('Vector.replace: index is out of range: ' + index);\n    }\n    return new Vector(L.update(index, val, this._list));\n  };\n  /**\n   * Replace the first occurence (if any) of the element you give by\n   * the new value you give.\n   *\n   *     Vector.of(1, 2, 3, 4, 2).replaceFirst(2, 5)\n   *     => Vector.of(1, 5, 3, 4, 2)\n   *\n   */\n  Vector.prototype.replaceFirst = function (element, newVal) {\n    // it's a little annoying that areEqual will check whether the element\n    // has an equals function for each element in the list, but then\n    // what if the list allows null or undefined and the newVal is null or\n    // undefined? With type erasure then I don't know what equality to use\n    // on the next elements\n    var index = L.findIndex(function (v) {\n      return Comparison_1.areEqual(v, element);\n    }, this._list);\n    return index >= 0 ? new Vector(L.update(index, newVal, this._list)) : this;\n  };\n  /**\n   * Replace all occurences of the element you give by\n   * the new value you give.\n   *\n   *     Vector.of(1, 2, 3, 4, 2).replaceAll(2, 5)\n   *     => Vector.of(1, 5, 3, 4, 5)\n   *\n   */\n  Vector.prototype.replaceAll = function (element, newVal) {\n    // if we're going to update many elements, then append in a loop\n    // would give better perf (not copying multiple times the same slice).\n    // if we won't update that many, update in a loop would give better perf...\n    // assuming it's the latter case.\n    var idx = 0;\n    return this.foldLeft(this, function (sofar, cur) {\n      var r = Comparison_1.areEqual(cur, element) ? new Vector(L.update(idx, newVal, sofar._list)) : sofar;\n      ++idx;\n      return r;\n    });\n  };\n  /**\n   * Append an element at the end of the collection.\n   */\n  Vector.prototype.append = function (val) {\n    return new Vector(L.append(val, this._list));\n  };\n  /**\n   * Append multiple elements at the end of the collection.\n   * Note that arrays are also iterables.\n   */\n  Vector.prototype.appendAll = function (elts) {\n    if (elts._list && elts.replace) {\n      // elts is a vector too\n      return new Vector(L.concat(this._list, elts._list));\n    }\n    return new Vector(L.concat(this._list, L.from(elts)));\n  };\n  /**\n   * Remove multiple elements from a vector\n   *\n   *     Vector.of(1,2,3,4,3,2,1).removeAll([2,4])\n   *     => Vector.of(1,3,3,1)\n   */\n  Vector.prototype.removeAll = function (elts) {\n    return SeqHelpers.removeAll(this, elts);\n  };\n  /**\n   * Get the first value of the collection, if any.\n   * returns Option.Some if the collection is not empty,\n   * Option.None if it's empty.\n   */\n  Vector.prototype.head = function () {\n    return this.get(0);\n  };\n  /**\n   * Get the last value of the collection, if any.\n   * returns Option.Some if the collection is not empty,\n   * Option.None if it's empty.\n   */\n  Vector.prototype.last = function () {\n    return Option_1.Option.of(L.last(this._list));\n  };\n  /**\n   * Return a new vector containing all the elements in this\n   * vector except the last one, or the empty vector if this\n   * is the empty vector.\n   *\n   *     Vector.of(1,2,3).init()\n   *     => Vector.of(1,2)\n   */\n  Vector.prototype.init = function () {\n    return new Vector(L.pop(this._list));\n  };\n  /**\n   * Returns a new collection, discarding the first elements\n   * until one element fails the predicate. All elements\n   * after that point are retained.\n   */\n  Vector.prototype.dropWhile = function (predicate) {\n    return new Vector(L.dropWhile(predicate, this._list));\n  };\n  /**\n   * Search for the first item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   */\n  Vector.prototype.find = function (predicate) {\n    return Option_1.Option.of(L.find(predicate, this._list));\n  };\n  /**\n   * Search for the last item matching the predicate you pass,\n   * return Option.Some of that element if found,\n   * Option.None otherwise.\n   */\n  Vector.prototype.findLast = function (predicate) {\n    return Option_1.Option.of(L.findLast(predicate, this._list));\n  };\n  /**\n   * Search for the first item matching the predicate you pass,\n   * returning its index in the form of Option.Some if found,\n   * Option.None otherwise.\n   */\n  Vector.prototype.findIndex = function (predicate) {\n    return Option_1.Option.of(L.findIndex(predicate, this._list)).filter(function (i) {\n      return i != -1;\n    });\n  };\n  Vector.prototype.allMatch = function (predicate) {\n    return L.every(predicate, this._list);\n  };\n  /**\n   * Returns true if there the predicate returns true for any\n   * element in the collection.\n   */\n  Vector.prototype.anyMatch = function (predicate) {\n    return L.some(predicate, this._list);\n  };\n  Vector.prototype.partition = function (predicate) {\n    return L.partition(predicate, this._list).map(function (x) {\n      return new Vector(x);\n    });\n  };\n  /**\n   * Returns true if the item is in the collection,\n   * false otherwise.\n   */\n  Vector.prototype.contains = function (v) {\n    return this.find(function (x) {\n      return Comparison_1.areEqual(x, v);\n    }).isSome();\n  };\n  /**\n   * Group elements in the collection using a classifier function.\n   * Elements are then organized in a map. The key is the value of\n   * the classifier, and in value we get the list of elements\n   * matching that value.\n   *\n   * also see [[Vector.arrangeBy]]\n   */\n  Vector.prototype.groupBy = function (classifier) {\n    return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, v) {\n      return acc.putWithMerge(classifier(v), Vector.of(v),\n      // !!! DOUBLE CHECK THIS\n      function (v1, v2) {\n        return v1.append(L.nth(0, v2._list));\n      });\n    });\n  };\n  /**\n   * Matches each element with a unique key that you extract from it.\n   * If the same key is present twice, the function will return None.\n   *\n   * also see [[Vector.groupBy]]\n   */\n  Vector.prototype.arrangeBy = function (getKey) {\n    return SeqHelpers.arrangeBy(this, getKey);\n  };\n  /**\n   * Remove duplicate items; elements are mapped to keys, those\n   * get compared.\n   *\n   *     Vector.of(1,1,2,3,2,3,1).distinctBy(x => x);\n   *     => Vector.of(1,2,3)\n   */\n  Vector.prototype.distinctBy = function (keyExtractor) {\n    return SeqHelpers.distinctBy(this, keyExtractor);\n  };\n  Vector.prototype[Symbol.iterator] = function () {\n    return this._list[Symbol.iterator]();\n  };\n  /**\n   * Call a function for element in the collection.\n   */\n  Vector.prototype.forEach = function (fun) {\n    L.forEach(fun, this._list);\n    return this;\n  };\n  /**\n   * Return a new collection where each element was transformed\n   * by the mapper function you give.\n   */\n  Vector.prototype.map = function (fun) {\n    return new Vector(L.map(fun, this._list));\n  };\n  Vector.prototype.filter = function (fun) {\n    return new Vector(L.filter(fun, this._list));\n  };\n  /**\n   * Apply the mapper function on every element of this collection.\n   * The mapper function returns an Option; if the Option is a Some,\n   * the value it contains is added to the result Collection, if it's\n   * a None, the value is discarded.\n   *\n   *     Vector.of(1,2,6).mapOption(x => x%2===0 ?\n   *         Option.of(x+1) : Option.none<number>())\n   *     => Vector.of(3, 7)\n   */\n  Vector.prototype.mapOption = function (mapper) {\n    var vec = L.empty();\n    for (var i = 0; i < this.length(); i++) {\n      var v = mapper(L.nth(i, this._list));\n      if (v.isSome()) {\n        vec = L.append(v.get(), vec);\n      }\n    }\n    return new Vector(vec);\n  };\n  /**\n   * Calls the function you give for each item in the collection,\n   * your function returns a collection, all the collections are\n   * concatenated.\n   * This is the monadic bind.\n   */\n  Vector.prototype.flatMap = function (mapper) {\n    return new Vector(L.chain(function (x) {\n      return mapper(x)._list;\n    }, this._list));\n  };\n  /**\n   * Reduces the collection to a single value using the\n   * associative binary function you give. Since the function\n   * is associative, order of application doesn't matter.\n   *\n   * Example:\n   *\n   *     Vector.of(1,2,3).fold(0, (a,b) => a + b);\n   *     => 6\n   */\n  Vector.prototype.fold = function (zero, fn) {\n    return this.foldLeft(zero, fn);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Left-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n   *     => \"cba!\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the previous value and\n   *           the current collection item, and returning\n   *           an updated value.\n   */\n  Vector.prototype.foldLeft = function (zero, fn) {\n    return L.foldl(fn, zero, this._list);\n  };\n  /**\n   * Reduces the collection to a single value.\n   * Right-associative.\n   *\n   * Example:\n   *\n   *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n   *     => \"!cba\"\n   *\n   * @param zero The initial value\n   * @param fn A function taking the current collection item and\n   *           the previous value , and returning\n   *           an updated value.\n   */\n  Vector.prototype.foldRight = function (zero, fn) {\n    return L.foldr(fn, zero, this._list);\n  };\n  /**\n   * Returns the index of the first occurence of the value you give, if present\n   *\n   *     Vector.of(1, 2, 3, 4, 3).indexOf(3)\n   *     => Option.of(2)\n   */\n  Vector.prototype.indexOf = function (element) {\n    return Option_1.Option.of(L.findIndex(function (v) {\n      return Comparison_1.areEqual(v, element);\n    }, this._list)).filter(function (i) {\n      return i >= 0;\n    });\n  };\n  /**\n   * Randomly reorder the elements of the collection.\n   */\n  Vector.prototype.shuffle = function () {\n    return Vector.ofIterable(SeqHelpers.shuffle(this.toArray()));\n  };\n  /**\n   * Transform this value to another value type.\n   * Enables fluent-style programming by chaining calls.\n   */\n  Vector.prototype.transform = function (converter) {\n    return converter(this);\n  };\n  /**\n   * Two objects are equal if they represent the same value,\n   * regardless of whether they are the same object physically\n   * in memory.\n   */\n  Vector.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || !other._list || !L.isList(other._list)) {\n      return false;\n    }\n    if (this.length() !== other.length()) return false;\n    for (var i = 0; i < this.length(); i++) {\n      var myVal = L.nth(i, this._list);\n      var hisVal = L.nth(i, other._list);\n      if (myVal === undefined !== (hisVal === undefined)) {\n        return false;\n      }\n      if (myVal === undefined || hisVal === undefined) {\n        // they are both undefined, the || is for TS's flow analysis\n        // so he realizes none of them is undefined after this.\n        continue;\n      }\n      if (!Comparison_1.areEqual(myVal, hisVal)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Get a number for that object. Two different values\n   * may get the same number, but one value must always get\n   * the same number. The formula can impact performance.\n   */\n  Vector.prototype.hashCode = function () {\n    var hash = 1;\n    for (var i = 0; i < this.length(); i++) {\n      hash = 31 * hash + Comparison_1.getHashCode(L.nth(i, this._list));\n    }\n    return hash;\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   *\n   * Also see [[Vector.mkString]]\n   */\n  Vector.prototype.toString = function () {\n    var r = \"Vector(\";\n    for (var i = 0; i < this.length(); i++) {\n      if (i > 0) {\n        r += \", \";\n      }\n      r += SeqHelpers.toStringHelper(L.nth(i, this._list));\n    }\n    return r + \")\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   * Most of the time should be the same as toString()\n   */\n  Vector.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  /**\n   * Joins elements of the collection by a separator.\n   * Example:\n   *\n   *     Vector.of(1,2,3).mkString(\", \")\n   *     => \"1, 2, 3\"\n   */\n  Vector.prototype.mkString = function (separator) {\n    var r = \"\";\n    for (var i = 0; i < this.length(); i++) {\n      if (i > 0) {\n        r += separator;\n      }\n      r += SeqHelpers.toStringHelper(L.nth(i, this._list), {\n        quoteStrings: false\n      });\n    }\n    return r;\n  };\n  /**\n   * Returns a new collection with elements\n   * sorted according to the comparator you give.\n   *\n   * also see [[Vector.sortOn]]\n   */\n  Vector.prototype.sortBy = function (compare) {\n    return Vector.ofIterable(this.toArray().sort(compare));\n  };\n  /**\n   * Give a function associating a number or a string with\n   * elements from the collection, and the elements\n   * are sorted according to that value.\n   *\n   *     Vector.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n   *     => Vector.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n   *\n   * You can also sort by multiple criteria, and request 'descending'\n   * sorting:\n   *\n   *     Vector.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n   *     => Vector.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n   *\n   * also see [[Vector.sortBy]]\n   */\n  Vector.prototype.sortOn = function () {\n    var getKeys = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      getKeys[_i] = arguments[_i];\n    }\n    return SeqHelpers.sortOn(this, getKeys);\n  };\n  /**\n   * Convert this collection to a map. You give a function which\n   * for each element in the collection returns a pair. The\n   * key of the pair will be used as a key in the map, the value,\n   * as a value in the map. If several values get the same key,\n   * entries will be lost.\n   *\n   *     Vector.of(1,2,3).toMap(x=>[x.toString(), x])\n   *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n   */\n  Vector.prototype.toMap = function (converter) {\n    return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, cur) {\n      var converted = converter(cur);\n      return acc.put(converted[0], converted[1]);\n    });\n  };\n  /**\n   * Convert this collection to a set. Since the elements of the\n   * Seq may not support equality, you must pass a function returning\n   * a value supporting equality.\n   *\n   *     Vector.of(1,2,3,3,4).toSet(x=>x)\n   *     => HashSet.of(1,2,3,4)\n   */\n  Vector.prototype.toSet = function (converter) {\n    return this.foldLeft(HashSet_1.HashSet.empty(), function (acc, cur) {\n      return acc.add(converter(cur));\n    });\n  };\n  /**\n   * Convert to array.\n   */\n  Vector.prototype.toArray = function () {\n    return L.toArray(this._list);\n  };\n  ;\n  /**\n   * @hidden\n   */\n  Vector.prototype.hasTrueEquality = function () {\n    return SeqHelpers.seqHasTrueEquality(this);\n  };\n  /**\n   * Combine any number of iterables you give in as\n   * parameters to produce a new collection which combines all,\n   * in tuples. For instance:\n   *\n   *     Vector.zip(Vector.of(1,2,3), [\"a\",\"b\",\"c\"], LinkedList.of(8,9,10))\n   *     => Vector.of([1,\"a\",8], [2,\"b\",9], [3,\"c\",10])\n   *\n   * The result collection will have the length of the shorter\n   * of the input iterables. Extra elements will be discarded.\n   *\n   * Also see [the non-static version](#zip), which only combines two\n   * collections.\n   * @param A A is the type of the tuple that'll be generated\n   *          (`[number,string,number]` for the code sample)\n   */\n  Vector.zip = function () {\n    var iterables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      iterables[_i] = arguments[_i];\n    }\n    var r = L.empty();\n    var iterators = iterables.map(function (i) {\n      return i[Symbol.iterator]();\n    });\n    var items = iterators.map(function (i) {\n      return i.next();\n    });\n    while (!items.some(function (item) {\n      return item.done;\n    })) {\n      r = L.append(items.map(function (item) {\n        return item.value;\n      }), r);\n      items = iterators.map(function (i) {\n        return i.next();\n      });\n    }\n    return new Vector(r);\n  };\n  /**\n   * Combine this collection with the collection you give in\n   * parameter to produce a new collection which combines both,\n   * in pairs. For instance:\n   *\n   *     Vector.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n   *     => Vector.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n   *\n   * The result collection will have the length of the shorter\n   * of both collections. Extra elements will be discarded.\n   *\n   * Also see [[Vector.zip]] (static version which can more than two\n   * iterables)\n   */\n  Vector.prototype.zip = function (other) {\n    var r = L.empty();\n    var thisIterator = this[Symbol.iterator]();\n    var otherIterator = other[Symbol.iterator]();\n    var thisCurItem = thisIterator.next();\n    var otherCurItem = otherIterator.next();\n    while (!thisCurItem.done && !otherCurItem.done) {\n      r = L.append([thisCurItem.value, otherCurItem.value], r);\n      thisCurItem = thisIterator.next();\n      otherCurItem = otherIterator.next();\n    }\n    return new Vector(r);\n  };\n  /**\n   * Reverse the collection. For instance:\n   *\n   *     Vector.of(1,2,3).reverse();\n   *     => Vector.of(3,2,1)\n   */\n  Vector.prototype.reverse = function () {\n    return new Vector(L.reverse(this._list));\n  };\n  /**\n   * Combine this collection with the index of the elements\n   * in it. Handy if you need the index when you map on\n   * the collection for instance:\n   *\n   *     Vector.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx)\n   *     => Vector.of(\"a0\", \"b1\")\n   */\n  Vector.prototype.zipWithIndex = function () {\n    return SeqHelpers.zipWithIndex(this);\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate.\n   */\n  Vector.prototype.takeWhile = function (predicate) {\n    return new Vector(L.takeWhile(predicate, this._list));\n  };\n  /**\n   * Returns a new collection, discarding the elements\n   * after the first element which fails the predicate,\n   * but starting from the end of the collection.\n   *\n   *     Vector.of(1,2,3,4).takeRightWhile(x => x > 2)\n   *     => Vector.of(3,4)\n   */\n  Vector.prototype.takeRightWhile = function (predicate) {\n    return new Vector(L.takeLastWhile(predicate, this._list));\n  };\n  /**\n   * Split the collection at a specific index.\n   *\n   *     Vector.of(1,2,3,4,5).splitAt(3)\n   *     => [Vector.of(1,2,3), Vector.of(4,5)]\n   */\n  Vector.prototype.splitAt = function (index) {\n    if (index < 0) {\n      return [Vector.empty(), this];\n    }\n    return L.splitAt(index, this._list).map(function (x) {\n      return new Vector(x);\n    });\n  };\n  /**\n   * Takes a predicate; returns a pair of collections.\n   * The first one is the longest prefix of this collection\n   * which satisfies the predicate, and the second collection\n   * is the remainder of the collection.\n   *\n   *    Vector.of(1,2,3,4,5,6).span(x => x <3)\n   *    => [Vector.of(1,2), Vector.of(3,4,5,6)]\n   */\n  Vector.prototype.span = function (predicate) {\n    // could be potentially faster using splitAt.\n    var first = this.takeWhile(predicate);\n    return [first, this.drop(first.length())];\n  };\n  /**\n   * Returns a new collection with the first\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  Vector.prototype.drop = function (n) {\n    return new Vector(L.drop(n, this._list));\n  };\n  /**\n   * Return a new collection containing the first n\n   * elements from this collection\n   *\n   *     Vector.of(1,2,3,4).take(2)\n   *     => Vector.of(1,2)\n   */\n  Vector.prototype.take = function (n) {\n    if (n < 0) {\n      return Vector.empty();\n    }\n    return new Vector(L.take(n, this._list));\n  };\n  /**\n   * Prepend an element at the beginning of the collection.\n   */\n  Vector.prototype.prepend = function (elt) {\n    return new Vector(L.prepend(elt, this._list));\n  };\n  /**\n   * Prepend multiple elements at the beginning of the collection.\n   */\n  Vector.prototype.prependAll = function (elts) {\n    return Vector.ofIterable(elts).appendAll(this);\n  };\n  /**\n   * Removes the first element matching the predicate\n   * (use [[Seq.filter]] to remove all elements matching a predicate)\n   */\n  Vector.prototype.removeFirst = function (predicate) {\n    var v1 = this.takeWhile(function (x) {\n      return !predicate(x);\n    });\n    return v1.appendAll(this.drop(v1.length() + 1));\n  };\n  /**\n   * Returns a new collection with the last\n   * n elements discarded.\n   * If the collection has less than n elements,\n   * returns the empty collection.\n   */\n  Vector.prototype.dropRight = function (n) {\n    if (n >= this.length()) {\n      return Vector.empty();\n    }\n    return new Vector(L.dropLast(n, this._list));\n  };\n  /**\n   * Returns a new collection, discarding the last elements\n   * until one element fails the predicate. All elements\n   * before that point are retained.\n   */\n  Vector.prototype.dropRightWhile = function (predicate) {\n    var i = this.length() - 1;\n    for (; i >= 0; i--) {\n      if (!predicate(L.nth(i, this._list))) {\n        return this.take(i + 1);\n      }\n    }\n    return Vector.empty();\n  };\n  /**\n   * Get all the elements in the collection but the first one.\n   * If the collection is empty, return None.\n   */\n  Vector.prototype.tail = function () {\n    if (this.isEmpty()) {\n      return Option_1.Option.none();\n    }\n    return Option_1.Option.of(new Vector(L.tail(this._list)));\n  };\n  /**\n   * Reduces the collection to a single value by repeatedly\n   * calling the combine function.\n   * No starting value. The order in which the elements are\n   * passed to the combining function is undetermined.\n   */\n  Vector.prototype.reduce = function (combine) {\n    return SeqHelpers.reduce(this, combine);\n  };\n  /**\n   * Compare values in the collection and return the smallest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[Vector.minOn]]\n   */\n  Vector.prototype.minBy = function (compare) {\n    return SeqHelpers.minBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the smallest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     Vector.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n   *     => Option.of({name:\"Paula\", age:6})\n   *\n   * also see [[Vector.minBy]]\n   */\n  Vector.prototype.minOn = function (getOrderable) {\n    return SeqHelpers.minOn(this, getOrderable);\n  };\n  /**\n   * Compare values in the collection and return the largest element.\n   * Returns Option.none if the collection is empty.\n   *\n   * also see [[Vector.maxOn]]\n   */\n  Vector.prototype.maxBy = function (compare) {\n    return SeqHelpers.maxBy(this, compare);\n  };\n  /**\n   * Call the function you give for each value in the collection\n   * and return the element for which the result was the largest.\n   * Returns Option.none if the collection is empty.\n   *\n   *     Vector.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n   *     => Option.of({name:\"Joe\", age:12})\n   *\n   * also see [[Vector.maxBy]]\n   */\n  Vector.prototype.maxOn = function (getOrderable) {\n    return SeqHelpers.maxOn(this, getOrderable);\n  };\n  /**\n   * Call the function you give for each element in the collection\n   * and sum all the numbers, return that sum.\n   * Will return 0 if the collection is empty.\n   *\n   *     Vector.of(1,2,3).sumOn(x=>x)\n   *     => 6\n   */\n  Vector.prototype.sumOn = function (getNumber) {\n    return SeqHelpers.sumOn(this, getNumber);\n  };\n  /**\n   * Slides a window of a specific size over the sequence.\n   * Returns a lazy stream so memory use is not prohibitive.\n   *\n   *     Vector.of(1,2,3,4,5,6,7,8).sliding(3)\n   *     => Stream.of(Vector.of(1,2,3), Vector.of(4,5,6), Vector.of(7,8))\n   */\n  Vector.prototype.sliding = function (count) {\n    return SeqHelpers.sliding(this, count);\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   * The last element of the result is the final cumulative result.\n   *\n   *     Vector.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n   *     => Vector.of(0,1,3,6)\n   */\n  Vector.prototype.scanLeft = function (init, fn) {\n    return new Vector(L.scan(fn, init, this._list));\n  };\n  /**\n   * Apply the function you give to all elements of the sequence\n   * in turn, keeping the intermediate results and returning them\n   * along with the final result in a list.\n   * The first element of the result is the final cumulative result.\n   *\n   *     Vector.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n   *     => Vector.of(6,5,3,0)\n   */\n  Vector.prototype.scanRight = function (init, fn) {\n    var r = [];\n    r.unshift(init);\n    var cur = init;\n    for (var i = this.length() - 1; i >= 0; i--) {\n      cur = fn(L.nth(i, this._list), cur);\n      r.unshift(cur);\n    }\n    return Vector.ofIterable(r);\n  };\n  return Vector;\n}();\nexports.Vector = Vector;","map":{"version":3,"names":["Value_1","require","Option_1","HashMap_1","HashSet_1","Comparison_1","SeqHelpers","L","Vector","_list","empty","of","data","_i","arguments","length","ofIterable","elts","from","isEmpty","v","isNotEmpty","prototype","unfoldRight","seed","fn","nextVal","r","isSome","append","get","index","Option","nth","single","head","none","replace","val","Error","update","replaceFirst","element","newVal","findIndex","areEqual","replaceAll","idx","foldLeft","sofar","cur","appendAll","concat","removeAll","last","init","pop","dropWhile","predicate","find","findLast","filter","i","allMatch","every","anyMatch","some","partition","map","x","contains","groupBy","classifier","HashMap","acc","putWithMerge","v1","v2","arrangeBy","getKey","distinctBy","keyExtractor","Symbol","iterator","forEach","fun","mapOption","mapper","vec","flatMap","chain","fold","zero","foldl","foldRight","foldr","indexOf","shuffle","toArray","transform","converter","equals","other","isList","myVal","hisVal","undefined","hashCode","hash","getHashCode","toString","toStringHelper","inspect","mkString","separator","quoteStrings","sortBy","compare","sort","sortOn","getKeys","toMap","converted","put","toSet","HashSet","add","hasTrueEquality","seqHasTrueEquality","zip","iterables","iterators","items","next","item","done","value","thisIterator","otherIterator","thisCurItem","otherCurItem","reverse","zipWithIndex","takeWhile","takeRightWhile","takeLastWhile","splitAt","span","first","drop","n","take","prepend","elt","prependAll","removeFirst","dropRight","dropLast","dropRightWhile","tail","reduce","combine","minBy","minOn","getOrderable","maxBy","maxOn","sumOn","getNumber","sliding","count","scanLeft","scan","scanRight","unshift","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/src/Vector.ts"],"sourcesContent":["import { inspect } from './Value';\nimport { Option } from \"./Option\";\nimport { HashMap } from \"./HashMap\";\nimport { HashSet } from \"./HashSet\";\nimport { Stream } from \"./Stream\";\nimport { Seq, IterableArray } from \"./Seq\";\nimport { WithEquality, areEqual, getHashCode,\n         Ordering, ToOrderable } from \"./Comparison\";\nimport * as SeqHelpers from \"./SeqHelpers\";\nimport * as L from \"list\";\n\n/**\n * A general-purpose list class with all-around good performance.\n * quasi-O(1) (actually O(log32(n))) access, append, replace.\n * It's backed by a bit-mapped vector trie.\n * @param T the item type\n */\nexport class Vector<T> implements Seq<T> {\n\n    /**\n     * @hidden\n     */\n    // _contents will be undefined only if length===0\n    protected constructor(private _list: L.List<T>) {}\n\n    /**\n     * The empty vector.\n     * @param T the item type\n     */\n    static empty<T>(): Vector<T> {\n        return new Vector(L.empty());\n    }\n\n    /**\n     * Build a vector from a series of items (any number, as parameters)\n     * @param T the item type\n     */\n    static of<T>(...data: T[]): Vector<T> {\n        return Vector.ofIterable(data);\n    }\n\n    /**\n     * Build a vector from any iterable, which means also\n     * an array for instance.\n     * @param T the item type\n     */\n    static ofIterable<T>(elts: Iterable<T>): Vector<T> {\n        return new Vector(L.from(elts));\n    }\n\n    /**\n     * Curried predicate to find out whether the vector is empty.\n     *\n     *     LinkedList.of(Vector.of(1), Vector.empty<number>())\n     *         .filter(Vector.isEmpty)\n     *     => LinkedList.of(Vector.empty<number>())\n     */\n    static isEmpty<T>(v: Vector<T>): boolean {\n        return v.isEmpty();\n    }\n\n    /**\n     * Curried predicate to find out whether the vector is empty.\n     *\n     *     LinkedList.of(Vector.of(1), Vector.empty<number>())\n     *         .filter(Vector.isNotEmpty)\n     *     => LinkedList.of(Vector.of(1))\n     */\n    static isNotEmpty<T>(v: Vector<T>): boolean {\n        return !v.isEmpty();\n    }\n\n    /**\n     * Get the length of the collection.\n     */\n    length(): number {\n        return L.length(this._list);\n    }\n\n    /**\n     * true if the collection is empty, false otherwise.\n     */\n    isEmpty(): boolean {\n        return L.length(this._list) === 0;\n    }\n\n    /**\n     * Dual to the foldRight function. Build a collection from a seed.\n     * Takes a starting element and a function.\n     * It applies the function on the starting element; if the\n     * function returns None, it stops building the list, if it\n     * returns Some of a pair, it adds the first element to the result\n     * and takes the second element as a seed to keep going.\n     *\n     *     Vector.unfoldRight(\n     *          10, x=>Option.of(x)\n     *              .filter(x => x!==0)\n     *              .map<[number,number]>(x => [x,x-1]))\n     *     => Vector.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n     */\n    static unfoldRight<T,U>(seed: T, fn: (x:T)=>Option<[U,T]>): Vector<U> {\n        let nextVal = fn(seed);\n        let r = L.empty();\n        while (nextVal.isSome()) {\n            r = L.append(nextVal.get()[0], r);\n            nextVal = fn(nextVal.get()[1]);\n        }\n        return new Vector(r);\n    }\n\n    /**\n     * Retrieve the element at index idx.\n     * Returns an option because the collection may\n     * contain less elements than the index.\n     */\n    get(index: number): Option<T> {\n        return Option.of(L.nth(index, this._list));\n    }\n\n    /**\n     * If the collection contains a single element,\n     * return Some of its value, otherwise return None.\n     */\n    single(): Option<T> {\n        return L.length(this._list) === 1 ?\n            this.head() :\n            Option.none<T>();\n    }\n\n    /**\n     * Replace the value of element at the index you give.\n     * Will throw if the index is out of bounds!\n     */\n    replace(index: number, val: T): Vector<T> {\n        if (index >= this.length() || index < 0) {\n            throw new Error('Vector.replace: index is out of range: ' + index);\n        }\n        return new Vector(L.update(index, val, this._list));\n    }\n\n    /**\n     * Replace the first occurence (if any) of the element you give by\n     * the new value you give.\n     *\n     *     Vector.of(1, 2, 3, 4, 2).replaceFirst(2, 5)\n     *     => Vector.of(1, 5, 3, 4, 2)\n     * \n     */\n    replaceFirst(element: T&WithEquality, newVal: T&WithEquality): Vector<T> {\n        // it's a little annoying that areEqual will check whether the element\n        // has an equals function for each element in the list, but then\n        // what if the list allows null or undefined and the newVal is null or\n        // undefined? With type erasure then I don't know what equality to use\n        // on the next elements\n        const index = L.findIndex(v => areEqual(v, element), this._list);\n        return (index >= 0)\n            ? new Vector(L.update(index, newVal, this._list))\n            : this;\n    }\n\n    /**\n     * Replace all occurences of the element you give by\n     * the new value you give.\n     *\n     *     Vector.of(1, 2, 3, 4, 2).replaceAll(2, 5)\n     *     => Vector.of(1, 5, 3, 4, 5)\n     *\n     */\n    replaceAll(element: T&WithEquality, newVal: T&WithEquality): Vector<T> {\n        // if we're going to update many elements, then append in a loop\n        // would give better perf (not copying multiple times the same slice).\n        // if we won't update that many, update in a loop would give better perf...\n        // assuming it's the latter case.\n        let idx = 0;\n        return this.foldLeft(\n            this as Vector<T>,\n            (sofar, cur) => {\n                const r = areEqual(cur, element)\n                    ? new Vector(L.update(idx, newVal, sofar._list))\n                    : sofar;\n                ++idx;\n                return r;\n            });\n    }\n\n    /**\n     * Append an element at the end of the collection.\n     */\n    append(val:T): Vector<T> {\n        return new Vector(L.append(val, this._list));\n    }\n\n    /**\n     * Append multiple elements at the end of the collection.\n     * Note that arrays are also iterables.\n     */\n    appendAll(elts: Iterable<T>): Vector<T> {\n        if ((<any>elts)._list && (<any>elts).replace) {\n            // elts is a vector too\n            return new Vector(L.concat(this._list, (<Vector<T>>elts)._list));\n        }\n        return new Vector(L.concat(this._list, L.from(elts)));\n    }\n\n    /**\n     * Remove multiple elements from a vector\n     *\n     *     Vector.of(1,2,3,4,3,2,1).removeAll([2,4])\n     *     => Vector.of(1,3,3,1)\n     */\n    removeAll(elts:Iterable<T&WithEquality>): Vector<T> {\n        return <Vector<T>><any>SeqHelpers.removeAll(this, elts);\n    }\n\n    /**\n     * Get the first value of the collection, if any.\n     * returns Option.Some if the collection is not empty,\n     * Option.None if it's empty.\n     */\n    head(): Option<T> {\n        return this.get(0);\n    }\n\n    /**\n     * Get the last value of the collection, if any.\n     * returns Option.Some if the collection is not empty,\n     * Option.None if it's empty.\n     */\n    last(): Option<T> {\n        return Option.of(L.last(this._list));\n    }\n\n    /**\n     * Return a new vector containing all the elements in this\n     * vector except the last one, or the empty vector if this\n     * is the empty vector.\n     *\n     *     Vector.of(1,2,3).init()\n     *     => Vector.of(1,2)\n     */\n    init(): Vector<T> {\n        return new Vector(L.pop(this._list));\n    }\n\n    /**\n     * Returns a new collection, discarding the first elements\n     * until one element fails the predicate. All elements\n     * after that point are retained.\n     */\n    dropWhile(predicate:(x:T)=>boolean): Vector<T> {\n        return new Vector(L.dropWhile(predicate, this._list));\n    }\n\n    /**\n     * Search for the first item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     */\n    find(predicate:(v:T)=>boolean): Option<T> {\n        return Option.of(L.find(predicate, this._list));\n    }\n\n    /**\n     * Search for the last item matching the predicate you pass,\n     * return Option.Some of that element if found,\n     * Option.None otherwise.\n     */\n    findLast(predicate:(v:T)=>boolean): Option<T> {\n        return Option.of(L.findLast(predicate, this._list));\n    }\n\n    /**\n     * Search for the first item matching the predicate you pass,\n     * returning its index in the form of Option.Some if found,\n     * Option.None otherwise.\n     */\n    findIndex(predicate:(v:T)=>boolean): Option<number> {\n        return Option.of(L.findIndex(predicate, this._list)).filter(i => i != -1);\n    }\n\n    /**\n     * Returns true if the predicate returns true for all the\n     * elements in the collection.\n     */\n    allMatch<U extends T>(predicate:(v:T)=>v is U): this is Vector<U>;\n    allMatch(predicate:(v:T)=>boolean): boolean;\n    allMatch(predicate:(v:T)=>boolean): boolean {\n        return L.every(predicate, this._list);\n    }\n\n    /**\n     * Returns true if there the predicate returns true for any\n     * element in the collection.\n     */\n    anyMatch(predicate:(v:T)=>boolean): boolean {\n        return L.some(predicate, this._list);\n    }\n\n    /**\n     * Returns a pair of two collections; the first one\n     * will only contain the items from this collection for\n     * which the predicate you give returns true, the second\n     * will only contain the items from this collection where\n     * the predicate returns false.\n     *\n     *     Vector.of(1,2,3,4).partition(x => x%2===0)\n     *     => [Vector.of(2,4),Vector.of(1,3)]\n     */\n    partition<U extends T>(predicate:(v:T)=>v is U): [Vector<U>,Vector<Exclude<T,U>>];\n    partition(predicate:(x:T)=>boolean): [Vector<T>,Vector<T>];\n    partition(predicate:(v:T)=>boolean): [Vector<T>,Vector<T>] {\n        return <[Vector<T>,Vector<T>]>L.partition(predicate, this._list)\n            .map(x => new Vector(x));\n    }\n\n    /**\n     * Returns true if the item is in the collection,\n     * false otherwise.\n     */\n    contains(v:T&WithEquality): boolean {\n        return this.find(x => areEqual(x,v)).isSome();\n    }\n\n    /**\n     * Group elements in the collection using a classifier function.\n     * Elements are then organized in a map. The key is the value of\n     * the classifier, and in value we get the list of elements\n     * matching that value.\n     *\n     * also see [[Vector.arrangeBy]]\n     */\n    groupBy<C>(classifier: (v:T)=>C & WithEquality): HashMap<C,Vector<T>> {\n        return this.foldLeft(\n            HashMap.empty<C,Vector<T>>(),\n            (acc: HashMap<C,Vector<T>>, v:T) =>\n                acc.putWithMerge(\n                    classifier(v), Vector.of(v), // !!! DOUBLE CHECK THIS\n                    (v1:Vector<T>,v2:Vector<T>) => v1.append(<T>L.nth(0, v2._list))));\n    }\n\n    /**\n     * Matches each element with a unique key that you extract from it.\n     * If the same key is present twice, the function will return None.\n     *\n     * also see [[Vector.groupBy]]\n     */\n    arrangeBy<K>(getKey: (v:T)=>K&WithEquality): Option<HashMap<K,T>> {\n        return SeqHelpers.arrangeBy<T,K>(this, getKey);\n    }\n\n    /**\n     * Remove duplicate items; elements are mapped to keys, those\n     * get compared.\n     *\n     *     Vector.of(1,1,2,3,2,3,1).distinctBy(x => x);\n     *     => Vector.of(1,2,3)\n     */\n    distinctBy<U>(keyExtractor: (x:T)=>U&WithEquality): Vector<T> {\n        return <Vector<T>>SeqHelpers.distinctBy(this, keyExtractor);\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return this._list[Symbol.iterator]();\n    }\n\n    /**\n     * Call a function for element in the collection.\n     */\n    forEach(fun:(x:T)=>void):Vector<T> {\n        L.forEach(fun, this._list);\n        return this;\n    }\n\n    /**\n     * Return a new collection where each element was transformed\n     * by the mapper function you give.\n     */\n    map<U>(fun:(x:T)=>U): Vector<U> {\n        return new Vector(L.map(fun, this._list));\n    }\n\n    /**\n     * Call a predicate for each element in the collection,\n     * build a new collection holding only the elements\n     * for which the predicate returned true.\n     */\n    filter<U extends T>(fun:(v:T)=>v is U): Vector<U>;\n    filter(fun:(v:T)=>boolean): Vector<T>;\n    filter(fun:(v:T)=>boolean): Vector<T> {\n        return new Vector(L.filter(fun, this._list));\n    }\n\n    /**\n     * Apply the mapper function on every element of this collection.\n     * The mapper function returns an Option; if the Option is a Some,\n     * the value it contains is added to the result Collection, if it's\n     * a None, the value is discarded.\n     *\n     *     Vector.of(1,2,6).mapOption(x => x%2===0 ?\n     *         Option.of(x+1) : Option.none<number>())\n     *     => Vector.of(3, 7)\n     */\n    mapOption<U>(mapper:(v:T)=>Option<U>): Vector<U> {\n        let vec = L.empty();\n        for (let i = 0; i < this.length(); i++) {\n            const v = mapper(<T>L.nth(i, this._list));\n            if (v.isSome()) {\n                vec = L.append(v.get(), vec);\n            }\n        }\n        return new Vector(vec);\n    }\n\n    /**\n     * Calls the function you give for each item in the collection,\n     * your function returns a collection, all the collections are\n     * concatenated.\n     * This is the monadic bind.\n     */\n    flatMap<U>(mapper:(v:T)=>Vector<U>): Vector<U> {\n        return new Vector(L.chain(x => mapper(x)._list, this._list));\n    }\n\n    /**\n     * Reduces the collection to a single value using the\n     * associative binary function you give. Since the function\n     * is associative, order of application doesn't matter.\n     *\n     * Example:\n     *\n     *     Vector.of(1,2,3).fold(0, (a,b) => a + b);\n     *     => 6\n     */\n    fold(zero:T, fn:(v1:T,v2:T)=>T): T {\n        return this.foldLeft(zero, fn);\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Left-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldLeft(\"!\", (xs,x) => x+xs);\n     *     => \"cba!\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the previous value and\n     *           the current collection item, and returning\n     *           an updated value.\n     */\n    foldLeft<U>(zero:U, fn:(soFar:U,cur:T)=>U):U {\n        return L.foldl(fn, zero, this._list);\n    }\n\n    /**\n     * Reduces the collection to a single value.\n     * Right-associative.\n     *\n     * Example:\n     *\n     *     Vector.of(\"a\", \"b\", \"c\").foldRight(\"!\", (x,xs) => xs+x);\n     *     => \"!cba\"\n     *\n     * @param zero The initial value\n     * @param fn A function taking the current collection item and\n     *           the previous value , and returning\n     *           an updated value.\n     */\n    foldRight<U>(zero: U, fn:(cur:T, soFar:U)=>U): U {\n        return L.foldr(fn, zero, this._list);\n    }\n\n\n    /**\n     * Returns the index of the first occurence of the value you give, if present\n     *\n     *     Vector.of(1, 2, 3, 4, 3).indexOf(3)\n     *     => Option.of(2)\n     */\n    indexOf(element: T & WithEquality): Option<number> {\n        return Option.of(L.findIndex(v => areEqual(v, element), this._list))\n            .filter(i => i >= 0);\n    }\n\n    /**\n     * Randomly reorder the elements of the collection.\n     */\n    shuffle(): Vector<T> {\n        return Vector.ofIterable(SeqHelpers.shuffle(this.toArray()));\n    }\n\n    /**\n     * Transform this value to another value type.\n     * Enables fluent-style programming by chaining calls.\n     */\n    transform<U>(converter:(x:Vector<T>)=>U): U {\n        return converter(this);\n    }\n\n    /**\n     * Two objects are equal if they represent the same value,\n     * regardless of whether they are the same object physically\n     * in memory.\n     */\n    equals(other:Vector<T&WithEquality>): boolean {\n        if (<any>other === this) {\n            return true;\n        }\n        if (!other || (!other._list) || (!L.isList(other._list))) {\n            return false;\n        }\n        if (this.length() !== other.length()) return false;\n        for (let i = 0; i < this.length(); i++) {\n            const myVal: T & WithEquality|null|undefined = <T&WithEquality>L.nth(i, this._list);\n            const hisVal: T & WithEquality|null|undefined = L.nth(i, other._list);\n            if ((myVal === undefined) !== (hisVal === undefined)) {\n                return false;\n            }\n            if (myVal === undefined || hisVal === undefined) {\n                // they are both undefined, the || is for TS's flow analysis\n                // so he realizes none of them is undefined after this.\n                continue;\n            }\n            if (!areEqual(myVal, hisVal)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get a number for that object. Two different values\n     * may get the same number, but one value must always get\n     * the same number. The formula can impact performance.\n     */\n    hashCode(): number {\n        let hash = 1;\n        for (let i=0;i<this.length();i++) {\n            hash = 31 * hash + getHashCode(L.nth(i, this._list));\n        }\n        return hash;\n    }\n\n    /**\n     * Get a human-friendly string representation of that value.\n     *\n     * Also see [[Vector.mkString]]\n     */\n    toString(): string {\n        let r = \"Vector(\";\n        for (let i=0;i<this.length();i++) {\n            if (i>0) {\n                r += \", \";\n            }\n            r += SeqHelpers.toStringHelper(L.nth(i, this._list));\n        }\n        return r + \")\";\n    }\n\n    /**\n     * Used by the node REPL to display values.\n     * Most of the time should be the same as toString()\n     */\n    [inspect](): string {\n        return this.toString();\n    }\n\n    /**\n     * Joins elements of the collection by a separator.\n     * Example:\n     *\n     *     Vector.of(1,2,3).mkString(\", \")\n     *     => \"1, 2, 3\"\n     */\n    mkString(separator: string): string {\n        let r = \"\";\n        for (let i=0;i<this.length();i++) {\n            if (i>0) {\n                r += separator;\n            }\n            r += SeqHelpers.toStringHelper(<T>L.nth(i, this._list), {quoteStrings:false});\n        }\n        return r;\n    }\n\n    /**\n     * Returns a new collection with elements\n     * sorted according to the comparator you give.\n     *\n     * also see [[Vector.sortOn]]\n     */\n    sortBy(compare: (v1:T,v2:T)=>Ordering): Vector<T> {\n        return Vector.ofIterable<T>(this.toArray().sort(compare));\n    }\n\n    /**\n     * Give a function associating a number or a string with\n     * elements from the collection, and the elements\n     * are sorted according to that value.\n     *\n     *     Vector.of({a:3,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a)\n     *     => Vector.of({a:1,b:\"test\"},{a:2,b:\"a\"},{a:3,b:\"b\"})\n     *\n     * You can also sort by multiple criteria, and request 'descending'\n     * sorting:\n     *\n     *     Vector.of({a:1,b:\"b\"},{a:1,b:\"test\"},{a:2,b:\"a\"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})\n     *     => Vector.of({a:1,b:\"test\"},{a:1,b:\"b\"},{a:2,b:\"a\"})\n     *\n     * also see [[Vector.sortBy]]\n     */\n    sortOn(...getKeys: Array<ToOrderable<T>|{desc:ToOrderable<T>}>): Vector<T> {\n        return <Vector<T>>SeqHelpers.sortOn<T>(this, getKeys);\n    }\n\n    /**\n     * Convert this collection to a map. You give a function which\n     * for each element in the collection returns a pair. The\n     * key of the pair will be used as a key in the map, the value,\n     * as a value in the map. If several values get the same key,\n     * entries will be lost.\n     *\n     *     Vector.of(1,2,3).toMap(x=>[x.toString(), x])\n     *     => HashMap.of([\"1\",1], [\"2\",2], [\"3\",3])\n     */\n    toMap<K,V>(converter:(x:T)=>[K & WithEquality,V]): HashMap<K,V> {\n        return this.foldLeft(HashMap.empty<K,V>(), (acc,cur) => {\n            const converted = converter(cur);\n            return acc.put(converted[0], converted[1]);\n        });\n    }\n\n    /**\n     * Convert this collection to a set. Since the elements of the\n     * Seq may not support equality, you must pass a function returning\n     * a value supporting equality.\n     *\n     *     Vector.of(1,2,3,3,4).toSet(x=>x)\n     *     => HashSet.of(1,2,3,4)\n     */\n    toSet<K>(converter:(x:T)=>K&WithEquality): HashSet<K> {\n        return this.foldLeft(HashSet.empty<K>(), (acc,cur) => {\n            return acc.add(converter(cur));\n        });\n    }\n\n    /**\n     * Convert to array.\n     */\n    toArray(): T[] {\n        return L.toArray(this._list);\n    };\n\n    /**\n     * @hidden\n     */\n    hasTrueEquality(): boolean {\n        return SeqHelpers.seqHasTrueEquality<T>(this);\n    }\n\n    /**\n     * Combine any number of iterables you give in as\n     * parameters to produce a new collection which combines all,\n     * in tuples. For instance:\n     *\n     *     Vector.zip(Vector.of(1,2,3), [\"a\",\"b\",\"c\"], LinkedList.of(8,9,10))\n     *     => Vector.of([1,\"a\",8], [2,\"b\",9], [3,\"c\",10])\n     *\n     * The result collection will have the length of the shorter\n     * of the input iterables. Extra elements will be discarded.\n     *\n     * Also see [the non-static version](#zip), which only combines two\n     * collections.\n     * @param A A is the type of the tuple that'll be generated\n     *          (`[number,string,number]` for the code sample)\n     */\n    static zip<A extends any[]>(...iterables: IterableArray<A>): Vector<A> {\n        let r = <L.List<A>>L.empty();\n        const iterators = iterables.map(i => i[Symbol.iterator]());\n        let items = iterators.map(i => i.next());\n\n        while (!items.some(item => item.done)) {\n            r = L.append<A>(<any>items.map(item => item.value), r);\n            items = iterators.map(i => i.next());\n        }\n        return new Vector(r);\n    }\n\n    /**\n     * Combine this collection with the collection you give in\n     * parameter to produce a new collection which combines both,\n     * in pairs. For instance:\n     *\n     *     Vector.of(1,2,3).zip([\"a\",\"b\",\"c\"])\n     *     => Vector.of([1,\"a\"], [2,\"b\"], [3,\"c\"])\n     *\n     * The result collection will have the length of the shorter\n     * of both collections. Extra elements will be discarded.\n     *\n     * Also see [[Vector.zip]] (static version which can more than two\n     * iterables)\n     */\n    zip<U>(other: Iterable<U>): Vector<[T,U]> {\n        let r = <L.List<[T,U]>>L.empty();\n        const thisIterator = this[Symbol.iterator]();\n        const otherIterator = other[Symbol.iterator]();\n        let thisCurItem = thisIterator.next();\n        let otherCurItem = otherIterator.next();\n\n        while (!thisCurItem.done && !otherCurItem.done) {\n            r = L.append<[T,U]>([thisCurItem.value, otherCurItem.value], r);\n            thisCurItem = thisIterator.next();\n            otherCurItem = otherIterator.next();\n        }\n        return new Vector(r);\n    }\n\n    /**\n     * Reverse the collection. For instance:\n     *\n     *     Vector.of(1,2,3).reverse();\n     *     => Vector.of(3,2,1)\n     */\n    reverse(): Vector<T> {\n        return new Vector(L.reverse(this._list));\n    }\n\n    /**\n     * Combine this collection with the index of the elements\n     * in it. Handy if you need the index when you map on\n     * the collection for instance:\n     *\n     *     Vector.of(\"a\",\"b\").zipWithIndex().map(([v,idx]) => v+idx)\n     *     => Vector.of(\"a0\", \"b1\")\n     */\n    zipWithIndex(): Vector<[T,number]> {\n        return <Vector<[T,number]>>SeqHelpers.zipWithIndex<T>(this);\n    }\n\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate.\n     */\n    takeWhile(predicate:(x:T)=>boolean): Vector<T> {\n        return new Vector(L.takeWhile(predicate, this._list));\n    }\n\n    /**\n     * Returns a new collection, discarding the elements\n     * after the first element which fails the predicate,\n     * but starting from the end of the collection.\n     *\n     *     Vector.of(1,2,3,4).takeRightWhile(x => x > 2)\n     *     => Vector.of(3,4)\n     */\n    takeRightWhile(predicate:(x:T)=>boolean): Vector<T> {\n        return new Vector(L.takeLastWhile(predicate, this._list));\n    }\n\n    /**\n     * Split the collection at a specific index.\n     *\n     *     Vector.of(1,2,3,4,5).splitAt(3)\n     *     => [Vector.of(1,2,3), Vector.of(4,5)]\n     */\n    splitAt(index:number): [Vector<T>,Vector<T>] {\n        if (index < 0) {\n            return [Vector.empty<T>(), this];\n        }\n        return <[Vector<T>,Vector<T>]>L.splitAt(index, this._list).map(x => new Vector(x));\n    }\n\n    /**\n     * Takes a predicate; returns a pair of collections.\n     * The first one is the longest prefix of this collection\n     * which satisfies the predicate, and the second collection\n     * is the remainder of the collection.\n     *\n     *    Vector.of(1,2,3,4,5,6).span(x => x <3)\n     *    => [Vector.of(1,2), Vector.of(3,4,5,6)]\n     */\n    span(predicate:(x:T)=>boolean): [Vector<T>,Vector<T>] {\n        // could be potentially faster using splitAt.\n        const first = this.takeWhile(predicate);\n        return [first, this.drop(first.length())];\n    }\n\n    /**\n     * Returns a new collection with the first\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    drop(n:number): Vector<T> {\n        return new Vector(L.drop(n, this._list));\n    }\n\n    /**\n     * Return a new collection containing the first n\n     * elements from this collection\n     *\n     *     Vector.of(1,2,3,4).take(2)\n     *     => Vector.of(1,2)\n     */\n    take(n:number): Vector<T> {\n        if (n<0) {\n            return Vector.empty<T>();\n        }\n        return new Vector(L.take(n, this._list));\n    }\n\n    /**\n     * Prepend an element at the beginning of the collection.\n     */\n    prepend(elt: T): Vector<T> {\n        return new Vector(L.prepend(elt, this._list));\n    }\n\n    /**\n     * Prepend multiple elements at the beginning of the collection.\n     */\n    prependAll(elts: Iterable<T>): Vector<T> {\n        return Vector.ofIterable(elts).appendAll(this);\n    }\n\n    /**\n     * Removes the first element matching the predicate\n     * (use [[Seq.filter]] to remove all elements matching a predicate)\n     */\n    removeFirst(predicate: (v:T)=>boolean): Vector<T> {\n        const v1 = this.takeWhile(x => !predicate(x));\n        return v1.appendAll(this.drop(v1.length()+1));\n    }\n\n    /**\n     * Returns a new collection with the last\n     * n elements discarded.\n     * If the collection has less than n elements,\n     * returns the empty collection.\n     */\n    dropRight(n:number): Vector<T> {\n        if (n>=this.length()) {\n            return Vector.empty<T>();\n        }\n        return new Vector(L.dropLast(n, this._list));\n    }\n\n    /**\n     * Returns a new collection, discarding the last elements\n     * until one element fails the predicate. All elements\n     * before that point are retained.\n     */\n    dropRightWhile(predicate:(x:T)=>boolean): Vector<T> {\n        let i=this.length()-1;\n        for (;i>=0;i--) {\n            if (!predicate(<T>L.nth(i, this._list))) {\n                return this.take(i+1);\n            }\n        }\n        return Vector.empty<T>();\n    }\n\n    /**\n     * Get all the elements in the collection but the first one.\n     * If the collection is empty, return None.\n     */\n    tail(): Option<Vector<T>> {\n        if (this.isEmpty()) {\n            return Option.none<Vector<T>>();\n        }\n        return Option.of(new Vector(L.tail(this._list)));\n    }\n\n    /**\n     * Reduces the collection to a single value by repeatedly\n     * calling the combine function.\n     * No starting value. The order in which the elements are\n     * passed to the combining function is undetermined.\n     */\n    reduce(combine: (v1:T,v2:T)=>T): Option<T> {\n        return SeqHelpers.reduce(this, combine);\n    }\n\n    /**\n     * Compare values in the collection and return the smallest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[Vector.minOn]]\n     */\n    minBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return SeqHelpers.minBy(this, compare);\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the smallest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     Vector.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).minOn(x=>x.age)\n     *     => Option.of({name:\"Paula\", age:6})\n     *\n     * also see [[Vector.minBy]]\n     */\n    minOn(getOrderable: ToOrderable<T>): Option<T> {\n        return SeqHelpers.minOn(this, getOrderable);\n    }\n\n    /**\n     * Compare values in the collection and return the largest element.\n     * Returns Option.none if the collection is empty.\n     *\n     * also see [[Vector.maxOn]]\n     */\n    maxBy(compare: (v1:T,v2:T)=>Ordering): Option<T> {\n        return SeqHelpers.maxBy(this, compare);\n    }\n\n    /**\n     * Call the function you give for each value in the collection\n     * and return the element for which the result was the largest.\n     * Returns Option.none if the collection is empty.\n     *\n     *     Vector.of({name:\"Joe\", age:12}, {name:\"Paula\", age:6}).maxOn(x=>x.age)\n     *     => Option.of({name:\"Joe\", age:12})\n     *\n     * also see [[Vector.maxBy]]\n     */\n    maxOn(getOrderable: ToOrderable<T>): Option<T> {\n        return SeqHelpers.maxOn(this, getOrderable);\n    }\n\n    /**\n     * Call the function you give for each element in the collection\n     * and sum all the numbers, return that sum.\n     * Will return 0 if the collection is empty.\n     *\n     *     Vector.of(1,2,3).sumOn(x=>x)\n     *     => 6\n     */\n    sumOn(getNumber: (v:T)=>number): number {\n        return SeqHelpers.sumOn(this, getNumber);\n    }\n\n    /**\n     * Slides a window of a specific size over the sequence.\n     * Returns a lazy stream so memory use is not prohibitive.\n     *\n     *     Vector.of(1,2,3,4,5,6,7,8).sliding(3)\n     *     => Stream.of(Vector.of(1,2,3), Vector.of(4,5,6), Vector.of(7,8))\n     */\n    sliding(count:number): Stream<Vector<T>> {\n        return <Stream<Vector<T>>>SeqHelpers.sliding(this, count);\n    }\n\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     * The last element of the result is the final cumulative result.\n     *\n     *     Vector.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)\n     *     => Vector.of(0,1,3,6)\n     */\n    scanLeft<U>(init:U, fn:(soFar:U,cur:T)=>U): Vector<U> {\n        return new Vector(L.scan(fn, init, this._list));\n    }\n\n    /**\n     * Apply the function you give to all elements of the sequence\n     * in turn, keeping the intermediate results and returning them\n     * along with the final result in a list.\n     * The first element of the result is the final cumulative result.\n     *\n     *     Vector.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)\n     *     => Vector.of(6,5,3,0)\n     */\n    scanRight<U>(init:U, fn:(cur:T,soFar:U)=>U): Vector<U> {\n        const r:U[] = [];\n        r.unshift(init);\n        let cur = init;\n        for (let i = this.length()-1; i>=0; i--) {\n            cur = fn(<T>L.nth(i, this._list), cur);\n            r.unshift(cur);\n        }\n        return Vector.ofIterable(r);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}