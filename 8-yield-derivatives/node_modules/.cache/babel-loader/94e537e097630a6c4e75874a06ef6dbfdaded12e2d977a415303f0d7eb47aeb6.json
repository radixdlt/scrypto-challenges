{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar RadixLogger_1 = require(\"../common/RadixLogger\");\nvar promise_retry_1 = tslib_1.__importDefault(require(\"promise-retry\"));\nvar __1 = require(\"../..\");\nvar atommodel_1 = require(\"../atommodel\");\nvar ipaddr_js_1 = tslib_1.__importDefault(require(\"ipaddr.js\"));\nvar RadixUniverse = /** @class */function () {\n  function RadixUniverse() {\n    var _this = this;\n    this.initialized = false;\n    this.liveNodes = [];\n    this.connectedNodes = [];\n    this.lastNetworkUpdate = 0;\n    this.networkUpdateInterval = 1000 * 60 * 10;\n    /**\n     * Close all open connections\n     * Recommended to call this before quitting the application, so that nodes can close the corresponding open connections as well\n     */\n    this.closeAllConnections = function () {\n      var e_1, _a;\n      try {\n        for (var _b = tslib_1.__values(_this.connectedNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var connection = _c.value;\n          connection.close();\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n  }\n  /**\n   * Bootstraps the universe with a specific configuration\n   * Must be called before performing any operations\n   * Use one of the predefined static configurations in this class\n   * @param config\n   */\n  RadixUniverse.prototype.bootstrap = function (config) {\n    var e_2, _a;\n    this.universeConfig = config.universeConfig;\n    this.nodeDiscovery = config.nodeDiscovery;\n    // Deserialize config\n    this.universeConfig.initialize();\n    try {\n      // Find native token\n      for (var _b = tslib_1.__values(this.universeConfig.genesis), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var atom = _c.value;\n        var tokenClasses = atom.getParticlesOfType(atommodel_1.RadixTokenDefinitionParticle);\n        if (tokenClasses.length === 0) {\n          throw new Error(\"Couldn't find native token in genesis\");\n        } else {\n          if (tokenClasses.length > 1) {\n            RadixLogger_1.logger.warn('More than 1 tokens defined in genesis, using the first');\n          }\n          this.nativeToken = tokenClasses[0].getRRI();\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    __1.radixTokenManager.initialize(this.universeConfig.genesis, this.nativeToken);\n    this.initialized = true;\n  };\n  /**\n   * Gets the universe magic byte, used mainly for generating an address from a public key\n   * @returns\n   */\n  RadixUniverse.prototype.getMagicByte = function () {\n    this.isInitialized();\n    return this.universeConfig.getMagicByte();\n  };\n  RadixUniverse.prototype.loadPeersFromBootstrap = function () {\n    var _this = this;\n    // const bootstrapNodesLenght = (this.nodeDiscovery as RadixNodeDiscoveryHardcoded).bootstrapNodes.length;\n    // if(bootstrapNodesLenght > 1)\n    //     throw new Error('not cool ' + bootstrapNodesLenght)\n    return promise_retry_1.default(function (retry, attempt) {\n      return tslib_1.__awaiter(_this, void 0, void 0, function () {\n        var _a, error_1;\n        return tslib_1.__generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              _b.trys.push([0, 2,, 3]);\n              _a = this;\n              return [4 /*yield*/, this.nodeDiscovery.loadNodes()];\n            case 1:\n              _a.liveNodes = _b.sent();\n              this.lastNetworkUpdate = Date.now();\n              return [2 /*return*/, this.liveNodes];\n            case 2:\n              error_1 = _b.sent();\n              RadixLogger_1.logger.error(error_1);\n              retry();\n              return [3 /*break*/, 3];\n            case 3:\n              return [2 /*return*/];\n          }\n        });\n      });\n    }, {\n      retries: 1000,\n      maxtimeout: 60000\n    });\n  };\n  /**\n   * Gets a RadixNodeConnection for a specified shard\n   * Updates the node list if neccessary\n   * @param shard\n   * @returns node connection\n   */\n  RadixUniverse.prototype.getNodeConnection = function (shard) {\n    var _this = this;\n    this.isInitialized();\n    return new Promise(function (resolve, reject) {\n      var e_3, _a, e_4, _b;\n      try {\n        // Find active connection, return\n        for (var _c = tslib_1.__values(_this.connectedNodes), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var node = _d.value;\n          if (node.isReady() && node.node.canServiceShard(shard)) {\n            RadixLogger_1.logger.info('Got an active connection');\n            return resolve(node);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n      var _loop_1 = function (nodeConnection) {\n        if (nodeConnection.node.canServiceShard(shard)) {\n          RadixLogger_1.logger.info('Got a pending connection');\n          // Wait for ready or error\n          nodeConnection.on('open', function () {\n            resolve(nodeConnection);\n          });\n          nodeConnection.on('closed', function () {\n            resolve(_this.getNodeConnection(shard));\n          });\n          return {\n            value: void 0\n          };\n        }\n      };\n      try {\n        // Failing that, find a pending node connection\n        for (var _e = tslib_1.__values(_this.connectedNodes), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var nodeConnection = _f.value;\n          var state_1 = _loop_1(nodeConnection);\n          if (typeof state_1 === \"object\") return state_1.value;\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n      // Open a new connection, return when ready\n      RadixLogger_1.logger.info('Opening a new connection');\n      _this.openNodeConnection(shard).then(function (connection) {\n        if (connection) {\n          resolve(connection);\n        } else {\n          reject(\"Coudln't find a node to connect to\");\n        }\n      });\n    });\n  };\n  RadixUniverse.prototype.openNodeConnection = function (shard) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _loop_2, this_1, _a, _b, node, state_2, e_5_1;\n      var e_5, _c;\n      var _this = this;\n      return tslib_1.__generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            if (!(Date.now() - this.lastNetworkUpdate > this.networkUpdateInterval)) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.loadPeersFromBootstrap()];\n          case 1:\n            _d.sent();\n            _d.label = 2;\n          case 2:\n            // Randomize node order every time\n            this.liveNodes = __1.shuffleArray(this.liveNodes);\n            _loop_2 = function (node) {\n              var connection_1, error_2;\n              return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    if (!node.canServiceShard(shard)) return [3 /*break*/, 5];\n                    connection_1 = new __1.RadixNodeConnection(node);\n                    this_1.connectedNodes.push(connection_1);\n                    connection_1.on('closed', function () {\n                      // Remove connection from connected nodes \n                      var nodeIndex = _this.connectedNodes.indexOf(connection_1);\n                      if (nodeIndex > -1) {\n                        _this.connectedNodes.splice(nodeIndex, 1);\n                      }\n                    });\n                    _a.label = 1;\n                  case 1:\n                    _a.trys.push([1, 3,, 4]);\n                    return [4 /*yield*/, connection_1.openConnection()];\n                  case 2:\n                    _a.sent();\n                    return [3 /*break*/, 4];\n                  case 3:\n                    error_2 = _a.sent();\n                    RadixLogger_1.logger.error(error_2);\n                    return [2 /*return*/, {\n                      value: null\n                    }];\n                  case 4:\n                    return [2 /*return*/, {\n                      value: connection_1\n                    }];\n                  case 5:\n                    return [2 /*return*/];\n                }\n              });\n            };\n            this_1 = this;\n            _d.label = 3;\n          case 3:\n            _d.trys.push([3, 8, 9, 10]);\n            _a = tslib_1.__values(this.liveNodes), _b = _a.next();\n            _d.label = 4;\n          case 4:\n            if (!!_b.done) return [3 /*break*/, 7];\n            node = _b.value;\n            return [5 /*yield**/, _loop_2(node)];\n          case 5:\n            state_2 = _d.sent();\n            if (typeof state_2 === \"object\") return [2 /*return*/, state_2.value];\n            _d.label = 6;\n          case 6:\n            _b = _a.next();\n            return [3 /*break*/, 4];\n          case 7:\n            return [3 /*break*/, 10];\n          case 8:\n            e_5_1 = _d.sent();\n            e_5 = {\n              error: e_5_1\n            };\n            return [3 /*break*/, 10];\n          case 9:\n            try {\n              if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            } finally {\n              if (e_5) throw e_5.error;\n            }\n            return [7 /*endfinally*/];\n          case 10:\n            return [2 /*return*/, null];\n        }\n      });\n    });\n  };\n  RadixUniverse.prototype.getLiveNodes = function () {\n    return this.liveNodes;\n  };\n  RadixUniverse.prototype.isInitialized = function () {\n    if (!this.initialized) {\n      throw new Error('Universe needs to be initialized before using the library, please call \"radixUniverse.bootstrap\" with a universe configuration');\n    }\n  };\n  /**\n   * Given an IP address this function resolves a deterministic\n   * DNS record in the radixnode.net domain.\n   *\n   * @param address IP address or hostname\n   */\n  RadixUniverse.resolveNodeName = function (address) {\n    try {\n      var ipbytes = ipaddr_js_1.default.parse(address).toByteArray();\n      if (ipbytes.length == 4) {\n        // IPv4\n        // trivial but safe left-shift function that does not overflow\n        var shl = function (base, exp) {\n          return base * Math.pow(2, exp);\n        };\n        // use + instead of | (bitwise or) because it overflows\n        var ip = ipbytes[3] + shl(ipbytes[2], 8) + shl(ipbytes[1], 16) + shl(ipbytes[0], 24);\n        return \"a\" + ip.toString(36) + \".radixnode.net\";\n      }\n      RadixLogger_1.logger.warn('No base36 encoder for IPv6 yet');\n      return \"[\" + address + \"]\";\n    } catch (err) {\n      // the address has neither IPv6 nor IPv4 format => hostname\n    }\n    return address;\n  };\n  RadixUniverse.BETANET = {\n    universeConfig: __1.RadixUniverseConfig.BETANET,\n    nodeDiscovery: new __1.RadixNodeDiscoveryFromNodeFinder('https://betanet-staging.radixdlt.com/node-finder', function (ip, port) {\n      return \"wss://\" + RadixUniverse.resolveNodeName(ip) + \"/rpc\";\n    }, function (ip, port) {\n      return \"https://\" + RadixUniverse.resolveNodeName(ip) + \"/rpc\";\n    })\n  };\n  RadixUniverse.SUNSTONE = {\n    universeConfig: __1.RadixUniverseConfig.SUNSTONE,\n    nodeDiscovery: new __1.RadixNodeDiscoveryFromNodeFinder('https://sunstone.radixdlt.com/node-finder', function (ip, port) {\n      return \"wss://\" + RadixUniverse.resolveNodeName(ip) + \"/rpc\";\n    }, function (ip, port) {\n      return \"https://\" + RadixUniverse.resolveNodeName(ip) + \"/rpc\";\n    })\n  };\n  RadixUniverse.LOCALHOST = {\n    universeConfig: __1.RadixUniverseConfig.LOCAL,\n    nodeDiscovery: new __1.RadixNodeDiscoveryHardcoded(['localhost:8080', 'localhost:8081'])\n  };\n  RadixUniverse.LOCALHOST_SINGLENODE = {\n    universeConfig: __1.RadixUniverseConfig.LOCAL,\n    nodeDiscovery: new __1.RadixNodeDiscoveryHardcoded(['localhost:8080'])\n  };\n  RadixUniverse.BETANET_EMULATOR = {\n    universeConfig: __1.RadixUniverseConfig.BETANET,\n    nodeDiscovery: new __1.RadixNodeDiscoveryHardcodedSecure(['sunstone-emu.radixdlt.com:443'])\n  };\n  return RadixUniverse;\n}();\nexports.default = RadixUniverse;\nexports.radixUniverse = new RadixUniverse();","map":{"version":3,"names":["RadixLogger_1","require","promise_retry_1","tslib_1","__importDefault","__1","atommodel_1","ipaddr_js_1","RadixUniverse","_this","initialized","liveNodes","connectedNodes","lastNetworkUpdate","networkUpdateInterval","closeAllConnections","_b","__values","_c","next","done","connection","value","close","prototype","bootstrap","config","universeConfig","nodeDiscovery","initialize","genesis","atom","tokenClasses","getParticlesOfType","RadixTokenDefinitionParticle","length","Error","logger","warn","nativeToken","getRRI","radixTokenManager","getMagicByte","isInitialized","loadPeersFromBootstrap","default","retry","attempt","__awaiter","_a","loadNodes","sent","Date","now","error","error_1","retries","maxtimeout","getNodeConnection","shard","Promise","resolve","reject","_d","node","isReady","canServiceShard","info","nodeConnection","on","_e","_f","openNodeConnection","then","shuffleArray","connection_1","RadixNodeConnection","this_1","push","nodeIndex","indexOf","splice","openConnection","error_2","getLiveNodes","resolveNodeName","address","ipbytes","parse","toByteArray","shl","base","exp","Math","pow","ip","toString","err","BETANET","RadixUniverseConfig","RadixNodeDiscoveryFromNodeFinder","port","SUNSTONE","LOCALHOST","LOCAL","RadixNodeDiscoveryHardcoded","LOCALHOST_SINGLENODE","BETANET_EMULATOR","RadixNodeDiscoveryHardcodedSecure","exports","radixUniverse"],"sources":["../../../../src/modules/universe/RadixUniverse.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}