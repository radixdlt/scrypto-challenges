{"ast":null,"code":"'use strict';\n\nconst encoder = require('./encoder');\nconst decoder = require('./decoder');\nconst constants = require('./constants');\nconst MT = constants.MT;\n\n/**\n * Wrapper around a JavaScript Map object that allows the keys to be\n * any complex type.  The base Map object allows this, but will only\n * compare the keys by identity, not by value.  CborMap translates keys\n * to CBOR first (and base64's them to ensure by-value comparison).\n *\n * This is not a subclass of Object, because it would be tough to get\n * the semantics to be an exact match.\n *\n * @class CborMap\n * @extends {Map}\n */\nclass CborMap extends Map {\n  /**\n   * Creates an instance of CborMap.\n   * @param {Iterable<any, any>} [iterable] An Array or other iterable\n   *   object whose elements are key-value pairs (arrays with two elements, e.g.\n   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added\n   *   to the new CborMap; null values are treated as undefined.\n   */\n  constructor(iterable) {\n    super(iterable);\n  }\n\n  /**\n   * @private\n   */\n  static _encode(key) {\n    return encoder.encodeCanonical(key).toString('base64');\n  }\n\n  /**\n   * @private\n   */\n  static _decode(key) {\n    return decoder.decodeFirstSync(key, 'base64');\n  }\n\n  /**\n   * Retrieve a specified element.\n   *\n   * @param {any} key The key identifying the element to retrieve.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {any} The element if it exists, or <code>undefined</code>.\n   */\n  get(key) {\n    return super.get(CborMap._encode(key));\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {any} key The key identifying the element to store.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @param {any} val The element to store\n   */\n  set(key, val) {\n    return super.set(CborMap._encode(key), val);\n  }\n\n  /**\n   * Removes the specified element.\n   *\n   * @param {any} key The key identifying the element to delete.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean}\n   */\n  delete(key) {\n    return super.delete(CborMap._encode(key));\n  }\n\n  /**\n   * Does an element with the specified key exist?\n   *\n   * @param {any} key The key identifying the element to check.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean}\n   */\n  has(key) {\n    return super.has(CborMap._encode(key));\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element\n   * in the Map object in insertion order.  The keys are decoded into their\n   * original format.\n   *\n   * @returns {IterableIterator<any>}\n   */\n  *keys() {\n    for (const k of super.keys()) {\n      yield CborMap._decode(k);\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator}\n   */\n  *entries() {\n    for (const kv of super.entries()) {\n      yield [CborMap._decode(kv[0]), kv[1]];\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator}\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map\n   * object, in insertion order.\n   *\n   * @param {function(any, any, Map): undefined} fun Function to execute for\n   *  each element, which takes a value, a key, and the Map being traversed.\n   * @param {any} thisArg Value to use as this when executing callback\n   */\n  forEach(fun, thisArg) {\n    if (typeof fun !== 'function') {\n      throw new TypeError('Must be function');\n    }\n    for (const kv of super.entries()) {\n      fun.call(this, kv[1], CborMap._decode(kv[0]), this);\n    }\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {Object} gen The generator to push onto\n   * @returns {boolean} true on success\n   */\n  encodeCBOR(gen) {\n    if (!gen._pushInt(this.size, MT.MAP)) {\n      return false;\n    }\n    if (gen.canonical) {\n      const entries = Array.from(super.entries()).map(kv => [Buffer.from(kv[0], 'base64'), kv[1]]);\n      entries.sort((a, b) => a[0].compare(b[0]));\n      for (const kv of entries) {\n        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {\n          return false;\n        }\n      }\n    } else {\n      for (const kv of super.entries()) {\n        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\nmodule.exports = CborMap;","map":{"version":3,"names":["encoder","require","decoder","constants","MT","CborMap","Map","constructor","iterable","_encode","key","encodeCanonical","toString","_decode","decodeFirstSync","get","set","val","delete","has","keys","k","entries","kv","Symbol","iterator","forEach","fun","thisArg","TypeError","call","encodeCBOR","gen","_pushInt","size","MAP","canonical","Array","from","map","Buffer","sort","a","b","compare","push","pushAny","module","exports"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/cbor/lib/map.js"],"sourcesContent":["'use strict'\n\nconst encoder = require('./encoder')\nconst decoder = require('./decoder')\nconst constants = require('./constants')\nconst MT = constants.MT\n\n/**\n * Wrapper around a JavaScript Map object that allows the keys to be\n * any complex type.  The base Map object allows this, but will only\n * compare the keys by identity, not by value.  CborMap translates keys\n * to CBOR first (and base64's them to ensure by-value comparison).\n *\n * This is not a subclass of Object, because it would be tough to get\n * the semantics to be an exact match.\n *\n * @class CborMap\n * @extends {Map}\n */\nclass CborMap extends Map {\n  /**\n   * Creates an instance of CborMap.\n   * @param {Iterable<any, any>} [iterable] An Array or other iterable\n   *   object whose elements are key-value pairs (arrays with two elements, e.g.\n   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added\n   *   to the new CborMap; null values are treated as undefined.\n   */\n  constructor(iterable) {\n    super(iterable)\n  }\n\n  /**\n   * @private\n   */\n  static _encode(key) {\n    return encoder.encodeCanonical(key).toString('base64')\n  }\n\n  /**\n   * @private\n   */\n  static _decode(key) {\n    return decoder.decodeFirstSync(key, 'base64')\n  }\n\n  /**\n   * Retrieve a specified element.\n   *\n   * @param {any} key The key identifying the element to retrieve.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {any} The element if it exists, or <code>undefined</code>.\n   */\n  get(key) {\n    return super.get(CborMap._encode(key))\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {any} key The key identifying the element to store.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @param {any} val The element to store\n   */\n  set(key, val) {\n    return super.set(CborMap._encode(key), val)\n  }\n\n  /**\n   * Removes the specified element.\n   *\n   * @param {any} key The key identifying the element to delete.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean}\n   */\n  delete(key) {\n    return super.delete(CborMap._encode(key))\n  }\n\n  /**\n   * Does an element with the specified key exist?\n   *\n   * @param {any} key The key identifying the element to check.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean}\n   */\n  has(key) {\n    return super.has(CborMap._encode(key))\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element\n   * in the Map object in insertion order.  The keys are decoded into their\n   * original format.\n   *\n   * @returns {IterableIterator<any>}\n   */\n  *keys() {\n    for (const k of super.keys()) {\n      yield CborMap._decode(k)\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator}\n   */\n  *entries() {\n    for (const kv of super.entries()) {\n      yield [CborMap._decode(kv[0]), kv[1]]\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map\n   * object, in insertion order.\n   *\n   * @param {function(any, any, Map): undefined} fun Function to execute for\n   *  each element, which takes a value, a key, and the Map being traversed.\n   * @param {any} thisArg Value to use as this when executing callback\n   */\n  forEach(fun, thisArg) {\n    if (typeof(fun) !== 'function') {\n      throw new TypeError('Must be function')\n    }\n    for (const kv of super.entries()) {\n      fun.call(this, kv[1], CborMap._decode(kv[0]), this)\n    }\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {Object} gen The generator to push onto\n   * @returns {boolean} true on success\n   */\n  encodeCBOR(gen) {\n    if (!gen._pushInt(this.size, MT.MAP)) {\n      return false\n    }\n    if (gen.canonical) {\n      const entries = Array.from(super.entries())\n        .map((kv) => [Buffer.from(kv[0], 'base64'), kv[1]])\n      entries.sort((a, b) => a[0].compare(b[0]))\n      for (const kv of entries) {\n        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    } else {\n      for (const kv of super.entries()) {\n        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n}\n\nmodule.exports = CborMap\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}