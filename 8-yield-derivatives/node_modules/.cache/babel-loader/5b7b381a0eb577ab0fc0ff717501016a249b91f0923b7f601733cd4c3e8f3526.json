{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar Value_1 = require(\"./Value\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\n/**\n * Represent a lazily evaluated value. You give a function which\n * will return a value; that function is only called when the value\n * is requested from Lazy, but it will be computed at most once.\n * If the value is requested again, the previously computed result\n * will be returned: Lazy is memoizing.\n */\nvar Lazy = /** @class */function () {\n  function Lazy(thunk) {\n    this.thunk = thunk;\n  }\n  /**\n   * Build a Lazy from a computation returning a value.\n   * The computation will be called at most once.\n   */\n  Lazy.of = function (thunk) {\n    return new Lazy(thunk);\n  };\n  /**\n   * Evaluate the value, cache its value, and return it, or return the\n   * previously computed value.\n   */\n  Lazy.prototype.get = function () {\n    if (this.thunk) {\n      this.value = this.thunk();\n      this.thunk = undefined;\n    }\n    return this.value;\n  };\n  /**\n   * Returns true if the computation underlying this Lazy was already\n   * performed, false otherwise.\n   */\n  Lazy.prototype.isEvaluated = function () {\n    return this.thunk === undefined;\n  };\n  /**\n   * Return a new lazy where the element was transformed\n   * by the mapper function you give.\n   */\n  Lazy.prototype.map = function (mapper) {\n    var _this = this;\n    return new Lazy(function () {\n      return mapper(_this.get());\n    });\n  };\n  /**\n   * Get a human-friendly string representation of that value.\n   */\n  Lazy.prototype.toString = function () {\n    return this.isEvaluated() ? \"Lazy(\" + SeqHelpers_1.toStringHelper(this.get()) + \")\" : \"Lazy(?)\";\n  };\n  /**\n   * Used by the node REPL to display values.\n   * Most of the time should be the same as toString()\n   */\n  Lazy.prototype[Value_1.inspect] = function () {\n    return this.toString();\n  };\n  return Lazy;\n}();\nexports.Lazy = Lazy;","map":{"version":3,"names":["exports","__esModule","Value_1","require","SeqHelpers_1","Lazy","thunk","of","prototype","get","value","undefined","isEvaluated","map","mapper","_this","toString","toStringHelper","inspect"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/prelude-ts/dist/src/Lazy.js"],"sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar Value_1 = require(\"./Value\");\nvar SeqHelpers_1 = require(\"./SeqHelpers\");\n/**\n * Represent a lazily evaluated value. You give a function which\n * will return a value; that function is only called when the value\n * is requested from Lazy, but it will be computed at most once.\n * If the value is requested again, the previously computed result\n * will be returned: Lazy is memoizing.\n */\nvar Lazy = /** @class */ (function () {\n    function Lazy(thunk) {\n        this.thunk = thunk;\n    }\n    /**\n     * Build a Lazy from a computation returning a value.\n     * The computation will be called at most once.\n     */\n    Lazy.of = function (thunk) {\n        return new Lazy(thunk);\n    };\n    /**\n     * Evaluate the value, cache its value, and return it, or return the\n     * previously computed value.\n     */\n    Lazy.prototype.get = function () {\n        if (this.thunk) {\n            this.value = this.thunk();\n            this.thunk = undefined;\n        }\n        return this.value;\n    };\n    /**\n     * Returns true if the computation underlying this Lazy was already\n     * performed, false otherwise.\n     */\n    Lazy.prototype.isEvaluated = function () {\n        return this.thunk === undefined;\n    };\n    /**\n     * Return a new lazy where the element was transformed\n     * by the mapper function you give.\n     */\n    Lazy.prototype.map = function (mapper) {\n        var _this = this;\n        return new Lazy(function () { return mapper(_this.get()); });\n    };\n    /**\n     * Get a human-friendly string representation of that value.\n     */\n    Lazy.prototype.toString = function () {\n        return this.isEvaluated() ?\n            \"Lazy(\" + SeqHelpers_1.toStringHelper(this.get()) + \")\" :\n            \"Lazy(?)\";\n    };\n    /**\n     * Used by the node REPL to display values.\n     * Most of the time should be the same as toString()\n     */\n    Lazy.prototype[Value_1.inspect] = function () {\n        return this.toString();\n    };\n    return Lazy;\n}());\nexports.Lazy = Lazy;\n//# sourceMappingURL=Lazy.js.map"],"mappings":"AAAA,YAAY;;AACZA,OAAO,CAACC,UAAU,GAAG,IAAI;AACzB,IAAIC,OAAO,GAAGC,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIC,YAAY,GAAGD,OAAO,CAAC,cAAc,CAAC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIE,IAAI,GAAG,aAAe,YAAY;EAClC,SAASA,IAAIA,CAACC,KAAK,EAAE;IACjB,IAAI,CAACA,KAAK,GAAGA,KAAK;EACtB;EACA;AACJ;AACA;AACA;EACID,IAAI,CAACE,EAAE,GAAG,UAAUD,KAAK,EAAE;IACvB,OAAO,IAAID,IAAI,CAACC,KAAK,CAAC;EAC1B,CAAC;EACD;AACJ;AACA;AACA;EACID,IAAI,CAACG,SAAS,CAACC,GAAG,GAAG,YAAY;IAC7B,IAAI,IAAI,CAACH,KAAK,EAAE;MACZ,IAAI,CAACI,KAAK,GAAG,IAAI,CAACJ,KAAK,CAAC,CAAC;MACzB,IAAI,CAACA,KAAK,GAAGK,SAAS;IAC1B;IACA,OAAO,IAAI,CAACD,KAAK;EACrB,CAAC;EACD;AACJ;AACA;AACA;EACIL,IAAI,CAACG,SAAS,CAACI,WAAW,GAAG,YAAY;IACrC,OAAO,IAAI,CAACN,KAAK,KAAKK,SAAS;EACnC,CAAC;EACD;AACJ;AACA;AACA;EACIN,IAAI,CAACG,SAAS,CAACK,GAAG,GAAG,UAAUC,MAAM,EAAE;IACnC,IAAIC,KAAK,GAAG,IAAI;IAChB,OAAO,IAAIV,IAAI,CAAC,YAAY;MAAE,OAAOS,MAAM,CAACC,KAAK,CAACN,GAAG,CAAC,CAAC,CAAC;IAAE,CAAC,CAAC;EAChE,CAAC;EACD;AACJ;AACA;EACIJ,IAAI,CAACG,SAAS,CAACQ,QAAQ,GAAG,YAAY;IAClC,OAAO,IAAI,CAACJ,WAAW,CAAC,CAAC,GACrB,OAAO,GAAGR,YAAY,CAACa,cAAc,CAAC,IAAI,CAACR,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,GACvD,SAAS;EACjB,CAAC;EACD;AACJ;AACA;AACA;EACIJ,IAAI,CAACG,SAAS,CAACN,OAAO,CAACgB,OAAO,CAAC,GAAG,YAAY;IAC1C,OAAO,IAAI,CAACF,QAAQ,CAAC,CAAC;EAC1B,CAAC;EACD,OAAOX,IAAI;AACf,CAAC,CAAC,CAAE;AACJL,OAAO,CAACK,IAAI,GAAGA,IAAI","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}