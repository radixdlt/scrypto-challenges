{"ast":null,"code":"import { noChange as t } from \"../lit-html.js\";\nimport { directive as i, Directive as s, PartType as r } from \"../directive.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst o = i(class extends s {\n  constructor(t) {\n    var i;\n    if (super(t), t.type !== r.ATTRIBUTE || \"class\" !== t.name || (null === (i = t.strings) || void 0 === i ? void 0 : i.length) > 2) throw Error(\"`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.\");\n  }\n  render(t) {\n    return \" \" + Object.keys(t).filter(i => t[i]).join(\" \") + \" \";\n  }\n  update(i, _ref) {\n    let [s] = _ref;\n    var r, o;\n    if (void 0 === this.it) {\n      this.it = new Set(), void 0 !== i.strings && (this.nt = new Set(i.strings.join(\" \").split(/\\s/).filter(t => \"\" !== t)));\n      for (const t in s) s[t] && !(null === (r = this.nt) || void 0 === r ? void 0 : r.has(t)) && this.it.add(t);\n      return this.render(s);\n    }\n    const e = i.element.classList;\n    this.it.forEach(t => {\n      t in s || (e.remove(t), this.it.delete(t));\n    });\n    for (const t in s) {\n      const i = !!s[t];\n      i === this.it.has(t) || (null === (o = this.nt) || void 0 === o ? void 0 : o.has(t)) || (i ? (e.add(t), this.it.add(t)) : (e.remove(t), this.it.delete(t)));\n    }\n    return t;\n  }\n});\nexport { o as classMap };","map":{"version":3,"names":["o","i","s","constructor","t","type","r","ATTRIBUTE","name","strings","length","Error","render","Object","keys","filter","join","update","_ref","it","Set","nt","split","has","add","e","element","classList","forEach","remove","delete","classMap"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/lit-html/src/directives/class-map.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\n\n/**\n * A key-value set of class names to truthy values.\n */\nexport interface ClassInfo {\n  readonly [name: string]: string | boolean | number;\n}\n\nclass ClassMapDirective extends Directive {\n  /**\n   * Stores the ClassInfo object applied to a given AttributePart.\n   * Used to unset existing values when a new ClassInfo object is applied.\n   */\n  private _previousClasses?: Set<string>;\n  private _staticClasses?: Set<string>;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      partInfo.type !== PartType.ATTRIBUTE ||\n      partInfo.name !== 'class' ||\n      (partInfo.strings?.length as number) > 2\n    ) {\n      throw new Error(\n        '`classMap()` can only be used in the `class` attribute ' +\n          'and must be the only part in the attribute.'\n      );\n    }\n  }\n\n  render(classInfo: ClassInfo) {\n    // Add spaces to ensure separation from static classes\n    return (\n      ' ' +\n      Object.keys(classInfo)\n        .filter((key) => classInfo[key])\n        .join(' ') +\n      ' '\n    );\n  }\n\n  override update(part: AttributePart, [classInfo]: DirectiveParameters<this>) {\n    // Remember dynamic classes on the first render\n    if (this._previousClasses === undefined) {\n      this._previousClasses = new Set();\n      if (part.strings !== undefined) {\n        this._staticClasses = new Set(\n          part.strings\n            .join(' ')\n            .split(/\\s/)\n            .filter((s) => s !== '')\n        );\n      }\n      for (const name in classInfo) {\n        if (classInfo[name] && !this._staticClasses?.has(name)) {\n          this._previousClasses.add(name);\n        }\n      }\n      return this.render(classInfo);\n    }\n\n    const classList = part.element.classList;\n\n    // Remove old classes that no longer apply\n    // We use forEach() instead of for-of so that we don't require down-level\n    // iteration.\n    this._previousClasses.forEach((name) => {\n      if (!(name in classInfo)) {\n        classList.remove(name);\n        this._previousClasses!.delete(name);\n      }\n    });\n\n    // Add or remove classes based on their classMap value\n    for (const name in classInfo) {\n      // We explicitly want a loose truthy check of `value` because it seems\n      // more convenient that '' and 0 are skipped.\n      const value = !!classInfo[name];\n      if (\n        value !== this._previousClasses.has(name) &&\n        !this._staticClasses?.has(name)\n      ) {\n        if (value) {\n          classList.add(name);\n          this._previousClasses.add(name);\n        } else {\n          classList.remove(name);\n          this._previousClasses.delete(name);\n        }\n      }\n    }\n    return noChange;\n  }\n}\n\n/**\n * A directive that applies dynamic CSS classes.\n *\n * This must be used in the `class` attribute and must be the only part used in\n * the attribute. It takes each property in the `classInfo` argument and adds\n * the property name to the element's `classList` if the property value is\n * truthy; if the property value is falsey, the property name is removed from\n * the element's `class`.\n *\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\n * truthy.\n *\n * @param classInfo\n */\nexport const classMap = directive(ClassMapDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {ClassMapDirective};\n"],"mappings":";;;;;;;MA2HaA,CAAA,GAAWC,CAAA,CArGxB,cAAgCC,CAAA;EAQ9BC,YAAYC,CAAA;IAAA,IAAAH,CAAA;IAEV,IADA,MAAMG,CAAA,GAEJA,CAAA,CAASC,IAAA,KAASC,CAAA,CAASC,SAAA,IACT,YAAlBH,CAAA,CAASI,IAAA,eACRP,CAAA,GAAAG,CAAA,CAASK,OAAA,gBAAAR,CAAA,YAAAA,CAAA,CAASS,MAAA,IAAoB,GAEvC,MAAUC,KAAA,CACR,qGAIL;EAAA;EAEDC,OAAOR,CAAA;IAEL,OACE,MACAS,MAAA,CAAOC,IAAA,CAAKV,CAAA,EACTW,MAAA,CAAQd,CAAA,IAAQG,CAAA,CAAUH,CAAA,GAC1Be,IAAA,CAAK,OACR,GAEH;EAAA;EAEQC,OAAOhB,CAAA,EAAAiB,IAAA,EAAsB;IAAA,IAAtB,CAAsBhB,CAAA,IAAAgB,IAAA;IAAA,IAAAZ,CAAA,EAAAN,CAAA;IAEpC,SAA8B,MAA1B,KAAKmB,EAAA,EAAgC;MACvC,KAAKA,EAAA,GAAmB,IAAIC,GAAA,SACP,MAAjBnB,CAAA,CAAKQ,OAAA,KACP,KAAKY,EAAA,GAAiB,IAAID,GAAA,CACxBnB,CAAA,CAAKQ,OAAA,CACFO,IAAA,CAAK,KACLM,KAAA,CAAM,MACNP,MAAA,CAAQX,CAAA,IAAY,OAANA,CAAA;MAGrB,KAAK,MAAMA,CAAA,IAAQF,CAAA,EACbA,CAAA,CAAUE,CAAA,OAA+B,UAArBE,CAAA,QAAKe,EAAA,UAAgB,MAAAf,CAAA,YAAAA,CAAA,CAAAiB,GAAA,CAAInB,CAAA,MAC/C,KAAKe,EAAA,CAAiBK,GAAA,CAAIpB,CAAA;MAG9B,OAAO,KAAKQ,MAAA,CAAOV,CAAA,CACpB;IAAA;IAED,MAAMuB,CAAA,GAAYxB,CAAA,CAAKyB,OAAA,CAAQC,SAAA;IAK/B,KAAKR,EAAA,CAAiBS,OAAA,CAASxB,CAAA;MACvBA,CAAA,IAAQF,CAAA,KACZuB,CAAA,CAAUI,MAAA,CAAOzB,CAAA,GACjB,KAAKe,EAAA,CAAkBW,MAAA,CAAO1B,CAAA,EAC/B;IAAA;IAIH,KAAK,MAAMA,CAAA,IAAQF,CAAA,EAAW;MAG5B,MAAMD,CAAA,KAAUC,CAAA,CAAUE,CAAA;MAExBH,CAAA,KAAU,KAAKkB,EAAA,CAAiBI,GAAA,CAAInB,CAAA,MACd,UAArBJ,CAAA,QAAKqB,EAAA,UAAgB,MAAArB,CAAA,YAAAA,CAAA,CAAAuB,GAAA,CAAInB,CAAA,OAEtBH,CAAA,IACFwB,CAAA,CAAUD,GAAA,CAAIpB,CAAA,GACd,KAAKe,EAAA,CAAiBK,GAAA,CAAIpB,CAAA,MAE1BqB,CAAA,CAAUI,MAAA,CAAOzB,CAAA,GACjB,KAAKe,EAAA,CAAiBW,MAAA,CAAO1B,CAAA,GAGlC;IAAA;IACD,OAAOA,CACR;EAAA;AAAA;AAAA,SAAAJ,CAAA,IAAA+B,QAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}