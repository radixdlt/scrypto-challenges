{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PublicKey = exports.isPublicKey = void 0;\nconst tslib_1 = require(\"tslib\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst elliptic_1 = require(\"elliptic\");\nconst bn_js_1 = (0, tslib_1.__importDefault)(require(\"bn.js\"));\nconst util_1 = require(\"@radixdlt/util\");\nconst primitives_1 = require(\"@radixdlt/primitives\");\nconst ecPointOnCurve_1 = require(\"./ecPointOnCurve\");\nconst thirdPartyLibEllipticSecp256k1 = new elliptic_1.ec('secp256k1');\nconst isPublicKey = something => {\n  const inspection = something;\n  return inspection.asData !== undefined && inspection.isValidSignature !== undefined && inspection.decodeToPointOnCurve !== undefined && inspection.equals !== undefined && inspection.toString !== undefined;\n};\nexports.isPublicKey = isPublicKey;\n// eslint-disable-next-line max-lines-per-function\nconst publicKeyFromEllipticKey = ecKeyPair => {\n  const validation = ecKeyPair.validate();\n  if (!validation.result) {\n    return (0, neverthrow_1.err)(new Error(`Invalid privateKey: ${validation.reason}`));\n  }\n  const newKeyAsData = input => Buffer.from(ecKeyPair.getPublic(input.compressed, 'array'));\n  const isValidSignature = input => {\n    const message = input.hashedMessage;\n    const signature = input.signature;\n    const r = (0, primitives_1.bnFromUInt256)(signature.r);\n    const s = (0, primitives_1.bnFromUInt256)(signature.s);\n    return ecKeyPair.verify(new bn_js_1.default(message), {\n      r,\n      s\n    });\n  };\n  const equals = other => {\n    const comparePubKeyBytes = compressed => {\n      const newKeyBytes = newKeyAsData({\n        compressed\n      });\n      const otherBytes = other.asData({\n        compressed\n      });\n      return (0, util_1.buffersEquals)(newKeyBytes, otherBytes);\n    };\n    return comparePubKeyBytes(true) && comparePubKeyBytes(false);\n  };\n  const toString = compressed => newKeyAsData({\n    compressed: compressed !== null && compressed !== void 0 ? compressed : true\n  }).toString('hex');\n  const publicKey = {\n    __hex: toString(),\n    asData: newKeyAsData,\n    toString,\n    isValidSignature: isValidSignature,\n    equals: equals,\n    decodeToPointOnCurve: () => {\n      const shortPoint = ecKeyPair.getPublic();\n      const pointOnCurveResult = (0, ecPointOnCurve_1.__pointOnCurveFromEllipticShortPoint)(shortPoint);\n      if (pointOnCurveResult.isErr()) throw new Error(`Incorrect implementation, should always be able to decode a valid public key\n\t\t\t\t\t into a point on the curve, but got error ${pointOnCurveResult.error.message}`);\n      return pointOnCurveResult.value;\n    }\n  };\n  return (0, neverthrow_1.ok)(publicKey);\n};\nconst fromPrivateKey = input => fromPrivateKeyScalar({\n  scalar: input.privateKey.scalar\n});\nconst fromPrivateKeyScalar = input => {\n  const result = publicKeyFromEllipticKey(thirdPartyLibEllipticSecp256k1.keyFromPrivate(input.scalar.toString(16)));\n  if (result.isErr()) {\n    throw new Error(`Failed to derive public key from private key, this should never happend since you passed in an 'PrivateKeyT' type value, which should have been validated. You must somehow have bypassed validation, or our implementation is incorrect, which is a fatal error.`);\n  }\n  return result.value;\n};\nconst fromBuffer = publicKeyBytes => {\n  try {\n    const ecKeyPairElliptic = thirdPartyLibEllipticSecp256k1.keyFromPublic(publicKeyBytes);\n    return publicKeyFromEllipticKey(ecKeyPairElliptic);\n  } catch (e) {\n    const underlyingError = (0, util_1.msgFromError)(e);\n    const errMsg = `Failed to decode bytes into public key, underlying error: ${underlyingError}. bytes: '${publicKeyBytes.toString('hex')}'`;\n    console.error(errMsg);\n    return (0, neverthrow_1.err)(new Error(errMsg));\n  }\n};\nconst compressedByteCount = 33;\nexports.PublicKey = {\n  compressedByteCount,\n  fromBuffer,\n  fromPrivateKey,\n  fromPrivateKeyScalar\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","PublicKey","isPublicKey","tslib_1","require","neverthrow_1","elliptic_1","bn_js_1","__importDefault","util_1","primitives_1","ecPointOnCurve_1","thirdPartyLibEllipticSecp256k1","ec","something","inspection","asData","undefined","isValidSignature","decodeToPointOnCurve","equals","toString","publicKeyFromEllipticKey","ecKeyPair","validation","validate","result","err","Error","reason","newKeyAsData","input","Buffer","from","getPublic","compressed","message","hashedMessage","signature","r","bnFromUInt256","s","verify","default","other","comparePubKeyBytes","newKeyBytes","otherBytes","buffersEquals","publicKey","__hex","shortPoint","pointOnCurveResult","__pointOnCurveFromEllipticShortPoint","isErr","error","ok","fromPrivateKey","fromPrivateKeyScalar","scalar","privateKey","keyFromPrivate","fromBuffer","publicKeyBytes","ecKeyPairElliptic","keyFromPublic","e","underlyingError","msgFromError","errMsg","console","compressedByteCount"],"sources":["/Users/mdabdurrazzak/RadInsu/node_modules/@radixdlt/crypto/dist/elliptic-curve/publicKey.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PublicKey = exports.isPublicKey = void 0;\nconst tslib_1 = require(\"tslib\");\nconst neverthrow_1 = require(\"neverthrow\");\nconst elliptic_1 = require(\"elliptic\");\nconst bn_js_1 = (0, tslib_1.__importDefault)(require(\"bn.js\"));\nconst util_1 = require(\"@radixdlt/util\");\nconst primitives_1 = require(\"@radixdlt/primitives\");\nconst ecPointOnCurve_1 = require(\"./ecPointOnCurve\");\nconst thirdPartyLibEllipticSecp256k1 = new elliptic_1.ec('secp256k1');\nconst isPublicKey = (something) => {\n    const inspection = something;\n    return (inspection.asData !== undefined &&\n        inspection.isValidSignature !== undefined &&\n        inspection.decodeToPointOnCurve !== undefined &&\n        inspection.equals !== undefined &&\n        inspection.toString !== undefined);\n};\nexports.isPublicKey = isPublicKey;\n// eslint-disable-next-line max-lines-per-function\nconst publicKeyFromEllipticKey = (ecKeyPair) => {\n    const validation = ecKeyPair.validate();\n    if (!validation.result) {\n        return (0, neverthrow_1.err)(new Error(`Invalid privateKey: ${validation.reason}`));\n    }\n    const newKeyAsData = (input) => Buffer.from(ecKeyPair.getPublic(input.compressed, 'array'));\n    const isValidSignature = (input) => {\n        const message = input.hashedMessage;\n        const signature = input.signature;\n        const r = (0, primitives_1.bnFromUInt256)(signature.r);\n        const s = (0, primitives_1.bnFromUInt256)(signature.s);\n        return ecKeyPair.verify(new bn_js_1.default(message), { r, s });\n    };\n    const equals = (other) => {\n        const comparePubKeyBytes = (compressed) => {\n            const newKeyBytes = newKeyAsData({ compressed });\n            const otherBytes = other.asData({ compressed });\n            return (0, util_1.buffersEquals)(newKeyBytes, otherBytes);\n        };\n        return comparePubKeyBytes(true) && comparePubKeyBytes(false);\n    };\n    const toString = (compressed) => newKeyAsData({ compressed: compressed !== null && compressed !== void 0 ? compressed : true }).toString('hex');\n    const publicKey = {\n        __hex: toString(),\n        asData: newKeyAsData,\n        toString,\n        isValidSignature: isValidSignature,\n        equals: equals,\n        decodeToPointOnCurve: () => {\n            const shortPoint = ecKeyPair.getPublic();\n            const pointOnCurveResult = (0, ecPointOnCurve_1.__pointOnCurveFromEllipticShortPoint)(shortPoint);\n            if (pointOnCurveResult.isErr())\n                throw new Error(`Incorrect implementation, should always be able to decode a valid public key\n\t\t\t\t\t into a point on the curve, but got error ${pointOnCurveResult.error.message}`);\n            return pointOnCurveResult.value;\n        },\n    };\n    return (0, neverthrow_1.ok)(publicKey);\n};\nconst fromPrivateKey = (input) => fromPrivateKeyScalar({ scalar: input.privateKey.scalar });\nconst fromPrivateKeyScalar = (input) => {\n    const result = publicKeyFromEllipticKey(thirdPartyLibEllipticSecp256k1.keyFromPrivate(input.scalar.toString(16)));\n    if (result.isErr()) {\n        throw new Error(`Failed to derive public key from private key, this should never happend since you passed in an 'PrivateKeyT' type value, which should have been validated. You must somehow have bypassed validation, or our implementation is incorrect, which is a fatal error.`);\n    }\n    return result.value;\n};\nconst fromBuffer = (publicKeyBytes) => {\n    try {\n        const ecKeyPairElliptic = thirdPartyLibEllipticSecp256k1.keyFromPublic(publicKeyBytes);\n        return publicKeyFromEllipticKey(ecKeyPairElliptic);\n    }\n    catch (e) {\n        const underlyingError = (0, util_1.msgFromError)(e);\n        const errMsg = `Failed to decode bytes into public key, underlying error: ${underlyingError}. bytes: '${publicKeyBytes.toString('hex')}'`;\n        console.error(errMsg);\n        return (0, neverthrow_1.err)(new Error(errMsg));\n    }\n};\nconst compressedByteCount = 33;\nexports.PublicKey = {\n    compressedByteCount,\n    fromBuffer,\n    fromPrivateKey,\n    fromPrivateKeyScalar,\n};\n//# sourceMappingURL=publicKey.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}