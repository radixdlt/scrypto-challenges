"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const router_1 = require("./router");
const transports_1 = __importDefault(require("./transports"));
class Server {
    constructor(options) {
        this.routers = [];
        this.transports = [];
        if (options.methodMapping) {
            this.addRouter(options.openrpcDocument, options.methodMapping);
        }
        if (options.transportConfigs) {
            options.transportConfigs.forEach((transportConfig) => {
                this.addDefaultTransport(transportConfig.type, transportConfig.options);
            });
        }
    }
    addTransport(transport) {
        this.routers.forEach((router) => {
            transport.addRouter(router);
        });
        this.transports.push(transport);
    }
    addDefaultTransport(transportType, transportOptions) {
        const TransportClass = transports_1.default[transportType];
        console.log(`Adding Transport of the type ${transportType} on port ${transportOptions.port}`);
        if (TransportClass === undefined) {
            throw new Error(`The transport "${transportType}" is not a valid transport type.`);
        }
        const transport = new TransportClass(transportOptions);
        this.addTransport(transport);
    }
    addRouter(openrpcDocument, methodMapping) {
        const router = new router_1.Router(openrpcDocument, methodMapping);
        this.routers.push(router);
        this.transports.forEach((transport) => transport.addRouter(router));
        return router;
    }
    removeRouter(routerToRemove) {
        this.routers = this.routers.filter((r) => r !== routerToRemove);
        this.transports.forEach((transport) => transport.removeRouter(routerToRemove));
    }
    start() {
        this.transports.forEach((transport) => transport.start());
    }
}
exports.default = Server;
