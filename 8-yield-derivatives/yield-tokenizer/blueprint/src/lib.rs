//! The Yield Tokenizer is a yield derivative protocol that offers the possibility to profit from the current XRD value of LSUs without losing the exposure to the yield they can generate in the future. To achieve this, the Yield Tokenizer dApp uses LSUs as input and generates two resources as output: a fungible resource, the **sXRD**, and a non-fungible one, the **Yield Token (YT)**. The sXRD is a synthetic derivative designed to have roughly the same market value as the XRD. The YT, on the other hand, represent current position in LSU and can be exchanged at any time for XRD whose value close to the yield generated by the LSUs that were used for its creation. The use of NFTs for representing yield positions allows for the support of multiple LSUs, but for the purpose of this challenge, we will consider that the LSUs come from the same validator.

pub mod staking_pool;

use self::staking_pool::staking_pool::*;
use scrypto::prelude::*;

/// A data structure for the Yield Token.
#[derive(ScryptoSbor, NonFungibleData)]
pub struct YieldTokenData {
    /// Resource address of underlying LSU
    underlying_lsu_resource: ResourceAddress,
    /// Amount of underlying LSU
    underlying_lsu_amount: Decimal,
    /// Redemption value at the start of the yield tokenization process
    /// this correspond to minted sXRD
    redemption_value_at_start: Decimal,
}

/// A data structure for the unstaked XRD claim NFT
#[derive(ScryptoSbor, NonFungibleData)]
pub struct UnstakeData {
    pub name: String,
    pub claim_epoch: Epoch,
    pub claim_amount: Decimal,
}

#[blueprint]
mod yield_tokenizer {
    struct YieldTokenizer {
        /// sXRD resource manager
        /// sXRD is a derivative of XRD that is created during the LSU yield tokenization process
        /// the protocol ensures redemption of sXRD for XRD at any time. In case the system lake XRD ,
        /// sXRD will redeem for corresponding LSU, from a redemption value perspective, and redeemed sXRD will be shared to the LSU provider.
        sxrd_rm: ResourceManager,

        /// Yield Token Resource Manager
        /// Yield Token Resource Manager is a derivative of LSU that is created during the yield tokenization process
        /// its an NFT that keep the value of Yield generated by the LSUs that were used for its creation, from the day it was minted
        /// to the day it's presented for redemption
        yt_rm: ResourceManager,

        /// XRD Vault
        /// XRD Vault is a resource that is used to hold the XRD unstaked during redemption of Yield Token and also from from XRD directly use to mint sXRD
        /// minting sXRD with XRD is the second hard peg melanism and will help in keeping sXRD price close to XRD price
        xrd_vault: FungibleVault,

        /// Penalty rate for sXRD redemption for LSU
        /// Redemption for LSU is an extreme case as it reduce Yield exposure of owner of LSU deposited in the pool to the underlying LSU yield.
        /// Redeemed sXRD is distributed to them as a compensation but an additional penalty is applied to assure that LSU depositor has a minimum yield.
        /// In some way this penalty ensure the minimum yield an LSU depositor will get.
        /// e.i if the SLU APY is 10 % and the penalty rate is 5% that translate to yield generated over 6 months minimum,
        /// beyond that, the LSU depositor will MAY get less yield
        sxrd_redeem_penalty_rate: Decimal,

        /// Accepted LSU Validator Component
        lsu_validator_component: Global<Validator>,

        /// Accepted LSU resource address
        lsu_address: ResourceAddress,

        /// LSU Staking pool
        /// This staking pool is use to ensure faire distribution of sXRD redeemed for LSU among all LSU contributors
        lsu_pool: Owned<StakingPool>,

        /// Vault storing pending claim NFT fro unstaked XRD
        claim_vault: Option<NonFungibleVault>,

        /// Claim limit
        /// Max Number of claim NFTs that can claimed at a time
        claim_limit: u32,
    }

    impl YieldTokenizer {
        /// Initialize YieldTokenizer
        ///
        /// Instantiate YieldTokenizer that will be used to generate yield token from LSUs.

        /// To create Yield Token, user must provide:
        /// * Accepted LSU
        /// * Claim limit
        /// * Redemption penalty for sXRD redemption for LSU
        ///
        /// Note: Instantiation will fail if the provided LSU is not a valid LSU.
        pub fn instantiate(
            accepted_lsu: ResourceAddress,
            claim_limit: u32,
            sxrd_redeem_penalty_rate: Decimal,
            owner_role: Option<OwnerRole>,
        ) -> Global<YieldTokenizer> {
            assert!(
                Decimal::ZERO <= sxrd_redeem_penalty_rate
                    && sxrd_redeem_penalty_rate <= Decimal::ONE,
                "Penalty rate must be between zero and one!"
            );

            let lsu_validator_component = Self::retrieve_validator_component(accepted_lsu);
            assert!(Self::validate_lsu(accepted_lsu), "Not an LSU!");

            let (address_reservation, component_address) =
                Runtime::allocate_component_address(YieldTokenizer::blueprint_id());

            // sXRD resource manager
            let sxrd_rm: ResourceManager = ResourceBuilder::new_fungible(
                owner_role.clone().unwrap_or(OwnerRole::None),
            )
            .divisibility(DIVISIBILITY_MAXIMUM)
            .metadata(metadata! {
                init {
                    "name" => "sXRD Token", locked;
                    "symbol" => "sXRD", locked;
                    "yield_tokenizer_component" => GlobalAddress::from(component_address), locked;
                }
            })
            .mint_roles(mint_roles! {
                minter => rule!(require(global_caller(component_address)));
                minter_updater => rule!(deny_all);
            })
            .burn_roles(burn_roles! {
                burner => rule!(require(global_caller(component_address)));
                burner_updater => rule!(deny_all);
            })
            .create_with_no_initial_supply();

            // YT resource manager
            let yt_rm: ResourceManager = ResourceBuilder::new_ruid_non_fungible::<YieldTokenData>(
                owner_role.clone().unwrap_or(OwnerRole::None),
            )
            .metadata(metadata! {
                init {
                    "name" => "Yield Token", locked;
                    "symbol" => "YT", locked;
                    "yield_tokenizer_component" => GlobalAddress::from(component_address), locked;
                }
            })
            .mint_roles(mint_roles! {
                minter => rule!(require(global_caller(component_address)));
                minter_updater => rule!(deny_all);
            })
            .burn_roles(burn_roles! {
                burner => rule!(allow_all);
                burner_updater => rule!(deny_all);
            })
            .non_fungible_data_update_roles(non_fungible_data_update_roles! {
                non_fungible_data_updater => rule!(require(global_caller(component_address)));
                non_fungible_data_updater_updater => rule!(deny_all);
            })
            .create_with_no_initial_supply();

            (Self {
                sxrd_rm,
                yt_rm,
                xrd_vault: FungibleVault::new(XRD),
                sxrd_redeem_penalty_rate,
                lsu_validator_component,
                lsu_address: accepted_lsu,
                lsu_pool: Blueprint::<StakingPool>::instantiate(accepted_lsu, sxrd_rm.address()),

                claim_vault: None,
                claim_limit,
            })
            .instantiate()
            .prepare_to_globalize(owner_role.unwrap_or(OwnerRole::None))
            .with_address(address_reservation)
            .globalize()
        }

        // * Tokenization methods *//

        /// Tokenize the LSU to its sXRD and YT. the method can also take XRD as input,
        /// in which case it will stake provided XRD to to get LSU
        ///
        /// # Arguments
        ///
        /// * `input_token`: [`FungibleBucket`] - A fungible bucket of LSU or XRD
        ///
        ///
        /// # Returns
        ///
        /// * [`FungibleBucket`] - A fungible bucket of sXRD.
        /// * [`NonFungibleBucket`] - A non fungible bucket of YT.
        pub fn tokenize_yield(
            &mut self,
            input_bucket: FungibleBucket,
        ) -> (FungibleBucket, NonFungibleBucket) {
            let lsu_bucket = if input_bucket.resource_address() == XRD {
                let mut validator = Self::retrieve_validator_component(self.lsu_address);
                validator.stake(input_bucket.into()).as_fungible()
            } else {
                assert_eq!(input_bucket.resource_address(), self.lsu_address);

                input_bucket
            };

            let lsu_amount = lsu_bucket.amount();
            let redemption_value = self
                .lsu_validator_component
                .get_redemption_value(lsu_bucket.amount());

            let sxrd_bucket = self.sxrd_rm.mint(redemption_value).as_fungible();

            let yt_bucket = self
                .yt_rm
                .mint_ruid_non_fungible(YieldTokenData {
                    underlying_lsu_resource: self.lsu_address,
                    underlying_lsu_amount: lsu_amount,
                    redemption_value_at_start: redemption_value,
                })
                .as_non_fungible();

            let nft: NonFungible<YieldTokenData> = yt_bucket.non_fungible();

            let yt_id = nft.local_id();

            self.lsu_pool.contribute(yt_id.clone(), lsu_bucket);

            (sxrd_bucket, yt_bucket)
        }

        /// Mint sXRD with XRD.
        ///
        /// Mint sXRD with the provided XRD tokens. The returned [`FungibleBucket`] contains
        /// the minted sXRD.
        ///
        /// # Arguments
        ///
        /// * `xrd_token`: [`FungibleBucket`] - A fungible bucket of XRD tokens to mint sXRD with.
        ///
        /// # Returns
        ///
        /// * [`FungibleBucket`] - A fungible bucket of sXRD.
        pub fn mint_sxrd(&mut self, xrd_token: FungibleBucket) -> FungibleBucket {
            assert_eq!(xrd_token.resource_address(), XRD);
            let xrd_amount = xrd_token.amount();
            self.xrd_vault.put(xrd_token);
            self.sxrd_rm.mint(xrd_amount).as_fungible()
        }

        //* Redemption methods *//

        /// Redeem sXRD for XRD or LSU if we don't have enough XRD.
        /// Redemption method for sXRD.
        ///
        ///
        /// # Arguments
        ///
        /// * `sxrd_bucket`: [`FungibleBucket`] - A fungible bucket of sXRD to redeem.
        /// * `only_xrd`: bool - Flag to indicate if we should fail if we don't have enough XRD.
        ///
        /// # Returns
        ///
        /// * [`FungibleBucket`] - A fungible bucket of either XRD or LSU.
        pub fn redeem_sxrd(
            &mut self,
            sxrd_bucket: FungibleBucket,
            only_xrd: bool,
        ) -> FungibleBucket {
            assert_eq!(sxrd_bucket.resource_address(), self.sxrd_rm.address());

            // Check if we can claim some unstake  claim NFTs.
            while self.xrd_vault.amount() < sxrd_bucket.amount() {
                if self.claim_nfts(self.claim_limit) == Decimal::ZERO {
                    break;
                }
            }

            if sxrd_bucket.amount() <= self.xrd_vault.amount() {
                // Redeem sXRD for XRD
                let xrd_bucket = self.xrd_vault.take(sxrd_bucket.amount());
                sxrd_bucket.burn();
                xrd_bucket
            } else {
                assert!(!only_xrd, "Not enough XRD!");

                // Redeem sXRD for LSU
                self.redeem_sxrd_for_lsu(sxrd_bucket)
            }
        }

        /// Claims owed yield for sXRD.
        ///
        /// This method claims the yield owned by the caller for sXRD. The amount of sXRD
        /// claimed is determined by the yield owned by the caller based on the yield
        /// token's data.
        ///
        /// # Arguments
        ///
        /// * `yt`: [`NonFungibleBucket`] - A non fungible bucket of yield token.
        ///
        /// # Returns
        ///
        /// * [`FungibleBucket`] - A fungible bucket of sXRD.
        pub fn claim_yield_for_sxrd(&mut self, yt: NonFungibleBucket) -> FungibleBucket {
            let returned_sxrd_bucket = yt.non_fungible_local_ids().into_iter().fold(
                FungibleBucket::new(self.sxrd_rm.address()),
                |mut returned_sxrd_bucket, id| {
                    let data = self.yt_rm.get_non_fungible_data::<YieldTokenData>(&id);

                    // Calculate XRD amount corresponding to yield owned
                    let sxrd_value = self.calc_yield_owed(&data);

                    // Unstake underlying lsu amount.
                    let (lsu_bucket, received_sxrd_bucket) = self.lsu_pool.redeem(id.clone());
                    self.unstake_lsu(lsu_bucket);

                    returned_sxrd_bucket.put(received_sxrd_bucket);

                    // Mint sXRD amount corresponding to yield owned
                    returned_sxrd_bucket.put(self.sxrd_rm.mint(sxrd_value).as_fungible());

                    returned_sxrd_bucket
                },
            );

            self.yt_rm.burn(yt);

            returned_sxrd_bucket
        }

        /// Claims owed yield for LSU.
        /// Redeeming sXRD may depend on XRD availability, secondary sXRD price or subject to penalty in case on redemption
        /// against LSU. This method is meant to be used by a YT holder who want to avoid potential uncertainty around sXRD
        /// and are willing to wait the unstake period to claim his yield
        /// In that case the protocol will withdraw the underlying lsu with redemption value equals to the yield
        /// and return them to the holder
        pub fn claim_yield_for_lsu(
            &mut self,
            yt: NonFungibleBucket,
        ) -> (FungibleBucket, FungibleBucket) {
            let (returned_lsu_bucket, returned_sxrd_bucket) =
                yt.non_fungible_local_ids().into_iter().fold(
                    (
                        FungibleBucket::new(self.lsu_address),
                        FungibleBucket::new(self.sxrd_rm.address()),
                    ),
                    |(mut returned_lsu_bucket, mut returned_sxrd_bucket), id| {
                        let data = self.yt_rm.get_non_fungible_data::<YieldTokenData>(&id);

                        // Withdraw underlying lsu to unstake
                        let (mut lsu_bucket, sxrd_bucket) = self.lsu_pool.redeem(id.clone());

                        // Calculate LSU amount corresponding to yield owned
                        let yield_owed = self.calc_yield_owed(&data);
                        let required_lsu_for_yield_owed =
                            self.calc_required_lsu_for_yield_owed(yield_owed);

                        // Take yield redemption amount from LSU withdrawal
                        // Behave like an "sXRD redemption in advance" but without penalty, but XRD will be delivered later
                        // after the unstake period
                        let required_lsu_bucket = lsu_bucket.take(required_lsu_for_yield_owed);

                        // Unstake remaining underlying lsu amount.
                        self.unstake_lsu(lsu_bucket);

                        returned_lsu_bucket.put(required_lsu_bucket);

                        returned_sxrd_bucket.put(sxrd_bucket);

                        (returned_lsu_bucket, returned_sxrd_bucket)
                    },
                );

            self.yt_rm.burn(yt);

            (returned_lsu_bucket, returned_sxrd_bucket)
        }

        /// Claim NFTs and put in XRD Vault
        pub fn claim_nfts(&mut self, limit: u32) -> Decimal {
            if let Some(ref mut vault) = self.claim_vault {
                let claimable_nft_ids = vault
                    .non_fungible_local_ids(limit)
                    .into_iter()
                    .filter(|id| {
                        let resource_manager = vault.resource_manager();
                        let data = resource_manager.get_non_fungible_data::<UnstakeData>(id);

                        Runtime::current_epoch() >= data.claim_epoch
                    })
                    .collect::<IndexSet<NonFungibleLocalId>>();

                if !claimable_nft_ids.is_empty() {
                    let claimable_bucket = vault.take_non_fungibles(&claimable_nft_ids);

                    let xrd_bucket = self
                        .lsu_validator_component
                        .claim_xrd(claimable_bucket.into());
                    let claimed_amount = xrd_bucket.amount();
                    self.xrd_vault.put(xrd_bucket.as_fungible());
                    return claimed_amount;
                }
            }
            Decimal::ZERO
        }

        // * Getters methods *//

        /// Retrieves the `ResourceAddress` of sXRD.
        ///
        /// # Returns
        ///
        /// * [`ResourceAddress`] - The address of sXRD.
        pub fn sxrd_address(&self) -> ResourceAddress {
            self.sxrd_rm.address()
        }

        /// Retrieves the `ResourceAddress` of YT.
        ///
        /// # Returns
        ///
        /// * [`ResourceAddress`] - The address of YT.
        pub fn yt_address(&self) -> ResourceAddress {
            self.yt_rm.address()
        }

        /// Retrieves the `ResourceAddress` of the underlying LSU.
        ///
        /// # Returns
        ///
        /// * [`ResourceAddress`] - The address of the underlying LSU.
        pub fn underlying_resource(&self) -> ResourceAddress {
            self.lsu_address
        }

        // * Private methods *//

        /// Redeem sXRD for LSU.
        fn redeem_sxrd_for_lsu(&mut self, mut sxrd_bucket: FungibleBucket) -> FungibleBucket {
            assert_eq!(sxrd_bucket.resource_address(), self.sxrd_rm.address());

            // Pay a penalty to YT owners as we will be redeeming sXRD for LSU
            let sxrd_penalty =
                sxrd_bucket.take(sxrd_bucket.amount() * self.sxrd_redeem_penalty_rate);

            self.lsu_pool.distribute(sxrd_penalty);

            // Get LSU with XRD redemption value equal remaining sXRD amount
            let required_lsu_for_sxrd: Decimal =
                self.calc_required_lsu_for_yield_owed(sxrd_bucket.amount());

            let lsu_bucket = self.lsu_pool.withdraw(required_lsu_for_sxrd);

            // Burn sXRD : sXRD burnt value = XRD value leaving the component
            self.sxrd_rm.burn(sxrd_bucket);

            // Return redeemed LSU
            lsu_bucket.as_fungible()
        }

        /// Retrieve validator component.
        fn retrieve_validator_component(lsu_address: ResourceAddress) -> Global<Validator> {
            let metadata: GlobalAddress = ResourceManager::from(lsu_address)
                .get_metadata("validator")
                .unwrap()
                .unwrap_or_else(|| Runtime::panic(String::from("Not an LSU!")));
            ComponentAddress::try_from(metadata).unwrap().into()
        }

        /// Validate lsu.
        fn validate_lsu(input_lsu_address: ResourceAddress) -> bool {
            let metadata: GlobalAddress = ResourceManager::from(input_lsu_address)
                .get_metadata("validator")
                .unwrap()
                .unwrap_or_else(|| Runtime::panic(String::from("Not an LSU!")));
            let validator_address = ComponentAddress::try_from(metadata).unwrap();
            let validator: Global<Validator> = Global::from(validator_address);
            let lsu_address: GlobalAddress = validator
                .get_metadata("pool_unit")
                .unwrap()
                .unwrap_or_else(|| Runtime::panic(String::from("Not an LSU!")));

            input_lsu_address == ResourceAddress::try_from(lsu_address).unwrap()
        }

        /// Calculates the required LSU to redeem yield earned for the period.
        ///
        /// # Arguments
        ///
        /// * `yield_owed`: [`Decimal`] - The redemption value of the yield owed.
        ///
        /// # Returns
        ///
        /// * [`Decimal`] - The required LSU amount to redeem yield owed.
        fn calc_required_lsu_for_yield_owed(&self, yield_owed: Decimal) -> Decimal {
            let one_lsu_redemption_value = self
                .lsu_validator_component
                .get_redemption_value(Decimal::ONE);

            yield_owed.checked_div(one_lsu_redemption_value).unwrap()
        }

        /// Calculates earned yield of YT.
        ///
        /// # Arguments
        ///
        /// * `data`: [`&YieldTokenData`] - The `NonFungibleData` of YT.
        ///
        /// # Returns
        ///
        /// * [`Decimal`] - The calculated earned yield from YT for the current period.
        fn calc_yield_owed(&self, data: &YieldTokenData) -> Decimal {
            let redemption_value = self
                .lsu_validator_component
                .get_redemption_value(data.underlying_lsu_amount);

            debug!("Redemption Value: {:?}", redemption_value);

            let redemption_value_at_start = data.redemption_value_at_start;

            debug!("Redemption Value: {:?}", redemption_value_at_start);

            assert!(
                redemption_value > redemption_value_at_start,
                "No rewards earned yet."
            );

            redemption_value
                .checked_sub(redemption_value_at_start)
                .unwrap()
        }

        /// Unstake LSU and put in LSU Vault
        fn unstake_lsu(&mut self, lsu_bucket: FungibleBucket) {
            let unstake_bucket = self.lsu_validator_component.unstake(lsu_bucket.into());
            match self.claim_vault {
                None => {
                    self.claim_vault = Some(NonFungibleVault::with_bucket(
                        unstake_bucket.as_non_fungible(),
                    ));
                }
                Some(ref mut vault) => vault.put(unstake_bucket.as_non_fungible()),
            };
        }
    }
}
